import { ensureArray as k, getTokenBalance as p, hexSchema as B } from "@argent/x-shared";
import { useCallback as y } from "react";
const A = async ({ feeTokenAddress: a, calls: n, selectedAccount: r, transactionReviewService: o, appDomain: t, accountDeployTransaction: e, isDelayedTransaction: m }) => {
  const u = {
    type: "INVOKE",
    calls: k(n)
  };
  if (!r || !a)
    return;
  const c = e ? [e, u] : [u];
  return { result: await o.simulateAndReview(r, c, a, t, e, m) };
}, C = async (a, n, r, o) => {
  var d, l, f, F, E, g, v;
  let t = !1;
  const e = (d = n.transactions) == null ? void 0 : d.find((s) => {
    var w, x;
    return (x = (w = s == null ? void 0 : s.simulation) == null ? void 0 : w.summary) == null ? void 0 : x.find((T) => T.sent);
  });
  if (!e || !((l = e.simulation) != null && l.summary))
    return t;
  const m = e.simulation.summary.filter((s) => s.sent).map((s) => s.token.address);
  if (!(((f = n.enrichedFeeEstimation) == null ? void 0 : f.transactions.feeTokenAddress) && m.includes((F = n.enrichedFeeEstimation) == null ? void 0 : F.transactions.feeTokenAddress)) || !((g = (E = n.enrichedFeeEstimation) == null ? void 0 : E.transactions) != null && g.max))
    return t;
  const c = "amount" in n.enrichedFeeEstimation.transactions.max ? n.enrichedFeeEstimation.transactions.max.amount * n.enrichedFeeEstimation.transactions.max.pricePerUnit : "maxFee" in n.enrichedFeeEstimation.transactions.max ? n.enrichedFeeEstimation.transactions.max.maxFee : void 0, i = (v = e.simulation.summary.find((s) => s.sent && s.token.address === r)) == null ? void 0 : v.value;
  if (!c || !i)
    return t;
  const h = await p(r, a, o) ?? 0n;
  return BigInt(h) > c + BigInt(i) || (t = !0), t;
}, b = () => y(async ({ feeTokenAddress: n, calls: r, selectedAccount: o, transactionReviewService: t, appDomain: e, accountDeployPayload: m, provider: u, isDelayedTransaction: c }) => {
  if (!o)
    return;
  const i = await A({
    feeTokenAddress: n,
    calls: r,
    selectedAccount: o,
    transactionReviewService: t,
    appDomain: e,
    accountDeployTransaction: G(m),
    isDelayedTransaction: c
  });
  if (!i || !i.result || !n)
    return;
  const h = await C(o.address, i.result, n, u);
  return { ...i.result, isSendingMoreThanBalanceAndGas: h };
}, []), G = (a) => a ? {
  type: "DEPLOY_ACCOUNT",
  calldata: a.calldata,
  classHash: B.parse(a.class_hash),
  salt: B.parse(a.salt),
  signature: []
} : void 0;
export {
  G as buildAccountDeployTransaction,
  C as checkGasFeeBalance,
  A as getReviewForTransactions,
  b as useTransactionReviewV2webFetcher
};
