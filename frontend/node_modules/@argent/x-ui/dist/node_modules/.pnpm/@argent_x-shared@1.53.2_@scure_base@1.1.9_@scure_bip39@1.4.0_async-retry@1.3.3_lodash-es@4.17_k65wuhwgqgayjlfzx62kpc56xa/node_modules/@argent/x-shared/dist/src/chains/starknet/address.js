import { memoize as d } from "lodash-es";
import { validateChecksumAddress as c, validateAndParseAddress as i } from "starknet";
import { z as t } from "zod";
const m = t.string().refine((r) => {
  if (r.toLowerCase() === r)
    return !0;
  try {
    return c(r) && u(r);
  } catch {
  }
  return !1;
}, "Invalid address (checksum error)");
t.string().refine((r) => {
  try {
    return i(r);
  } catch {
  }
  return !1;
}, "Invalid address (validation error)");
const a = t.string().regex(/^0x[0-9a-fA-F]+$/, "Invalid address"), l = a.min(50, "Addresses must at least be 50 characters long").max(66, "Addresses must at most be 66 characters long");
a.length(66, "Address must be 66 characters long");
const h = l.pipe(m).transform((r) => `0x${(r.startsWith("0x") ? r.slice(2) : r).padStart(64, "0")}`);
h.or(t.literal("")).transform((r) => r === "" ? void 0 : r).optional();
const x = a.transform((r) => `0x${r.replace(/^0x/, "").toLowerCase().padStart(64, "0")}`), u = (r) => !/^0x[0-9a-f]{63,64}$/.test(r);
d((r) => {
  const s = r.slice(0, 6), e = r.slice(-4);
  return `${s}…${e}`;
});
d((r, s) => {
  if (r.length < s)
    return r;
  const e = Math.floor((s - 1) / 2), n = r.slice(0, e), o = r.slice(-e);
  return `${n}…${o}`;
});
export {
  h as addressSchema,
  x as addressSchemaArgentBackend,
  a as addressSchemaBase,
  l as addressSchemaLooseLength,
  m as validChecksumAddressSchema
};
