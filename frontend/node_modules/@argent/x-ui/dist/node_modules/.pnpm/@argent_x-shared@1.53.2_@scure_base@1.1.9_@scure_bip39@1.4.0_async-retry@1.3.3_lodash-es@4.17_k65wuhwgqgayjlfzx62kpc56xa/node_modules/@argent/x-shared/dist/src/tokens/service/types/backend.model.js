import { z as a } from "zod";
import { addressSchema as t, addressSchemaArgentBackend as o } from "../../../chains/starknet/address.js";
import { defiPositionTypeSchema as p } from "./defiPositionType.model.js";
import { createSchemaWithWarnings as d } from "../../../utils/schemas.js";
a.object({
  status: a.literal("initialising")
}).or(a.object({
  status: a.literal("initialised"),
  balances: a.array(a.object({
    tokenAddress: o,
    tokenBalance: a.string()
  }))
}));
const g = a.object({
  id: a.number(),
  address: t,
  brandColor: a.string().optional(),
  name: a.string(),
  symbol: a.string(),
  decimals: a.number(),
  iconUrl: a.string().optional(),
  sendable: a.boolean(),
  popular: a.boolean(),
  refundable: a.boolean(),
  listed: a.boolean(),
  tradable: a.boolean(),
  category: a.union([
    a.literal("tokens"),
    a.literal("currencies"),
    a.literal("savings")
  ]),
  pricingId: a.number().optional(),
  dappId: a.string().optional(),
  marketData: a.object({
    marketCap: a.number(),
    marketCap24hChange: a.number(),
    dailyVolume: a.number(),
    rank: a.number()
  }).optional(),
  tags: a.array(a.string()).optional()
});
a.object({
  tokens: a.array(g)
});
const m = a.object({
  pricingId: a.number(),
  ethValue: a.string(),
  ccyValue: a.string(),
  ethDayChange: a.string(),
  ccyDayChange: a.string()
});
a.object({
  prices: a.array(m)
});
const n = a.object({
  tokenAddress: o,
  principal: a.string(),
  accruedFees: a.string(),
  minPrice: a.string(),
  maxPrice: a.string(),
  currentPrice: a.string()
}), e = a.object({
  id: a.string(),
  investmentId: a.string().optional(),
  tokenAddress: t.optional(),
  totalBalances: a.record(a.string())
}), i = e.extend({
  tokenId: a.string(),
  data: a.object({
    poolFeePercentage: a.string(),
    tickSpacingPercentage: a.string().optional(),
    token0: n,
    token1: n
  })
});
a.array(i);
const r = e.extend({
  data: a.object({
    apy: a.string(),
    totalApy: a.string()
  }),
  investmentId: a.string().optional(),
  totalBalances: a.record(a.string())
});
a.array(r);
const s = e.extend({
  data: a.object({
    apy: a.string().optional(),
    totalApy: a.string().optional(),
    group: a.number().optional(),
    collateral: a.boolean(),
    debt: a.boolean(),
    lending: a.boolean()
  })
});
a.array(s);
const c = e.extend({
  id: a.string(),
  data: a.object({
    delegatingTo: t
  }),
  totalBalances: a.record(a.string())
});
a.array(c);
const l = e.extend({
  investmentId: a.string().optional(),
  data: a.object({
    stakerInfo: a.object({
      name: a.string().optional(),
      iconUrl: a.string().optional(),
      address: t
    }),
    accruedRewards: a.string(),
    stakedAmount: a.string(),
    pendingWithdrawal: a.object({
      amount: a.string(),
      withdrawableAfter: a.number()
    }).optional(),
    apy: a.string().optional(),
    totalApy: a.string().optional()
  })
});
a.array(l);
const b = i.or(s).or(c).or(r).or(l), u = a.array(b), y = d({
  productId: a.string().optional(),
  name: a.string(),
  manageUrl: a.string().optional(),
  type: p,
  groups: a.record(a.object({
    name: a.string().optional(),
    healthRatio: a.string().optional()
  })).optional(),
  positions: u
}), h = a.object({
  dappId: a.string(),
  products: a.array(y)
});
a.object({
  dapps: a.array(h)
});
const k = a.object({
  name: a.string().optional(),
  tokenAddress: t,
  amount: a.string().optional(),
  claimUrl: a.string().optional(),
  claimStart: a.number(),
  claimEnd: a.number().optional()
});
a.object({
  accountAddress: t,
  chain: a.string(),
  airdrops: a.array(k)
});
export {
  k as apiAirdropSchema,
  s as apiCollateralizedDebtPositionSchema,
  i as apiConcentratedLiquidityPositionSchema,
  y as apiDefiDecompositionProduct,
  u as apiDefiDecompositionProducts,
  h as apiDefiDecompositionSchema,
  n as apiDefiDecompositionToken,
  b as apiDefiPositionSchema,
  c as apiDelegatedTokensSchema,
  m as apiPriceDetailsSchema,
  r as apiStakingPositionSchema,
  l as apiStrkDelegatedStakingSchema,
  g as apiTokenInfoSchema
};
