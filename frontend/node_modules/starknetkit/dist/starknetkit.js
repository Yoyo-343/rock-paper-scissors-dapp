import { m as w } from "./core-d21d2e96.js";
import { M as $, g as B, L as r } from "./Modal-bd983919.js";
import { D as E } from "./trpc-94e013dd.js";
import { i as I, f as y, m as R, e as U, A as x, g as F } from "./index-1da7177c.js";
import "starknet";
import { r as A, s as T } from "./connector-d812307b.js";
import { ArgentX as _ } from "./argentX.js";
import { BraavosMobileBaseConnector as j } from "./braavosMobile.js";
import { Braavos as z } from "./braavos.js";
import { Fordefi as C } from "./fordefi.js";
import { Keplr as W } from "./keplr.js";
import { MetaMask as k } from "./metamask.js";
import "./index-07fcd913.js";
const Q = () => {
  const a = navigator.userAgent.toLowerCase(), s = /android|webos|iphone|ipad|ipod|blackberry|windows phone/.test(a), o = "ontouchstart" in window || navigator.maxTouchPoints > 0, m = window.innerWidth <= 768;
  return s && (o || m);
}, q = () => typeof window < "u" ? /^((?!chrome|android).)*safari/i.test(navigator.userAgent) : !1, P = ({
  argentMobileOptions: a,
  webWalletUrl: s
}) => {
  const o = (
    // | StarknetkitCompoundConnector
    []
  );
  return o.push(new _()), q() || (o.push(new z()), k.isWalletInjected() && o.push(new k()), C.isWalletInjected() && o.push(new C()), W.isWalletInjected() && o.push(new W())), Q() && o.push(new j()), o;
}, at = (a) => ({
  starknetkitConnectModal: async () => await K({
    ...a,
    skipEmit: !0,
    resultType: void 0
  })
});
let n = null;
const K = async ({
  modalMode: a = "canAsk",
  storeVersion: s = F(),
  modalTheme: o,
  dappName: m,
  resultType: p = "wallet",
  skipEmit: b = !1,
  ...c
}) => {
  const { webWalletUrl: M = E, argentMobileOptions: v } = c, { connectors: i } = c;
  n = null;
  const d = !i || i.length === 0 ? P({
    argentMobileOptions: v,
    webWalletUrl: M
  }) : i;
  b && d?.map((t) => {
    I(t) && "connector" in t && "_options" in t.connector && (t.connector._options.shouldEmit = !1);
  });
  const f = localStorage.getItem("starknetLastConnectedWallet");
  if (a === "neverAsk")
    try {
      const t = y(d, f);
      let u = null;
      return t && p === "wallet" && (u = await t.connect({
        onlyQRCode: !0
      })), {
        connector: t,
        wallet: t?.wallet ?? null,
        connectorData: u
      };
    } catch (t) {
      throw A(), new Error(t);
    }
  const g = await w.getAvailableWallets(c);
  if (a === "canAsk" && f && ((await w.getAuthorizedWallets(c)).find((e) => e.id === f) ?? g.length === 1 ? g[0] : void 0)) {
    const e = y(d, f);
    let l = null;
    return p === "wallet" && (l = await e?.connect({
      onlyQRCode: !0
    }) ?? null), e && (n = e), {
      connector: n,
      connectorData: l,
      wallet: e?.wallet ?? null
    };
  }
  const L = (await w.getDiscoveryWallets(c)).map(
    (t) => t.id.toLowerCase() === "argentx" ? {
      ...t,
      name: "Ready Wallet (formerly Argent)"
    } : t
  ), S = R({
    availableConnectors: d,
    installedWallets: g,
    discoveryWallets: L,
    storeVersion: s,
    customOrder: i ? i?.length > 0 : !1
  });
  return new Promise((t, u) => {
    const e = new $({
      target: B(),
      props: {
        dappName: m,
        callback: async (l, D = !1) => {
          try {
            if (!l)
              throw new Error("Connector error");
            if (e.$set({ selectedWallet: l }), !l.installed) {
              e.$set({ layout: r.download });
              return;
            }
            if (n = U(
              l.connector,
              D
            ), p === "wallet") {
              n instanceof x ? e.$set({ layout: r.qrCode }) : e.$set({ layout: r.connecting });
              const h = await n?.connect({
                onlyQRCode: !0
              }) ?? null;
              n !== null && T(n.id), t({
                connector: n,
                connectorData: h,
                wallet: n?.wallet ?? null
              }), e.$set({ layout: r.success }), setTimeout(() => e.$destroy(), 500);
            } else
              t({
                connector: n,
                wallet: null,
                connectorData: null
              }), e.$destroy();
          } catch (h) {
            [r.connecting, r.qrCode].includes(e.getLayout()) ? e.$set({ layout: r.loginFailure }) : u(h);
          }
        },
        theme: o === "system" ? null : o ?? null,
        modalWallets: S
      }
    });
  });
}, lt = () => n ? n.wallet : null, rt = async (a = {}) => (A(), n && await n.disconnect(), n = null, w.disconnect(a));
export {
  K as connect,
  rt as disconnect,
  lt as getSelectedConnectorWallet,
  at as useStarknetkitConnectModal
};
