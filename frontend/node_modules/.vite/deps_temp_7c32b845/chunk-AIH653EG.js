import {
  C,
  Fe,
  L2 as L,
  M,
  Pe,
  Q,
  Re,
  S,
  U,
  Ve,
  W,
  bl,
  fn,
  main,
  n,
  p,
  wl
} from "./chunk-AJC5X6ZJ.js";
import {
  CallData,
  Field,
  FpSqrtEven,
  HashMD,
  TypedDataRevision,
  WalletAccount,
  aInRange,
  abool,
  addAddressPadding,
  bytesToHex,
  bytesToNumberLE,
  concatBytes,
  concatBytes2,
  constants_exports,
  createHasher,
  ensureBytes,
  equalBytes,
  getChecksumAddress,
  hash_exports,
  isNegativeLE,
  keccak_256,
  memoized,
  mod,
  num_exports,
  numberToBytesLE,
  pippenger,
  pow,
  pow2,
  randomBytes,
  secp256k1,
  sha256,
  shortString_exports,
  typedData_exports,
  u64_default,
  utf8ToBytes,
  validateBasic,
  validateObject,
  wNAF,
  wrapConstructor
} from "./chunk-IPCCDMRO.js";
import {
  __commonJS,
  __esm,
  __export,
  __glob,
  __publicField,
  __require,
  __toCommonJS,
  __toESM
} from "./chunk-MYUJR7WL.js";

// node_modules/@metamask/sdk/node_modules/cross-fetch/dist/browser-ponyfill.js
var require_browser_ponyfill = __commonJS({
  "node_modules/@metamask/sdk/node_modules/cross-fetch/dist/browser-ponyfill.js"(exports, module) {
    var __global__ = typeof globalThis !== "undefined" && globalThis || typeof self !== "undefined" && self || typeof global !== "undefined" && global;
    var __globalThis__ = function() {
      function F3() {
        this.fetch = false;
        this.DOMException = __global__.DOMException;
      }
      F3.prototype = __global__;
      return new F3();
    }();
    (function(globalThis2) {
      var irrelevant = function(exports2) {
        var g2 = typeof globalThis2 !== "undefined" && globalThis2 || typeof self !== "undefined" && self || // eslint-disable-next-line no-undef
        typeof global !== "undefined" && global || {};
        var support = {
          searchParams: "URLSearchParams" in g2,
          iterable: "Symbol" in g2 && "iterator" in Symbol,
          blob: "FileReader" in g2 && "Blob" in g2 && function() {
            try {
              new Blob();
              return true;
            } catch (e9) {
              return false;
            }
          }(),
          formData: "FormData" in g2,
          arrayBuffer: "ArrayBuffer" in g2
        };
        function isDataView(obj) {
          return obj && DataView.prototype.isPrototypeOf(obj);
        }
        if (support.arrayBuffer) {
          var viewClasses = [
            "[object Int8Array]",
            "[object Uint8Array]",
            "[object Uint8ClampedArray]",
            "[object Int16Array]",
            "[object Uint16Array]",
            "[object Int32Array]",
            "[object Uint32Array]",
            "[object Float32Array]",
            "[object Float64Array]"
          ];
          var isArrayBufferView = ArrayBuffer.isView || function(obj) {
            return obj && viewClasses.indexOf(Object.prototype.toString.call(obj)) > -1;
          };
        }
        function normalizeName(name) {
          if (typeof name !== "string") {
            name = String(name);
          }
          if (/[^a-z0-9\-#$%&'*+.^_`|~!]/i.test(name) || name === "") {
            throw new TypeError('Invalid character in header field name: "' + name + '"');
          }
          return name.toLowerCase();
        }
        function normalizeValue(value2) {
          if (typeof value2 !== "string") {
            value2 = String(value2);
          }
          return value2;
        }
        function iteratorFor(items) {
          var iterator = {
            next: function() {
              var value2 = items.shift();
              return { done: value2 === void 0, value: value2 };
            }
          };
          if (support.iterable) {
            iterator[Symbol.iterator] = function() {
              return iterator;
            };
          }
          return iterator;
        }
        function Headers2(headers) {
          this.map = {};
          if (headers instanceof Headers2) {
            headers.forEach(function(value2, name) {
              this.append(name, value2);
            }, this);
          } else if (Array.isArray(headers)) {
            headers.forEach(function(header) {
              if (header.length != 2) {
                throw new TypeError("Headers constructor: expected name/value pair to be length 2, found" + header.length);
              }
              this.append(header[0], header[1]);
            }, this);
          } else if (headers) {
            Object.getOwnPropertyNames(headers).forEach(function(name) {
              this.append(name, headers[name]);
            }, this);
          }
        }
        Headers2.prototype.append = function(name, value2) {
          name = normalizeName(name);
          value2 = normalizeValue(value2);
          var oldValue = this.map[name];
          this.map[name] = oldValue ? oldValue + ", " + value2 : value2;
        };
        Headers2.prototype["delete"] = function(name) {
          delete this.map[normalizeName(name)];
        };
        Headers2.prototype.get = function(name) {
          name = normalizeName(name);
          return this.has(name) ? this.map[name] : null;
        };
        Headers2.prototype.has = function(name) {
          return this.map.hasOwnProperty(normalizeName(name));
        };
        Headers2.prototype.set = function(name, value2) {
          this.map[normalizeName(name)] = normalizeValue(value2);
        };
        Headers2.prototype.forEach = function(callback, thisArg) {
          for (var name in this.map) {
            if (this.map.hasOwnProperty(name)) {
              callback.call(thisArg, this.map[name], name, this);
            }
          }
        };
        Headers2.prototype.keys = function() {
          var items = [];
          this.forEach(function(value2, name) {
            items.push(name);
          });
          return iteratorFor(items);
        };
        Headers2.prototype.values = function() {
          var items = [];
          this.forEach(function(value2) {
            items.push(value2);
          });
          return iteratorFor(items);
        };
        Headers2.prototype.entries = function() {
          var items = [];
          this.forEach(function(value2, name) {
            items.push([name, value2]);
          });
          return iteratorFor(items);
        };
        if (support.iterable) {
          Headers2.prototype[Symbol.iterator] = Headers2.prototype.entries;
        }
        function consumed(body) {
          if (body._noBody) return;
          if (body.bodyUsed) {
            return Promise.reject(new TypeError("Already read"));
          }
          body.bodyUsed = true;
        }
        function fileReaderReady(reader) {
          return new Promise(function(resolve, reject) {
            reader.onload = function() {
              resolve(reader.result);
            };
            reader.onerror = function() {
              reject(reader.error);
            };
          });
        }
        function readBlobAsArrayBuffer(blob3) {
          var reader = new FileReader();
          var promise = fileReaderReady(reader);
          reader.readAsArrayBuffer(blob3);
          return promise;
        }
        function readBlobAsText(blob3) {
          var reader = new FileReader();
          var promise = fileReaderReady(reader);
          var match = /charset=([A-Za-z0-9_-]+)/.exec(blob3.type);
          var encoding = match ? match[1] : "utf-8";
          reader.readAsText(blob3, encoding);
          return promise;
        }
        function readArrayBufferAsText(buf) {
          var view = new Uint8Array(buf);
          var chars2 = new Array(view.length);
          for (var i4 = 0; i4 < view.length; i4++) {
            chars2[i4] = String.fromCharCode(view[i4]);
          }
          return chars2.join("");
        }
        function bufferClone(buf) {
          if (buf.slice) {
            return buf.slice(0);
          } else {
            var view = new Uint8Array(buf.byteLength);
            view.set(new Uint8Array(buf));
            return view.buffer;
          }
        }
        function Body() {
          this.bodyUsed = false;
          this._initBody = function(body) {
            this.bodyUsed = this.bodyUsed;
            this._bodyInit = body;
            if (!body) {
              this._noBody = true;
              this._bodyText = "";
            } else if (typeof body === "string") {
              this._bodyText = body;
            } else if (support.blob && Blob.prototype.isPrototypeOf(body)) {
              this._bodyBlob = body;
            } else if (support.formData && FormData.prototype.isPrototypeOf(body)) {
              this._bodyFormData = body;
            } else if (support.searchParams && URLSearchParams.prototype.isPrototypeOf(body)) {
              this._bodyText = body.toString();
            } else if (support.arrayBuffer && support.blob && isDataView(body)) {
              this._bodyArrayBuffer = bufferClone(body.buffer);
              this._bodyInit = new Blob([this._bodyArrayBuffer]);
            } else if (support.arrayBuffer && (ArrayBuffer.prototype.isPrototypeOf(body) || isArrayBufferView(body))) {
              this._bodyArrayBuffer = bufferClone(body);
            } else {
              this._bodyText = body = Object.prototype.toString.call(body);
            }
            if (!this.headers.get("content-type")) {
              if (typeof body === "string") {
                this.headers.set("content-type", "text/plain;charset=UTF-8");
              } else if (this._bodyBlob && this._bodyBlob.type) {
                this.headers.set("content-type", this._bodyBlob.type);
              } else if (support.searchParams && URLSearchParams.prototype.isPrototypeOf(body)) {
                this.headers.set("content-type", "application/x-www-form-urlencoded;charset=UTF-8");
              }
            }
          };
          if (support.blob) {
            this.blob = function() {
              var rejected = consumed(this);
              if (rejected) {
                return rejected;
              }
              if (this._bodyBlob) {
                return Promise.resolve(this._bodyBlob);
              } else if (this._bodyArrayBuffer) {
                return Promise.resolve(new Blob([this._bodyArrayBuffer]));
              } else if (this._bodyFormData) {
                throw new Error("could not read FormData body as blob");
              } else {
                return Promise.resolve(new Blob([this._bodyText]));
              }
            };
          }
          this.arrayBuffer = function() {
            if (this._bodyArrayBuffer) {
              var isConsumed = consumed(this);
              if (isConsumed) {
                return isConsumed;
              } else if (ArrayBuffer.isView(this._bodyArrayBuffer)) {
                return Promise.resolve(
                  this._bodyArrayBuffer.buffer.slice(
                    this._bodyArrayBuffer.byteOffset,
                    this._bodyArrayBuffer.byteOffset + this._bodyArrayBuffer.byteLength
                  )
                );
              } else {
                return Promise.resolve(this._bodyArrayBuffer);
              }
            } else if (support.blob) {
              return this.blob().then(readBlobAsArrayBuffer);
            } else {
              throw new Error("could not read as ArrayBuffer");
            }
          };
          this.text = function() {
            var rejected = consumed(this);
            if (rejected) {
              return rejected;
            }
            if (this._bodyBlob) {
              return readBlobAsText(this._bodyBlob);
            } else if (this._bodyArrayBuffer) {
              return Promise.resolve(readArrayBufferAsText(this._bodyArrayBuffer));
            } else if (this._bodyFormData) {
              throw new Error("could not read FormData body as text");
            } else {
              return Promise.resolve(this._bodyText);
            }
          };
          if (support.formData) {
            this.formData = function() {
              return this.text().then(decode4);
            };
          }
          this.json = function() {
            return this.text().then(JSON.parse);
          };
          return this;
        }
        var methods = ["CONNECT", "DELETE", "GET", "HEAD", "OPTIONS", "PATCH", "POST", "PUT", "TRACE"];
        function normalizeMethod(method) {
          var upcased = method.toUpperCase();
          return methods.indexOf(upcased) > -1 ? upcased : method;
        }
        function Request2(input, options) {
          if (!(this instanceof Request2)) {
            throw new TypeError('Please use the "new" operator, this DOM object constructor cannot be called as a function.');
          }
          options = options || {};
          var body = options.body;
          if (input instanceof Request2) {
            if (input.bodyUsed) {
              throw new TypeError("Already read");
            }
            this.url = input.url;
            this.credentials = input.credentials;
            if (!options.headers) {
              this.headers = new Headers2(input.headers);
            }
            this.method = input.method;
            this.mode = input.mode;
            this.signal = input.signal;
            if (!body && input._bodyInit != null) {
              body = input._bodyInit;
              input.bodyUsed = true;
            }
          } else {
            this.url = String(input);
          }
          this.credentials = options.credentials || this.credentials || "same-origin";
          if (options.headers || !this.headers) {
            this.headers = new Headers2(options.headers);
          }
          this.method = normalizeMethod(options.method || this.method || "GET");
          this.mode = options.mode || this.mode || null;
          this.signal = options.signal || this.signal || function() {
            if ("AbortController" in g2) {
              var ctrl = new AbortController();
              return ctrl.signal;
            }
          }();
          this.referrer = null;
          if ((this.method === "GET" || this.method === "HEAD") && body) {
            throw new TypeError("Body not allowed for GET or HEAD requests");
          }
          this._initBody(body);
          if (this.method === "GET" || this.method === "HEAD") {
            if (options.cache === "no-store" || options.cache === "no-cache") {
              var reParamSearch = /([?&])_=[^&]*/;
              if (reParamSearch.test(this.url)) {
                this.url = this.url.replace(reParamSearch, "$1_=" + (/* @__PURE__ */ new Date()).getTime());
              } else {
                var reQueryString = /\?/;
                this.url += (reQueryString.test(this.url) ? "&" : "?") + "_=" + (/* @__PURE__ */ new Date()).getTime();
              }
            }
          }
        }
        Request2.prototype.clone = function() {
          return new Request2(this, { body: this._bodyInit });
        };
        function decode4(body) {
          var form = new FormData();
          body.trim().split("&").forEach(function(bytes) {
            if (bytes) {
              var split = bytes.split("=");
              var name = split.shift().replace(/\+/g, " ");
              var value2 = split.join("=").replace(/\+/g, " ");
              form.append(decodeURIComponent(name), decodeURIComponent(value2));
            }
          });
          return form;
        }
        function parseHeaders(rawHeaders) {
          var headers = new Headers2();
          var preProcessedHeaders = rawHeaders.replace(/\r?\n[\t ]+/g, " ");
          preProcessedHeaders.split("\r").map(function(header) {
            return header.indexOf("\n") === 0 ? header.substr(1, header.length) : header;
          }).forEach(function(line) {
            var parts2 = line.split(":");
            var key = parts2.shift().trim();
            if (key) {
              var value2 = parts2.join(":").trim();
              try {
                headers.append(key, value2);
              } catch (error) {
                console.warn("Response " + error.message);
              }
            }
          });
          return headers;
        }
        Body.call(Request2.prototype);
        function Response2(bodyInit, options) {
          if (!(this instanceof Response2)) {
            throw new TypeError('Please use the "new" operator, this DOM object constructor cannot be called as a function.');
          }
          if (!options) {
            options = {};
          }
          this.type = "default";
          this.status = options.status === void 0 ? 200 : options.status;
          if (this.status < 200 || this.status > 599) {
            throw new RangeError("Failed to construct 'Response': The status provided (0) is outside the range [200, 599].");
          }
          this.ok = this.status >= 200 && this.status < 300;
          this.statusText = options.statusText === void 0 ? "" : "" + options.statusText;
          this.headers = new Headers2(options.headers);
          this.url = options.url || "";
          this._initBody(bodyInit);
        }
        Body.call(Response2.prototype);
        Response2.prototype.clone = function() {
          return new Response2(this._bodyInit, {
            status: this.status,
            statusText: this.statusText,
            headers: new Headers2(this.headers),
            url: this.url
          });
        };
        Response2.error = function() {
          var response = new Response2(null, { status: 200, statusText: "" });
          response.ok = false;
          response.status = 0;
          response.type = "error";
          return response;
        };
        var redirectStatuses = [301, 302, 303, 307, 308];
        Response2.redirect = function(url2, status) {
          if (redirectStatuses.indexOf(status) === -1) {
            throw new RangeError("Invalid status code");
          }
          return new Response2(null, { status, headers: { location: url2 } });
        };
        exports2.DOMException = g2.DOMException;
        try {
          new exports2.DOMException();
        } catch (err) {
          exports2.DOMException = function(message, name) {
            this.message = message;
            this.name = name;
            var error = Error(message);
            this.stack = error.stack;
          };
          exports2.DOMException.prototype = Object.create(Error.prototype);
          exports2.DOMException.prototype.constructor = exports2.DOMException;
        }
        function fetch2(input, init) {
          return new Promise(function(resolve, reject) {
            var request = new Request2(input, init);
            if (request.signal && request.signal.aborted) {
              return reject(new exports2.DOMException("Aborted", "AbortError"));
            }
            var xhr = new XMLHttpRequest();
            function abortXhr() {
              xhr.abort();
            }
            xhr.onload = function() {
              var options = {
                statusText: xhr.statusText,
                headers: parseHeaders(xhr.getAllResponseHeaders() || "")
              };
              if (request.url.indexOf("file://") === 0 && (xhr.status < 200 || xhr.status > 599)) {
                options.status = 200;
              } else {
                options.status = xhr.status;
              }
              options.url = "responseURL" in xhr ? xhr.responseURL : options.headers.get("X-Request-URL");
              var body = "response" in xhr ? xhr.response : xhr.responseText;
              setTimeout(function() {
                resolve(new Response2(body, options));
              }, 0);
            };
            xhr.onerror = function() {
              setTimeout(function() {
                reject(new TypeError("Network request failed"));
              }, 0);
            };
            xhr.ontimeout = function() {
              setTimeout(function() {
                reject(new TypeError("Network request timed out"));
              }, 0);
            };
            xhr.onabort = function() {
              setTimeout(function() {
                reject(new exports2.DOMException("Aborted", "AbortError"));
              }, 0);
            };
            function fixUrl(url2) {
              try {
                return url2 === "" && g2.location.href ? g2.location.href : url2;
              } catch (e9) {
                return url2;
              }
            }
            xhr.open(request.method, fixUrl(request.url), true);
            if (request.credentials === "include") {
              xhr.withCredentials = true;
            } else if (request.credentials === "omit") {
              xhr.withCredentials = false;
            }
            if ("responseType" in xhr) {
              if (support.blob) {
                xhr.responseType = "blob";
              } else if (support.arrayBuffer) {
                xhr.responseType = "arraybuffer";
              }
            }
            if (init && typeof init.headers === "object" && !(init.headers instanceof Headers2 || g2.Headers && init.headers instanceof g2.Headers)) {
              var names = [];
              Object.getOwnPropertyNames(init.headers).forEach(function(name) {
                names.push(normalizeName(name));
                xhr.setRequestHeader(name, normalizeValue(init.headers[name]));
              });
              request.headers.forEach(function(value2, name) {
                if (names.indexOf(name) === -1) {
                  xhr.setRequestHeader(name, value2);
                }
              });
            } else {
              request.headers.forEach(function(value2, name) {
                xhr.setRequestHeader(name, value2);
              });
            }
            if (request.signal) {
              request.signal.addEventListener("abort", abortXhr);
              xhr.onreadystatechange = function() {
                if (xhr.readyState === 4) {
                  request.signal.removeEventListener("abort", abortXhr);
                }
              };
            }
            xhr.send(typeof request._bodyInit === "undefined" ? null : request._bodyInit);
          });
        }
        fetch2.polyfill = true;
        if (!g2.fetch) {
          g2.fetch = fetch2;
          g2.Headers = Headers2;
          g2.Request = Request2;
          g2.Response = Response2;
        }
        exports2.Headers = Headers2;
        exports2.Request = Request2;
        exports2.Response = Response2;
        exports2.fetch = fetch2;
        return exports2;
      }({});
    })(__globalThis__);
    __globalThis__.fetch.ponyfill = true;
    delete __globalThis__.fetch.polyfill;
    var ctx = __global__.fetch ? __global__ : __globalThis__;
    exports = ctx.fetch;
    exports.default = ctx.fetch;
    exports.fetch = ctx.fetch;
    exports.Headers = ctx.Headers;
    exports.Request = ctx.Request;
    exports.Response = ctx.Response;
    module.exports = exports;
  }
});

// node_modules/ms/index.js
var require_ms = __commonJS({
  "node_modules/ms/index.js"(exports, module) {
    var s2 = 1e3;
    var m4 = s2 * 60;
    var h3 = m4 * 60;
    var d3 = h3 * 24;
    var w5 = d3 * 7;
    var y2 = d3 * 365.25;
    module.exports = function(val, options) {
      options = options || {};
      var type2 = typeof val;
      if (type2 === "string" && val.length > 0) {
        return parse3(val);
      } else if (type2 === "number" && isFinite(val)) {
        return options.long ? fmtLong(val) : fmtShort(val);
      }
      throw new Error(
        "val is not a non-empty string or a valid number. val=" + JSON.stringify(val)
      );
    };
    function parse3(str) {
      str = String(str);
      if (str.length > 100) {
        return;
      }
      var match = /^(-?(?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)?$/i.exec(
        str
      );
      if (!match) {
        return;
      }
      var n6 = parseFloat(match[1]);
      var type2 = (match[2] || "ms").toLowerCase();
      switch (type2) {
        case "years":
        case "year":
        case "yrs":
        case "yr":
        case "y":
          return n6 * y2;
        case "weeks":
        case "week":
        case "w":
          return n6 * w5;
        case "days":
        case "day":
        case "d":
          return n6 * d3;
        case "hours":
        case "hour":
        case "hrs":
        case "hr":
        case "h":
          return n6 * h3;
        case "minutes":
        case "minute":
        case "mins":
        case "min":
        case "m":
          return n6 * m4;
        case "seconds":
        case "second":
        case "secs":
        case "sec":
        case "s":
          return n6 * s2;
        case "milliseconds":
        case "millisecond":
        case "msecs":
        case "msec":
        case "ms":
          return n6;
        default:
          return void 0;
      }
    }
    function fmtShort(ms2) {
      var msAbs = Math.abs(ms2);
      if (msAbs >= d3) {
        return Math.round(ms2 / d3) + "d";
      }
      if (msAbs >= h3) {
        return Math.round(ms2 / h3) + "h";
      }
      if (msAbs >= m4) {
        return Math.round(ms2 / m4) + "m";
      }
      if (msAbs >= s2) {
        return Math.round(ms2 / s2) + "s";
      }
      return ms2 + "ms";
    }
    function fmtLong(ms2) {
      var msAbs = Math.abs(ms2);
      if (msAbs >= d3) {
        return plural(ms2, msAbs, d3, "day");
      }
      if (msAbs >= h3) {
        return plural(ms2, msAbs, h3, "hour");
      }
      if (msAbs >= m4) {
        return plural(ms2, msAbs, m4, "minute");
      }
      if (msAbs >= s2) {
        return plural(ms2, msAbs, s2, "second");
      }
      return ms2 + " ms";
    }
    function plural(ms2, msAbs, n6, name) {
      var isPlural = msAbs >= n6 * 1.5;
      return Math.round(ms2 / n6) + " " + name + (isPlural ? "s" : "");
    }
  }
});

// node_modules/debug/src/common.js
var require_common = __commonJS({
  "node_modules/debug/src/common.js"(exports, module) {
    function setup(env) {
      createDebug.debug = createDebug;
      createDebug.default = createDebug;
      createDebug.coerce = coerce2;
      createDebug.disable = disable;
      createDebug.enable = enable;
      createDebug.enabled = enabled;
      createDebug.humanize = require_ms();
      createDebug.destroy = destroy;
      Object.keys(env).forEach((key) => {
        createDebug[key] = env[key];
      });
      createDebug.names = [];
      createDebug.skips = [];
      createDebug.formatters = {};
      function selectColor(namespace) {
        let hash = 0;
        for (let i4 = 0; i4 < namespace.length; i4++) {
          hash = (hash << 5) - hash + namespace.charCodeAt(i4);
          hash |= 0;
        }
        return createDebug.colors[Math.abs(hash) % createDebug.colors.length];
      }
      createDebug.selectColor = selectColor;
      function createDebug(namespace) {
        let prevTime;
        let enableOverride = null;
        let namespacesCache;
        let enabledCache;
        function debug(...args) {
          if (!debug.enabled) {
            return;
          }
          const self2 = debug;
          const curr = Number(/* @__PURE__ */ new Date());
          const ms2 = curr - (prevTime || curr);
          self2.diff = ms2;
          self2.prev = prevTime;
          self2.curr = curr;
          prevTime = curr;
          args[0] = createDebug.coerce(args[0]);
          if (typeof args[0] !== "string") {
            args.unshift("%O");
          }
          let index = 0;
          args[0] = args[0].replace(/%([a-zA-Z%])/g, (match, format) => {
            if (match === "%%") {
              return "%";
            }
            index++;
            const formatter = createDebug.formatters[format];
            if (typeof formatter === "function") {
              const val = args[index];
              match = formatter.call(self2, val);
              args.splice(index, 1);
              index--;
            }
            return match;
          });
          createDebug.formatArgs.call(self2, args);
          const logFn = self2.log || createDebug.log;
          logFn.apply(self2, args);
        }
        debug.namespace = namespace;
        debug.useColors = createDebug.useColors();
        debug.color = createDebug.selectColor(namespace);
        debug.extend = extend;
        debug.destroy = createDebug.destroy;
        Object.defineProperty(debug, "enabled", {
          enumerable: true,
          configurable: false,
          get: () => {
            if (enableOverride !== null) {
              return enableOverride;
            }
            if (namespacesCache !== createDebug.namespaces) {
              namespacesCache = createDebug.namespaces;
              enabledCache = createDebug.enabled(namespace);
            }
            return enabledCache;
          },
          set: (v2) => {
            enableOverride = v2;
          }
        });
        if (typeof createDebug.init === "function") {
          createDebug.init(debug);
        }
        return debug;
      }
      function extend(namespace, delimiter) {
        const newDebug = createDebug(this.namespace + (typeof delimiter === "undefined" ? ":" : delimiter) + namespace);
        newDebug.log = this.log;
        return newDebug;
      }
      function enable(namespaces) {
        createDebug.save(namespaces);
        createDebug.namespaces = namespaces;
        createDebug.names = [];
        createDebug.skips = [];
        let i4;
        const split = (typeof namespaces === "string" ? namespaces : "").split(/[\s,]+/);
        const len = split.length;
        for (i4 = 0; i4 < len; i4++) {
          if (!split[i4]) {
            continue;
          }
          namespaces = split[i4].replace(/\*/g, ".*?");
          if (namespaces[0] === "-") {
            createDebug.skips.push(new RegExp("^" + namespaces.slice(1) + "$"));
          } else {
            createDebug.names.push(new RegExp("^" + namespaces + "$"));
          }
        }
      }
      function disable() {
        const namespaces = [
          ...createDebug.names.map(toNamespace),
          ...createDebug.skips.map(toNamespace).map((namespace) => "-" + namespace)
        ].join(",");
        createDebug.enable("");
        return namespaces;
      }
      function enabled(name) {
        if (name[name.length - 1] === "*") {
          return true;
        }
        let i4;
        let len;
        for (i4 = 0, len = createDebug.skips.length; i4 < len; i4++) {
          if (createDebug.skips[i4].test(name)) {
            return false;
          }
        }
        for (i4 = 0, len = createDebug.names.length; i4 < len; i4++) {
          if (createDebug.names[i4].test(name)) {
            return true;
          }
        }
        return false;
      }
      function toNamespace(regexp) {
        return regexp.toString().substring(2, regexp.toString().length - 2).replace(/\.\*\?$/, "*");
      }
      function coerce2(val) {
        if (val instanceof Error) {
          return val.stack || val.message;
        }
        return val;
      }
      function destroy() {
        console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.");
      }
      createDebug.enable(createDebug.load());
      return createDebug;
    }
    module.exports = setup;
  }
});

// node_modules/debug/src/browser.js
var require_browser = __commonJS({
  "node_modules/debug/src/browser.js"(exports, module) {
    exports.formatArgs = formatArgs;
    exports.save = save;
    exports.load = load;
    exports.useColors = useColors;
    exports.storage = localstorage();
    exports.destroy = /* @__PURE__ */ (() => {
      let warned = false;
      return () => {
        if (!warned) {
          warned = true;
          console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.");
        }
      };
    })();
    exports.colors = [
      "#0000CC",
      "#0000FF",
      "#0033CC",
      "#0033FF",
      "#0066CC",
      "#0066FF",
      "#0099CC",
      "#0099FF",
      "#00CC00",
      "#00CC33",
      "#00CC66",
      "#00CC99",
      "#00CCCC",
      "#00CCFF",
      "#3300CC",
      "#3300FF",
      "#3333CC",
      "#3333FF",
      "#3366CC",
      "#3366FF",
      "#3399CC",
      "#3399FF",
      "#33CC00",
      "#33CC33",
      "#33CC66",
      "#33CC99",
      "#33CCCC",
      "#33CCFF",
      "#6600CC",
      "#6600FF",
      "#6633CC",
      "#6633FF",
      "#66CC00",
      "#66CC33",
      "#9900CC",
      "#9900FF",
      "#9933CC",
      "#9933FF",
      "#99CC00",
      "#99CC33",
      "#CC0000",
      "#CC0033",
      "#CC0066",
      "#CC0099",
      "#CC00CC",
      "#CC00FF",
      "#CC3300",
      "#CC3333",
      "#CC3366",
      "#CC3399",
      "#CC33CC",
      "#CC33FF",
      "#CC6600",
      "#CC6633",
      "#CC9900",
      "#CC9933",
      "#CCCC00",
      "#CCCC33",
      "#FF0000",
      "#FF0033",
      "#FF0066",
      "#FF0099",
      "#FF00CC",
      "#FF00FF",
      "#FF3300",
      "#FF3333",
      "#FF3366",
      "#FF3399",
      "#FF33CC",
      "#FF33FF",
      "#FF6600",
      "#FF6633",
      "#FF9900",
      "#FF9933",
      "#FFCC00",
      "#FFCC33"
    ];
    function useColors() {
      if (typeof window !== "undefined" && window.process && (window.process.type === "renderer" || window.process.__nwjs)) {
        return true;
      }
      if (typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/(edge|trident)\/(\d+)/)) {
        return false;
      }
      let m4;
      return typeof document !== "undefined" && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance || // Is firebug? http://stackoverflow.com/a/398120/376773
      typeof window !== "undefined" && window.console && (window.console.firebug || window.console.exception && window.console.table) || // Is firefox >= v31?
      // https://developer.mozilla.org/en-US/docs/Tools/Web_Console#Styling_messages
      typeof navigator !== "undefined" && navigator.userAgent && (m4 = navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/)) && parseInt(m4[1], 10) >= 31 || // Double check webkit in userAgent just in case we are in a worker
      typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\/(\d+)/);
    }
    function formatArgs(args) {
      args[0] = (this.useColors ? "%c" : "") + this.namespace + (this.useColors ? " %c" : " ") + args[0] + (this.useColors ? "%c " : " ") + "+" + module.exports.humanize(this.diff);
      if (!this.useColors) {
        return;
      }
      const c3 = "color: " + this.color;
      args.splice(1, 0, c3, "color: inherit");
      let index = 0;
      let lastC = 0;
      args[0].replace(/%[a-zA-Z%]/g, (match) => {
        if (match === "%%") {
          return;
        }
        index++;
        if (match === "%c") {
          lastC = index;
        }
      });
      args.splice(lastC, 0, c3);
    }
    exports.log = console.debug || console.log || (() => {
    });
    function save(namespaces) {
      try {
        if (namespaces) {
          exports.storage.setItem("debug", namespaces);
        } else {
          exports.storage.removeItem("debug");
        }
      } catch (error) {
      }
    }
    function load() {
      let r2;
      try {
        r2 = exports.storage.getItem("debug");
      } catch (error) {
      }
      if (!r2 && typeof process !== "undefined" && "env" in process) {
        r2 = process.env.DEBUG;
      }
      return r2;
    }
    function localstorage() {
      try {
        return localStorage;
      } catch (error) {
      }
    }
    module.exports = require_common()(exports);
    var { formatters } = module.exports;
    formatters.j = function(v2) {
      try {
        return JSON.stringify(v2);
      } catch (error) {
        return "[UnexpectedJSONParseError]: " + error.message;
      }
    };
  }
});

// node_modules/openapi-fetch/dist/cjs/index.cjs
var require_cjs = __commonJS({
  "node_modules/openapi-fetch/dist/cjs/index.cjs"(exports, module) {
    "use strict";
    var __defProp = Object.defineProperty;
    var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
    var __getOwnPropNames = Object.getOwnPropertyNames;
    var __hasOwnProp = Object.prototype.hasOwnProperty;
    var __export2 = (target, all) => {
      for (var name in all)
        __defProp(target, name, { get: all[name], enumerable: true });
    };
    var __copyProps = (to2, from, except, desc) => {
      if (from && typeof from === "object" || typeof from === "function") {
        for (let key of __getOwnPropNames(from))
          if (!__hasOwnProp.call(to2, key) && key !== except)
            __defProp(to2, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
      }
      return to2;
    };
    var __toCommonJS2 = (mod2) => __copyProps(__defProp({}, "__esModule", { value: true }), mod2);
    var index_exports = {};
    __export2(index_exports, {
      createFinalURL: () => createFinalURL,
      createPathBasedClient: () => createPathBasedClient,
      createQuerySerializer: () => createQuerySerializer,
      default: () => createClient,
      defaultBodySerializer: () => defaultBodySerializer,
      defaultPathSerializer: () => defaultPathSerializer,
      mergeHeaders: () => mergeHeaders,
      randomID: () => randomID,
      removeTrailingSlash: () => removeTrailingSlash,
      serializeArrayParam: () => serializeArrayParam,
      serializeObjectParam: () => serializeObjectParam,
      serializePrimitiveParam: () => serializePrimitiveParam,
      wrapAsPathBasedClient: () => wrapAsPathBasedClient
    });
    module.exports = __toCommonJS2(index_exports);
    var PATH_PARAM_RE = /\{[^{}]+\}/g;
    var supportsRequestInitExt = () => {
      var _a2, _b;
      return typeof process === "object" && Number.parseInt((_b = (_a2 = process == null ? void 0 : process.versions) == null ? void 0 : _a2.node) == null ? void 0 : _b.substring(0, 2)) >= 18 && process.versions.undici;
    };
    function randomID() {
      return Math.random().toString(36).slice(2, 11);
    }
    function createClient(clientOptions) {
      let {
        baseUrl = "",
        Request: CustomRequest = globalThis.Request,
        fetch: baseFetch = globalThis.fetch,
        querySerializer: globalQuerySerializer,
        bodySerializer: globalBodySerializer,
        headers: baseHeaders,
        requestInitExt = void 0,
        ...baseOptions
      } = { ...clientOptions };
      requestInitExt = supportsRequestInitExt() ? requestInitExt : void 0;
      baseUrl = removeTrailingSlash(baseUrl);
      const middlewares = [];
      async function coreFetch(schemaPath, fetchOptions) {
        const {
          baseUrl: localBaseUrl,
          fetch: fetch2 = baseFetch,
          Request: Request2 = CustomRequest,
          headers,
          params = {},
          parseAs = "json",
          querySerializer: requestQuerySerializer,
          bodySerializer = globalBodySerializer ?? defaultBodySerializer,
          body,
          ...init
        } = fetchOptions || {};
        let finalBaseUrl = baseUrl;
        if (localBaseUrl) {
          finalBaseUrl = removeTrailingSlash(localBaseUrl) ?? baseUrl;
        }
        let querySerializer = typeof globalQuerySerializer === "function" ? globalQuerySerializer : createQuerySerializer(globalQuerySerializer);
        if (requestQuerySerializer) {
          querySerializer = typeof requestQuerySerializer === "function" ? requestQuerySerializer : createQuerySerializer({
            ...typeof globalQuerySerializer === "object" ? globalQuerySerializer : {},
            ...requestQuerySerializer
          });
        }
        const serializedBody = body === void 0 ? void 0 : bodySerializer(
          body,
          // Note: we declare mergeHeaders() both here and below because it’s a bit of a chicken-or-egg situation:
          // bodySerializer() needs all headers so we aren’t dropping ones set by the user, however,
          // the result of this ALSO sets the lowest-priority content-type header. So we re-merge below,
          // setting the content-type at the very beginning to be overwritten.
          // Lastly, based on the way headers work, it’s not a simple “present-or-not” check becauase null intentionally un-sets headers.
          mergeHeaders(baseHeaders, headers, params.header)
        );
        const finalHeaders = mergeHeaders(
          // with no body, we should not to set Content-Type
          serializedBody === void 0 || // if serialized body is FormData; browser will correctly set Content-Type & boundary expression
          serializedBody instanceof FormData ? {} : {
            "Content-Type": "application/json"
          },
          baseHeaders,
          headers,
          params.header
        );
        const requestInit = {
          redirect: "follow",
          ...baseOptions,
          ...init,
          body: serializedBody,
          headers: finalHeaders
        };
        let id2;
        let options;
        let request = new CustomRequest(
          createFinalURL(schemaPath, { baseUrl: finalBaseUrl, params, querySerializer }),
          requestInit
        );
        let response;
        for (const key in init) {
          if (!(key in request)) {
            request[key] = init[key];
          }
        }
        if (middlewares.length) {
          id2 = randomID();
          options = Object.freeze({
            baseUrl: finalBaseUrl,
            fetch: fetch2,
            parseAs,
            querySerializer,
            bodySerializer
          });
          for (const m4 of middlewares) {
            if (m4 && typeof m4 === "object" && typeof m4.onRequest === "function") {
              const result = await m4.onRequest({
                request,
                schemaPath,
                params,
                options,
                id: id2
              });
              if (result) {
                if (result instanceof CustomRequest) {
                  request = result;
                } else if (result instanceof Response) {
                  response = result;
                  break;
                } else {
                  throw new Error("onRequest: must return new Request() or Response() when modifying the request");
                }
              }
            }
          }
        }
        if (!response) {
          try {
            response = await fetch2(request, requestInitExt);
          } catch (error2) {
            let errorAfterMiddleware = error2;
            if (middlewares.length) {
              for (let i4 = middlewares.length - 1; i4 >= 0; i4--) {
                const m4 = middlewares[i4];
                if (m4 && typeof m4 === "object" && typeof m4.onError === "function") {
                  const result = await m4.onError({
                    request,
                    error: errorAfterMiddleware,
                    schemaPath,
                    params,
                    options,
                    id: id2
                  });
                  if (result) {
                    if (result instanceof Response) {
                      errorAfterMiddleware = void 0;
                      response = result;
                      break;
                    }
                    if (result instanceof Error) {
                      errorAfterMiddleware = result;
                      continue;
                    }
                    throw new Error("onError: must return new Response() or instance of Error");
                  }
                }
              }
            }
            if (errorAfterMiddleware) {
              throw errorAfterMiddleware;
            }
          }
          if (middlewares.length) {
            for (let i4 = middlewares.length - 1; i4 >= 0; i4--) {
              const m4 = middlewares[i4];
              if (m4 && typeof m4 === "object" && typeof m4.onResponse === "function") {
                const result = await m4.onResponse({
                  request,
                  response,
                  schemaPath,
                  params,
                  options,
                  id: id2
                });
                if (result) {
                  if (!(result instanceof Response)) {
                    throw new Error("onResponse: must return new Response() when modifying the response");
                  }
                  response = result;
                }
              }
            }
          }
        }
        if (response.status === 204 || request.method === "HEAD" || response.headers.get("Content-Length") === "0") {
          return response.ok ? { data: void 0, response } : { error: void 0, response };
        }
        if (response.ok) {
          if (parseAs === "stream") {
            return { data: response.body, response };
          }
          return { data: await response[parseAs](), response };
        }
        let error = await response.text();
        try {
          error = JSON.parse(error);
        } catch {
        }
        return { error, response };
      }
      return {
        request(method, url2, init) {
          return coreFetch(url2, { ...init, method: method.toUpperCase() });
        },
        /** Call a GET endpoint */
        GET(url2, init) {
          return coreFetch(url2, { ...init, method: "GET" });
        },
        /** Call a PUT endpoint */
        PUT(url2, init) {
          return coreFetch(url2, { ...init, method: "PUT" });
        },
        /** Call a POST endpoint */
        POST(url2, init) {
          return coreFetch(url2, { ...init, method: "POST" });
        },
        /** Call a DELETE endpoint */
        DELETE(url2, init) {
          return coreFetch(url2, { ...init, method: "DELETE" });
        },
        /** Call a OPTIONS endpoint */
        OPTIONS(url2, init) {
          return coreFetch(url2, { ...init, method: "OPTIONS" });
        },
        /** Call a HEAD endpoint */
        HEAD(url2, init) {
          return coreFetch(url2, { ...init, method: "HEAD" });
        },
        /** Call a PATCH endpoint */
        PATCH(url2, init) {
          return coreFetch(url2, { ...init, method: "PATCH" });
        },
        /** Call a TRACE endpoint */
        TRACE(url2, init) {
          return coreFetch(url2, { ...init, method: "TRACE" });
        },
        /** Register middleware */
        use(...middleware) {
          for (const m4 of middleware) {
            if (!m4) {
              continue;
            }
            if (typeof m4 !== "object" || !("onRequest" in m4 || "onResponse" in m4 || "onError" in m4)) {
              throw new Error("Middleware must be an object with one of `onRequest()`, `onResponse() or `onError()`");
            }
            middlewares.push(m4);
          }
        },
        /** Unregister middleware */
        eject(...middleware) {
          for (const m4 of middleware) {
            const i4 = middlewares.indexOf(m4);
            if (i4 !== -1) {
              middlewares.splice(i4, 1);
            }
          }
        }
      };
    }
    var PathCallForwarder = class {
      constructor(client, url2) {
        __publicField(this, "GET", (init) => {
          return this.client.GET(this.url, init);
        });
        __publicField(this, "PUT", (init) => {
          return this.client.PUT(this.url, init);
        });
        __publicField(this, "POST", (init) => {
          return this.client.POST(this.url, init);
        });
        __publicField(this, "DELETE", (init) => {
          return this.client.DELETE(this.url, init);
        });
        __publicField(this, "OPTIONS", (init) => {
          return this.client.OPTIONS(this.url, init);
        });
        __publicField(this, "HEAD", (init) => {
          return this.client.HEAD(this.url, init);
        });
        __publicField(this, "PATCH", (init) => {
          return this.client.PATCH(this.url, init);
        });
        __publicField(this, "TRACE", (init) => {
          return this.client.TRACE(this.url, init);
        });
        this.client = client;
        this.url = url2;
      }
    };
    var PathClientProxyHandler = class {
      constructor() {
        this.client = null;
      }
      // Assume the property is an URL.
      get(coreClient, url2) {
        const forwarder = new PathCallForwarder(coreClient, url2);
        this.client[url2] = forwarder;
        return forwarder;
      }
    };
    function wrapAsPathBasedClient(coreClient) {
      const handler = new PathClientProxyHandler();
      const proxy = new Proxy(coreClient, handler);
      function Client() {
      }
      Client.prototype = proxy;
      const client = new Client();
      handler.client = client;
      return client;
    }
    function createPathBasedClient(clientOptions) {
      return wrapAsPathBasedClient(createClient(clientOptions));
    }
    function serializePrimitiveParam(name, value2, options) {
      if (value2 === void 0 || value2 === null) {
        return "";
      }
      if (typeof value2 === "object") {
        throw new Error(
          "Deeply-nested arrays/objects aren’t supported. Provide your own `querySerializer()` to handle these."
        );
      }
      return `${name}=${(options == null ? void 0 : options.allowReserved) === true ? value2 : encodeURIComponent(value2)}`;
    }
    function serializeObjectParam(name, value2, options) {
      if (!value2 || typeof value2 !== "object") {
        return "";
      }
      const values = [];
      const joiner = {
        simple: ",",
        label: ".",
        matrix: ";"
      }[options.style] || "&";
      if (options.style !== "deepObject" && options.explode === false) {
        for (const k3 in value2) {
          values.push(k3, options.allowReserved === true ? value2[k3] : encodeURIComponent(value2[k3]));
        }
        const final2 = values.join(",");
        switch (options.style) {
          case "form": {
            return `${name}=${final2}`;
          }
          case "label": {
            return `.${final2}`;
          }
          case "matrix": {
            return `;${name}=${final2}`;
          }
          default: {
            return final2;
          }
        }
      }
      for (const k3 in value2) {
        const finalName = options.style === "deepObject" ? `${name}[${k3}]` : k3;
        values.push(serializePrimitiveParam(finalName, value2[k3], options));
      }
      const final = values.join(joiner);
      return options.style === "label" || options.style === "matrix" ? `${joiner}${final}` : final;
    }
    function serializeArrayParam(name, value2, options) {
      if (!Array.isArray(value2)) {
        return "";
      }
      if (options.explode === false) {
        const joiner2 = { form: ",", spaceDelimited: "%20", pipeDelimited: "|" }[options.style] || ",";
        const final = (options.allowReserved === true ? value2 : value2.map((v2) => encodeURIComponent(v2))).join(joiner2);
        switch (options.style) {
          case "simple": {
            return final;
          }
          case "label": {
            return `.${final}`;
          }
          case "matrix": {
            return `;${name}=${final}`;
          }
          default: {
            return `${name}=${final}`;
          }
        }
      }
      const joiner = { simple: ",", label: ".", matrix: ";" }[options.style] || "&";
      const values = [];
      for (const v2 of value2) {
        if (options.style === "simple" || options.style === "label") {
          values.push(options.allowReserved === true ? v2 : encodeURIComponent(v2));
        } else {
          values.push(serializePrimitiveParam(name, v2, options));
        }
      }
      return options.style === "label" || options.style === "matrix" ? `${joiner}${values.join(joiner)}` : values.join(joiner);
    }
    function createQuerySerializer(options) {
      return function querySerializer(queryParams) {
        const search = [];
        if (queryParams && typeof queryParams === "object") {
          for (const name in queryParams) {
            const value2 = queryParams[name];
            if (value2 === void 0 || value2 === null) {
              continue;
            }
            if (Array.isArray(value2)) {
              if (value2.length === 0) {
                continue;
              }
              search.push(
                serializeArrayParam(name, value2, {
                  style: "form",
                  explode: true,
                  ...options == null ? void 0 : options.array,
                  allowReserved: (options == null ? void 0 : options.allowReserved) || false
                })
              );
              continue;
            }
            if (typeof value2 === "object") {
              search.push(
                serializeObjectParam(name, value2, {
                  style: "deepObject",
                  explode: true,
                  ...options == null ? void 0 : options.object,
                  allowReserved: (options == null ? void 0 : options.allowReserved) || false
                })
              );
              continue;
            }
            search.push(serializePrimitiveParam(name, value2, options));
          }
        }
        return search.join("&");
      };
    }
    function defaultPathSerializer(pathname, pathParams) {
      let nextURL = pathname;
      for (const match of pathname.match(PATH_PARAM_RE) ?? []) {
        let name = match.substring(1, match.length - 1);
        let explode = false;
        let style = "simple";
        if (name.endsWith("*")) {
          explode = true;
          name = name.substring(0, name.length - 1);
        }
        if (name.startsWith(".")) {
          style = "label";
          name = name.substring(1);
        } else if (name.startsWith(";")) {
          style = "matrix";
          name = name.substring(1);
        }
        if (!pathParams || pathParams[name] === void 0 || pathParams[name] === null) {
          continue;
        }
        const value2 = pathParams[name];
        if (Array.isArray(value2)) {
          nextURL = nextURL.replace(match, serializeArrayParam(name, value2, { style, explode }));
          continue;
        }
        if (typeof value2 === "object") {
          nextURL = nextURL.replace(match, serializeObjectParam(name, value2, { style, explode }));
          continue;
        }
        if (style === "matrix") {
          nextURL = nextURL.replace(match, `;${serializePrimitiveParam(name, value2)}`);
          continue;
        }
        nextURL = nextURL.replace(match, style === "label" ? `.${encodeURIComponent(value2)}` : encodeURIComponent(value2));
      }
      return nextURL;
    }
    function defaultBodySerializer(body, headers) {
      if (body instanceof FormData) {
        return body;
      }
      if (headers) {
        const contentType = headers.get instanceof Function ? headers.get("Content-Type") ?? headers.get("content-type") : headers["Content-Type"] ?? headers["content-type"];
        if (contentType === "application/x-www-form-urlencoded") {
          return new URLSearchParams(body).toString();
        }
      }
      return JSON.stringify(body);
    }
    function createFinalURL(pathname, options) {
      var _a2;
      let finalURL = `${options.baseUrl}${pathname}`;
      if ((_a2 = options.params) == null ? void 0 : _a2.path) {
        finalURL = defaultPathSerializer(finalURL, options.params.path);
      }
      let search = options.querySerializer(options.params.query ?? {});
      if (search.startsWith("?")) {
        search = search.substring(1);
      }
      if (search) {
        finalURL += `?${search}`;
      }
      return finalURL;
    }
    function mergeHeaders(...allHeaders) {
      const finalHeaders = new Headers();
      for (const h3 of allHeaders) {
        if (!h3 || typeof h3 !== "object") {
          continue;
        }
        const iterator = h3 instanceof Headers ? h3.entries() : Object.entries(h3);
        for (const [k3, v2] of iterator) {
          if (v2 === null) {
            finalHeaders.delete(k3);
          } else if (Array.isArray(v2)) {
            for (const v22 of v2) {
              finalHeaders.append(k3, v22);
            }
          } else if (v2 !== void 0) {
            finalHeaders.set(k3, v2);
          }
        }
      }
      return finalHeaders;
    }
    function removeTrailingSlash(url2) {
      if (url2.endsWith("/")) {
        return url2.substring(0, url2.length - 1);
      }
      return url2;
    }
  }
});

// node_modules/@metamask/sdk-analytics/dist/index.js
var require_dist = __commonJS({
  "node_modules/@metamask/sdk-analytics/dist/index.js"(exports, module) {
    "use strict";
    var __create = Object.create;
    var __defProp = Object.defineProperty;
    var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
    var __getOwnPropNames = Object.getOwnPropertyNames;
    var __getProtoOf = Object.getPrototypeOf;
    var __hasOwnProp = Object.prototype.hasOwnProperty;
    var __export2 = (target, all) => {
      for (var name in all)
        __defProp(target, name, { get: all[name], enumerable: true });
    };
    var __copyProps = (to2, from, except, desc) => {
      if (from && typeof from === "object" || typeof from === "function") {
        for (let key of __getOwnPropNames(from))
          if (!__hasOwnProp.call(to2, key) && key !== except)
            __defProp(to2, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
      }
      return to2;
    };
    var __toESM2 = (mod2, isNodeMode, target) => (target = mod2 != null ? __create(__getProtoOf(mod2)) : {}, __copyProps(
      // If the importer is in node compatibility mode or this is not an ESM
      // file that has been converted to a CommonJS file using a Babel-
      // compatible transform (i.e. "__esModule" has not been set), then set
      // "default" to the CommonJS "module.exports" for node compatibility.
      isNodeMode || !mod2 || !mod2.__esModule ? __defProp(target, "default", { value: mod2, enumerable: true }) : target,
      mod2
    ));
    var __toCommonJS2 = (mod2) => __copyProps(__defProp({}, "__esModule", { value: true }), mod2);
    var index_exports = {};
    __export2(index_exports, {
      analytics: () => analytics
    });
    module.exports = __toCommonJS2(index_exports);
    var import_openapi_fetch = __toESM2(require_cjs());
    var Sender = class {
      constructor(options) {
        this.batch = [];
        this.maxTimeoutMs = 3e4;
        this.timeoutId = null;
        this.isSending = false;
        this.batchSize = options.batchSize;
        this.baseTimeoutMs = options.baseTimeoutMs;
        this.currentTimeoutMs = options.baseTimeoutMs;
        this.sendFn = options.sendFn;
      }
      enqueue(item) {
        this.batch.push(item);
        this.schedule();
      }
      schedule() {
        if (this.batch.length > 0 && !this.timeoutId) {
          this.timeoutId = setTimeout(() => {
            this.timeoutId = null;
            this.flush();
          }, this.currentTimeoutMs);
        }
      }
      async flush() {
        if (this.isSending || this.batch.length === 0) {
          return;
        }
        this.isSending = true;
        const current = [...this.batch.slice(0, this.batchSize)];
        this.batch = this.batch.slice(this.batchSize);
        try {
          await this.sendFn(current);
          this.currentTimeoutMs = this.baseTimeoutMs;
        } catch (error) {
          console.error("Sender: Failed to send batch", error);
          this.batch = [...current, ...this.batch];
          this.currentTimeoutMs = Math.min(
            this.currentTimeoutMs * 2,
            this.maxTimeoutMs
          );
        } finally {
          this.isSending = false;
          this.schedule();
        }
      }
    };
    var sender_default = Sender;
    var Analytics = class {
      constructor(baseUrl) {
        this.enabled = false;
        this.properties = {};
        const client2 = (0, import_openapi_fetch.default)({ baseUrl });
        const sendFn = async (batch) => {
          const res = await client2.POST("/v1/events", { body: batch });
          if (res.response.status !== 200) {
            throw new Error(res.error);
          }
        };
        this.sender = new sender_default({ batchSize: 100, baseTimeoutMs: 200, sendFn });
      }
      enable() {
        this.enabled = true;
      }
      setGlobalProperty(key, value2) {
        this.properties[key] = value2;
      }
      track(name, properties) {
        if (!this.enabled) {
          return;
        }
        const event = {
          name,
          ...this.properties,
          ...properties
        };
        this.sender.enqueue(event);
      }
    };
    var analytics_default = Analytics;
    var endpoint;
    var _a2;
    if (typeof process !== "undefined" && process.env) {
      endpoint = (_a2 = process.env.METAMASK_ANALYTICS_ENDPOINT) != null ? _a2 : process.env.NEXT_PUBLIC_METAMASK_ANALYTICS_ENDPOINT;
    }
    var METAMASK_ANALYTICS_ENDPOINT = endpoint != null ? endpoint : "https://mm-sdk-analytics.api.cx.metamask.io/";
    var client = new analytics_default(METAMASK_ANALYTICS_ENDPOINT);
    var analytics = client;
  }
});

// node_modules/eventemitter2/lib/eventemitter2.js
var require_eventemitter2 = __commonJS({
  "node_modules/eventemitter2/lib/eventemitter2.js"(exports, module) {
    !function(undefined2) {
      var hasOwnProperty = Object.hasOwnProperty;
      var isArray = Array.isArray ? Array.isArray : function _isArray(obj) {
        return Object.prototype.toString.call(obj) === "[object Array]";
      };
      var defaultMaxListeners = 10;
      var nextTickSupported = typeof process == "object" && typeof process.nextTick == "function";
      var symbolsSupported = typeof Symbol === "function";
      var reflectSupported = typeof Reflect === "object";
      var setImmediateSupported = typeof setImmediate === "function";
      var _setImmediate = setImmediateSupported ? setImmediate : setTimeout;
      var ownKeys = symbolsSupported ? reflectSupported && typeof Reflect.ownKeys === "function" ? Reflect.ownKeys : function(obj) {
        var arr = Object.getOwnPropertyNames(obj);
        arr.push.apply(arr, Object.getOwnPropertySymbols(obj));
        return arr;
      } : Object.keys;
      function init() {
        this._events = {};
        if (this._conf) {
          configure.call(this, this._conf);
        }
      }
      function configure(conf) {
        if (conf) {
          this._conf = conf;
          conf.delimiter && (this.delimiter = conf.delimiter);
          if (conf.maxListeners !== undefined2) {
            this._maxListeners = conf.maxListeners;
          }
          conf.wildcard && (this.wildcard = conf.wildcard);
          conf.newListener && (this._newListener = conf.newListener);
          conf.removeListener && (this._removeListener = conf.removeListener);
          conf.verboseMemoryLeak && (this.verboseMemoryLeak = conf.verboseMemoryLeak);
          conf.ignoreErrors && (this.ignoreErrors = conf.ignoreErrors);
          if (this.wildcard) {
            this.listenerTree = {};
          }
        }
      }
      function logPossibleMemoryLeak(count, eventName) {
        var errorMsg = "(node) warning: possible EventEmitter memory leak detected. " + count + " listeners added. Use emitter.setMaxListeners() to increase limit.";
        if (this.verboseMemoryLeak) {
          errorMsg += " Event name: " + eventName + ".";
        }
        if (typeof process !== "undefined" && process.emitWarning) {
          var e9 = new Error(errorMsg);
          e9.name = "MaxListenersExceededWarning";
          e9.emitter = this;
          e9.count = count;
          process.emitWarning(e9);
        } else {
          console.error(errorMsg);
          if (console.trace) {
            console.trace();
          }
        }
      }
      var toArray2 = function(a, b3, c3) {
        var n6 = arguments.length;
        switch (n6) {
          case 0:
            return [];
          case 1:
            return [a];
          case 2:
            return [a, b3];
          case 3:
            return [a, b3, c3];
          default:
            var arr = new Array(n6);
            while (n6--) {
              arr[n6] = arguments[n6];
            }
            return arr;
        }
      };
      function toObject(keys, values) {
        var obj = {};
        var key;
        var len = keys.length;
        var valuesCount = values ? values.length : 0;
        for (var i4 = 0; i4 < len; i4++) {
          key = keys[i4];
          obj[key] = i4 < valuesCount ? values[i4] : undefined2;
        }
        return obj;
      }
      function TargetObserver(emitter, target, options) {
        this._emitter = emitter;
        this._target = target;
        this._listeners = {};
        this._listenersCount = 0;
        var on3, off;
        if (options.on || options.off) {
          on3 = options.on;
          off = options.off;
        }
        if (target.addEventListener) {
          on3 = target.addEventListener;
          off = target.removeEventListener;
        } else if (target.addListener) {
          on3 = target.addListener;
          off = target.removeListener;
        } else if (target.on) {
          on3 = target.on;
          off = target.off;
        }
        if (!on3 && !off) {
          throw Error("target does not implement any known event API");
        }
        if (typeof on3 !== "function") {
          throw TypeError("on method must be a function");
        }
        if (typeof off !== "function") {
          throw TypeError("off method must be a function");
        }
        this._on = on3;
        this._off = off;
        var _observers = emitter._observers;
        if (_observers) {
          _observers.push(this);
        } else {
          emitter._observers = [this];
        }
      }
      Object.assign(TargetObserver.prototype, {
        subscribe: function(event, localEvent, reducer) {
          var observer = this;
          var target = this._target;
          var emitter = this._emitter;
          var listeners = this._listeners;
          var handler = function() {
            var args = toArray2.apply(null, arguments);
            var eventObj = {
              data: args,
              name: localEvent,
              original: event
            };
            if (reducer) {
              var result = reducer.call(target, eventObj);
              if (result !== false) {
                emitter.emit.apply(emitter, [eventObj.name].concat(args));
              }
              return;
            }
            emitter.emit.apply(emitter, [localEvent].concat(args));
          };
          if (listeners[event]) {
            throw Error("Event '" + event + "' is already listening");
          }
          this._listenersCount++;
          if (emitter._newListener && emitter._removeListener && !observer._onNewListener) {
            this._onNewListener = function(_event) {
              if (_event === localEvent && listeners[event] === null) {
                listeners[event] = handler;
                observer._on.call(target, event, handler);
              }
            };
            emitter.on("newListener", this._onNewListener);
            this._onRemoveListener = function(_event) {
              if (_event === localEvent && !emitter.hasListeners(_event) && listeners[event]) {
                listeners[event] = null;
                observer._off.call(target, event, handler);
              }
            };
            listeners[event] = null;
            emitter.on("removeListener", this._onRemoveListener);
          } else {
            listeners[event] = handler;
            observer._on.call(target, event, handler);
          }
        },
        unsubscribe: function(event) {
          var observer = this;
          var listeners = this._listeners;
          var emitter = this._emitter;
          var handler;
          var events;
          var off = this._off;
          var target = this._target;
          var i4;
          if (event && typeof event !== "string") {
            throw TypeError("event must be a string");
          }
          function clearRefs() {
            if (observer._onNewListener) {
              emitter.off("newListener", observer._onNewListener);
              emitter.off("removeListener", observer._onRemoveListener);
              observer._onNewListener = null;
              observer._onRemoveListener = null;
            }
            var index = findTargetIndex.call(emitter, observer);
            emitter._observers.splice(index, 1);
          }
          if (event) {
            handler = listeners[event];
            if (!handler) return;
            off.call(target, event, handler);
            delete listeners[event];
            if (!--this._listenersCount) {
              clearRefs();
            }
          } else {
            events = ownKeys(listeners);
            i4 = events.length;
            while (i4-- > 0) {
              event = events[i4];
              off.call(target, event, listeners[event]);
            }
            this._listeners = {};
            this._listenersCount = 0;
            clearRefs();
          }
        }
      });
      function resolveOptions(options, schema, reducers, allowUnknown) {
        var computedOptions = Object.assign({}, schema);
        if (!options) return computedOptions;
        if (typeof options !== "object") {
          throw TypeError("options must be an object");
        }
        var keys = Object.keys(options);
        var length = keys.length;
        var option, value2;
        var reducer;
        function reject(reason) {
          throw Error('Invalid "' + option + '" option value' + (reason ? ". Reason: " + reason : ""));
        }
        for (var i4 = 0; i4 < length; i4++) {
          option = keys[i4];
          if (!allowUnknown && !hasOwnProperty.call(schema, option)) {
            throw Error('Unknown "' + option + '" option');
          }
          value2 = options[option];
          if (value2 !== undefined2) {
            reducer = reducers[option];
            computedOptions[option] = reducer ? reducer(value2, reject) : value2;
          }
        }
        return computedOptions;
      }
      function constructorReducer(value2, reject) {
        if (typeof value2 !== "function" || !value2.hasOwnProperty("prototype")) {
          reject("value must be a constructor");
        }
        return value2;
      }
      function makeTypeReducer(types) {
        var message = "value must be type of " + types.join("|");
        var len = types.length;
        var firstType = types[0];
        var secondType = types[1];
        if (len === 1) {
          return function(v2, reject) {
            if (typeof v2 === firstType) {
              return v2;
            }
            reject(message);
          };
        }
        if (len === 2) {
          return function(v2, reject) {
            var kind = typeof v2;
            if (kind === firstType || kind === secondType) return v2;
            reject(message);
          };
        }
        return function(v2, reject) {
          var kind = typeof v2;
          var i4 = len;
          while (i4-- > 0) {
            if (kind === types[i4]) return v2;
          }
          reject(message);
        };
      }
      var functionReducer = makeTypeReducer(["function"]);
      var objectFunctionReducer = makeTypeReducer(["object", "function"]);
      function makeCancelablePromise(Promise2, executor, options) {
        var isCancelable;
        var callbacks;
        var timer = 0;
        var subscriptionClosed;
        var promise = new Promise2(function(resolve, reject, onCancel) {
          options = resolveOptions(options, {
            timeout: 0,
            overload: false
          }, {
            timeout: function(value2, reject2) {
              value2 *= 1;
              if (typeof value2 !== "number" || value2 < 0 || !Number.isFinite(value2)) {
                reject2("timeout must be a positive number");
              }
              return value2;
            }
          });
          isCancelable = !options.overload && typeof Promise2.prototype.cancel === "function" && typeof onCancel === "function";
          function cleanup() {
            if (callbacks) {
              callbacks = null;
            }
            if (timer) {
              clearTimeout(timer);
              timer = 0;
            }
          }
          var _resolve = function(value2) {
            cleanup();
            resolve(value2);
          };
          var _reject = function(err) {
            cleanup();
            reject(err);
          };
          if (isCancelable) {
            executor(_resolve, _reject, onCancel);
          } else {
            callbacks = [function(reason) {
              _reject(reason || Error("canceled"));
            }];
            executor(_resolve, _reject, function(cb) {
              if (subscriptionClosed) {
                throw Error("Unable to subscribe on cancel event asynchronously");
              }
              if (typeof cb !== "function") {
                throw TypeError("onCancel callback must be a function");
              }
              callbacks.push(cb);
            });
            subscriptionClosed = true;
          }
          if (options.timeout > 0) {
            timer = setTimeout(function() {
              var reason = Error("timeout");
              reason.code = "ETIMEDOUT";
              timer = 0;
              promise.cancel(reason);
              reject(reason);
            }, options.timeout);
          }
        });
        if (!isCancelable) {
          promise.cancel = function(reason) {
            if (!callbacks) {
              return;
            }
            var length = callbacks.length;
            for (var i4 = 1; i4 < length; i4++) {
              callbacks[i4](reason);
            }
            callbacks[0](reason);
            callbacks = null;
          };
        }
        return promise;
      }
      function findTargetIndex(observer) {
        var observers = this._observers;
        if (!observers) {
          return -1;
        }
        var len = observers.length;
        for (var i4 = 0; i4 < len; i4++) {
          if (observers[i4]._target === observer) return i4;
        }
        return -1;
      }
      function searchListenerTree(handlers, type2, tree, i4, typeLength) {
        if (!tree) {
          return null;
        }
        if (i4 === 0) {
          var kind = typeof type2;
          if (kind === "string") {
            var ns2, n6, l5 = 0, j4 = 0, delimiter = this.delimiter, dl2 = delimiter.length;
            if ((n6 = type2.indexOf(delimiter)) !== -1) {
              ns2 = new Array(5);
              do {
                ns2[l5++] = type2.slice(j4, n6);
                j4 = n6 + dl2;
              } while ((n6 = type2.indexOf(delimiter, j4)) !== -1);
              ns2[l5++] = type2.slice(j4);
              type2 = ns2;
              typeLength = l5;
            } else {
              type2 = [type2];
              typeLength = 1;
            }
          } else if (kind === "object") {
            typeLength = type2.length;
          } else {
            type2 = [type2];
            typeLength = 1;
          }
        }
        var listeners = null, branch, xTree, xxTree, isolatedBranch, endReached, currentType = type2[i4], nextType = type2[i4 + 1], branches, _listeners;
        if (i4 === typeLength) {
          if (tree._listeners) {
            if (typeof tree._listeners === "function") {
              handlers && handlers.push(tree._listeners);
              listeners = [tree];
            } else {
              handlers && handlers.push.apply(handlers, tree._listeners);
              listeners = [tree];
            }
          }
        } else {
          if (currentType === "*") {
            branches = ownKeys(tree);
            n6 = branches.length;
            while (n6-- > 0) {
              branch = branches[n6];
              if (branch !== "_listeners") {
                _listeners = searchListenerTree(handlers, type2, tree[branch], i4 + 1, typeLength);
                if (_listeners) {
                  if (listeners) {
                    listeners.push.apply(listeners, _listeners);
                  } else {
                    listeners = _listeners;
                  }
                }
              }
            }
            return listeners;
          } else if (currentType === "**") {
            endReached = i4 + 1 === typeLength || i4 + 2 === typeLength && nextType === "*";
            if (endReached && tree._listeners) {
              listeners = searchListenerTree(handlers, type2, tree, typeLength, typeLength);
            }
            branches = ownKeys(tree);
            n6 = branches.length;
            while (n6-- > 0) {
              branch = branches[n6];
              if (branch !== "_listeners") {
                if (branch === "*" || branch === "**") {
                  if (tree[branch]._listeners && !endReached) {
                    _listeners = searchListenerTree(handlers, type2, tree[branch], typeLength, typeLength);
                    if (_listeners) {
                      if (listeners) {
                        listeners.push.apply(listeners, _listeners);
                      } else {
                        listeners = _listeners;
                      }
                    }
                  }
                  _listeners = searchListenerTree(handlers, type2, tree[branch], i4, typeLength);
                } else if (branch === nextType) {
                  _listeners = searchListenerTree(handlers, type2, tree[branch], i4 + 2, typeLength);
                } else {
                  _listeners = searchListenerTree(handlers, type2, tree[branch], i4, typeLength);
                }
                if (_listeners) {
                  if (listeners) {
                    listeners.push.apply(listeners, _listeners);
                  } else {
                    listeners = _listeners;
                  }
                }
              }
            }
            return listeners;
          } else if (tree[currentType]) {
            listeners = searchListenerTree(handlers, type2, tree[currentType], i4 + 1, typeLength);
          }
        }
        xTree = tree["*"];
        if (xTree) {
          searchListenerTree(handlers, type2, xTree, i4 + 1, typeLength);
        }
        xxTree = tree["**"];
        if (xxTree) {
          if (i4 < typeLength) {
            if (xxTree._listeners) {
              searchListenerTree(handlers, type2, xxTree, typeLength, typeLength);
            }
            branches = ownKeys(xxTree);
            n6 = branches.length;
            while (n6-- > 0) {
              branch = branches[n6];
              if (branch !== "_listeners") {
                if (branch === nextType) {
                  searchListenerTree(handlers, type2, xxTree[branch], i4 + 2, typeLength);
                } else if (branch === currentType) {
                  searchListenerTree(handlers, type2, xxTree[branch], i4 + 1, typeLength);
                } else {
                  isolatedBranch = {};
                  isolatedBranch[branch] = xxTree[branch];
                  searchListenerTree(handlers, type2, { "**": isolatedBranch }, i4 + 1, typeLength);
                }
              }
            }
          } else if (xxTree._listeners) {
            searchListenerTree(handlers, type2, xxTree, typeLength, typeLength);
          } else if (xxTree["*"] && xxTree["*"]._listeners) {
            searchListenerTree(handlers, type2, xxTree["*"], typeLength, typeLength);
          }
        }
        return listeners;
      }
      function growListenerTree(type2, listener, prepend) {
        var len = 0, j4 = 0, i4, delimiter = this.delimiter, dl2 = delimiter.length, ns2;
        if (typeof type2 === "string") {
          if ((i4 = type2.indexOf(delimiter)) !== -1) {
            ns2 = new Array(5);
            do {
              ns2[len++] = type2.slice(j4, i4);
              j4 = i4 + dl2;
            } while ((i4 = type2.indexOf(delimiter, j4)) !== -1);
            ns2[len++] = type2.slice(j4);
          } else {
            ns2 = [type2];
            len = 1;
          }
        } else {
          ns2 = type2;
          len = type2.length;
        }
        if (len > 1) {
          for (i4 = 0; i4 + 1 < len; i4++) {
            if (ns2[i4] === "**" && ns2[i4 + 1] === "**") {
              return;
            }
          }
        }
        var tree = this.listenerTree, name;
        for (i4 = 0; i4 < len; i4++) {
          name = ns2[i4];
          tree = tree[name] || (tree[name] = {});
          if (i4 === len - 1) {
            if (!tree._listeners) {
              tree._listeners = listener;
            } else {
              if (typeof tree._listeners === "function") {
                tree._listeners = [tree._listeners];
              }
              if (prepend) {
                tree._listeners.unshift(listener);
              } else {
                tree._listeners.push(listener);
              }
              if (!tree._listeners.warned && this._maxListeners > 0 && tree._listeners.length > this._maxListeners) {
                tree._listeners.warned = true;
                logPossibleMemoryLeak.call(this, tree._listeners.length, name);
              }
            }
            return true;
          }
        }
        return true;
      }
      function collectTreeEvents(tree, events, root, asArray) {
        var branches = ownKeys(tree);
        var i4 = branches.length;
        var branch, branchName, path;
        var hasListeners = tree["_listeners"];
        var isArrayPath;
        while (i4-- > 0) {
          branchName = branches[i4];
          branch = tree[branchName];
          if (branchName === "_listeners") {
            path = root;
          } else {
            path = root ? root.concat(branchName) : [branchName];
          }
          isArrayPath = asArray || typeof branchName === "symbol";
          hasListeners && events.push(isArrayPath ? path : path.join(this.delimiter));
          if (typeof branch === "object") {
            collectTreeEvents.call(this, branch, events, path, isArrayPath);
          }
        }
        return events;
      }
      function recursivelyGarbageCollect(root) {
        var keys = ownKeys(root);
        var i4 = keys.length;
        var obj, key, flag;
        while (i4-- > 0) {
          key = keys[i4];
          obj = root[key];
          if (obj) {
            flag = true;
            if (key !== "_listeners" && !recursivelyGarbageCollect(obj)) {
              delete root[key];
            }
          }
        }
        return flag;
      }
      function Listener(emitter, event, listener) {
        this.emitter = emitter;
        this.event = event;
        this.listener = listener;
      }
      Listener.prototype.off = function() {
        this.emitter.off(this.event, this.listener);
        return this;
      };
      function setupListener(event, listener, options) {
        if (options === true) {
          promisify = true;
        } else if (options === false) {
          async = true;
        } else {
          if (!options || typeof options !== "object") {
            throw TypeError("options should be an object or true");
          }
          var async = options.async;
          var promisify = options.promisify;
          var nextTick2 = options.nextTick;
          var objectify = options.objectify;
        }
        if (async || nextTick2 || promisify) {
          var _listener = listener;
          var _origin = listener._origin || listener;
          if (nextTick2 && !nextTickSupported) {
            throw Error("process.nextTick is not supported");
          }
          if (promisify === undefined2) {
            promisify = listener.constructor.name === "AsyncFunction";
          }
          listener = function() {
            var args = arguments;
            var context = this;
            var event2 = this.event;
            return promisify ? nextTick2 ? Promise.resolve() : new Promise(function(resolve) {
              _setImmediate(resolve);
            }).then(function() {
              context.event = event2;
              return _listener.apply(context, args);
            }) : (nextTick2 ? process.nextTick : _setImmediate)(function() {
              context.event = event2;
              _listener.apply(context, args);
            });
          };
          listener._async = true;
          listener._origin = _origin;
        }
        return [listener, objectify ? new Listener(this, event, listener) : this];
      }
      function EventEmitter2(conf) {
        this._events = {};
        this._newListener = false;
        this._removeListener = false;
        this.verboseMemoryLeak = false;
        configure.call(this, conf);
      }
      EventEmitter2.EventEmitter2 = EventEmitter2;
      EventEmitter2.prototype.listenTo = function(target, events, options) {
        if (typeof target !== "object") {
          throw TypeError("target musts be an object");
        }
        var emitter = this;
        options = resolveOptions(options, {
          on: undefined2,
          off: undefined2,
          reducers: undefined2
        }, {
          on: functionReducer,
          off: functionReducer,
          reducers: objectFunctionReducer
        });
        function listen(events2) {
          if (typeof events2 !== "object") {
            throw TypeError("events must be an object");
          }
          var reducers = options.reducers;
          var index = findTargetIndex.call(emitter, target);
          var observer;
          if (index === -1) {
            observer = new TargetObserver(emitter, target, options);
          } else {
            observer = emitter._observers[index];
          }
          var keys = ownKeys(events2);
          var len = keys.length;
          var event;
          var isSingleReducer = typeof reducers === "function";
          for (var i4 = 0; i4 < len; i4++) {
            event = keys[i4];
            observer.subscribe(
              event,
              events2[event] || event,
              isSingleReducer ? reducers : reducers && reducers[event]
            );
          }
        }
        isArray(events) ? listen(toObject(events)) : typeof events === "string" ? listen(toObject(events.split(/\s+/))) : listen(events);
        return this;
      };
      EventEmitter2.prototype.stopListeningTo = function(target, event) {
        var observers = this._observers;
        if (!observers) {
          return false;
        }
        var i4 = observers.length;
        var observer;
        var matched = false;
        if (target && typeof target !== "object") {
          throw TypeError("target should be an object");
        }
        while (i4-- > 0) {
          observer = observers[i4];
          if (!target || observer._target === target) {
            observer.unsubscribe(event);
            matched = true;
          }
        }
        return matched;
      };
      EventEmitter2.prototype.delimiter = ".";
      EventEmitter2.prototype.setMaxListeners = function(n6) {
        if (n6 !== undefined2) {
          this._maxListeners = n6;
          if (!this._conf) this._conf = {};
          this._conf.maxListeners = n6;
        }
      };
      EventEmitter2.prototype.getMaxListeners = function() {
        return this._maxListeners;
      };
      EventEmitter2.prototype.event = "";
      EventEmitter2.prototype.once = function(event, fn3, options) {
        return this._once(event, fn3, false, options);
      };
      EventEmitter2.prototype.prependOnceListener = function(event, fn3, options) {
        return this._once(event, fn3, true, options);
      };
      EventEmitter2.prototype._once = function(event, fn3, prepend, options) {
        return this._many(event, 1, fn3, prepend, options);
      };
      EventEmitter2.prototype.many = function(event, ttl, fn3, options) {
        return this._many(event, ttl, fn3, false, options);
      };
      EventEmitter2.prototype.prependMany = function(event, ttl, fn3, options) {
        return this._many(event, ttl, fn3, true, options);
      };
      EventEmitter2.prototype._many = function(event, ttl, fn3, prepend, options) {
        var self2 = this;
        if (typeof fn3 !== "function") {
          throw new Error("many only accepts instances of Function");
        }
        function listener() {
          if (--ttl === 0) {
            self2.off(event, listener);
          }
          return fn3.apply(this, arguments);
        }
        listener._origin = fn3;
        return this._on(event, listener, prepend, options);
      };
      EventEmitter2.prototype.emit = function() {
        if (!this._events && !this._all) {
          return false;
        }
        this._events || init.call(this);
        var type2 = arguments[0], ns2, wildcard = this.wildcard;
        var args, l5, i4, j4, containsSymbol;
        if (type2 === "newListener" && !this._newListener) {
          if (!this._events.newListener) {
            return false;
          }
        }
        if (wildcard) {
          ns2 = type2;
          if (type2 !== "newListener" && type2 !== "removeListener") {
            if (typeof type2 === "object") {
              l5 = type2.length;
              if (symbolsSupported) {
                for (i4 = 0; i4 < l5; i4++) {
                  if (typeof type2[i4] === "symbol") {
                    containsSymbol = true;
                    break;
                  }
                }
              }
              if (!containsSymbol) {
                type2 = type2.join(this.delimiter);
              }
            }
          }
        }
        var al2 = arguments.length;
        var handler;
        if (this._all && this._all.length) {
          handler = this._all.slice();
          for (i4 = 0, l5 = handler.length; i4 < l5; i4++) {
            this.event = type2;
            switch (al2) {
              case 1:
                handler[i4].call(this, type2);
                break;
              case 2:
                handler[i4].call(this, type2, arguments[1]);
                break;
              case 3:
                handler[i4].call(this, type2, arguments[1], arguments[2]);
                break;
              default:
                handler[i4].apply(this, arguments);
            }
          }
        }
        if (wildcard) {
          handler = [];
          searchListenerTree.call(this, handler, ns2, this.listenerTree, 0, l5);
        } else {
          handler = this._events[type2];
          if (typeof handler === "function") {
            this.event = type2;
            switch (al2) {
              case 1:
                handler.call(this);
                break;
              case 2:
                handler.call(this, arguments[1]);
                break;
              case 3:
                handler.call(this, arguments[1], arguments[2]);
                break;
              default:
                args = new Array(al2 - 1);
                for (j4 = 1; j4 < al2; j4++) args[j4 - 1] = arguments[j4];
                handler.apply(this, args);
            }
            return true;
          } else if (handler) {
            handler = handler.slice();
          }
        }
        if (handler && handler.length) {
          if (al2 > 3) {
            args = new Array(al2 - 1);
            for (j4 = 1; j4 < al2; j4++) args[j4 - 1] = arguments[j4];
          }
          for (i4 = 0, l5 = handler.length; i4 < l5; i4++) {
            this.event = type2;
            switch (al2) {
              case 1:
                handler[i4].call(this);
                break;
              case 2:
                handler[i4].call(this, arguments[1]);
                break;
              case 3:
                handler[i4].call(this, arguments[1], arguments[2]);
                break;
              default:
                handler[i4].apply(this, args);
            }
          }
          return true;
        } else if (!this.ignoreErrors && !this._all && type2 === "error") {
          if (arguments[1] instanceof Error) {
            throw arguments[1];
          } else {
            throw new Error("Uncaught, unspecified 'error' event.");
          }
        }
        return !!this._all;
      };
      EventEmitter2.prototype.emitAsync = function() {
        if (!this._events && !this._all) {
          return false;
        }
        this._events || init.call(this);
        var type2 = arguments[0], wildcard = this.wildcard, ns2, containsSymbol;
        var args, l5, i4, j4;
        if (type2 === "newListener" && !this._newListener) {
          if (!this._events.newListener) {
            return Promise.resolve([false]);
          }
        }
        if (wildcard) {
          ns2 = type2;
          if (type2 !== "newListener" && type2 !== "removeListener") {
            if (typeof type2 === "object") {
              l5 = type2.length;
              if (symbolsSupported) {
                for (i4 = 0; i4 < l5; i4++) {
                  if (typeof type2[i4] === "symbol") {
                    containsSymbol = true;
                    break;
                  }
                }
              }
              if (!containsSymbol) {
                type2 = type2.join(this.delimiter);
              }
            }
          }
        }
        var promises = [];
        var al2 = arguments.length;
        var handler;
        if (this._all) {
          for (i4 = 0, l5 = this._all.length; i4 < l5; i4++) {
            this.event = type2;
            switch (al2) {
              case 1:
                promises.push(this._all[i4].call(this, type2));
                break;
              case 2:
                promises.push(this._all[i4].call(this, type2, arguments[1]));
                break;
              case 3:
                promises.push(this._all[i4].call(this, type2, arguments[1], arguments[2]));
                break;
              default:
                promises.push(this._all[i4].apply(this, arguments));
            }
          }
        }
        if (wildcard) {
          handler = [];
          searchListenerTree.call(this, handler, ns2, this.listenerTree, 0);
        } else {
          handler = this._events[type2];
        }
        if (typeof handler === "function") {
          this.event = type2;
          switch (al2) {
            case 1:
              promises.push(handler.call(this));
              break;
            case 2:
              promises.push(handler.call(this, arguments[1]));
              break;
            case 3:
              promises.push(handler.call(this, arguments[1], arguments[2]));
              break;
            default:
              args = new Array(al2 - 1);
              for (j4 = 1; j4 < al2; j4++) args[j4 - 1] = arguments[j4];
              promises.push(handler.apply(this, args));
          }
        } else if (handler && handler.length) {
          handler = handler.slice();
          if (al2 > 3) {
            args = new Array(al2 - 1);
            for (j4 = 1; j4 < al2; j4++) args[j4 - 1] = arguments[j4];
          }
          for (i4 = 0, l5 = handler.length; i4 < l5; i4++) {
            this.event = type2;
            switch (al2) {
              case 1:
                promises.push(handler[i4].call(this));
                break;
              case 2:
                promises.push(handler[i4].call(this, arguments[1]));
                break;
              case 3:
                promises.push(handler[i4].call(this, arguments[1], arguments[2]));
                break;
              default:
                promises.push(handler[i4].apply(this, args));
            }
          }
        } else if (!this.ignoreErrors && !this._all && type2 === "error") {
          if (arguments[1] instanceof Error) {
            return Promise.reject(arguments[1]);
          } else {
            return Promise.reject("Uncaught, unspecified 'error' event.");
          }
        }
        return Promise.all(promises);
      };
      EventEmitter2.prototype.on = function(type2, listener, options) {
        return this._on(type2, listener, false, options);
      };
      EventEmitter2.prototype.prependListener = function(type2, listener, options) {
        return this._on(type2, listener, true, options);
      };
      EventEmitter2.prototype.onAny = function(fn3) {
        return this._onAny(fn3, false);
      };
      EventEmitter2.prototype.prependAny = function(fn3) {
        return this._onAny(fn3, true);
      };
      EventEmitter2.prototype.addListener = EventEmitter2.prototype.on;
      EventEmitter2.prototype._onAny = function(fn3, prepend) {
        if (typeof fn3 !== "function") {
          throw new Error("onAny only accepts instances of Function");
        }
        if (!this._all) {
          this._all = [];
        }
        if (prepend) {
          this._all.unshift(fn3);
        } else {
          this._all.push(fn3);
        }
        return this;
      };
      EventEmitter2.prototype._on = function(type2, listener, prepend, options) {
        if (typeof type2 === "function") {
          this._onAny(type2, listener);
          return this;
        }
        if (typeof listener !== "function") {
          throw new Error("on only accepts instances of Function");
        }
        this._events || init.call(this);
        var returnValue = this, temp;
        if (options !== undefined2) {
          temp = setupListener.call(this, type2, listener, options);
          listener = temp[0];
          returnValue = temp[1];
        }
        if (this._newListener) {
          this.emit("newListener", type2, listener);
        }
        if (this.wildcard) {
          growListenerTree.call(this, type2, listener, prepend);
          return returnValue;
        }
        if (!this._events[type2]) {
          this._events[type2] = listener;
        } else {
          if (typeof this._events[type2] === "function") {
            this._events[type2] = [this._events[type2]];
          }
          if (prepend) {
            this._events[type2].unshift(listener);
          } else {
            this._events[type2].push(listener);
          }
          if (!this._events[type2].warned && this._maxListeners > 0 && this._events[type2].length > this._maxListeners) {
            this._events[type2].warned = true;
            logPossibleMemoryLeak.call(this, this._events[type2].length, type2);
          }
        }
        return returnValue;
      };
      EventEmitter2.prototype.off = function(type2, listener) {
        if (typeof listener !== "function") {
          throw new Error("removeListener only takes instances of Function");
        }
        var handlers, leafs = [];
        if (this.wildcard) {
          var ns2 = typeof type2 === "string" ? type2.split(this.delimiter) : type2.slice();
          leafs = searchListenerTree.call(this, null, ns2, this.listenerTree, 0);
          if (!leafs) return this;
        } else {
          if (!this._events[type2]) return this;
          handlers = this._events[type2];
          leafs.push({ _listeners: handlers });
        }
        for (var iLeaf = 0; iLeaf < leafs.length; iLeaf++) {
          var leaf = leafs[iLeaf];
          handlers = leaf._listeners;
          if (isArray(handlers)) {
            var position = -1;
            for (var i4 = 0, length = handlers.length; i4 < length; i4++) {
              if (handlers[i4] === listener || handlers[i4].listener && handlers[i4].listener === listener || handlers[i4]._origin && handlers[i4]._origin === listener) {
                position = i4;
                break;
              }
            }
            if (position < 0) {
              continue;
            }
            if (this.wildcard) {
              leaf._listeners.splice(position, 1);
            } else {
              this._events[type2].splice(position, 1);
            }
            if (handlers.length === 0) {
              if (this.wildcard) {
                delete leaf._listeners;
              } else {
                delete this._events[type2];
              }
            }
            if (this._removeListener)
              this.emit("removeListener", type2, listener);
            return this;
          } else if (handlers === listener || handlers.listener && handlers.listener === listener || handlers._origin && handlers._origin === listener) {
            if (this.wildcard) {
              delete leaf._listeners;
            } else {
              delete this._events[type2];
            }
            if (this._removeListener)
              this.emit("removeListener", type2, listener);
          }
        }
        this.listenerTree && recursivelyGarbageCollect(this.listenerTree);
        return this;
      };
      EventEmitter2.prototype.offAny = function(fn3) {
        var i4 = 0, l5 = 0, fns;
        if (fn3 && this._all && this._all.length > 0) {
          fns = this._all;
          for (i4 = 0, l5 = fns.length; i4 < l5; i4++) {
            if (fn3 === fns[i4]) {
              fns.splice(i4, 1);
              if (this._removeListener)
                this.emit("removeListenerAny", fn3);
              return this;
            }
          }
        } else {
          fns = this._all;
          if (this._removeListener) {
            for (i4 = 0, l5 = fns.length; i4 < l5; i4++)
              this.emit("removeListenerAny", fns[i4]);
          }
          this._all = [];
        }
        return this;
      };
      EventEmitter2.prototype.removeListener = EventEmitter2.prototype.off;
      EventEmitter2.prototype.removeAllListeners = function(type2) {
        if (type2 === undefined2) {
          !this._events || init.call(this);
          return this;
        }
        if (this.wildcard) {
          var leafs = searchListenerTree.call(this, null, type2, this.listenerTree, 0), leaf, i4;
          if (!leafs) return this;
          for (i4 = 0; i4 < leafs.length; i4++) {
            leaf = leafs[i4];
            leaf._listeners = null;
          }
          this.listenerTree && recursivelyGarbageCollect(this.listenerTree);
        } else if (this._events) {
          this._events[type2] = null;
        }
        return this;
      };
      EventEmitter2.prototype.listeners = function(type2) {
        var _events = this._events;
        var keys, listeners, allListeners;
        var i4;
        var listenerTree;
        if (type2 === undefined2) {
          if (this.wildcard) {
            throw Error("event name required for wildcard emitter");
          }
          if (!_events) {
            return [];
          }
          keys = ownKeys(_events);
          i4 = keys.length;
          allListeners = [];
          while (i4-- > 0) {
            listeners = _events[keys[i4]];
            if (typeof listeners === "function") {
              allListeners.push(listeners);
            } else {
              allListeners.push.apply(allListeners, listeners);
            }
          }
          return allListeners;
        } else {
          if (this.wildcard) {
            listenerTree = this.listenerTree;
            if (!listenerTree) return [];
            var handlers = [];
            var ns2 = typeof type2 === "string" ? type2.split(this.delimiter) : type2.slice();
            searchListenerTree.call(this, handlers, ns2, listenerTree, 0);
            return handlers;
          }
          if (!_events) {
            return [];
          }
          listeners = _events[type2];
          if (!listeners) {
            return [];
          }
          return typeof listeners === "function" ? [listeners] : listeners;
        }
      };
      EventEmitter2.prototype.eventNames = function(nsAsArray) {
        var _events = this._events;
        return this.wildcard ? collectTreeEvents.call(this, this.listenerTree, [], null, nsAsArray) : _events ? ownKeys(_events) : [];
      };
      EventEmitter2.prototype.listenerCount = function(type2) {
        return this.listeners(type2).length;
      };
      EventEmitter2.prototype.hasListeners = function(type2) {
        if (this.wildcard) {
          var handlers = [];
          var ns2 = typeof type2 === "string" ? type2.split(this.delimiter) : type2.slice();
          searchListenerTree.call(this, handlers, ns2, this.listenerTree, 0);
          return handlers.length > 0;
        }
        var _events = this._events;
        var _all = this._all;
        return !!(_all && _all.length || _events && (type2 === undefined2 ? ownKeys(_events).length : _events[type2]));
      };
      EventEmitter2.prototype.listenersAny = function() {
        if (this._all) {
          return this._all;
        } else {
          return [];
        }
      };
      EventEmitter2.prototype.waitFor = function(event, options) {
        var self2 = this;
        var type2 = typeof options;
        if (type2 === "number") {
          options = { timeout: options };
        } else if (type2 === "function") {
          options = { filter: options };
        }
        options = resolveOptions(options, {
          timeout: 0,
          filter: undefined2,
          handleError: false,
          Promise,
          overload: false
        }, {
          filter: functionReducer,
          Promise: constructorReducer
        });
        return makeCancelablePromise(options.Promise, function(resolve, reject, onCancel) {
          function listener() {
            var filter = options.filter;
            if (filter && !filter.apply(self2, arguments)) {
              return;
            }
            self2.off(event, listener);
            if (options.handleError) {
              var err = arguments[0];
              err ? reject(err) : resolve(toArray2.apply(null, arguments).slice(1));
            } else {
              resolve(toArray2.apply(null, arguments));
            }
          }
          onCancel(function() {
            self2.off(event, listener);
          });
          self2._on(event, listener, false);
        }, {
          timeout: options.timeout,
          overload: options.overload
        });
      };
      function once(emitter, name, options) {
        options = resolveOptions(options, {
          Promise,
          timeout: 0,
          overload: false
        }, {
          Promise: constructorReducer
        });
        var _Promise = options.Promise;
        return makeCancelablePromise(_Promise, function(resolve, reject, onCancel) {
          var handler;
          if (typeof emitter.addEventListener === "function") {
            handler = function() {
              resolve(toArray2.apply(null, arguments));
            };
            onCancel(function() {
              emitter.removeEventListener(name, handler);
            });
            emitter.addEventListener(
              name,
              handler,
              { once: true }
            );
            return;
          }
          var eventListener = function() {
            errorListener && emitter.removeListener("error", errorListener);
            resolve(toArray2.apply(null, arguments));
          };
          var errorListener;
          if (name !== "error") {
            errorListener = function(err) {
              emitter.removeListener(name, eventListener);
              reject(err);
            };
            emitter.once("error", errorListener);
          }
          onCancel(function() {
            errorListener && emitter.removeListener("error", errorListener);
            emitter.removeListener(name, eventListener);
          });
          emitter.once(name, eventListener);
        }, {
          timeout: options.timeout,
          overload: options.overload
        });
      }
      var prototype = EventEmitter2.prototype;
      Object.defineProperties(EventEmitter2, {
        defaultMaxListeners: {
          get: function() {
            return prototype._maxListeners;
          },
          set: function(n6) {
            if (typeof n6 !== "number" || n6 < 0 || Number.isNaN(n6)) {
              throw TypeError("n must be a non-negative number");
            }
            prototype._maxListeners = n6;
          },
          enumerable: true
        },
        once: {
          value: once,
          writable: true,
          configurable: true
        }
      });
      Object.defineProperties(prototype, {
        _maxListeners: {
          value: defaultMaxListeners,
          writable: true,
          configurable: true
        },
        _observers: { value: null, writable: true, configurable: true }
      });
      if (typeof define === "function" && define.amd) {
        define(function() {
          return EventEmitter2;
        });
      } else if (typeof exports === "object") {
        module.exports = EventEmitter2;
      } else {
        var _global = new Function("", "return this")();
        _global.EventEmitter2 = EventEmitter2;
      }
    }();
  }
});

// node_modules/uuid/dist/esm-browser/rng.js
function rng() {
  if (!getRandomValues) {
    getRandomValues = typeof crypto !== "undefined" && crypto.getRandomValues && crypto.getRandomValues.bind(crypto) || typeof msCrypto !== "undefined" && typeof msCrypto.getRandomValues === "function" && msCrypto.getRandomValues.bind(msCrypto);
    if (!getRandomValues) {
      throw new Error("crypto.getRandomValues() not supported. See https://github.com/uuidjs/uuid#getrandomvalues-not-supported");
    }
  }
  return getRandomValues(rnds8);
}
var getRandomValues, rnds8;
var init_rng = __esm({
  "node_modules/uuid/dist/esm-browser/rng.js"() {
    rnds8 = new Uint8Array(16);
  }
});

// node_modules/uuid/dist/esm-browser/regex.js
var regex_default;
var init_regex = __esm({
  "node_modules/uuid/dist/esm-browser/regex.js"() {
    regex_default = /^(?:[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}|00000000-0000-0000-0000-000000000000)$/i;
  }
});

// node_modules/uuid/dist/esm-browser/validate.js
function validate(uuid) {
  return typeof uuid === "string" && regex_default.test(uuid);
}
var validate_default;
var init_validate = __esm({
  "node_modules/uuid/dist/esm-browser/validate.js"() {
    init_regex();
    validate_default = validate;
  }
});

// node_modules/uuid/dist/esm-browser/stringify.js
function stringify(arr) {
  var offset2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0;
  var uuid = (byteToHex[arr[offset2 + 0]] + byteToHex[arr[offset2 + 1]] + byteToHex[arr[offset2 + 2]] + byteToHex[arr[offset2 + 3]] + "-" + byteToHex[arr[offset2 + 4]] + byteToHex[arr[offset2 + 5]] + "-" + byteToHex[arr[offset2 + 6]] + byteToHex[arr[offset2 + 7]] + "-" + byteToHex[arr[offset2 + 8]] + byteToHex[arr[offset2 + 9]] + "-" + byteToHex[arr[offset2 + 10]] + byteToHex[arr[offset2 + 11]] + byteToHex[arr[offset2 + 12]] + byteToHex[arr[offset2 + 13]] + byteToHex[arr[offset2 + 14]] + byteToHex[arr[offset2 + 15]]).toLowerCase();
  if (!validate_default(uuid)) {
    throw TypeError("Stringified UUID is invalid");
  }
  return uuid;
}
var byteToHex, i4, stringify_default;
var init_stringify = __esm({
  "node_modules/uuid/dist/esm-browser/stringify.js"() {
    init_validate();
    byteToHex = [];
    for (i4 = 0; i4 < 256; ++i4) {
      byteToHex.push((i4 + 256).toString(16).substr(1));
    }
    stringify_default = stringify;
  }
});

// node_modules/uuid/dist/esm-browser/v1.js
function v1(options, buf, offset2) {
  var i4 = buf && offset2 || 0;
  var b3 = buf || new Array(16);
  options = options || {};
  var node = options.node || _nodeId;
  var clockseq = options.clockseq !== void 0 ? options.clockseq : _clockseq;
  if (node == null || clockseq == null) {
    var seedBytes = options.random || (options.rng || rng)();
    if (node == null) {
      node = _nodeId = [seedBytes[0] | 1, seedBytes[1], seedBytes[2], seedBytes[3], seedBytes[4], seedBytes[5]];
    }
    if (clockseq == null) {
      clockseq = _clockseq = (seedBytes[6] << 8 | seedBytes[7]) & 16383;
    }
  }
  var msecs = options.msecs !== void 0 ? options.msecs : Date.now();
  var nsecs = options.nsecs !== void 0 ? options.nsecs : _lastNSecs + 1;
  var dt3 = msecs - _lastMSecs + (nsecs - _lastNSecs) / 1e4;
  if (dt3 < 0 && options.clockseq === void 0) {
    clockseq = clockseq + 1 & 16383;
  }
  if ((dt3 < 0 || msecs > _lastMSecs) && options.nsecs === void 0) {
    nsecs = 0;
  }
  if (nsecs >= 1e4) {
    throw new Error("uuid.v1(): Can't create more than 10M uuids/sec");
  }
  _lastMSecs = msecs;
  _lastNSecs = nsecs;
  _clockseq = clockseq;
  msecs += 122192928e5;
  var tl2 = ((msecs & 268435455) * 1e4 + nsecs) % 4294967296;
  b3[i4++] = tl2 >>> 24 & 255;
  b3[i4++] = tl2 >>> 16 & 255;
  b3[i4++] = tl2 >>> 8 & 255;
  b3[i4++] = tl2 & 255;
  var tmh = msecs / 4294967296 * 1e4 & 268435455;
  b3[i4++] = tmh >>> 8 & 255;
  b3[i4++] = tmh & 255;
  b3[i4++] = tmh >>> 24 & 15 | 16;
  b3[i4++] = tmh >>> 16 & 255;
  b3[i4++] = clockseq >>> 8 | 128;
  b3[i4++] = clockseq & 255;
  for (var n6 = 0; n6 < 6; ++n6) {
    b3[i4 + n6] = node[n6];
  }
  return buf || stringify_default(b3);
}
var _nodeId, _clockseq, _lastMSecs, _lastNSecs, v1_default;
var init_v1 = __esm({
  "node_modules/uuid/dist/esm-browser/v1.js"() {
    init_rng();
    init_stringify();
    _lastMSecs = 0;
    _lastNSecs = 0;
    v1_default = v1;
  }
});

// node_modules/uuid/dist/esm-browser/parse.js
function parse(uuid) {
  if (!validate_default(uuid)) {
    throw TypeError("Invalid UUID");
  }
  var v2;
  var arr = new Uint8Array(16);
  arr[0] = (v2 = parseInt(uuid.slice(0, 8), 16)) >>> 24;
  arr[1] = v2 >>> 16 & 255;
  arr[2] = v2 >>> 8 & 255;
  arr[3] = v2 & 255;
  arr[4] = (v2 = parseInt(uuid.slice(9, 13), 16)) >>> 8;
  arr[5] = v2 & 255;
  arr[6] = (v2 = parseInt(uuid.slice(14, 18), 16)) >>> 8;
  arr[7] = v2 & 255;
  arr[8] = (v2 = parseInt(uuid.slice(19, 23), 16)) >>> 8;
  arr[9] = v2 & 255;
  arr[10] = (v2 = parseInt(uuid.slice(24, 36), 16)) / 1099511627776 & 255;
  arr[11] = v2 / 4294967296 & 255;
  arr[12] = v2 >>> 24 & 255;
  arr[13] = v2 >>> 16 & 255;
  arr[14] = v2 >>> 8 & 255;
  arr[15] = v2 & 255;
  return arr;
}
var parse_default;
var init_parse = __esm({
  "node_modules/uuid/dist/esm-browser/parse.js"() {
    init_validate();
    parse_default = parse;
  }
});

// node_modules/uuid/dist/esm-browser/v35.js
function stringToBytes(str) {
  str = unescape(encodeURIComponent(str));
  var bytes = [];
  for (var i4 = 0; i4 < str.length; ++i4) {
    bytes.push(str.charCodeAt(i4));
  }
  return bytes;
}
function v35_default(name, version2, hashfunc) {
  function generateUUID(value2, namespace, buf, offset2) {
    if (typeof value2 === "string") {
      value2 = stringToBytes(value2);
    }
    if (typeof namespace === "string") {
      namespace = parse_default(namespace);
    }
    if (namespace.length !== 16) {
      throw TypeError("Namespace must be array-like (16 iterable integer values, 0-255)");
    }
    var bytes = new Uint8Array(16 + value2.length);
    bytes.set(namespace);
    bytes.set(value2, namespace.length);
    bytes = hashfunc(bytes);
    bytes[6] = bytes[6] & 15 | version2;
    bytes[8] = bytes[8] & 63 | 128;
    if (buf) {
      offset2 = offset2 || 0;
      for (var i4 = 0; i4 < 16; ++i4) {
        buf[offset2 + i4] = bytes[i4];
      }
      return buf;
    }
    return stringify_default(bytes);
  }
  try {
    generateUUID.name = name;
  } catch (err) {
  }
  generateUUID.DNS = DNS;
  generateUUID.URL = URL2;
  return generateUUID;
}
var DNS, URL2;
var init_v35 = __esm({
  "node_modules/uuid/dist/esm-browser/v35.js"() {
    init_stringify();
    init_parse();
    DNS = "6ba7b810-9dad-11d1-80b4-00c04fd430c8";
    URL2 = "6ba7b811-9dad-11d1-80b4-00c04fd430c8";
  }
});

// node_modules/uuid/dist/esm-browser/md5.js
function md5(bytes) {
  if (typeof bytes === "string") {
    var msg = unescape(encodeURIComponent(bytes));
    bytes = new Uint8Array(msg.length);
    for (var i4 = 0; i4 < msg.length; ++i4) {
      bytes[i4] = msg.charCodeAt(i4);
    }
  }
  return md5ToHexEncodedArray(wordsToMd5(bytesToWords(bytes), bytes.length * 8));
}
function md5ToHexEncodedArray(input) {
  var output = [];
  var length32 = input.length * 32;
  var hexTab = "0123456789abcdef";
  for (var i4 = 0; i4 < length32; i4 += 8) {
    var x3 = input[i4 >> 5] >>> i4 % 32 & 255;
    var hex = parseInt(hexTab.charAt(x3 >>> 4 & 15) + hexTab.charAt(x3 & 15), 16);
    output.push(hex);
  }
  return output;
}
function getOutputLength(inputLength8) {
  return (inputLength8 + 64 >>> 9 << 4) + 14 + 1;
}
function wordsToMd5(x3, len) {
  x3[len >> 5] |= 128 << len % 32;
  x3[getOutputLength(len) - 1] = len;
  var a = 1732584193;
  var b3 = -271733879;
  var c3 = -1732584194;
  var d3 = 271733878;
  for (var i4 = 0; i4 < x3.length; i4 += 16) {
    var olda = a;
    var oldb = b3;
    var oldc = c3;
    var oldd = d3;
    a = md5ff(a, b3, c3, d3, x3[i4], 7, -680876936);
    d3 = md5ff(d3, a, b3, c3, x3[i4 + 1], 12, -389564586);
    c3 = md5ff(c3, d3, a, b3, x3[i4 + 2], 17, 606105819);
    b3 = md5ff(b3, c3, d3, a, x3[i4 + 3], 22, -1044525330);
    a = md5ff(a, b3, c3, d3, x3[i4 + 4], 7, -176418897);
    d3 = md5ff(d3, a, b3, c3, x3[i4 + 5], 12, 1200080426);
    c3 = md5ff(c3, d3, a, b3, x3[i4 + 6], 17, -1473231341);
    b3 = md5ff(b3, c3, d3, a, x3[i4 + 7], 22, -45705983);
    a = md5ff(a, b3, c3, d3, x3[i4 + 8], 7, 1770035416);
    d3 = md5ff(d3, a, b3, c3, x3[i4 + 9], 12, -1958414417);
    c3 = md5ff(c3, d3, a, b3, x3[i4 + 10], 17, -42063);
    b3 = md5ff(b3, c3, d3, a, x3[i4 + 11], 22, -1990404162);
    a = md5ff(a, b3, c3, d3, x3[i4 + 12], 7, 1804603682);
    d3 = md5ff(d3, a, b3, c3, x3[i4 + 13], 12, -40341101);
    c3 = md5ff(c3, d3, a, b3, x3[i4 + 14], 17, -1502002290);
    b3 = md5ff(b3, c3, d3, a, x3[i4 + 15], 22, 1236535329);
    a = md5gg(a, b3, c3, d3, x3[i4 + 1], 5, -165796510);
    d3 = md5gg(d3, a, b3, c3, x3[i4 + 6], 9, -1069501632);
    c3 = md5gg(c3, d3, a, b3, x3[i4 + 11], 14, 643717713);
    b3 = md5gg(b3, c3, d3, a, x3[i4], 20, -373897302);
    a = md5gg(a, b3, c3, d3, x3[i4 + 5], 5, -701558691);
    d3 = md5gg(d3, a, b3, c3, x3[i4 + 10], 9, 38016083);
    c3 = md5gg(c3, d3, a, b3, x3[i4 + 15], 14, -660478335);
    b3 = md5gg(b3, c3, d3, a, x3[i4 + 4], 20, -405537848);
    a = md5gg(a, b3, c3, d3, x3[i4 + 9], 5, 568446438);
    d3 = md5gg(d3, a, b3, c3, x3[i4 + 14], 9, -1019803690);
    c3 = md5gg(c3, d3, a, b3, x3[i4 + 3], 14, -187363961);
    b3 = md5gg(b3, c3, d3, a, x3[i4 + 8], 20, 1163531501);
    a = md5gg(a, b3, c3, d3, x3[i4 + 13], 5, -1444681467);
    d3 = md5gg(d3, a, b3, c3, x3[i4 + 2], 9, -51403784);
    c3 = md5gg(c3, d3, a, b3, x3[i4 + 7], 14, 1735328473);
    b3 = md5gg(b3, c3, d3, a, x3[i4 + 12], 20, -1926607734);
    a = md5hh(a, b3, c3, d3, x3[i4 + 5], 4, -378558);
    d3 = md5hh(d3, a, b3, c3, x3[i4 + 8], 11, -2022574463);
    c3 = md5hh(c3, d3, a, b3, x3[i4 + 11], 16, 1839030562);
    b3 = md5hh(b3, c3, d3, a, x3[i4 + 14], 23, -35309556);
    a = md5hh(a, b3, c3, d3, x3[i4 + 1], 4, -1530992060);
    d3 = md5hh(d3, a, b3, c3, x3[i4 + 4], 11, 1272893353);
    c3 = md5hh(c3, d3, a, b3, x3[i4 + 7], 16, -155497632);
    b3 = md5hh(b3, c3, d3, a, x3[i4 + 10], 23, -1094730640);
    a = md5hh(a, b3, c3, d3, x3[i4 + 13], 4, 681279174);
    d3 = md5hh(d3, a, b3, c3, x3[i4], 11, -358537222);
    c3 = md5hh(c3, d3, a, b3, x3[i4 + 3], 16, -722521979);
    b3 = md5hh(b3, c3, d3, a, x3[i4 + 6], 23, 76029189);
    a = md5hh(a, b3, c3, d3, x3[i4 + 9], 4, -640364487);
    d3 = md5hh(d3, a, b3, c3, x3[i4 + 12], 11, -421815835);
    c3 = md5hh(c3, d3, a, b3, x3[i4 + 15], 16, 530742520);
    b3 = md5hh(b3, c3, d3, a, x3[i4 + 2], 23, -995338651);
    a = md5ii(a, b3, c3, d3, x3[i4], 6, -198630844);
    d3 = md5ii(d3, a, b3, c3, x3[i4 + 7], 10, 1126891415);
    c3 = md5ii(c3, d3, a, b3, x3[i4 + 14], 15, -1416354905);
    b3 = md5ii(b3, c3, d3, a, x3[i4 + 5], 21, -57434055);
    a = md5ii(a, b3, c3, d3, x3[i4 + 12], 6, 1700485571);
    d3 = md5ii(d3, a, b3, c3, x3[i4 + 3], 10, -1894986606);
    c3 = md5ii(c3, d3, a, b3, x3[i4 + 10], 15, -1051523);
    b3 = md5ii(b3, c3, d3, a, x3[i4 + 1], 21, -2054922799);
    a = md5ii(a, b3, c3, d3, x3[i4 + 8], 6, 1873313359);
    d3 = md5ii(d3, a, b3, c3, x3[i4 + 15], 10, -30611744);
    c3 = md5ii(c3, d3, a, b3, x3[i4 + 6], 15, -1560198380);
    b3 = md5ii(b3, c3, d3, a, x3[i4 + 13], 21, 1309151649);
    a = md5ii(a, b3, c3, d3, x3[i4 + 4], 6, -145523070);
    d3 = md5ii(d3, a, b3, c3, x3[i4 + 11], 10, -1120210379);
    c3 = md5ii(c3, d3, a, b3, x3[i4 + 2], 15, 718787259);
    b3 = md5ii(b3, c3, d3, a, x3[i4 + 9], 21, -343485551);
    a = safeAdd(a, olda);
    b3 = safeAdd(b3, oldb);
    c3 = safeAdd(c3, oldc);
    d3 = safeAdd(d3, oldd);
  }
  return [a, b3, c3, d3];
}
function bytesToWords(input) {
  if (input.length === 0) {
    return [];
  }
  var length8 = input.length * 8;
  var output = new Uint32Array(getOutputLength(length8));
  for (var i4 = 0; i4 < length8; i4 += 8) {
    output[i4 >> 5] |= (input[i4 / 8] & 255) << i4 % 32;
  }
  return output;
}
function safeAdd(x3, y2) {
  var lsw = (x3 & 65535) + (y2 & 65535);
  var msw = (x3 >> 16) + (y2 >> 16) + (lsw >> 16);
  return msw << 16 | lsw & 65535;
}
function bitRotateLeft(num, cnt) {
  return num << cnt | num >>> 32 - cnt;
}
function md5cmn(q4, a, b3, x3, s2, t3) {
  return safeAdd(bitRotateLeft(safeAdd(safeAdd(a, q4), safeAdd(x3, t3)), s2), b3);
}
function md5ff(a, b3, c3, d3, x3, s2, t3) {
  return md5cmn(b3 & c3 | ~b3 & d3, a, b3, x3, s2, t3);
}
function md5gg(a, b3, c3, d3, x3, s2, t3) {
  return md5cmn(b3 & d3 | c3 & ~d3, a, b3, x3, s2, t3);
}
function md5hh(a, b3, c3, d3, x3, s2, t3) {
  return md5cmn(b3 ^ c3 ^ d3, a, b3, x3, s2, t3);
}
function md5ii(a, b3, c3, d3, x3, s2, t3) {
  return md5cmn(c3 ^ (b3 | ~d3), a, b3, x3, s2, t3);
}
var md5_default;
var init_md5 = __esm({
  "node_modules/uuid/dist/esm-browser/md5.js"() {
    md5_default = md5;
  }
});

// node_modules/uuid/dist/esm-browser/v3.js
var v3, v3_default;
var init_v3 = __esm({
  "node_modules/uuid/dist/esm-browser/v3.js"() {
    init_v35();
    init_md5();
    v3 = v35_default("v3", 48, md5_default);
    v3_default = v3;
  }
});

// node_modules/uuid/dist/esm-browser/v4.js
function v4(options, buf, offset2) {
  options = options || {};
  var rnds = options.random || (options.rng || rng)();
  rnds[6] = rnds[6] & 15 | 64;
  rnds[8] = rnds[8] & 63 | 128;
  if (buf) {
    offset2 = offset2 || 0;
    for (var i4 = 0; i4 < 16; ++i4) {
      buf[offset2 + i4] = rnds[i4];
    }
    return buf;
  }
  return stringify_default(rnds);
}
var v4_default;
var init_v4 = __esm({
  "node_modules/uuid/dist/esm-browser/v4.js"() {
    init_rng();
    init_stringify();
    v4_default = v4;
  }
});

// node_modules/uuid/dist/esm-browser/sha1.js
function f2(s2, x3, y2, z3) {
  switch (s2) {
    case 0:
      return x3 & y2 ^ ~x3 & z3;
    case 1:
      return x3 ^ y2 ^ z3;
    case 2:
      return x3 & y2 ^ x3 & z3 ^ y2 & z3;
    case 3:
      return x3 ^ y2 ^ z3;
  }
}
function ROTL(x3, n6) {
  return x3 << n6 | x3 >>> 32 - n6;
}
function sha1(bytes) {
  var K4 = [1518500249, 1859775393, 2400959708, 3395469782];
  var H3 = [1732584193, 4023233417, 2562383102, 271733878, 3285377520];
  if (typeof bytes === "string") {
    var msg = unescape(encodeURIComponent(bytes));
    bytes = [];
    for (var i4 = 0; i4 < msg.length; ++i4) {
      bytes.push(msg.charCodeAt(i4));
    }
  } else if (!Array.isArray(bytes)) {
    bytes = Array.prototype.slice.call(bytes);
  }
  bytes.push(128);
  var l5 = bytes.length / 4 + 2;
  var N3 = Math.ceil(l5 / 16);
  var M4 = new Array(N3);
  for (var _i2 = 0; _i2 < N3; ++_i2) {
    var arr = new Uint32Array(16);
    for (var j4 = 0; j4 < 16; ++j4) {
      arr[j4] = bytes[_i2 * 64 + j4 * 4] << 24 | bytes[_i2 * 64 + j4 * 4 + 1] << 16 | bytes[_i2 * 64 + j4 * 4 + 2] << 8 | bytes[_i2 * 64 + j4 * 4 + 3];
    }
    M4[_i2] = arr;
  }
  M4[N3 - 1][14] = (bytes.length - 1) * 8 / Math.pow(2, 32);
  M4[N3 - 1][14] = Math.floor(M4[N3 - 1][14]);
  M4[N3 - 1][15] = (bytes.length - 1) * 8 & 4294967295;
  for (var _i22 = 0; _i22 < N3; ++_i22) {
    var W3 = new Uint32Array(80);
    for (var t3 = 0; t3 < 16; ++t3) {
      W3[t3] = M4[_i22][t3];
    }
    for (var _t3 = 16; _t3 < 80; ++_t3) {
      W3[_t3] = ROTL(W3[_t3 - 3] ^ W3[_t3 - 8] ^ W3[_t3 - 14] ^ W3[_t3 - 16], 1);
    }
    var a = H3[0];
    var b3 = H3[1];
    var c3 = H3[2];
    var d3 = H3[3];
    var e9 = H3[4];
    for (var _t22 = 0; _t22 < 80; ++_t22) {
      var s2 = Math.floor(_t22 / 20);
      var T3 = ROTL(a, 5) + f2(s2, b3, c3, d3) + e9 + K4[s2] + W3[_t22] >>> 0;
      e9 = d3;
      d3 = c3;
      c3 = ROTL(b3, 30) >>> 0;
      b3 = a;
      a = T3;
    }
    H3[0] = H3[0] + a >>> 0;
    H3[1] = H3[1] + b3 >>> 0;
    H3[2] = H3[2] + c3 >>> 0;
    H3[3] = H3[3] + d3 >>> 0;
    H3[4] = H3[4] + e9 >>> 0;
  }
  return [H3[0] >> 24 & 255, H3[0] >> 16 & 255, H3[0] >> 8 & 255, H3[0] & 255, H3[1] >> 24 & 255, H3[1] >> 16 & 255, H3[1] >> 8 & 255, H3[1] & 255, H3[2] >> 24 & 255, H3[2] >> 16 & 255, H3[2] >> 8 & 255, H3[2] & 255, H3[3] >> 24 & 255, H3[3] >> 16 & 255, H3[3] >> 8 & 255, H3[3] & 255, H3[4] >> 24 & 255, H3[4] >> 16 & 255, H3[4] >> 8 & 255, H3[4] & 255];
}
var sha1_default;
var init_sha1 = __esm({
  "node_modules/uuid/dist/esm-browser/sha1.js"() {
    sha1_default = sha1;
  }
});

// node_modules/uuid/dist/esm-browser/v5.js
var v5, v5_default;
var init_v5 = __esm({
  "node_modules/uuid/dist/esm-browser/v5.js"() {
    init_v35();
    init_sha1();
    v5 = v35_default("v5", 80, sha1_default);
    v5_default = v5;
  }
});

// node_modules/uuid/dist/esm-browser/nil.js
var nil_default;
var init_nil = __esm({
  "node_modules/uuid/dist/esm-browser/nil.js"() {
    nil_default = "00000000-0000-0000-0000-000000000000";
  }
});

// node_modules/uuid/dist/esm-browser/version.js
function version(uuid) {
  if (!validate_default(uuid)) {
    throw TypeError("Invalid UUID");
  }
  return parseInt(uuid.substr(14, 1), 16);
}
var version_default;
var init_version = __esm({
  "node_modules/uuid/dist/esm-browser/version.js"() {
    init_validate();
    version_default = version;
  }
});

// node_modules/uuid/dist/esm-browser/index.js
var esm_browser_exports = {};
__export(esm_browser_exports, {
  NIL: () => nil_default,
  parse: () => parse_default,
  stringify: () => stringify_default,
  v1: () => v1_default,
  v3: () => v3_default,
  v4: () => v4_default,
  v5: () => v5_default,
  validate: () => validate_default,
  version: () => version_default
});
var init_esm_browser = __esm({
  "node_modules/uuid/dist/esm-browser/index.js"() {
    init_v1();
    init_v3();
    init_v4();
    init_v5();
    init_nil();
    init_version();
    init_validate();
    init_stringify();
    init_parse();
  }
});

// node_modules/base64-js/index.js
var require_base64_js = __commonJS({
  "node_modules/base64-js/index.js"(exports) {
    "use strict";
    exports.byteLength = byteLength2;
    exports.toByteArray = toByteArray;
    exports.fromByteArray = fromByteArray;
    var lookup3 = [];
    var revLookup = [];
    var Arr = typeof Uint8Array !== "undefined" ? Uint8Array : Array;
    var code = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
    for (i4 = 0, len = code.length; i4 < len; ++i4) {
      lookup3[i4] = code[i4];
      revLookup[code.charCodeAt(i4)] = i4;
    }
    var i4;
    var len;
    revLookup["-".charCodeAt(0)] = 62;
    revLookup["_".charCodeAt(0)] = 63;
    function getLens(b64) {
      var len2 = b64.length;
      if (len2 % 4 > 0) {
        throw new Error("Invalid string. Length must be a multiple of 4");
      }
      var validLen = b64.indexOf("=");
      if (validLen === -1) validLen = len2;
      var placeHoldersLen = validLen === len2 ? 0 : 4 - validLen % 4;
      return [validLen, placeHoldersLen];
    }
    function byteLength2(b64) {
      var lens = getLens(b64);
      var validLen = lens[0];
      var placeHoldersLen = lens[1];
      return (validLen + placeHoldersLen) * 3 / 4 - placeHoldersLen;
    }
    function _byteLength(b64, validLen, placeHoldersLen) {
      return (validLen + placeHoldersLen) * 3 / 4 - placeHoldersLen;
    }
    function toByteArray(b64) {
      var tmp;
      var lens = getLens(b64);
      var validLen = lens[0];
      var placeHoldersLen = lens[1];
      var arr = new Arr(_byteLength(b64, validLen, placeHoldersLen));
      var curByte = 0;
      var len2 = placeHoldersLen > 0 ? validLen - 4 : validLen;
      var i5;
      for (i5 = 0; i5 < len2; i5 += 4) {
        tmp = revLookup[b64.charCodeAt(i5)] << 18 | revLookup[b64.charCodeAt(i5 + 1)] << 12 | revLookup[b64.charCodeAt(i5 + 2)] << 6 | revLookup[b64.charCodeAt(i5 + 3)];
        arr[curByte++] = tmp >> 16 & 255;
        arr[curByte++] = tmp >> 8 & 255;
        arr[curByte++] = tmp & 255;
      }
      if (placeHoldersLen === 2) {
        tmp = revLookup[b64.charCodeAt(i5)] << 2 | revLookup[b64.charCodeAt(i5 + 1)] >> 4;
        arr[curByte++] = tmp & 255;
      }
      if (placeHoldersLen === 1) {
        tmp = revLookup[b64.charCodeAt(i5)] << 10 | revLookup[b64.charCodeAt(i5 + 1)] << 4 | revLookup[b64.charCodeAt(i5 + 2)] >> 2;
        arr[curByte++] = tmp >> 8 & 255;
        arr[curByte++] = tmp & 255;
      }
      return arr;
    }
    function tripletToBase64(num) {
      return lookup3[num >> 18 & 63] + lookup3[num >> 12 & 63] + lookup3[num >> 6 & 63] + lookup3[num & 63];
    }
    function encodeChunk(uint8, start, end) {
      var tmp;
      var output = [];
      for (var i5 = start; i5 < end; i5 += 3) {
        tmp = (uint8[i5] << 16 & 16711680) + (uint8[i5 + 1] << 8 & 65280) + (uint8[i5 + 2] & 255);
        output.push(tripletToBase64(tmp));
      }
      return output.join("");
    }
    function fromByteArray(uint8) {
      var tmp;
      var len2 = uint8.length;
      var extraBytes = len2 % 3;
      var parts2 = [];
      var maxChunkLength = 16383;
      for (var i5 = 0, len22 = len2 - extraBytes; i5 < len22; i5 += maxChunkLength) {
        parts2.push(encodeChunk(uint8, i5, i5 + maxChunkLength > len22 ? len22 : i5 + maxChunkLength));
      }
      if (extraBytes === 1) {
        tmp = uint8[len2 - 1];
        parts2.push(
          lookup3[tmp >> 2] + lookup3[tmp << 4 & 63] + "=="
        );
      } else if (extraBytes === 2) {
        tmp = (uint8[len2 - 2] << 8) + uint8[len2 - 1];
        parts2.push(
          lookup3[tmp >> 10] + lookup3[tmp >> 4 & 63] + lookup3[tmp << 2 & 63] + "="
        );
      }
      return parts2.join("");
    }
  }
});

// node_modules/ieee754/index.js
var require_ieee754 = __commonJS({
  "node_modules/ieee754/index.js"(exports) {
    exports.read = function(buffer, offset2, isLE, mLen, nBytes) {
      var e9, m4;
      var eLen = nBytes * 8 - mLen - 1;
      var eMax = (1 << eLen) - 1;
      var eBias = eMax >> 1;
      var nBits = -7;
      var i4 = isLE ? nBytes - 1 : 0;
      var d3 = isLE ? -1 : 1;
      var s2 = buffer[offset2 + i4];
      i4 += d3;
      e9 = s2 & (1 << -nBits) - 1;
      s2 >>= -nBits;
      nBits += eLen;
      for (; nBits > 0; e9 = e9 * 256 + buffer[offset2 + i4], i4 += d3, nBits -= 8) {
      }
      m4 = e9 & (1 << -nBits) - 1;
      e9 >>= -nBits;
      nBits += mLen;
      for (; nBits > 0; m4 = m4 * 256 + buffer[offset2 + i4], i4 += d3, nBits -= 8) {
      }
      if (e9 === 0) {
        e9 = 1 - eBias;
      } else if (e9 === eMax) {
        return m4 ? NaN : (s2 ? -1 : 1) * Infinity;
      } else {
        m4 = m4 + Math.pow(2, mLen);
        e9 = e9 - eBias;
      }
      return (s2 ? -1 : 1) * m4 * Math.pow(2, e9 - mLen);
    };
    exports.write = function(buffer, value2, offset2, isLE, mLen, nBytes) {
      var e9, m4, c3;
      var eLen = nBytes * 8 - mLen - 1;
      var eMax = (1 << eLen) - 1;
      var eBias = eMax >> 1;
      var rt3 = mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0;
      var i4 = isLE ? 0 : nBytes - 1;
      var d3 = isLE ? 1 : -1;
      var s2 = value2 < 0 || value2 === 0 && 1 / value2 < 0 ? 1 : 0;
      value2 = Math.abs(value2);
      if (isNaN(value2) || value2 === Infinity) {
        m4 = isNaN(value2) ? 1 : 0;
        e9 = eMax;
      } else {
        e9 = Math.floor(Math.log(value2) / Math.LN2);
        if (value2 * (c3 = Math.pow(2, -e9)) < 1) {
          e9--;
          c3 *= 2;
        }
        if (e9 + eBias >= 1) {
          value2 += rt3 / c3;
        } else {
          value2 += rt3 * Math.pow(2, 1 - eBias);
        }
        if (value2 * c3 >= 2) {
          e9++;
          c3 /= 2;
        }
        if (e9 + eBias >= eMax) {
          m4 = 0;
          e9 = eMax;
        } else if (e9 + eBias >= 1) {
          m4 = (value2 * c3 - 1) * Math.pow(2, mLen);
          e9 = e9 + eBias;
        } else {
          m4 = value2 * Math.pow(2, eBias - 1) * Math.pow(2, mLen);
          e9 = 0;
        }
      }
      for (; mLen >= 8; buffer[offset2 + i4] = m4 & 255, i4 += d3, m4 /= 256, mLen -= 8) {
      }
      e9 = e9 << mLen | m4;
      eLen += mLen;
      for (; eLen > 0; buffer[offset2 + i4] = e9 & 255, i4 += d3, e9 /= 256, eLen -= 8) {
      }
      buffer[offset2 + i4 - d3] |= s2 * 128;
    };
  }
});

// node_modules/buffer/index.js
var require_buffer = __commonJS({
  "node_modules/buffer/index.js"(exports) {
    "use strict";
    var base64 = require_base64_js();
    var ieee754 = require_ieee754();
    var customInspectSymbol = typeof Symbol === "function" && typeof Symbol["for"] === "function" ? Symbol["for"]("nodejs.util.inspect.custom") : null;
    exports.Buffer = Buffer4;
    exports.SlowBuffer = SlowBuffer;
    exports.INSPECT_MAX_BYTES = 50;
    var K_MAX_LENGTH = 2147483647;
    exports.kMaxLength = K_MAX_LENGTH;
    Buffer4.TYPED_ARRAY_SUPPORT = typedArraySupport();
    if (!Buffer4.TYPED_ARRAY_SUPPORT && typeof console !== "undefined" && typeof console.error === "function") {
      console.error(
        "This browser lacks typed array (Uint8Array) support which is required by `buffer` v5.x. Use `buffer` v4.x if you require old browser support."
      );
    }
    function typedArraySupport() {
      try {
        const arr = new Uint8Array(1);
        const proto = { foo: function() {
          return 42;
        } };
        Object.setPrototypeOf(proto, Uint8Array.prototype);
        Object.setPrototypeOf(arr, proto);
        return arr.foo() === 42;
      } catch (e9) {
        return false;
      }
    }
    Object.defineProperty(Buffer4.prototype, "parent", {
      enumerable: true,
      get: function() {
        if (!Buffer4.isBuffer(this)) return void 0;
        return this.buffer;
      }
    });
    Object.defineProperty(Buffer4.prototype, "offset", {
      enumerable: true,
      get: function() {
        if (!Buffer4.isBuffer(this)) return void 0;
        return this.byteOffset;
      }
    });
    function createBuffer(length) {
      if (length > K_MAX_LENGTH) {
        throw new RangeError('The value "' + length + '" is invalid for option "size"');
      }
      const buf = new Uint8Array(length);
      Object.setPrototypeOf(buf, Buffer4.prototype);
      return buf;
    }
    function Buffer4(arg, encodingOrOffset, length) {
      if (typeof arg === "number") {
        if (typeof encodingOrOffset === "string") {
          throw new TypeError(
            'The "string" argument must be of type string. Received type number'
          );
        }
        return allocUnsafe(arg);
      }
      return from(arg, encodingOrOffset, length);
    }
    Buffer4.poolSize = 8192;
    function from(value2, encodingOrOffset, length) {
      if (typeof value2 === "string") {
        return fromString(value2, encodingOrOffset);
      }
      if (ArrayBuffer.isView(value2)) {
        return fromArrayView(value2);
      }
      if (value2 == null) {
        throw new TypeError(
          "The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof value2
        );
      }
      if (isInstance(value2, ArrayBuffer) || value2 && isInstance(value2.buffer, ArrayBuffer)) {
        return fromArrayBuffer(value2, encodingOrOffset, length);
      }
      if (typeof SharedArrayBuffer !== "undefined" && (isInstance(value2, SharedArrayBuffer) || value2 && isInstance(value2.buffer, SharedArrayBuffer))) {
        return fromArrayBuffer(value2, encodingOrOffset, length);
      }
      if (typeof value2 === "number") {
        throw new TypeError(
          'The "value" argument must not be of type number. Received type number'
        );
      }
      const valueOf = value2.valueOf && value2.valueOf();
      if (valueOf != null && valueOf !== value2) {
        return Buffer4.from(valueOf, encodingOrOffset, length);
      }
      const b3 = fromObject(value2);
      if (b3) return b3;
      if (typeof Symbol !== "undefined" && Symbol.toPrimitive != null && typeof value2[Symbol.toPrimitive] === "function") {
        return Buffer4.from(value2[Symbol.toPrimitive]("string"), encodingOrOffset, length);
      }
      throw new TypeError(
        "The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof value2
      );
    }
    Buffer4.from = function(value2, encodingOrOffset, length) {
      return from(value2, encodingOrOffset, length);
    };
    Object.setPrototypeOf(Buffer4.prototype, Uint8Array.prototype);
    Object.setPrototypeOf(Buffer4, Uint8Array);
    function assertSize(size) {
      if (typeof size !== "number") {
        throw new TypeError('"size" argument must be of type number');
      } else if (size < 0) {
        throw new RangeError('The value "' + size + '" is invalid for option "size"');
      }
    }
    function alloc(size, fill, encoding) {
      assertSize(size);
      if (size <= 0) {
        return createBuffer(size);
      }
      if (fill !== void 0) {
        return typeof encoding === "string" ? createBuffer(size).fill(fill, encoding) : createBuffer(size).fill(fill);
      }
      return createBuffer(size);
    }
    Buffer4.alloc = function(size, fill, encoding) {
      return alloc(size, fill, encoding);
    };
    function allocUnsafe(size) {
      assertSize(size);
      return createBuffer(size < 0 ? 0 : checked(size) | 0);
    }
    Buffer4.allocUnsafe = function(size) {
      return allocUnsafe(size);
    };
    Buffer4.allocUnsafeSlow = function(size) {
      return allocUnsafe(size);
    };
    function fromString(string2, encoding) {
      if (typeof encoding !== "string" || encoding === "") {
        encoding = "utf8";
      }
      if (!Buffer4.isEncoding(encoding)) {
        throw new TypeError("Unknown encoding: " + encoding);
      }
      const length = byteLength2(string2, encoding) | 0;
      let buf = createBuffer(length);
      const actual = buf.write(string2, encoding);
      if (actual !== length) {
        buf = buf.slice(0, actual);
      }
      return buf;
    }
    function fromArrayLike(array2) {
      const length = array2.length < 0 ? 0 : checked(array2.length) | 0;
      const buf = createBuffer(length);
      for (let i4 = 0; i4 < length; i4 += 1) {
        buf[i4] = array2[i4] & 255;
      }
      return buf;
    }
    function fromArrayView(arrayView) {
      if (isInstance(arrayView, Uint8Array)) {
        const copy = new Uint8Array(arrayView);
        return fromArrayBuffer(copy.buffer, copy.byteOffset, copy.byteLength);
      }
      return fromArrayLike(arrayView);
    }
    function fromArrayBuffer(array2, byteOffset, length) {
      if (byteOffset < 0 || array2.byteLength < byteOffset) {
        throw new RangeError('"offset" is outside of buffer bounds');
      }
      if (array2.byteLength < byteOffset + (length || 0)) {
        throw new RangeError('"length" is outside of buffer bounds');
      }
      let buf;
      if (byteOffset === void 0 && length === void 0) {
        buf = new Uint8Array(array2);
      } else if (length === void 0) {
        buf = new Uint8Array(array2, byteOffset);
      } else {
        buf = new Uint8Array(array2, byteOffset, length);
      }
      Object.setPrototypeOf(buf, Buffer4.prototype);
      return buf;
    }
    function fromObject(obj) {
      if (Buffer4.isBuffer(obj)) {
        const len = checked(obj.length) | 0;
        const buf = createBuffer(len);
        if (buf.length === 0) {
          return buf;
        }
        obj.copy(buf, 0, 0, len);
        return buf;
      }
      if (obj.length !== void 0) {
        if (typeof obj.length !== "number" || numberIsNaN(obj.length)) {
          return createBuffer(0);
        }
        return fromArrayLike(obj);
      }
      if (obj.type === "Buffer" && Array.isArray(obj.data)) {
        return fromArrayLike(obj.data);
      }
    }
    function checked(length) {
      if (length >= K_MAX_LENGTH) {
        throw new RangeError("Attempt to allocate Buffer larger than maximum size: 0x" + K_MAX_LENGTH.toString(16) + " bytes");
      }
      return length | 0;
    }
    function SlowBuffer(length) {
      if (+length != length) {
        length = 0;
      }
      return Buffer4.alloc(+length);
    }
    Buffer4.isBuffer = function isBuffer(b3) {
      return b3 != null && b3._isBuffer === true && b3 !== Buffer4.prototype;
    };
    Buffer4.compare = function compare(a, b3) {
      if (isInstance(a, Uint8Array)) a = Buffer4.from(a, a.offset, a.byteLength);
      if (isInstance(b3, Uint8Array)) b3 = Buffer4.from(b3, b3.offset, b3.byteLength);
      if (!Buffer4.isBuffer(a) || !Buffer4.isBuffer(b3)) {
        throw new TypeError(
          'The "buf1", "buf2" arguments must be one of type Buffer or Uint8Array'
        );
      }
      if (a === b3) return 0;
      let x3 = a.length;
      let y2 = b3.length;
      for (let i4 = 0, len = Math.min(x3, y2); i4 < len; ++i4) {
        if (a[i4] !== b3[i4]) {
          x3 = a[i4];
          y2 = b3[i4];
          break;
        }
      }
      if (x3 < y2) return -1;
      if (y2 < x3) return 1;
      return 0;
    };
    Buffer4.isEncoding = function isEncoding(encoding) {
      switch (String(encoding).toLowerCase()) {
        case "hex":
        case "utf8":
        case "utf-8":
        case "ascii":
        case "latin1":
        case "binary":
        case "base64":
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
          return true;
        default:
          return false;
      }
    };
    Buffer4.concat = function concat(list, length) {
      if (!Array.isArray(list)) {
        throw new TypeError('"list" argument must be an Array of Buffers');
      }
      if (list.length === 0) {
        return Buffer4.alloc(0);
      }
      let i4;
      if (length === void 0) {
        length = 0;
        for (i4 = 0; i4 < list.length; ++i4) {
          length += list[i4].length;
        }
      }
      const buffer = Buffer4.allocUnsafe(length);
      let pos = 0;
      for (i4 = 0; i4 < list.length; ++i4) {
        let buf = list[i4];
        if (isInstance(buf, Uint8Array)) {
          if (pos + buf.length > buffer.length) {
            if (!Buffer4.isBuffer(buf)) buf = Buffer4.from(buf);
            buf.copy(buffer, pos);
          } else {
            Uint8Array.prototype.set.call(
              buffer,
              buf,
              pos
            );
          }
        } else if (!Buffer4.isBuffer(buf)) {
          throw new TypeError('"list" argument must be an Array of Buffers');
        } else {
          buf.copy(buffer, pos);
        }
        pos += buf.length;
      }
      return buffer;
    };
    function byteLength2(string2, encoding) {
      if (Buffer4.isBuffer(string2)) {
        return string2.length;
      }
      if (ArrayBuffer.isView(string2) || isInstance(string2, ArrayBuffer)) {
        return string2.byteLength;
      }
      if (typeof string2 !== "string") {
        throw new TypeError(
          'The "string" argument must be one of type string, Buffer, or ArrayBuffer. Received type ' + typeof string2
        );
      }
      const len = string2.length;
      const mustMatch = arguments.length > 2 && arguments[2] === true;
      if (!mustMatch && len === 0) return 0;
      let loweredCase = false;
      for (; ; ) {
        switch (encoding) {
          case "ascii":
          case "latin1":
          case "binary":
            return len;
          case "utf8":
          case "utf-8":
            return utf8ToBytes2(string2).length;
          case "ucs2":
          case "ucs-2":
          case "utf16le":
          case "utf-16le":
            return len * 2;
          case "hex":
            return len >>> 1;
          case "base64":
            return base64ToBytes(string2).length;
          default:
            if (loweredCase) {
              return mustMatch ? -1 : utf8ToBytes2(string2).length;
            }
            encoding = ("" + encoding).toLowerCase();
            loweredCase = true;
        }
      }
    }
    Buffer4.byteLength = byteLength2;
    function slowToString(encoding, start, end) {
      let loweredCase = false;
      if (start === void 0 || start < 0) {
        start = 0;
      }
      if (start > this.length) {
        return "";
      }
      if (end === void 0 || end > this.length) {
        end = this.length;
      }
      if (end <= 0) {
        return "";
      }
      end >>>= 0;
      start >>>= 0;
      if (end <= start) {
        return "";
      }
      if (!encoding) encoding = "utf8";
      while (true) {
        switch (encoding) {
          case "hex":
            return hexSlice(this, start, end);
          case "utf8":
          case "utf-8":
            return utf8Slice(this, start, end);
          case "ascii":
            return asciiSlice(this, start, end);
          case "latin1":
          case "binary":
            return latin1Slice(this, start, end);
          case "base64":
            return base64Slice(this, start, end);
          case "ucs2":
          case "ucs-2":
          case "utf16le":
          case "utf-16le":
            return utf16leSlice(this, start, end);
          default:
            if (loweredCase) throw new TypeError("Unknown encoding: " + encoding);
            encoding = (encoding + "").toLowerCase();
            loweredCase = true;
        }
      }
    }
    Buffer4.prototype._isBuffer = true;
    function swap(b3, n6, m4) {
      const i4 = b3[n6];
      b3[n6] = b3[m4];
      b3[m4] = i4;
    }
    Buffer4.prototype.swap16 = function swap16() {
      const len = this.length;
      if (len % 2 !== 0) {
        throw new RangeError("Buffer size must be a multiple of 16-bits");
      }
      for (let i4 = 0; i4 < len; i4 += 2) {
        swap(this, i4, i4 + 1);
      }
      return this;
    };
    Buffer4.prototype.swap32 = function swap32() {
      const len = this.length;
      if (len % 4 !== 0) {
        throw new RangeError("Buffer size must be a multiple of 32-bits");
      }
      for (let i4 = 0; i4 < len; i4 += 4) {
        swap(this, i4, i4 + 3);
        swap(this, i4 + 1, i4 + 2);
      }
      return this;
    };
    Buffer4.prototype.swap64 = function swap64() {
      const len = this.length;
      if (len % 8 !== 0) {
        throw new RangeError("Buffer size must be a multiple of 64-bits");
      }
      for (let i4 = 0; i4 < len; i4 += 8) {
        swap(this, i4, i4 + 7);
        swap(this, i4 + 1, i4 + 6);
        swap(this, i4 + 2, i4 + 5);
        swap(this, i4 + 3, i4 + 4);
      }
      return this;
    };
    Buffer4.prototype.toString = function toString2() {
      const length = this.length;
      if (length === 0) return "";
      if (arguments.length === 0) return utf8Slice(this, 0, length);
      return slowToString.apply(this, arguments);
    };
    Buffer4.prototype.toLocaleString = Buffer4.prototype.toString;
    Buffer4.prototype.equals = function equals(b3) {
      if (!Buffer4.isBuffer(b3)) throw new TypeError("Argument must be a Buffer");
      if (this === b3) return true;
      return Buffer4.compare(this, b3) === 0;
    };
    Buffer4.prototype.inspect = function inspect() {
      let str = "";
      const max = exports.INSPECT_MAX_BYTES;
      str = this.toString("hex", 0, max).replace(/(.{2})/g, "$1 ").trim();
      if (this.length > max) str += " ... ";
      return "<Buffer " + str + ">";
    };
    if (customInspectSymbol) {
      Buffer4.prototype[customInspectSymbol] = Buffer4.prototype.inspect;
    }
    Buffer4.prototype.compare = function compare(target, start, end, thisStart, thisEnd) {
      if (isInstance(target, Uint8Array)) {
        target = Buffer4.from(target, target.offset, target.byteLength);
      }
      if (!Buffer4.isBuffer(target)) {
        throw new TypeError(
          'The "target" argument must be one of type Buffer or Uint8Array. Received type ' + typeof target
        );
      }
      if (start === void 0) {
        start = 0;
      }
      if (end === void 0) {
        end = target ? target.length : 0;
      }
      if (thisStart === void 0) {
        thisStart = 0;
      }
      if (thisEnd === void 0) {
        thisEnd = this.length;
      }
      if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {
        throw new RangeError("out of range index");
      }
      if (thisStart >= thisEnd && start >= end) {
        return 0;
      }
      if (thisStart >= thisEnd) {
        return -1;
      }
      if (start >= end) {
        return 1;
      }
      start >>>= 0;
      end >>>= 0;
      thisStart >>>= 0;
      thisEnd >>>= 0;
      if (this === target) return 0;
      let x3 = thisEnd - thisStart;
      let y2 = end - start;
      const len = Math.min(x3, y2);
      const thisCopy = this.slice(thisStart, thisEnd);
      const targetCopy = target.slice(start, end);
      for (let i4 = 0; i4 < len; ++i4) {
        if (thisCopy[i4] !== targetCopy[i4]) {
          x3 = thisCopy[i4];
          y2 = targetCopy[i4];
          break;
        }
      }
      if (x3 < y2) return -1;
      if (y2 < x3) return 1;
      return 0;
    };
    function bidirectionalIndexOf(buffer, val, byteOffset, encoding, dir) {
      if (buffer.length === 0) return -1;
      if (typeof byteOffset === "string") {
        encoding = byteOffset;
        byteOffset = 0;
      } else if (byteOffset > 2147483647) {
        byteOffset = 2147483647;
      } else if (byteOffset < -2147483648) {
        byteOffset = -2147483648;
      }
      byteOffset = +byteOffset;
      if (numberIsNaN(byteOffset)) {
        byteOffset = dir ? 0 : buffer.length - 1;
      }
      if (byteOffset < 0) byteOffset = buffer.length + byteOffset;
      if (byteOffset >= buffer.length) {
        if (dir) return -1;
        else byteOffset = buffer.length - 1;
      } else if (byteOffset < 0) {
        if (dir) byteOffset = 0;
        else return -1;
      }
      if (typeof val === "string") {
        val = Buffer4.from(val, encoding);
      }
      if (Buffer4.isBuffer(val)) {
        if (val.length === 0) {
          return -1;
        }
        return arrayIndexOf(buffer, val, byteOffset, encoding, dir);
      } else if (typeof val === "number") {
        val = val & 255;
        if (typeof Uint8Array.prototype.indexOf === "function") {
          if (dir) {
            return Uint8Array.prototype.indexOf.call(buffer, val, byteOffset);
          } else {
            return Uint8Array.prototype.lastIndexOf.call(buffer, val, byteOffset);
          }
        }
        return arrayIndexOf(buffer, [val], byteOffset, encoding, dir);
      }
      throw new TypeError("val must be string, number or Buffer");
    }
    function arrayIndexOf(arr, val, byteOffset, encoding, dir) {
      let indexSize = 1;
      let arrLength = arr.length;
      let valLength = val.length;
      if (encoding !== void 0) {
        encoding = String(encoding).toLowerCase();
        if (encoding === "ucs2" || encoding === "ucs-2" || encoding === "utf16le" || encoding === "utf-16le") {
          if (arr.length < 2 || val.length < 2) {
            return -1;
          }
          indexSize = 2;
          arrLength /= 2;
          valLength /= 2;
          byteOffset /= 2;
        }
      }
      function read(buf, i5) {
        if (indexSize === 1) {
          return buf[i5];
        } else {
          return buf.readUInt16BE(i5 * indexSize);
        }
      }
      let i4;
      if (dir) {
        let foundIndex = -1;
        for (i4 = byteOffset; i4 < arrLength; i4++) {
          if (read(arr, i4) === read(val, foundIndex === -1 ? 0 : i4 - foundIndex)) {
            if (foundIndex === -1) foundIndex = i4;
            if (i4 - foundIndex + 1 === valLength) return foundIndex * indexSize;
          } else {
            if (foundIndex !== -1) i4 -= i4 - foundIndex;
            foundIndex = -1;
          }
        }
      } else {
        if (byteOffset + valLength > arrLength) byteOffset = arrLength - valLength;
        for (i4 = byteOffset; i4 >= 0; i4--) {
          let found = true;
          for (let j4 = 0; j4 < valLength; j4++) {
            if (read(arr, i4 + j4) !== read(val, j4)) {
              found = false;
              break;
            }
          }
          if (found) return i4;
        }
      }
      return -1;
    }
    Buffer4.prototype.includes = function includes(val, byteOffset, encoding) {
      return this.indexOf(val, byteOffset, encoding) !== -1;
    };
    Buffer4.prototype.indexOf = function indexOf(val, byteOffset, encoding) {
      return bidirectionalIndexOf(this, val, byteOffset, encoding, true);
    };
    Buffer4.prototype.lastIndexOf = function lastIndexOf(val, byteOffset, encoding) {
      return bidirectionalIndexOf(this, val, byteOffset, encoding, false);
    };
    function hexWrite(buf, string2, offset2, length) {
      offset2 = Number(offset2) || 0;
      const remaining = buf.length - offset2;
      if (!length) {
        length = remaining;
      } else {
        length = Number(length);
        if (length > remaining) {
          length = remaining;
        }
      }
      const strLen = string2.length;
      if (length > strLen / 2) {
        length = strLen / 2;
      }
      let i4;
      for (i4 = 0; i4 < length; ++i4) {
        const parsed = parseInt(string2.substr(i4 * 2, 2), 16);
        if (numberIsNaN(parsed)) return i4;
        buf[offset2 + i4] = parsed;
      }
      return i4;
    }
    function utf8Write(buf, string2, offset2, length) {
      return blitBuffer(utf8ToBytes2(string2, buf.length - offset2), buf, offset2, length);
    }
    function asciiWrite(buf, string2, offset2, length) {
      return blitBuffer(asciiToBytes(string2), buf, offset2, length);
    }
    function base64Write(buf, string2, offset2, length) {
      return blitBuffer(base64ToBytes(string2), buf, offset2, length);
    }
    function ucs2Write(buf, string2, offset2, length) {
      return blitBuffer(utf16leToBytes(string2, buf.length - offset2), buf, offset2, length);
    }
    Buffer4.prototype.write = function write(string2, offset2, length, encoding) {
      if (offset2 === void 0) {
        encoding = "utf8";
        length = this.length;
        offset2 = 0;
      } else if (length === void 0 && typeof offset2 === "string") {
        encoding = offset2;
        length = this.length;
        offset2 = 0;
      } else if (isFinite(offset2)) {
        offset2 = offset2 >>> 0;
        if (isFinite(length)) {
          length = length >>> 0;
          if (encoding === void 0) encoding = "utf8";
        } else {
          encoding = length;
          length = void 0;
        }
      } else {
        throw new Error(
          "Buffer.write(string, encoding, offset[, length]) is no longer supported"
        );
      }
      const remaining = this.length - offset2;
      if (length === void 0 || length > remaining) length = remaining;
      if (string2.length > 0 && (length < 0 || offset2 < 0) || offset2 > this.length) {
        throw new RangeError("Attempt to write outside buffer bounds");
      }
      if (!encoding) encoding = "utf8";
      let loweredCase = false;
      for (; ; ) {
        switch (encoding) {
          case "hex":
            return hexWrite(this, string2, offset2, length);
          case "utf8":
          case "utf-8":
            return utf8Write(this, string2, offset2, length);
          case "ascii":
          case "latin1":
          case "binary":
            return asciiWrite(this, string2, offset2, length);
          case "base64":
            return base64Write(this, string2, offset2, length);
          case "ucs2":
          case "ucs-2":
          case "utf16le":
          case "utf-16le":
            return ucs2Write(this, string2, offset2, length);
          default:
            if (loweredCase) throw new TypeError("Unknown encoding: " + encoding);
            encoding = ("" + encoding).toLowerCase();
            loweredCase = true;
        }
      }
    };
    Buffer4.prototype.toJSON = function toJSON() {
      return {
        type: "Buffer",
        data: Array.prototype.slice.call(this._arr || this, 0)
      };
    };
    function base64Slice(buf, start, end) {
      if (start === 0 && end === buf.length) {
        return base64.fromByteArray(buf);
      } else {
        return base64.fromByteArray(buf.slice(start, end));
      }
    }
    function utf8Slice(buf, start, end) {
      end = Math.min(buf.length, end);
      const res = [];
      let i4 = start;
      while (i4 < end) {
        const firstByte = buf[i4];
        let codePoint = null;
        let bytesPerSequence = firstByte > 239 ? 4 : firstByte > 223 ? 3 : firstByte > 191 ? 2 : 1;
        if (i4 + bytesPerSequence <= end) {
          let secondByte, thirdByte, fourthByte, tempCodePoint;
          switch (bytesPerSequence) {
            case 1:
              if (firstByte < 128) {
                codePoint = firstByte;
              }
              break;
            case 2:
              secondByte = buf[i4 + 1];
              if ((secondByte & 192) === 128) {
                tempCodePoint = (firstByte & 31) << 6 | secondByte & 63;
                if (tempCodePoint > 127) {
                  codePoint = tempCodePoint;
                }
              }
              break;
            case 3:
              secondByte = buf[i4 + 1];
              thirdByte = buf[i4 + 2];
              if ((secondByte & 192) === 128 && (thirdByte & 192) === 128) {
                tempCodePoint = (firstByte & 15) << 12 | (secondByte & 63) << 6 | thirdByte & 63;
                if (tempCodePoint > 2047 && (tempCodePoint < 55296 || tempCodePoint > 57343)) {
                  codePoint = tempCodePoint;
                }
              }
              break;
            case 4:
              secondByte = buf[i4 + 1];
              thirdByte = buf[i4 + 2];
              fourthByte = buf[i4 + 3];
              if ((secondByte & 192) === 128 && (thirdByte & 192) === 128 && (fourthByte & 192) === 128) {
                tempCodePoint = (firstByte & 15) << 18 | (secondByte & 63) << 12 | (thirdByte & 63) << 6 | fourthByte & 63;
                if (tempCodePoint > 65535 && tempCodePoint < 1114112) {
                  codePoint = tempCodePoint;
                }
              }
          }
        }
        if (codePoint === null) {
          codePoint = 65533;
          bytesPerSequence = 1;
        } else if (codePoint > 65535) {
          codePoint -= 65536;
          res.push(codePoint >>> 10 & 1023 | 55296);
          codePoint = 56320 | codePoint & 1023;
        }
        res.push(codePoint);
        i4 += bytesPerSequence;
      }
      return decodeCodePointsArray(res);
    }
    var MAX_ARGUMENTS_LENGTH = 4096;
    function decodeCodePointsArray(codePoints) {
      const len = codePoints.length;
      if (len <= MAX_ARGUMENTS_LENGTH) {
        return String.fromCharCode.apply(String, codePoints);
      }
      let res = "";
      let i4 = 0;
      while (i4 < len) {
        res += String.fromCharCode.apply(
          String,
          codePoints.slice(i4, i4 += MAX_ARGUMENTS_LENGTH)
        );
      }
      return res;
    }
    function asciiSlice(buf, start, end) {
      let ret = "";
      end = Math.min(buf.length, end);
      for (let i4 = start; i4 < end; ++i4) {
        ret += String.fromCharCode(buf[i4] & 127);
      }
      return ret;
    }
    function latin1Slice(buf, start, end) {
      let ret = "";
      end = Math.min(buf.length, end);
      for (let i4 = start; i4 < end; ++i4) {
        ret += String.fromCharCode(buf[i4]);
      }
      return ret;
    }
    function hexSlice(buf, start, end) {
      const len = buf.length;
      if (!start || start < 0) start = 0;
      if (!end || end < 0 || end > len) end = len;
      let out = "";
      for (let i4 = start; i4 < end; ++i4) {
        out += hexSliceLookupTable[buf[i4]];
      }
      return out;
    }
    function utf16leSlice(buf, start, end) {
      const bytes = buf.slice(start, end);
      let res = "";
      for (let i4 = 0; i4 < bytes.length - 1; i4 += 2) {
        res += String.fromCharCode(bytes[i4] + bytes[i4 + 1] * 256);
      }
      return res;
    }
    Buffer4.prototype.slice = function slice(start, end) {
      const len = this.length;
      start = ~~start;
      end = end === void 0 ? len : ~~end;
      if (start < 0) {
        start += len;
        if (start < 0) start = 0;
      } else if (start > len) {
        start = len;
      }
      if (end < 0) {
        end += len;
        if (end < 0) end = 0;
      } else if (end > len) {
        end = len;
      }
      if (end < start) end = start;
      const newBuf = this.subarray(start, end);
      Object.setPrototypeOf(newBuf, Buffer4.prototype);
      return newBuf;
    };
    function checkOffset(offset2, ext, length) {
      if (offset2 % 1 !== 0 || offset2 < 0) throw new RangeError("offset is not uint");
      if (offset2 + ext > length) throw new RangeError("Trying to access beyond buffer length");
    }
    Buffer4.prototype.readUintLE = Buffer4.prototype.readUIntLE = function readUIntLE(offset2, byteLength3, noAssert) {
      offset2 = offset2 >>> 0;
      byteLength3 = byteLength3 >>> 0;
      if (!noAssert) checkOffset(offset2, byteLength3, this.length);
      let val = this[offset2];
      let mul = 1;
      let i4 = 0;
      while (++i4 < byteLength3 && (mul *= 256)) {
        val += this[offset2 + i4] * mul;
      }
      return val;
    };
    Buffer4.prototype.readUintBE = Buffer4.prototype.readUIntBE = function readUIntBE(offset2, byteLength3, noAssert) {
      offset2 = offset2 >>> 0;
      byteLength3 = byteLength3 >>> 0;
      if (!noAssert) {
        checkOffset(offset2, byteLength3, this.length);
      }
      let val = this[offset2 + --byteLength3];
      let mul = 1;
      while (byteLength3 > 0 && (mul *= 256)) {
        val += this[offset2 + --byteLength3] * mul;
      }
      return val;
    };
    Buffer4.prototype.readUint8 = Buffer4.prototype.readUInt8 = function readUInt8(offset2, noAssert) {
      offset2 = offset2 >>> 0;
      if (!noAssert) checkOffset(offset2, 1, this.length);
      return this[offset2];
    };
    Buffer4.prototype.readUint16LE = Buffer4.prototype.readUInt16LE = function readUInt16LE(offset2, noAssert) {
      offset2 = offset2 >>> 0;
      if (!noAssert) checkOffset(offset2, 2, this.length);
      return this[offset2] | this[offset2 + 1] << 8;
    };
    Buffer4.prototype.readUint16BE = Buffer4.prototype.readUInt16BE = function readUInt16BE(offset2, noAssert) {
      offset2 = offset2 >>> 0;
      if (!noAssert) checkOffset(offset2, 2, this.length);
      return this[offset2] << 8 | this[offset2 + 1];
    };
    Buffer4.prototype.readUint32LE = Buffer4.prototype.readUInt32LE = function readUInt32LE(offset2, noAssert) {
      offset2 = offset2 >>> 0;
      if (!noAssert) checkOffset(offset2, 4, this.length);
      return (this[offset2] | this[offset2 + 1] << 8 | this[offset2 + 2] << 16) + this[offset2 + 3] * 16777216;
    };
    Buffer4.prototype.readUint32BE = Buffer4.prototype.readUInt32BE = function readUInt32BE(offset2, noAssert) {
      offset2 = offset2 >>> 0;
      if (!noAssert) checkOffset(offset2, 4, this.length);
      return this[offset2] * 16777216 + (this[offset2 + 1] << 16 | this[offset2 + 2] << 8 | this[offset2 + 3]);
    };
    Buffer4.prototype.readBigUInt64LE = defineBigIntMethod(function readBigUInt64LE(offset2) {
      offset2 = offset2 >>> 0;
      validateNumber(offset2, "offset");
      const first = this[offset2];
      const last = this[offset2 + 7];
      if (first === void 0 || last === void 0) {
        boundsError(offset2, this.length - 8);
      }
      const lo2 = first + this[++offset2] * 2 ** 8 + this[++offset2] * 2 ** 16 + this[++offset2] * 2 ** 24;
      const hi2 = this[++offset2] + this[++offset2] * 2 ** 8 + this[++offset2] * 2 ** 16 + last * 2 ** 24;
      return BigInt(lo2) + (BigInt(hi2) << BigInt(32));
    });
    Buffer4.prototype.readBigUInt64BE = defineBigIntMethod(function readBigUInt64BE(offset2) {
      offset2 = offset2 >>> 0;
      validateNumber(offset2, "offset");
      const first = this[offset2];
      const last = this[offset2 + 7];
      if (first === void 0 || last === void 0) {
        boundsError(offset2, this.length - 8);
      }
      const hi2 = first * 2 ** 24 + this[++offset2] * 2 ** 16 + this[++offset2] * 2 ** 8 + this[++offset2];
      const lo2 = this[++offset2] * 2 ** 24 + this[++offset2] * 2 ** 16 + this[++offset2] * 2 ** 8 + last;
      return (BigInt(hi2) << BigInt(32)) + BigInt(lo2);
    });
    Buffer4.prototype.readIntLE = function readIntLE(offset2, byteLength3, noAssert) {
      offset2 = offset2 >>> 0;
      byteLength3 = byteLength3 >>> 0;
      if (!noAssert) checkOffset(offset2, byteLength3, this.length);
      let val = this[offset2];
      let mul = 1;
      let i4 = 0;
      while (++i4 < byteLength3 && (mul *= 256)) {
        val += this[offset2 + i4] * mul;
      }
      mul *= 128;
      if (val >= mul) val -= Math.pow(2, 8 * byteLength3);
      return val;
    };
    Buffer4.prototype.readIntBE = function readIntBE(offset2, byteLength3, noAssert) {
      offset2 = offset2 >>> 0;
      byteLength3 = byteLength3 >>> 0;
      if (!noAssert) checkOffset(offset2, byteLength3, this.length);
      let i4 = byteLength3;
      let mul = 1;
      let val = this[offset2 + --i4];
      while (i4 > 0 && (mul *= 256)) {
        val += this[offset2 + --i4] * mul;
      }
      mul *= 128;
      if (val >= mul) val -= Math.pow(2, 8 * byteLength3);
      return val;
    };
    Buffer4.prototype.readInt8 = function readInt8(offset2, noAssert) {
      offset2 = offset2 >>> 0;
      if (!noAssert) checkOffset(offset2, 1, this.length);
      if (!(this[offset2] & 128)) return this[offset2];
      return (255 - this[offset2] + 1) * -1;
    };
    Buffer4.prototype.readInt16LE = function readInt16LE(offset2, noAssert) {
      offset2 = offset2 >>> 0;
      if (!noAssert) checkOffset(offset2, 2, this.length);
      const val = this[offset2] | this[offset2 + 1] << 8;
      return val & 32768 ? val | 4294901760 : val;
    };
    Buffer4.prototype.readInt16BE = function readInt16BE(offset2, noAssert) {
      offset2 = offset2 >>> 0;
      if (!noAssert) checkOffset(offset2, 2, this.length);
      const val = this[offset2 + 1] | this[offset2] << 8;
      return val & 32768 ? val | 4294901760 : val;
    };
    Buffer4.prototype.readInt32LE = function readInt32LE(offset2, noAssert) {
      offset2 = offset2 >>> 0;
      if (!noAssert) checkOffset(offset2, 4, this.length);
      return this[offset2] | this[offset2 + 1] << 8 | this[offset2 + 2] << 16 | this[offset2 + 3] << 24;
    };
    Buffer4.prototype.readInt32BE = function readInt32BE(offset2, noAssert) {
      offset2 = offset2 >>> 0;
      if (!noAssert) checkOffset(offset2, 4, this.length);
      return this[offset2] << 24 | this[offset2 + 1] << 16 | this[offset2 + 2] << 8 | this[offset2 + 3];
    };
    Buffer4.prototype.readBigInt64LE = defineBigIntMethod(function readBigInt64LE(offset2) {
      offset2 = offset2 >>> 0;
      validateNumber(offset2, "offset");
      const first = this[offset2];
      const last = this[offset2 + 7];
      if (first === void 0 || last === void 0) {
        boundsError(offset2, this.length - 8);
      }
      const val = this[offset2 + 4] + this[offset2 + 5] * 2 ** 8 + this[offset2 + 6] * 2 ** 16 + (last << 24);
      return (BigInt(val) << BigInt(32)) + BigInt(first + this[++offset2] * 2 ** 8 + this[++offset2] * 2 ** 16 + this[++offset2] * 2 ** 24);
    });
    Buffer4.prototype.readBigInt64BE = defineBigIntMethod(function readBigInt64BE(offset2) {
      offset2 = offset2 >>> 0;
      validateNumber(offset2, "offset");
      const first = this[offset2];
      const last = this[offset2 + 7];
      if (first === void 0 || last === void 0) {
        boundsError(offset2, this.length - 8);
      }
      const val = (first << 24) + // Overflow
      this[++offset2] * 2 ** 16 + this[++offset2] * 2 ** 8 + this[++offset2];
      return (BigInt(val) << BigInt(32)) + BigInt(this[++offset2] * 2 ** 24 + this[++offset2] * 2 ** 16 + this[++offset2] * 2 ** 8 + last);
    });
    Buffer4.prototype.readFloatLE = function readFloatLE(offset2, noAssert) {
      offset2 = offset2 >>> 0;
      if (!noAssert) checkOffset(offset2, 4, this.length);
      return ieee754.read(this, offset2, true, 23, 4);
    };
    Buffer4.prototype.readFloatBE = function readFloatBE(offset2, noAssert) {
      offset2 = offset2 >>> 0;
      if (!noAssert) checkOffset(offset2, 4, this.length);
      return ieee754.read(this, offset2, false, 23, 4);
    };
    Buffer4.prototype.readDoubleLE = function readDoubleLE(offset2, noAssert) {
      offset2 = offset2 >>> 0;
      if (!noAssert) checkOffset(offset2, 8, this.length);
      return ieee754.read(this, offset2, true, 52, 8);
    };
    Buffer4.prototype.readDoubleBE = function readDoubleBE(offset2, noAssert) {
      offset2 = offset2 >>> 0;
      if (!noAssert) checkOffset(offset2, 8, this.length);
      return ieee754.read(this, offset2, false, 52, 8);
    };
    function checkInt(buf, value2, offset2, ext, max, min) {
      if (!Buffer4.isBuffer(buf)) throw new TypeError('"buffer" argument must be a Buffer instance');
      if (value2 > max || value2 < min) throw new RangeError('"value" argument is out of bounds');
      if (offset2 + ext > buf.length) throw new RangeError("Index out of range");
    }
    Buffer4.prototype.writeUintLE = Buffer4.prototype.writeUIntLE = function writeUIntLE(value2, offset2, byteLength3, noAssert) {
      value2 = +value2;
      offset2 = offset2 >>> 0;
      byteLength3 = byteLength3 >>> 0;
      if (!noAssert) {
        const maxBytes = Math.pow(2, 8 * byteLength3) - 1;
        checkInt(this, value2, offset2, byteLength3, maxBytes, 0);
      }
      let mul = 1;
      let i4 = 0;
      this[offset2] = value2 & 255;
      while (++i4 < byteLength3 && (mul *= 256)) {
        this[offset2 + i4] = value2 / mul & 255;
      }
      return offset2 + byteLength3;
    };
    Buffer4.prototype.writeUintBE = Buffer4.prototype.writeUIntBE = function writeUIntBE(value2, offset2, byteLength3, noAssert) {
      value2 = +value2;
      offset2 = offset2 >>> 0;
      byteLength3 = byteLength3 >>> 0;
      if (!noAssert) {
        const maxBytes = Math.pow(2, 8 * byteLength3) - 1;
        checkInt(this, value2, offset2, byteLength3, maxBytes, 0);
      }
      let i4 = byteLength3 - 1;
      let mul = 1;
      this[offset2 + i4] = value2 & 255;
      while (--i4 >= 0 && (mul *= 256)) {
        this[offset2 + i4] = value2 / mul & 255;
      }
      return offset2 + byteLength3;
    };
    Buffer4.prototype.writeUint8 = Buffer4.prototype.writeUInt8 = function writeUInt8(value2, offset2, noAssert) {
      value2 = +value2;
      offset2 = offset2 >>> 0;
      if (!noAssert) checkInt(this, value2, offset2, 1, 255, 0);
      this[offset2] = value2 & 255;
      return offset2 + 1;
    };
    Buffer4.prototype.writeUint16LE = Buffer4.prototype.writeUInt16LE = function writeUInt16LE(value2, offset2, noAssert) {
      value2 = +value2;
      offset2 = offset2 >>> 0;
      if (!noAssert) checkInt(this, value2, offset2, 2, 65535, 0);
      this[offset2] = value2 & 255;
      this[offset2 + 1] = value2 >>> 8;
      return offset2 + 2;
    };
    Buffer4.prototype.writeUint16BE = Buffer4.prototype.writeUInt16BE = function writeUInt16BE(value2, offset2, noAssert) {
      value2 = +value2;
      offset2 = offset2 >>> 0;
      if (!noAssert) checkInt(this, value2, offset2, 2, 65535, 0);
      this[offset2] = value2 >>> 8;
      this[offset2 + 1] = value2 & 255;
      return offset2 + 2;
    };
    Buffer4.prototype.writeUint32LE = Buffer4.prototype.writeUInt32LE = function writeUInt32LE(value2, offset2, noAssert) {
      value2 = +value2;
      offset2 = offset2 >>> 0;
      if (!noAssert) checkInt(this, value2, offset2, 4, 4294967295, 0);
      this[offset2 + 3] = value2 >>> 24;
      this[offset2 + 2] = value2 >>> 16;
      this[offset2 + 1] = value2 >>> 8;
      this[offset2] = value2 & 255;
      return offset2 + 4;
    };
    Buffer4.prototype.writeUint32BE = Buffer4.prototype.writeUInt32BE = function writeUInt32BE(value2, offset2, noAssert) {
      value2 = +value2;
      offset2 = offset2 >>> 0;
      if (!noAssert) checkInt(this, value2, offset2, 4, 4294967295, 0);
      this[offset2] = value2 >>> 24;
      this[offset2 + 1] = value2 >>> 16;
      this[offset2 + 2] = value2 >>> 8;
      this[offset2 + 3] = value2 & 255;
      return offset2 + 4;
    };
    function wrtBigUInt64LE(buf, value2, offset2, min, max) {
      checkIntBI(value2, min, max, buf, offset2, 7);
      let lo2 = Number(value2 & BigInt(4294967295));
      buf[offset2++] = lo2;
      lo2 = lo2 >> 8;
      buf[offset2++] = lo2;
      lo2 = lo2 >> 8;
      buf[offset2++] = lo2;
      lo2 = lo2 >> 8;
      buf[offset2++] = lo2;
      let hi2 = Number(value2 >> BigInt(32) & BigInt(4294967295));
      buf[offset2++] = hi2;
      hi2 = hi2 >> 8;
      buf[offset2++] = hi2;
      hi2 = hi2 >> 8;
      buf[offset2++] = hi2;
      hi2 = hi2 >> 8;
      buf[offset2++] = hi2;
      return offset2;
    }
    function wrtBigUInt64BE(buf, value2, offset2, min, max) {
      checkIntBI(value2, min, max, buf, offset2, 7);
      let lo2 = Number(value2 & BigInt(4294967295));
      buf[offset2 + 7] = lo2;
      lo2 = lo2 >> 8;
      buf[offset2 + 6] = lo2;
      lo2 = lo2 >> 8;
      buf[offset2 + 5] = lo2;
      lo2 = lo2 >> 8;
      buf[offset2 + 4] = lo2;
      let hi2 = Number(value2 >> BigInt(32) & BigInt(4294967295));
      buf[offset2 + 3] = hi2;
      hi2 = hi2 >> 8;
      buf[offset2 + 2] = hi2;
      hi2 = hi2 >> 8;
      buf[offset2 + 1] = hi2;
      hi2 = hi2 >> 8;
      buf[offset2] = hi2;
      return offset2 + 8;
    }
    Buffer4.prototype.writeBigUInt64LE = defineBigIntMethod(function writeBigUInt64LE(value2, offset2 = 0) {
      return wrtBigUInt64LE(this, value2, offset2, BigInt(0), BigInt("0xffffffffffffffff"));
    });
    Buffer4.prototype.writeBigUInt64BE = defineBigIntMethod(function writeBigUInt64BE(value2, offset2 = 0) {
      return wrtBigUInt64BE(this, value2, offset2, BigInt(0), BigInt("0xffffffffffffffff"));
    });
    Buffer4.prototype.writeIntLE = function writeIntLE(value2, offset2, byteLength3, noAssert) {
      value2 = +value2;
      offset2 = offset2 >>> 0;
      if (!noAssert) {
        const limit = Math.pow(2, 8 * byteLength3 - 1);
        checkInt(this, value2, offset2, byteLength3, limit - 1, -limit);
      }
      let i4 = 0;
      let mul = 1;
      let sub = 0;
      this[offset2] = value2 & 255;
      while (++i4 < byteLength3 && (mul *= 256)) {
        if (value2 < 0 && sub === 0 && this[offset2 + i4 - 1] !== 0) {
          sub = 1;
        }
        this[offset2 + i4] = (value2 / mul >> 0) - sub & 255;
      }
      return offset2 + byteLength3;
    };
    Buffer4.prototype.writeIntBE = function writeIntBE(value2, offset2, byteLength3, noAssert) {
      value2 = +value2;
      offset2 = offset2 >>> 0;
      if (!noAssert) {
        const limit = Math.pow(2, 8 * byteLength3 - 1);
        checkInt(this, value2, offset2, byteLength3, limit - 1, -limit);
      }
      let i4 = byteLength3 - 1;
      let mul = 1;
      let sub = 0;
      this[offset2 + i4] = value2 & 255;
      while (--i4 >= 0 && (mul *= 256)) {
        if (value2 < 0 && sub === 0 && this[offset2 + i4 + 1] !== 0) {
          sub = 1;
        }
        this[offset2 + i4] = (value2 / mul >> 0) - sub & 255;
      }
      return offset2 + byteLength3;
    };
    Buffer4.prototype.writeInt8 = function writeInt8(value2, offset2, noAssert) {
      value2 = +value2;
      offset2 = offset2 >>> 0;
      if (!noAssert) checkInt(this, value2, offset2, 1, 127, -128);
      if (value2 < 0) value2 = 255 + value2 + 1;
      this[offset2] = value2 & 255;
      return offset2 + 1;
    };
    Buffer4.prototype.writeInt16LE = function writeInt16LE(value2, offset2, noAssert) {
      value2 = +value2;
      offset2 = offset2 >>> 0;
      if (!noAssert) checkInt(this, value2, offset2, 2, 32767, -32768);
      this[offset2] = value2 & 255;
      this[offset2 + 1] = value2 >>> 8;
      return offset2 + 2;
    };
    Buffer4.prototype.writeInt16BE = function writeInt16BE(value2, offset2, noAssert) {
      value2 = +value2;
      offset2 = offset2 >>> 0;
      if (!noAssert) checkInt(this, value2, offset2, 2, 32767, -32768);
      this[offset2] = value2 >>> 8;
      this[offset2 + 1] = value2 & 255;
      return offset2 + 2;
    };
    Buffer4.prototype.writeInt32LE = function writeInt32LE(value2, offset2, noAssert) {
      value2 = +value2;
      offset2 = offset2 >>> 0;
      if (!noAssert) checkInt(this, value2, offset2, 4, 2147483647, -2147483648);
      this[offset2] = value2 & 255;
      this[offset2 + 1] = value2 >>> 8;
      this[offset2 + 2] = value2 >>> 16;
      this[offset2 + 3] = value2 >>> 24;
      return offset2 + 4;
    };
    Buffer4.prototype.writeInt32BE = function writeInt32BE(value2, offset2, noAssert) {
      value2 = +value2;
      offset2 = offset2 >>> 0;
      if (!noAssert) checkInt(this, value2, offset2, 4, 2147483647, -2147483648);
      if (value2 < 0) value2 = 4294967295 + value2 + 1;
      this[offset2] = value2 >>> 24;
      this[offset2 + 1] = value2 >>> 16;
      this[offset2 + 2] = value2 >>> 8;
      this[offset2 + 3] = value2 & 255;
      return offset2 + 4;
    };
    Buffer4.prototype.writeBigInt64LE = defineBigIntMethod(function writeBigInt64LE(value2, offset2 = 0) {
      return wrtBigUInt64LE(this, value2, offset2, -BigInt("0x8000000000000000"), BigInt("0x7fffffffffffffff"));
    });
    Buffer4.prototype.writeBigInt64BE = defineBigIntMethod(function writeBigInt64BE(value2, offset2 = 0) {
      return wrtBigUInt64BE(this, value2, offset2, -BigInt("0x8000000000000000"), BigInt("0x7fffffffffffffff"));
    });
    function checkIEEE754(buf, value2, offset2, ext, max, min) {
      if (offset2 + ext > buf.length) throw new RangeError("Index out of range");
      if (offset2 < 0) throw new RangeError("Index out of range");
    }
    function writeFloat(buf, value2, offset2, littleEndian, noAssert) {
      value2 = +value2;
      offset2 = offset2 >>> 0;
      if (!noAssert) {
        checkIEEE754(buf, value2, offset2, 4, 34028234663852886e22, -34028234663852886e22);
      }
      ieee754.write(buf, value2, offset2, littleEndian, 23, 4);
      return offset2 + 4;
    }
    Buffer4.prototype.writeFloatLE = function writeFloatLE(value2, offset2, noAssert) {
      return writeFloat(this, value2, offset2, true, noAssert);
    };
    Buffer4.prototype.writeFloatBE = function writeFloatBE(value2, offset2, noAssert) {
      return writeFloat(this, value2, offset2, false, noAssert);
    };
    function writeDouble(buf, value2, offset2, littleEndian, noAssert) {
      value2 = +value2;
      offset2 = offset2 >>> 0;
      if (!noAssert) {
        checkIEEE754(buf, value2, offset2, 8, 17976931348623157e292, -17976931348623157e292);
      }
      ieee754.write(buf, value2, offset2, littleEndian, 52, 8);
      return offset2 + 8;
    }
    Buffer4.prototype.writeDoubleLE = function writeDoubleLE(value2, offset2, noAssert) {
      return writeDouble(this, value2, offset2, true, noAssert);
    };
    Buffer4.prototype.writeDoubleBE = function writeDoubleBE(value2, offset2, noAssert) {
      return writeDouble(this, value2, offset2, false, noAssert);
    };
    Buffer4.prototype.copy = function copy(target, targetStart, start, end) {
      if (!Buffer4.isBuffer(target)) throw new TypeError("argument should be a Buffer");
      if (!start) start = 0;
      if (!end && end !== 0) end = this.length;
      if (targetStart >= target.length) targetStart = target.length;
      if (!targetStart) targetStart = 0;
      if (end > 0 && end < start) end = start;
      if (end === start) return 0;
      if (target.length === 0 || this.length === 0) return 0;
      if (targetStart < 0) {
        throw new RangeError("targetStart out of bounds");
      }
      if (start < 0 || start >= this.length) throw new RangeError("Index out of range");
      if (end < 0) throw new RangeError("sourceEnd out of bounds");
      if (end > this.length) end = this.length;
      if (target.length - targetStart < end - start) {
        end = target.length - targetStart + start;
      }
      const len = end - start;
      if (this === target && typeof Uint8Array.prototype.copyWithin === "function") {
        this.copyWithin(targetStart, start, end);
      } else {
        Uint8Array.prototype.set.call(
          target,
          this.subarray(start, end),
          targetStart
        );
      }
      return len;
    };
    Buffer4.prototype.fill = function fill(val, start, end, encoding) {
      if (typeof val === "string") {
        if (typeof start === "string") {
          encoding = start;
          start = 0;
          end = this.length;
        } else if (typeof end === "string") {
          encoding = end;
          end = this.length;
        }
        if (encoding !== void 0 && typeof encoding !== "string") {
          throw new TypeError("encoding must be a string");
        }
        if (typeof encoding === "string" && !Buffer4.isEncoding(encoding)) {
          throw new TypeError("Unknown encoding: " + encoding);
        }
        if (val.length === 1) {
          const code = val.charCodeAt(0);
          if (encoding === "utf8" && code < 128 || encoding === "latin1") {
            val = code;
          }
        }
      } else if (typeof val === "number") {
        val = val & 255;
      } else if (typeof val === "boolean") {
        val = Number(val);
      }
      if (start < 0 || this.length < start || this.length < end) {
        throw new RangeError("Out of range index");
      }
      if (end <= start) {
        return this;
      }
      start = start >>> 0;
      end = end === void 0 ? this.length : end >>> 0;
      if (!val) val = 0;
      let i4;
      if (typeof val === "number") {
        for (i4 = start; i4 < end; ++i4) {
          this[i4] = val;
        }
      } else {
        const bytes = Buffer4.isBuffer(val) ? val : Buffer4.from(val, encoding);
        const len = bytes.length;
        if (len === 0) {
          throw new TypeError('The value "' + val + '" is invalid for argument "value"');
        }
        for (i4 = 0; i4 < end - start; ++i4) {
          this[i4 + start] = bytes[i4 % len];
        }
      }
      return this;
    };
    var errors = {};
    function E4(sym, getMessage, Base) {
      errors[sym] = class NodeError extends Base {
        constructor() {
          super();
          Object.defineProperty(this, "message", {
            value: getMessage.apply(this, arguments),
            writable: true,
            configurable: true
          });
          this.name = `${this.name} [${sym}]`;
          this.stack;
          delete this.name;
        }
        get code() {
          return sym;
        }
        set code(value2) {
          Object.defineProperty(this, "code", {
            configurable: true,
            enumerable: true,
            value: value2,
            writable: true
          });
        }
        toString() {
          return `${this.name} [${sym}]: ${this.message}`;
        }
      };
    }
    E4(
      "ERR_BUFFER_OUT_OF_BOUNDS",
      function(name) {
        if (name) {
          return `${name} is outside of buffer bounds`;
        }
        return "Attempt to access memory outside buffer bounds";
      },
      RangeError
    );
    E4(
      "ERR_INVALID_ARG_TYPE",
      function(name, actual) {
        return `The "${name}" argument must be of type number. Received type ${typeof actual}`;
      },
      TypeError
    );
    E4(
      "ERR_OUT_OF_RANGE",
      function(str, range, input) {
        let msg = `The value of "${str}" is out of range.`;
        let received = input;
        if (Number.isInteger(input) && Math.abs(input) > 2 ** 32) {
          received = addNumericalSeparator(String(input));
        } else if (typeof input === "bigint") {
          received = String(input);
          if (input > BigInt(2) ** BigInt(32) || input < -(BigInt(2) ** BigInt(32))) {
            received = addNumericalSeparator(received);
          }
          received += "n";
        }
        msg += ` It must be ${range}. Received ${received}`;
        return msg;
      },
      RangeError
    );
    function addNumericalSeparator(val) {
      let res = "";
      let i4 = val.length;
      const start = val[0] === "-" ? 1 : 0;
      for (; i4 >= start + 4; i4 -= 3) {
        res = `_${val.slice(i4 - 3, i4)}${res}`;
      }
      return `${val.slice(0, i4)}${res}`;
    }
    function checkBounds(buf, offset2, byteLength3) {
      validateNumber(offset2, "offset");
      if (buf[offset2] === void 0 || buf[offset2 + byteLength3] === void 0) {
        boundsError(offset2, buf.length - (byteLength3 + 1));
      }
    }
    function checkIntBI(value2, min, max, buf, offset2, byteLength3) {
      if (value2 > max || value2 < min) {
        const n6 = typeof min === "bigint" ? "n" : "";
        let range;
        if (byteLength3 > 3) {
          if (min === 0 || min === BigInt(0)) {
            range = `>= 0${n6} and < 2${n6} ** ${(byteLength3 + 1) * 8}${n6}`;
          } else {
            range = `>= -(2${n6} ** ${(byteLength3 + 1) * 8 - 1}${n6}) and < 2 ** ${(byteLength3 + 1) * 8 - 1}${n6}`;
          }
        } else {
          range = `>= ${min}${n6} and <= ${max}${n6}`;
        }
        throw new errors.ERR_OUT_OF_RANGE("value", range, value2);
      }
      checkBounds(buf, offset2, byteLength3);
    }
    function validateNumber(value2, name) {
      if (typeof value2 !== "number") {
        throw new errors.ERR_INVALID_ARG_TYPE(name, "number", value2);
      }
    }
    function boundsError(value2, length, type2) {
      if (Math.floor(value2) !== value2) {
        validateNumber(value2, type2);
        throw new errors.ERR_OUT_OF_RANGE(type2 || "offset", "an integer", value2);
      }
      if (length < 0) {
        throw new errors.ERR_BUFFER_OUT_OF_BOUNDS();
      }
      throw new errors.ERR_OUT_OF_RANGE(
        type2 || "offset",
        `>= ${type2 ? 1 : 0} and <= ${length}`,
        value2
      );
    }
    var INVALID_BASE64_RE = /[^+/0-9A-Za-z-_]/g;
    function base64clean(str) {
      str = str.split("=")[0];
      str = str.trim().replace(INVALID_BASE64_RE, "");
      if (str.length < 2) return "";
      while (str.length % 4 !== 0) {
        str = str + "=";
      }
      return str;
    }
    function utf8ToBytes2(string2, units) {
      units = units || Infinity;
      let codePoint;
      const length = string2.length;
      let leadSurrogate = null;
      const bytes = [];
      for (let i4 = 0; i4 < length; ++i4) {
        codePoint = string2.charCodeAt(i4);
        if (codePoint > 55295 && codePoint < 57344) {
          if (!leadSurrogate) {
            if (codePoint > 56319) {
              if ((units -= 3) > -1) bytes.push(239, 191, 189);
              continue;
            } else if (i4 + 1 === length) {
              if ((units -= 3) > -1) bytes.push(239, 191, 189);
              continue;
            }
            leadSurrogate = codePoint;
            continue;
          }
          if (codePoint < 56320) {
            if ((units -= 3) > -1) bytes.push(239, 191, 189);
            leadSurrogate = codePoint;
            continue;
          }
          codePoint = (leadSurrogate - 55296 << 10 | codePoint - 56320) + 65536;
        } else if (leadSurrogate) {
          if ((units -= 3) > -1) bytes.push(239, 191, 189);
        }
        leadSurrogate = null;
        if (codePoint < 128) {
          if ((units -= 1) < 0) break;
          bytes.push(codePoint);
        } else if (codePoint < 2048) {
          if ((units -= 2) < 0) break;
          bytes.push(
            codePoint >> 6 | 192,
            codePoint & 63 | 128
          );
        } else if (codePoint < 65536) {
          if ((units -= 3) < 0) break;
          bytes.push(
            codePoint >> 12 | 224,
            codePoint >> 6 & 63 | 128,
            codePoint & 63 | 128
          );
        } else if (codePoint < 1114112) {
          if ((units -= 4) < 0) break;
          bytes.push(
            codePoint >> 18 | 240,
            codePoint >> 12 & 63 | 128,
            codePoint >> 6 & 63 | 128,
            codePoint & 63 | 128
          );
        } else {
          throw new Error("Invalid code point");
        }
      }
      return bytes;
    }
    function asciiToBytes(str) {
      const byteArray = [];
      for (let i4 = 0; i4 < str.length; ++i4) {
        byteArray.push(str.charCodeAt(i4) & 255);
      }
      return byteArray;
    }
    function utf16leToBytes(str, units) {
      let c3, hi2, lo2;
      const byteArray = [];
      for (let i4 = 0; i4 < str.length; ++i4) {
        if ((units -= 2) < 0) break;
        c3 = str.charCodeAt(i4);
        hi2 = c3 >> 8;
        lo2 = c3 % 256;
        byteArray.push(lo2);
        byteArray.push(hi2);
      }
      return byteArray;
    }
    function base64ToBytes(str) {
      return base64.toByteArray(base64clean(str));
    }
    function blitBuffer(src, dst, offset2, length) {
      let i4;
      for (i4 = 0; i4 < length; ++i4) {
        if (i4 + offset2 >= dst.length || i4 >= src.length) break;
        dst[i4 + offset2] = src[i4];
      }
      return i4;
    }
    function isInstance(obj, type2) {
      return obj instanceof type2 || obj != null && obj.constructor != null && obj.constructor.name != null && obj.constructor.name === type2.name;
    }
    function numberIsNaN(obj) {
      return obj !== obj;
    }
    var hexSliceLookupTable = function() {
      const alphabet = "0123456789abcdef";
      const table = new Array(256);
      for (let i4 = 0; i4 < 16; ++i4) {
        const i16 = i4 * 16;
        for (let j4 = 0; j4 < 16; ++j4) {
          table[i16 + j4] = alphabet[i4] + alphabet[j4];
        }
      }
      return table;
    }();
    function defineBigIntMethod(fn3) {
      return typeof BigInt === "undefined" ? BufferBigIntNotDefined : fn3;
    }
    function BufferBigIntNotDefined() {
      throw new Error("BigInt not supported");
    }
  }
});

// browser-external:buffer
var require_buffer2 = __commonJS({
  "browser-external:buffer"(exports, module) {
    module.exports = Object.create(new Proxy({}, {
      get(_2, key) {
        if (key !== "__esModule" && key !== "__proto__" && key !== "constructor" && key !== "splice") {
          console.warn(`Module "buffer" has been externalized for browser compatibility. Cannot access "buffer.${key}" in client code. See https://vite.dev/guide/troubleshooting.html#module-externalized-for-browser-compatibility for more details.`);
        }
      }
    }));
  }
});

// node_modules/bn.js/lib/bn.js
var require_bn = __commonJS({
  "node_modules/bn.js/lib/bn.js"(exports, module) {
    (function(module2, exports2) {
      "use strict";
      function assert3(val, msg) {
        if (!val) throw new Error(msg || "Assertion failed");
      }
      function inherits(ctor, superCtor) {
        ctor.super_ = superCtor;
        var TempCtor = function() {
        };
        TempCtor.prototype = superCtor.prototype;
        ctor.prototype = new TempCtor();
        ctor.prototype.constructor = ctor;
      }
      function BN2(number2, base, endian) {
        if (BN2.isBN(number2)) {
          return number2;
        }
        this.negative = 0;
        this.words = null;
        this.length = 0;
        this.red = null;
        if (number2 !== null) {
          if (base === "le" || base === "be") {
            endian = base;
            base = 10;
          }
          this._init(number2 || 0, base || 10, endian || "be");
        }
      }
      if (typeof module2 === "object") {
        module2.exports = BN2;
      } else {
        exports2.BN = BN2;
      }
      BN2.BN = BN2;
      BN2.wordSize = 26;
      var Buffer4;
      try {
        if (typeof window !== "undefined" && typeof window.Buffer !== "undefined") {
          Buffer4 = window.Buffer;
        } else {
          Buffer4 = require_buffer2().Buffer;
        }
      } catch (e9) {
      }
      BN2.isBN = function isBN(num) {
        if (num instanceof BN2) {
          return true;
        }
        return num !== null && typeof num === "object" && num.constructor.wordSize === BN2.wordSize && Array.isArray(num.words);
      };
      BN2.max = function max(left, right) {
        if (left.cmp(right) > 0) return left;
        return right;
      };
      BN2.min = function min(left, right) {
        if (left.cmp(right) < 0) return left;
        return right;
      };
      BN2.prototype._init = function init(number2, base, endian) {
        if (typeof number2 === "number") {
          return this._initNumber(number2, base, endian);
        }
        if (typeof number2 === "object") {
          return this._initArray(number2, base, endian);
        }
        if (base === "hex") {
          base = 16;
        }
        assert3(base === (base | 0) && base >= 2 && base <= 36);
        number2 = number2.toString().replace(/\s+/g, "");
        var start = 0;
        if (number2[0] === "-") {
          start++;
          this.negative = 1;
        }
        if (start < number2.length) {
          if (base === 16) {
            this._parseHex(number2, start, endian);
          } else {
            this._parseBase(number2, base, start);
            if (endian === "le") {
              this._initArray(this.toArray(), base, endian);
            }
          }
        }
      };
      BN2.prototype._initNumber = function _initNumber(number2, base, endian) {
        if (number2 < 0) {
          this.negative = 1;
          number2 = -number2;
        }
        if (number2 < 67108864) {
          this.words = [number2 & 67108863];
          this.length = 1;
        } else if (number2 < 4503599627370496) {
          this.words = [
            number2 & 67108863,
            number2 / 67108864 & 67108863
          ];
          this.length = 2;
        } else {
          assert3(number2 < 9007199254740992);
          this.words = [
            number2 & 67108863,
            number2 / 67108864 & 67108863,
            1
          ];
          this.length = 3;
        }
        if (endian !== "le") return;
        this._initArray(this.toArray(), base, endian);
      };
      BN2.prototype._initArray = function _initArray(number2, base, endian) {
        assert3(typeof number2.length === "number");
        if (number2.length <= 0) {
          this.words = [0];
          this.length = 1;
          return this;
        }
        this.length = Math.ceil(number2.length / 3);
        this.words = new Array(this.length);
        for (var i4 = 0; i4 < this.length; i4++) {
          this.words[i4] = 0;
        }
        var j4, w5;
        var off = 0;
        if (endian === "be") {
          for (i4 = number2.length - 1, j4 = 0; i4 >= 0; i4 -= 3) {
            w5 = number2[i4] | number2[i4 - 1] << 8 | number2[i4 - 2] << 16;
            this.words[j4] |= w5 << off & 67108863;
            this.words[j4 + 1] = w5 >>> 26 - off & 67108863;
            off += 24;
            if (off >= 26) {
              off -= 26;
              j4++;
            }
          }
        } else if (endian === "le") {
          for (i4 = 0, j4 = 0; i4 < number2.length; i4 += 3) {
            w5 = number2[i4] | number2[i4 + 1] << 8 | number2[i4 + 2] << 16;
            this.words[j4] |= w5 << off & 67108863;
            this.words[j4 + 1] = w5 >>> 26 - off & 67108863;
            off += 24;
            if (off >= 26) {
              off -= 26;
              j4++;
            }
          }
        }
        return this._strip();
      };
      function parseHex4Bits(string2, index) {
        var c3 = string2.charCodeAt(index);
        if (c3 >= 48 && c3 <= 57) {
          return c3 - 48;
        } else if (c3 >= 65 && c3 <= 70) {
          return c3 - 55;
        } else if (c3 >= 97 && c3 <= 102) {
          return c3 - 87;
        } else {
          assert3(false, "Invalid character in " + string2);
        }
      }
      function parseHexByte(string2, lowerBound, index) {
        var r2 = parseHex4Bits(string2, index);
        if (index - 1 >= lowerBound) {
          r2 |= parseHex4Bits(string2, index - 1) << 4;
        }
        return r2;
      }
      BN2.prototype._parseHex = function _parseHex(number2, start, endian) {
        this.length = Math.ceil((number2.length - start) / 6);
        this.words = new Array(this.length);
        for (var i4 = 0; i4 < this.length; i4++) {
          this.words[i4] = 0;
        }
        var off = 0;
        var j4 = 0;
        var w5;
        if (endian === "be") {
          for (i4 = number2.length - 1; i4 >= start; i4 -= 2) {
            w5 = parseHexByte(number2, start, i4) << off;
            this.words[j4] |= w5 & 67108863;
            if (off >= 18) {
              off -= 18;
              j4 += 1;
              this.words[j4] |= w5 >>> 26;
            } else {
              off += 8;
            }
          }
        } else {
          var parseLength = number2.length - start;
          for (i4 = parseLength % 2 === 0 ? start + 1 : start; i4 < number2.length; i4 += 2) {
            w5 = parseHexByte(number2, start, i4) << off;
            this.words[j4] |= w5 & 67108863;
            if (off >= 18) {
              off -= 18;
              j4 += 1;
              this.words[j4] |= w5 >>> 26;
            } else {
              off += 8;
            }
          }
        }
        this._strip();
      };
      function parseBase(str, start, end, mul) {
        var r2 = 0;
        var b3 = 0;
        var len = Math.min(str.length, end);
        for (var i4 = start; i4 < len; i4++) {
          var c3 = str.charCodeAt(i4) - 48;
          r2 *= mul;
          if (c3 >= 49) {
            b3 = c3 - 49 + 10;
          } else if (c3 >= 17) {
            b3 = c3 - 17 + 10;
          } else {
            b3 = c3;
          }
          assert3(c3 >= 0 && b3 < mul, "Invalid character");
          r2 += b3;
        }
        return r2;
      }
      BN2.prototype._parseBase = function _parseBase(number2, base, start) {
        this.words = [0];
        this.length = 1;
        for (var limbLen = 0, limbPow = 1; limbPow <= 67108863; limbPow *= base) {
          limbLen++;
        }
        limbLen--;
        limbPow = limbPow / base | 0;
        var total = number2.length - start;
        var mod2 = total % limbLen;
        var end = Math.min(total, total - mod2) + start;
        var word = 0;
        for (var i4 = start; i4 < end; i4 += limbLen) {
          word = parseBase(number2, i4, i4 + limbLen, base);
          this.imuln(limbPow);
          if (this.words[0] + word < 67108864) {
            this.words[0] += word;
          } else {
            this._iaddn(word);
          }
        }
        if (mod2 !== 0) {
          var pow3 = 1;
          word = parseBase(number2, i4, number2.length, base);
          for (i4 = 0; i4 < mod2; i4++) {
            pow3 *= base;
          }
          this.imuln(pow3);
          if (this.words[0] + word < 67108864) {
            this.words[0] += word;
          } else {
            this._iaddn(word);
          }
        }
        this._strip();
      };
      BN2.prototype.copy = function copy(dest) {
        dest.words = new Array(this.length);
        for (var i4 = 0; i4 < this.length; i4++) {
          dest.words[i4] = this.words[i4];
        }
        dest.length = this.length;
        dest.negative = this.negative;
        dest.red = this.red;
      };
      function move(dest, src) {
        dest.words = src.words;
        dest.length = src.length;
        dest.negative = src.negative;
        dest.red = src.red;
      }
      BN2.prototype._move = function _move(dest) {
        move(dest, this);
      };
      BN2.prototype.clone = function clone() {
        var r2 = new BN2(null);
        this.copy(r2);
        return r2;
      };
      BN2.prototype._expand = function _expand(size) {
        while (this.length < size) {
          this.words[this.length++] = 0;
        }
        return this;
      };
      BN2.prototype._strip = function strip() {
        while (this.length > 1 && this.words[this.length - 1] === 0) {
          this.length--;
        }
        return this._normSign();
      };
      BN2.prototype._normSign = function _normSign() {
        if (this.length === 1 && this.words[0] === 0) {
          this.negative = 0;
        }
        return this;
      };
      if (typeof Symbol !== "undefined" && typeof Symbol.for === "function") {
        try {
          BN2.prototype[Symbol.for("nodejs.util.inspect.custom")] = inspect;
        } catch (e9) {
          BN2.prototype.inspect = inspect;
        }
      } else {
        BN2.prototype.inspect = inspect;
      }
      function inspect() {
        return (this.red ? "<BN-R: " : "<BN: ") + this.toString(16) + ">";
      }
      var zeros = [
        "",
        "0",
        "00",
        "000",
        "0000",
        "00000",
        "000000",
        "0000000",
        "00000000",
        "000000000",
        "0000000000",
        "00000000000",
        "000000000000",
        "0000000000000",
        "00000000000000",
        "000000000000000",
        "0000000000000000",
        "00000000000000000",
        "000000000000000000",
        "0000000000000000000",
        "00000000000000000000",
        "000000000000000000000",
        "0000000000000000000000",
        "00000000000000000000000",
        "000000000000000000000000",
        "0000000000000000000000000"
      ];
      var groupSizes = [
        0,
        0,
        25,
        16,
        12,
        11,
        10,
        9,
        8,
        8,
        7,
        7,
        7,
        7,
        6,
        6,
        6,
        6,
        6,
        6,
        6,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5
      ];
      var groupBases = [
        0,
        0,
        33554432,
        43046721,
        16777216,
        48828125,
        60466176,
        40353607,
        16777216,
        43046721,
        1e7,
        19487171,
        35831808,
        62748517,
        7529536,
        11390625,
        16777216,
        24137569,
        34012224,
        47045881,
        64e6,
        4084101,
        5153632,
        6436343,
        7962624,
        9765625,
        11881376,
        14348907,
        17210368,
        20511149,
        243e5,
        28629151,
        33554432,
        39135393,
        45435424,
        52521875,
        60466176
      ];
      BN2.prototype.toString = function toString2(base, padding) {
        base = base || 10;
        padding = padding | 0 || 1;
        var out;
        if (base === 16 || base === "hex") {
          out = "";
          var off = 0;
          var carry = 0;
          for (var i4 = 0; i4 < this.length; i4++) {
            var w5 = this.words[i4];
            var word = ((w5 << off | carry) & 16777215).toString(16);
            carry = w5 >>> 24 - off & 16777215;
            off += 2;
            if (off >= 26) {
              off -= 26;
              i4--;
            }
            if (carry !== 0 || i4 !== this.length - 1) {
              out = zeros[6 - word.length] + word + out;
            } else {
              out = word + out;
            }
          }
          if (carry !== 0) {
            out = carry.toString(16) + out;
          }
          while (out.length % padding !== 0) {
            out = "0" + out;
          }
          if (this.negative !== 0) {
            out = "-" + out;
          }
          return out;
        }
        if (base === (base | 0) && base >= 2 && base <= 36) {
          var groupSize = groupSizes[base];
          var groupBase = groupBases[base];
          out = "";
          var c3 = this.clone();
          c3.negative = 0;
          while (!c3.isZero()) {
            var r2 = c3.modrn(groupBase).toString(base);
            c3 = c3.idivn(groupBase);
            if (!c3.isZero()) {
              out = zeros[groupSize - r2.length] + r2 + out;
            } else {
              out = r2 + out;
            }
          }
          if (this.isZero()) {
            out = "0" + out;
          }
          while (out.length % padding !== 0) {
            out = "0" + out;
          }
          if (this.negative !== 0) {
            out = "-" + out;
          }
          return out;
        }
        assert3(false, "Base should be between 2 and 36");
      };
      BN2.prototype.toNumber = function toNumber() {
        var ret = this.words[0];
        if (this.length === 2) {
          ret += this.words[1] * 67108864;
        } else if (this.length === 3 && this.words[2] === 1) {
          ret += 4503599627370496 + this.words[1] * 67108864;
        } else if (this.length > 2) {
          assert3(false, "Number can only safely store up to 53 bits");
        }
        return this.negative !== 0 ? -ret : ret;
      };
      BN2.prototype.toJSON = function toJSON() {
        return this.toString(16, 2);
      };
      if (Buffer4) {
        BN2.prototype.toBuffer = function toBuffer2(endian, length) {
          return this.toArrayLike(Buffer4, endian, length);
        };
      }
      BN2.prototype.toArray = function toArray2(endian, length) {
        return this.toArrayLike(Array, endian, length);
      };
      var allocate = function allocate2(ArrayType, size) {
        if (ArrayType.allocUnsafe) {
          return ArrayType.allocUnsafe(size);
        }
        return new ArrayType(size);
      };
      BN2.prototype.toArrayLike = function toArrayLike(ArrayType, endian, length) {
        this._strip();
        var byteLength2 = this.byteLength();
        var reqLength = length || Math.max(1, byteLength2);
        assert3(byteLength2 <= reqLength, "byte array longer than desired length");
        assert3(reqLength > 0, "Requested array length <= 0");
        var res = allocate(ArrayType, reqLength);
        var postfix = endian === "le" ? "LE" : "BE";
        this["_toArrayLike" + postfix](res, byteLength2);
        return res;
      };
      BN2.prototype._toArrayLikeLE = function _toArrayLikeLE(res, byteLength2) {
        var position = 0;
        var carry = 0;
        for (var i4 = 0, shift = 0; i4 < this.length; i4++) {
          var word = this.words[i4] << shift | carry;
          res[position++] = word & 255;
          if (position < res.length) {
            res[position++] = word >> 8 & 255;
          }
          if (position < res.length) {
            res[position++] = word >> 16 & 255;
          }
          if (shift === 6) {
            if (position < res.length) {
              res[position++] = word >> 24 & 255;
            }
            carry = 0;
            shift = 0;
          } else {
            carry = word >>> 24;
            shift += 2;
          }
        }
        if (position < res.length) {
          res[position++] = carry;
          while (position < res.length) {
            res[position++] = 0;
          }
        }
      };
      BN2.prototype._toArrayLikeBE = function _toArrayLikeBE(res, byteLength2) {
        var position = res.length - 1;
        var carry = 0;
        for (var i4 = 0, shift = 0; i4 < this.length; i4++) {
          var word = this.words[i4] << shift | carry;
          res[position--] = word & 255;
          if (position >= 0) {
            res[position--] = word >> 8 & 255;
          }
          if (position >= 0) {
            res[position--] = word >> 16 & 255;
          }
          if (shift === 6) {
            if (position >= 0) {
              res[position--] = word >> 24 & 255;
            }
            carry = 0;
            shift = 0;
          } else {
            carry = word >>> 24;
            shift += 2;
          }
        }
        if (position >= 0) {
          res[position--] = carry;
          while (position >= 0) {
            res[position--] = 0;
          }
        }
      };
      if (Math.clz32) {
        BN2.prototype._countBits = function _countBits(w5) {
          return 32 - Math.clz32(w5);
        };
      } else {
        BN2.prototype._countBits = function _countBits(w5) {
          var t3 = w5;
          var r2 = 0;
          if (t3 >= 4096) {
            r2 += 13;
            t3 >>>= 13;
          }
          if (t3 >= 64) {
            r2 += 7;
            t3 >>>= 7;
          }
          if (t3 >= 8) {
            r2 += 4;
            t3 >>>= 4;
          }
          if (t3 >= 2) {
            r2 += 2;
            t3 >>>= 2;
          }
          return r2 + t3;
        };
      }
      BN2.prototype._zeroBits = function _zeroBits(w5) {
        if (w5 === 0) return 26;
        var t3 = w5;
        var r2 = 0;
        if ((t3 & 8191) === 0) {
          r2 += 13;
          t3 >>>= 13;
        }
        if ((t3 & 127) === 0) {
          r2 += 7;
          t3 >>>= 7;
        }
        if ((t3 & 15) === 0) {
          r2 += 4;
          t3 >>>= 4;
        }
        if ((t3 & 3) === 0) {
          r2 += 2;
          t3 >>>= 2;
        }
        if ((t3 & 1) === 0) {
          r2++;
        }
        return r2;
      };
      BN2.prototype.bitLength = function bitLength() {
        var w5 = this.words[this.length - 1];
        var hi2 = this._countBits(w5);
        return (this.length - 1) * 26 + hi2;
      };
      function toBitArray(num) {
        var w5 = new Array(num.bitLength());
        for (var bit = 0; bit < w5.length; bit++) {
          var off = bit / 26 | 0;
          var wbit = bit % 26;
          w5[bit] = num.words[off] >>> wbit & 1;
        }
        return w5;
      }
      BN2.prototype.zeroBits = function zeroBits() {
        if (this.isZero()) return 0;
        var r2 = 0;
        for (var i4 = 0; i4 < this.length; i4++) {
          var b3 = this._zeroBits(this.words[i4]);
          r2 += b3;
          if (b3 !== 26) break;
        }
        return r2;
      };
      BN2.prototype.byteLength = function byteLength2() {
        return Math.ceil(this.bitLength() / 8);
      };
      BN2.prototype.toTwos = function toTwos(width) {
        if (this.negative !== 0) {
          return this.abs().inotn(width).iaddn(1);
        }
        return this.clone();
      };
      BN2.prototype.fromTwos = function fromTwos(width) {
        if (this.testn(width - 1)) {
          return this.notn(width).iaddn(1).ineg();
        }
        return this.clone();
      };
      BN2.prototype.isNeg = function isNeg() {
        return this.negative !== 0;
      };
      BN2.prototype.neg = function neg() {
        return this.clone().ineg();
      };
      BN2.prototype.ineg = function ineg() {
        if (!this.isZero()) {
          this.negative ^= 1;
        }
        return this;
      };
      BN2.prototype.iuor = function iuor(num) {
        while (this.length < num.length) {
          this.words[this.length++] = 0;
        }
        for (var i4 = 0; i4 < num.length; i4++) {
          this.words[i4] = this.words[i4] | num.words[i4];
        }
        return this._strip();
      };
      BN2.prototype.ior = function ior(num) {
        assert3((this.negative | num.negative) === 0);
        return this.iuor(num);
      };
      BN2.prototype.or = function or2(num) {
        if (this.length > num.length) return this.clone().ior(num);
        return num.clone().ior(this);
      };
      BN2.prototype.uor = function uor(num) {
        if (this.length > num.length) return this.clone().iuor(num);
        return num.clone().iuor(this);
      };
      BN2.prototype.iuand = function iuand(num) {
        var b3;
        if (this.length > num.length) {
          b3 = num;
        } else {
          b3 = this;
        }
        for (var i4 = 0; i4 < b3.length; i4++) {
          this.words[i4] = this.words[i4] & num.words[i4];
        }
        this.length = b3.length;
        return this._strip();
      };
      BN2.prototype.iand = function iand(num) {
        assert3((this.negative | num.negative) === 0);
        return this.iuand(num);
      };
      BN2.prototype.and = function and(num) {
        if (this.length > num.length) return this.clone().iand(num);
        return num.clone().iand(this);
      };
      BN2.prototype.uand = function uand(num) {
        if (this.length > num.length) return this.clone().iuand(num);
        return num.clone().iuand(this);
      };
      BN2.prototype.iuxor = function iuxor(num) {
        var a;
        var b3;
        if (this.length > num.length) {
          a = this;
          b3 = num;
        } else {
          a = num;
          b3 = this;
        }
        for (var i4 = 0; i4 < b3.length; i4++) {
          this.words[i4] = a.words[i4] ^ b3.words[i4];
        }
        if (this !== a) {
          for (; i4 < a.length; i4++) {
            this.words[i4] = a.words[i4];
          }
        }
        this.length = a.length;
        return this._strip();
      };
      BN2.prototype.ixor = function ixor(num) {
        assert3((this.negative | num.negative) === 0);
        return this.iuxor(num);
      };
      BN2.prototype.xor = function xor(num) {
        if (this.length > num.length) return this.clone().ixor(num);
        return num.clone().ixor(this);
      };
      BN2.prototype.uxor = function uxor(num) {
        if (this.length > num.length) return this.clone().iuxor(num);
        return num.clone().iuxor(this);
      };
      BN2.prototype.inotn = function inotn(width) {
        assert3(typeof width === "number" && width >= 0);
        var bytesNeeded = Math.ceil(width / 26) | 0;
        var bitsLeft = width % 26;
        this._expand(bytesNeeded);
        if (bitsLeft > 0) {
          bytesNeeded--;
        }
        for (var i4 = 0; i4 < bytesNeeded; i4++) {
          this.words[i4] = ~this.words[i4] & 67108863;
        }
        if (bitsLeft > 0) {
          this.words[i4] = ~this.words[i4] & 67108863 >> 26 - bitsLeft;
        }
        return this._strip();
      };
      BN2.prototype.notn = function notn(width) {
        return this.clone().inotn(width);
      };
      BN2.prototype.setn = function setn(bit, val) {
        assert3(typeof bit === "number" && bit >= 0);
        var off = bit / 26 | 0;
        var wbit = bit % 26;
        this._expand(off + 1);
        if (val) {
          this.words[off] = this.words[off] | 1 << wbit;
        } else {
          this.words[off] = this.words[off] & ~(1 << wbit);
        }
        return this._strip();
      };
      BN2.prototype.iadd = function iadd(num) {
        var r2;
        if (this.negative !== 0 && num.negative === 0) {
          this.negative = 0;
          r2 = this.isub(num);
          this.negative ^= 1;
          return this._normSign();
        } else if (this.negative === 0 && num.negative !== 0) {
          num.negative = 0;
          r2 = this.isub(num);
          num.negative = 1;
          return r2._normSign();
        }
        var a, b3;
        if (this.length > num.length) {
          a = this;
          b3 = num;
        } else {
          a = num;
          b3 = this;
        }
        var carry = 0;
        for (var i4 = 0; i4 < b3.length; i4++) {
          r2 = (a.words[i4] | 0) + (b3.words[i4] | 0) + carry;
          this.words[i4] = r2 & 67108863;
          carry = r2 >>> 26;
        }
        for (; carry !== 0 && i4 < a.length; i4++) {
          r2 = (a.words[i4] | 0) + carry;
          this.words[i4] = r2 & 67108863;
          carry = r2 >>> 26;
        }
        this.length = a.length;
        if (carry !== 0) {
          this.words[this.length] = carry;
          this.length++;
        } else if (a !== this) {
          for (; i4 < a.length; i4++) {
            this.words[i4] = a.words[i4];
          }
        }
        return this;
      };
      BN2.prototype.add = function add(num) {
        var res;
        if (num.negative !== 0 && this.negative === 0) {
          num.negative = 0;
          res = this.sub(num);
          num.negative ^= 1;
          return res;
        } else if (num.negative === 0 && this.negative !== 0) {
          this.negative = 0;
          res = num.sub(this);
          this.negative = 1;
          return res;
        }
        if (this.length > num.length) return this.clone().iadd(num);
        return num.clone().iadd(this);
      };
      BN2.prototype.isub = function isub(num) {
        if (num.negative !== 0) {
          num.negative = 0;
          var r2 = this.iadd(num);
          num.negative = 1;
          return r2._normSign();
        } else if (this.negative !== 0) {
          this.negative = 0;
          this.iadd(num);
          this.negative = 1;
          return this._normSign();
        }
        var cmp = this.cmp(num);
        if (cmp === 0) {
          this.negative = 0;
          this.length = 1;
          this.words[0] = 0;
          return this;
        }
        var a, b3;
        if (cmp > 0) {
          a = this;
          b3 = num;
        } else {
          a = num;
          b3 = this;
        }
        var carry = 0;
        for (var i4 = 0; i4 < b3.length; i4++) {
          r2 = (a.words[i4] | 0) - (b3.words[i4] | 0) + carry;
          carry = r2 >> 26;
          this.words[i4] = r2 & 67108863;
        }
        for (; carry !== 0 && i4 < a.length; i4++) {
          r2 = (a.words[i4] | 0) + carry;
          carry = r2 >> 26;
          this.words[i4] = r2 & 67108863;
        }
        if (carry === 0 && i4 < a.length && a !== this) {
          for (; i4 < a.length; i4++) {
            this.words[i4] = a.words[i4];
          }
        }
        this.length = Math.max(this.length, i4);
        if (a !== this) {
          this.negative = 1;
        }
        return this._strip();
      };
      BN2.prototype.sub = function sub(num) {
        return this.clone().isub(num);
      };
      function smallMulTo(self2, num, out) {
        out.negative = num.negative ^ self2.negative;
        var len = self2.length + num.length | 0;
        out.length = len;
        len = len - 1 | 0;
        var a = self2.words[0] | 0;
        var b3 = num.words[0] | 0;
        var r2 = a * b3;
        var lo2 = r2 & 67108863;
        var carry = r2 / 67108864 | 0;
        out.words[0] = lo2;
        for (var k3 = 1; k3 < len; k3++) {
          var ncarry = carry >>> 26;
          var rword = carry & 67108863;
          var maxJ = Math.min(k3, num.length - 1);
          for (var j4 = Math.max(0, k3 - self2.length + 1); j4 <= maxJ; j4++) {
            var i4 = k3 - j4 | 0;
            a = self2.words[i4] | 0;
            b3 = num.words[j4] | 0;
            r2 = a * b3 + rword;
            ncarry += r2 / 67108864 | 0;
            rword = r2 & 67108863;
          }
          out.words[k3] = rword | 0;
          carry = ncarry | 0;
        }
        if (carry !== 0) {
          out.words[k3] = carry | 0;
        } else {
          out.length--;
        }
        return out._strip();
      }
      var comb10MulTo = function comb10MulTo2(self2, num, out) {
        var a = self2.words;
        var b3 = num.words;
        var o3 = out.words;
        var c3 = 0;
        var lo2;
        var mid;
        var hi2;
        var a0 = a[0] | 0;
        var al0 = a0 & 8191;
        var ah0 = a0 >>> 13;
        var a1 = a[1] | 0;
        var al1 = a1 & 8191;
        var ah1 = a1 >>> 13;
        var a2 = a[2] | 0;
        var al2 = a2 & 8191;
        var ah2 = a2 >>> 13;
        var a3 = a[3] | 0;
        var al3 = a3 & 8191;
        var ah3 = a3 >>> 13;
        var a4 = a[4] | 0;
        var al4 = a4 & 8191;
        var ah4 = a4 >>> 13;
        var a5 = a[5] | 0;
        var al5 = a5 & 8191;
        var ah5 = a5 >>> 13;
        var a6 = a[6] | 0;
        var al6 = a6 & 8191;
        var ah6 = a6 >>> 13;
        var a7 = a[7] | 0;
        var al7 = a7 & 8191;
        var ah7 = a7 >>> 13;
        var a8 = a[8] | 0;
        var al8 = a8 & 8191;
        var ah8 = a8 >>> 13;
        var a9 = a[9] | 0;
        var al9 = a9 & 8191;
        var ah9 = a9 >>> 13;
        var b0 = b3[0] | 0;
        var bl0 = b0 & 8191;
        var bh0 = b0 >>> 13;
        var b1 = b3[1] | 0;
        var bl1 = b1 & 8191;
        var bh1 = b1 >>> 13;
        var b22 = b3[2] | 0;
        var bl22 = b22 & 8191;
        var bh2 = b22 >>> 13;
        var b32 = b3[3] | 0;
        var bl3 = b32 & 8191;
        var bh3 = b32 >>> 13;
        var b4 = b3[4] | 0;
        var bl4 = b4 & 8191;
        var bh4 = b4 >>> 13;
        var b5 = b3[5] | 0;
        var bl5 = b5 & 8191;
        var bh5 = b5 >>> 13;
        var b6 = b3[6] | 0;
        var bl6 = b6 & 8191;
        var bh6 = b6 >>> 13;
        var b7 = b3[7] | 0;
        var bl7 = b7 & 8191;
        var bh7 = b7 >>> 13;
        var b8 = b3[8] | 0;
        var bl8 = b8 & 8191;
        var bh8 = b8 >>> 13;
        var b9 = b3[9] | 0;
        var bl9 = b9 & 8191;
        var bh9 = b9 >>> 13;
        out.negative = self2.negative ^ num.negative;
        out.length = 19;
        lo2 = Math.imul(al0, bl0);
        mid = Math.imul(al0, bh0);
        mid = mid + Math.imul(ah0, bl0) | 0;
        hi2 = Math.imul(ah0, bh0);
        var w0 = (c3 + lo2 | 0) + ((mid & 8191) << 13) | 0;
        c3 = (hi2 + (mid >>> 13) | 0) + (w0 >>> 26) | 0;
        w0 &= 67108863;
        lo2 = Math.imul(al1, bl0);
        mid = Math.imul(al1, bh0);
        mid = mid + Math.imul(ah1, bl0) | 0;
        hi2 = Math.imul(ah1, bh0);
        lo2 = lo2 + Math.imul(al0, bl1) | 0;
        mid = mid + Math.imul(al0, bh1) | 0;
        mid = mid + Math.imul(ah0, bl1) | 0;
        hi2 = hi2 + Math.imul(ah0, bh1) | 0;
        var w1 = (c3 + lo2 | 0) + ((mid & 8191) << 13) | 0;
        c3 = (hi2 + (mid >>> 13) | 0) + (w1 >>> 26) | 0;
        w1 &= 67108863;
        lo2 = Math.imul(al2, bl0);
        mid = Math.imul(al2, bh0);
        mid = mid + Math.imul(ah2, bl0) | 0;
        hi2 = Math.imul(ah2, bh0);
        lo2 = lo2 + Math.imul(al1, bl1) | 0;
        mid = mid + Math.imul(al1, bh1) | 0;
        mid = mid + Math.imul(ah1, bl1) | 0;
        hi2 = hi2 + Math.imul(ah1, bh1) | 0;
        lo2 = lo2 + Math.imul(al0, bl22) | 0;
        mid = mid + Math.imul(al0, bh2) | 0;
        mid = mid + Math.imul(ah0, bl22) | 0;
        hi2 = hi2 + Math.imul(ah0, bh2) | 0;
        var w22 = (c3 + lo2 | 0) + ((mid & 8191) << 13) | 0;
        c3 = (hi2 + (mid >>> 13) | 0) + (w22 >>> 26) | 0;
        w22 &= 67108863;
        lo2 = Math.imul(al3, bl0);
        mid = Math.imul(al3, bh0);
        mid = mid + Math.imul(ah3, bl0) | 0;
        hi2 = Math.imul(ah3, bh0);
        lo2 = lo2 + Math.imul(al2, bl1) | 0;
        mid = mid + Math.imul(al2, bh1) | 0;
        mid = mid + Math.imul(ah2, bl1) | 0;
        hi2 = hi2 + Math.imul(ah2, bh1) | 0;
        lo2 = lo2 + Math.imul(al1, bl22) | 0;
        mid = mid + Math.imul(al1, bh2) | 0;
        mid = mid + Math.imul(ah1, bl22) | 0;
        hi2 = hi2 + Math.imul(ah1, bh2) | 0;
        lo2 = lo2 + Math.imul(al0, bl3) | 0;
        mid = mid + Math.imul(al0, bh3) | 0;
        mid = mid + Math.imul(ah0, bl3) | 0;
        hi2 = hi2 + Math.imul(ah0, bh3) | 0;
        var w32 = (c3 + lo2 | 0) + ((mid & 8191) << 13) | 0;
        c3 = (hi2 + (mid >>> 13) | 0) + (w32 >>> 26) | 0;
        w32 &= 67108863;
        lo2 = Math.imul(al4, bl0);
        mid = Math.imul(al4, bh0);
        mid = mid + Math.imul(ah4, bl0) | 0;
        hi2 = Math.imul(ah4, bh0);
        lo2 = lo2 + Math.imul(al3, bl1) | 0;
        mid = mid + Math.imul(al3, bh1) | 0;
        mid = mid + Math.imul(ah3, bl1) | 0;
        hi2 = hi2 + Math.imul(ah3, bh1) | 0;
        lo2 = lo2 + Math.imul(al2, bl22) | 0;
        mid = mid + Math.imul(al2, bh2) | 0;
        mid = mid + Math.imul(ah2, bl22) | 0;
        hi2 = hi2 + Math.imul(ah2, bh2) | 0;
        lo2 = lo2 + Math.imul(al1, bl3) | 0;
        mid = mid + Math.imul(al1, bh3) | 0;
        mid = mid + Math.imul(ah1, bl3) | 0;
        hi2 = hi2 + Math.imul(ah1, bh3) | 0;
        lo2 = lo2 + Math.imul(al0, bl4) | 0;
        mid = mid + Math.imul(al0, bh4) | 0;
        mid = mid + Math.imul(ah0, bl4) | 0;
        hi2 = hi2 + Math.imul(ah0, bh4) | 0;
        var w42 = (c3 + lo2 | 0) + ((mid & 8191) << 13) | 0;
        c3 = (hi2 + (mid >>> 13) | 0) + (w42 >>> 26) | 0;
        w42 &= 67108863;
        lo2 = Math.imul(al5, bl0);
        mid = Math.imul(al5, bh0);
        mid = mid + Math.imul(ah5, bl0) | 0;
        hi2 = Math.imul(ah5, bh0);
        lo2 = lo2 + Math.imul(al4, bl1) | 0;
        mid = mid + Math.imul(al4, bh1) | 0;
        mid = mid + Math.imul(ah4, bl1) | 0;
        hi2 = hi2 + Math.imul(ah4, bh1) | 0;
        lo2 = lo2 + Math.imul(al3, bl22) | 0;
        mid = mid + Math.imul(al3, bh2) | 0;
        mid = mid + Math.imul(ah3, bl22) | 0;
        hi2 = hi2 + Math.imul(ah3, bh2) | 0;
        lo2 = lo2 + Math.imul(al2, bl3) | 0;
        mid = mid + Math.imul(al2, bh3) | 0;
        mid = mid + Math.imul(ah2, bl3) | 0;
        hi2 = hi2 + Math.imul(ah2, bh3) | 0;
        lo2 = lo2 + Math.imul(al1, bl4) | 0;
        mid = mid + Math.imul(al1, bh4) | 0;
        mid = mid + Math.imul(ah1, bl4) | 0;
        hi2 = hi2 + Math.imul(ah1, bh4) | 0;
        lo2 = lo2 + Math.imul(al0, bl5) | 0;
        mid = mid + Math.imul(al0, bh5) | 0;
        mid = mid + Math.imul(ah0, bl5) | 0;
        hi2 = hi2 + Math.imul(ah0, bh5) | 0;
        var w5 = (c3 + lo2 | 0) + ((mid & 8191) << 13) | 0;
        c3 = (hi2 + (mid >>> 13) | 0) + (w5 >>> 26) | 0;
        w5 &= 67108863;
        lo2 = Math.imul(al6, bl0);
        mid = Math.imul(al6, bh0);
        mid = mid + Math.imul(ah6, bl0) | 0;
        hi2 = Math.imul(ah6, bh0);
        lo2 = lo2 + Math.imul(al5, bl1) | 0;
        mid = mid + Math.imul(al5, bh1) | 0;
        mid = mid + Math.imul(ah5, bl1) | 0;
        hi2 = hi2 + Math.imul(ah5, bh1) | 0;
        lo2 = lo2 + Math.imul(al4, bl22) | 0;
        mid = mid + Math.imul(al4, bh2) | 0;
        mid = mid + Math.imul(ah4, bl22) | 0;
        hi2 = hi2 + Math.imul(ah4, bh2) | 0;
        lo2 = lo2 + Math.imul(al3, bl3) | 0;
        mid = mid + Math.imul(al3, bh3) | 0;
        mid = mid + Math.imul(ah3, bl3) | 0;
        hi2 = hi2 + Math.imul(ah3, bh3) | 0;
        lo2 = lo2 + Math.imul(al2, bl4) | 0;
        mid = mid + Math.imul(al2, bh4) | 0;
        mid = mid + Math.imul(ah2, bl4) | 0;
        hi2 = hi2 + Math.imul(ah2, bh4) | 0;
        lo2 = lo2 + Math.imul(al1, bl5) | 0;
        mid = mid + Math.imul(al1, bh5) | 0;
        mid = mid + Math.imul(ah1, bl5) | 0;
        hi2 = hi2 + Math.imul(ah1, bh5) | 0;
        lo2 = lo2 + Math.imul(al0, bl6) | 0;
        mid = mid + Math.imul(al0, bh6) | 0;
        mid = mid + Math.imul(ah0, bl6) | 0;
        hi2 = hi2 + Math.imul(ah0, bh6) | 0;
        var w6 = (c3 + lo2 | 0) + ((mid & 8191) << 13) | 0;
        c3 = (hi2 + (mid >>> 13) | 0) + (w6 >>> 26) | 0;
        w6 &= 67108863;
        lo2 = Math.imul(al7, bl0);
        mid = Math.imul(al7, bh0);
        mid = mid + Math.imul(ah7, bl0) | 0;
        hi2 = Math.imul(ah7, bh0);
        lo2 = lo2 + Math.imul(al6, bl1) | 0;
        mid = mid + Math.imul(al6, bh1) | 0;
        mid = mid + Math.imul(ah6, bl1) | 0;
        hi2 = hi2 + Math.imul(ah6, bh1) | 0;
        lo2 = lo2 + Math.imul(al5, bl22) | 0;
        mid = mid + Math.imul(al5, bh2) | 0;
        mid = mid + Math.imul(ah5, bl22) | 0;
        hi2 = hi2 + Math.imul(ah5, bh2) | 0;
        lo2 = lo2 + Math.imul(al4, bl3) | 0;
        mid = mid + Math.imul(al4, bh3) | 0;
        mid = mid + Math.imul(ah4, bl3) | 0;
        hi2 = hi2 + Math.imul(ah4, bh3) | 0;
        lo2 = lo2 + Math.imul(al3, bl4) | 0;
        mid = mid + Math.imul(al3, bh4) | 0;
        mid = mid + Math.imul(ah3, bl4) | 0;
        hi2 = hi2 + Math.imul(ah3, bh4) | 0;
        lo2 = lo2 + Math.imul(al2, bl5) | 0;
        mid = mid + Math.imul(al2, bh5) | 0;
        mid = mid + Math.imul(ah2, bl5) | 0;
        hi2 = hi2 + Math.imul(ah2, bh5) | 0;
        lo2 = lo2 + Math.imul(al1, bl6) | 0;
        mid = mid + Math.imul(al1, bh6) | 0;
        mid = mid + Math.imul(ah1, bl6) | 0;
        hi2 = hi2 + Math.imul(ah1, bh6) | 0;
        lo2 = lo2 + Math.imul(al0, bl7) | 0;
        mid = mid + Math.imul(al0, bh7) | 0;
        mid = mid + Math.imul(ah0, bl7) | 0;
        hi2 = hi2 + Math.imul(ah0, bh7) | 0;
        var w7 = (c3 + lo2 | 0) + ((mid & 8191) << 13) | 0;
        c3 = (hi2 + (mid >>> 13) | 0) + (w7 >>> 26) | 0;
        w7 &= 67108863;
        lo2 = Math.imul(al8, bl0);
        mid = Math.imul(al8, bh0);
        mid = mid + Math.imul(ah8, bl0) | 0;
        hi2 = Math.imul(ah8, bh0);
        lo2 = lo2 + Math.imul(al7, bl1) | 0;
        mid = mid + Math.imul(al7, bh1) | 0;
        mid = mid + Math.imul(ah7, bl1) | 0;
        hi2 = hi2 + Math.imul(ah7, bh1) | 0;
        lo2 = lo2 + Math.imul(al6, bl22) | 0;
        mid = mid + Math.imul(al6, bh2) | 0;
        mid = mid + Math.imul(ah6, bl22) | 0;
        hi2 = hi2 + Math.imul(ah6, bh2) | 0;
        lo2 = lo2 + Math.imul(al5, bl3) | 0;
        mid = mid + Math.imul(al5, bh3) | 0;
        mid = mid + Math.imul(ah5, bl3) | 0;
        hi2 = hi2 + Math.imul(ah5, bh3) | 0;
        lo2 = lo2 + Math.imul(al4, bl4) | 0;
        mid = mid + Math.imul(al4, bh4) | 0;
        mid = mid + Math.imul(ah4, bl4) | 0;
        hi2 = hi2 + Math.imul(ah4, bh4) | 0;
        lo2 = lo2 + Math.imul(al3, bl5) | 0;
        mid = mid + Math.imul(al3, bh5) | 0;
        mid = mid + Math.imul(ah3, bl5) | 0;
        hi2 = hi2 + Math.imul(ah3, bh5) | 0;
        lo2 = lo2 + Math.imul(al2, bl6) | 0;
        mid = mid + Math.imul(al2, bh6) | 0;
        mid = mid + Math.imul(ah2, bl6) | 0;
        hi2 = hi2 + Math.imul(ah2, bh6) | 0;
        lo2 = lo2 + Math.imul(al1, bl7) | 0;
        mid = mid + Math.imul(al1, bh7) | 0;
        mid = mid + Math.imul(ah1, bl7) | 0;
        hi2 = hi2 + Math.imul(ah1, bh7) | 0;
        lo2 = lo2 + Math.imul(al0, bl8) | 0;
        mid = mid + Math.imul(al0, bh8) | 0;
        mid = mid + Math.imul(ah0, bl8) | 0;
        hi2 = hi2 + Math.imul(ah0, bh8) | 0;
        var w8 = (c3 + lo2 | 0) + ((mid & 8191) << 13) | 0;
        c3 = (hi2 + (mid >>> 13) | 0) + (w8 >>> 26) | 0;
        w8 &= 67108863;
        lo2 = Math.imul(al9, bl0);
        mid = Math.imul(al9, bh0);
        mid = mid + Math.imul(ah9, bl0) | 0;
        hi2 = Math.imul(ah9, bh0);
        lo2 = lo2 + Math.imul(al8, bl1) | 0;
        mid = mid + Math.imul(al8, bh1) | 0;
        mid = mid + Math.imul(ah8, bl1) | 0;
        hi2 = hi2 + Math.imul(ah8, bh1) | 0;
        lo2 = lo2 + Math.imul(al7, bl22) | 0;
        mid = mid + Math.imul(al7, bh2) | 0;
        mid = mid + Math.imul(ah7, bl22) | 0;
        hi2 = hi2 + Math.imul(ah7, bh2) | 0;
        lo2 = lo2 + Math.imul(al6, bl3) | 0;
        mid = mid + Math.imul(al6, bh3) | 0;
        mid = mid + Math.imul(ah6, bl3) | 0;
        hi2 = hi2 + Math.imul(ah6, bh3) | 0;
        lo2 = lo2 + Math.imul(al5, bl4) | 0;
        mid = mid + Math.imul(al5, bh4) | 0;
        mid = mid + Math.imul(ah5, bl4) | 0;
        hi2 = hi2 + Math.imul(ah5, bh4) | 0;
        lo2 = lo2 + Math.imul(al4, bl5) | 0;
        mid = mid + Math.imul(al4, bh5) | 0;
        mid = mid + Math.imul(ah4, bl5) | 0;
        hi2 = hi2 + Math.imul(ah4, bh5) | 0;
        lo2 = lo2 + Math.imul(al3, bl6) | 0;
        mid = mid + Math.imul(al3, bh6) | 0;
        mid = mid + Math.imul(ah3, bl6) | 0;
        hi2 = hi2 + Math.imul(ah3, bh6) | 0;
        lo2 = lo2 + Math.imul(al2, bl7) | 0;
        mid = mid + Math.imul(al2, bh7) | 0;
        mid = mid + Math.imul(ah2, bl7) | 0;
        hi2 = hi2 + Math.imul(ah2, bh7) | 0;
        lo2 = lo2 + Math.imul(al1, bl8) | 0;
        mid = mid + Math.imul(al1, bh8) | 0;
        mid = mid + Math.imul(ah1, bl8) | 0;
        hi2 = hi2 + Math.imul(ah1, bh8) | 0;
        lo2 = lo2 + Math.imul(al0, bl9) | 0;
        mid = mid + Math.imul(al0, bh9) | 0;
        mid = mid + Math.imul(ah0, bl9) | 0;
        hi2 = hi2 + Math.imul(ah0, bh9) | 0;
        var w9 = (c3 + lo2 | 0) + ((mid & 8191) << 13) | 0;
        c3 = (hi2 + (mid >>> 13) | 0) + (w9 >>> 26) | 0;
        w9 &= 67108863;
        lo2 = Math.imul(al9, bl1);
        mid = Math.imul(al9, bh1);
        mid = mid + Math.imul(ah9, bl1) | 0;
        hi2 = Math.imul(ah9, bh1);
        lo2 = lo2 + Math.imul(al8, bl22) | 0;
        mid = mid + Math.imul(al8, bh2) | 0;
        mid = mid + Math.imul(ah8, bl22) | 0;
        hi2 = hi2 + Math.imul(ah8, bh2) | 0;
        lo2 = lo2 + Math.imul(al7, bl3) | 0;
        mid = mid + Math.imul(al7, bh3) | 0;
        mid = mid + Math.imul(ah7, bl3) | 0;
        hi2 = hi2 + Math.imul(ah7, bh3) | 0;
        lo2 = lo2 + Math.imul(al6, bl4) | 0;
        mid = mid + Math.imul(al6, bh4) | 0;
        mid = mid + Math.imul(ah6, bl4) | 0;
        hi2 = hi2 + Math.imul(ah6, bh4) | 0;
        lo2 = lo2 + Math.imul(al5, bl5) | 0;
        mid = mid + Math.imul(al5, bh5) | 0;
        mid = mid + Math.imul(ah5, bl5) | 0;
        hi2 = hi2 + Math.imul(ah5, bh5) | 0;
        lo2 = lo2 + Math.imul(al4, bl6) | 0;
        mid = mid + Math.imul(al4, bh6) | 0;
        mid = mid + Math.imul(ah4, bl6) | 0;
        hi2 = hi2 + Math.imul(ah4, bh6) | 0;
        lo2 = lo2 + Math.imul(al3, bl7) | 0;
        mid = mid + Math.imul(al3, bh7) | 0;
        mid = mid + Math.imul(ah3, bl7) | 0;
        hi2 = hi2 + Math.imul(ah3, bh7) | 0;
        lo2 = lo2 + Math.imul(al2, bl8) | 0;
        mid = mid + Math.imul(al2, bh8) | 0;
        mid = mid + Math.imul(ah2, bl8) | 0;
        hi2 = hi2 + Math.imul(ah2, bh8) | 0;
        lo2 = lo2 + Math.imul(al1, bl9) | 0;
        mid = mid + Math.imul(al1, bh9) | 0;
        mid = mid + Math.imul(ah1, bl9) | 0;
        hi2 = hi2 + Math.imul(ah1, bh9) | 0;
        var w10 = (c3 + lo2 | 0) + ((mid & 8191) << 13) | 0;
        c3 = (hi2 + (mid >>> 13) | 0) + (w10 >>> 26) | 0;
        w10 &= 67108863;
        lo2 = Math.imul(al9, bl22);
        mid = Math.imul(al9, bh2);
        mid = mid + Math.imul(ah9, bl22) | 0;
        hi2 = Math.imul(ah9, bh2);
        lo2 = lo2 + Math.imul(al8, bl3) | 0;
        mid = mid + Math.imul(al8, bh3) | 0;
        mid = mid + Math.imul(ah8, bl3) | 0;
        hi2 = hi2 + Math.imul(ah8, bh3) | 0;
        lo2 = lo2 + Math.imul(al7, bl4) | 0;
        mid = mid + Math.imul(al7, bh4) | 0;
        mid = mid + Math.imul(ah7, bl4) | 0;
        hi2 = hi2 + Math.imul(ah7, bh4) | 0;
        lo2 = lo2 + Math.imul(al6, bl5) | 0;
        mid = mid + Math.imul(al6, bh5) | 0;
        mid = mid + Math.imul(ah6, bl5) | 0;
        hi2 = hi2 + Math.imul(ah6, bh5) | 0;
        lo2 = lo2 + Math.imul(al5, bl6) | 0;
        mid = mid + Math.imul(al5, bh6) | 0;
        mid = mid + Math.imul(ah5, bl6) | 0;
        hi2 = hi2 + Math.imul(ah5, bh6) | 0;
        lo2 = lo2 + Math.imul(al4, bl7) | 0;
        mid = mid + Math.imul(al4, bh7) | 0;
        mid = mid + Math.imul(ah4, bl7) | 0;
        hi2 = hi2 + Math.imul(ah4, bh7) | 0;
        lo2 = lo2 + Math.imul(al3, bl8) | 0;
        mid = mid + Math.imul(al3, bh8) | 0;
        mid = mid + Math.imul(ah3, bl8) | 0;
        hi2 = hi2 + Math.imul(ah3, bh8) | 0;
        lo2 = lo2 + Math.imul(al2, bl9) | 0;
        mid = mid + Math.imul(al2, bh9) | 0;
        mid = mid + Math.imul(ah2, bl9) | 0;
        hi2 = hi2 + Math.imul(ah2, bh9) | 0;
        var w11 = (c3 + lo2 | 0) + ((mid & 8191) << 13) | 0;
        c3 = (hi2 + (mid >>> 13) | 0) + (w11 >>> 26) | 0;
        w11 &= 67108863;
        lo2 = Math.imul(al9, bl3);
        mid = Math.imul(al9, bh3);
        mid = mid + Math.imul(ah9, bl3) | 0;
        hi2 = Math.imul(ah9, bh3);
        lo2 = lo2 + Math.imul(al8, bl4) | 0;
        mid = mid + Math.imul(al8, bh4) | 0;
        mid = mid + Math.imul(ah8, bl4) | 0;
        hi2 = hi2 + Math.imul(ah8, bh4) | 0;
        lo2 = lo2 + Math.imul(al7, bl5) | 0;
        mid = mid + Math.imul(al7, bh5) | 0;
        mid = mid + Math.imul(ah7, bl5) | 0;
        hi2 = hi2 + Math.imul(ah7, bh5) | 0;
        lo2 = lo2 + Math.imul(al6, bl6) | 0;
        mid = mid + Math.imul(al6, bh6) | 0;
        mid = mid + Math.imul(ah6, bl6) | 0;
        hi2 = hi2 + Math.imul(ah6, bh6) | 0;
        lo2 = lo2 + Math.imul(al5, bl7) | 0;
        mid = mid + Math.imul(al5, bh7) | 0;
        mid = mid + Math.imul(ah5, bl7) | 0;
        hi2 = hi2 + Math.imul(ah5, bh7) | 0;
        lo2 = lo2 + Math.imul(al4, bl8) | 0;
        mid = mid + Math.imul(al4, bh8) | 0;
        mid = mid + Math.imul(ah4, bl8) | 0;
        hi2 = hi2 + Math.imul(ah4, bh8) | 0;
        lo2 = lo2 + Math.imul(al3, bl9) | 0;
        mid = mid + Math.imul(al3, bh9) | 0;
        mid = mid + Math.imul(ah3, bl9) | 0;
        hi2 = hi2 + Math.imul(ah3, bh9) | 0;
        var w12 = (c3 + lo2 | 0) + ((mid & 8191) << 13) | 0;
        c3 = (hi2 + (mid >>> 13) | 0) + (w12 >>> 26) | 0;
        w12 &= 67108863;
        lo2 = Math.imul(al9, bl4);
        mid = Math.imul(al9, bh4);
        mid = mid + Math.imul(ah9, bl4) | 0;
        hi2 = Math.imul(ah9, bh4);
        lo2 = lo2 + Math.imul(al8, bl5) | 0;
        mid = mid + Math.imul(al8, bh5) | 0;
        mid = mid + Math.imul(ah8, bl5) | 0;
        hi2 = hi2 + Math.imul(ah8, bh5) | 0;
        lo2 = lo2 + Math.imul(al7, bl6) | 0;
        mid = mid + Math.imul(al7, bh6) | 0;
        mid = mid + Math.imul(ah7, bl6) | 0;
        hi2 = hi2 + Math.imul(ah7, bh6) | 0;
        lo2 = lo2 + Math.imul(al6, bl7) | 0;
        mid = mid + Math.imul(al6, bh7) | 0;
        mid = mid + Math.imul(ah6, bl7) | 0;
        hi2 = hi2 + Math.imul(ah6, bh7) | 0;
        lo2 = lo2 + Math.imul(al5, bl8) | 0;
        mid = mid + Math.imul(al5, bh8) | 0;
        mid = mid + Math.imul(ah5, bl8) | 0;
        hi2 = hi2 + Math.imul(ah5, bh8) | 0;
        lo2 = lo2 + Math.imul(al4, bl9) | 0;
        mid = mid + Math.imul(al4, bh9) | 0;
        mid = mid + Math.imul(ah4, bl9) | 0;
        hi2 = hi2 + Math.imul(ah4, bh9) | 0;
        var w13 = (c3 + lo2 | 0) + ((mid & 8191) << 13) | 0;
        c3 = (hi2 + (mid >>> 13) | 0) + (w13 >>> 26) | 0;
        w13 &= 67108863;
        lo2 = Math.imul(al9, bl5);
        mid = Math.imul(al9, bh5);
        mid = mid + Math.imul(ah9, bl5) | 0;
        hi2 = Math.imul(ah9, bh5);
        lo2 = lo2 + Math.imul(al8, bl6) | 0;
        mid = mid + Math.imul(al8, bh6) | 0;
        mid = mid + Math.imul(ah8, bl6) | 0;
        hi2 = hi2 + Math.imul(ah8, bh6) | 0;
        lo2 = lo2 + Math.imul(al7, bl7) | 0;
        mid = mid + Math.imul(al7, bh7) | 0;
        mid = mid + Math.imul(ah7, bl7) | 0;
        hi2 = hi2 + Math.imul(ah7, bh7) | 0;
        lo2 = lo2 + Math.imul(al6, bl8) | 0;
        mid = mid + Math.imul(al6, bh8) | 0;
        mid = mid + Math.imul(ah6, bl8) | 0;
        hi2 = hi2 + Math.imul(ah6, bh8) | 0;
        lo2 = lo2 + Math.imul(al5, bl9) | 0;
        mid = mid + Math.imul(al5, bh9) | 0;
        mid = mid + Math.imul(ah5, bl9) | 0;
        hi2 = hi2 + Math.imul(ah5, bh9) | 0;
        var w14 = (c3 + lo2 | 0) + ((mid & 8191) << 13) | 0;
        c3 = (hi2 + (mid >>> 13) | 0) + (w14 >>> 26) | 0;
        w14 &= 67108863;
        lo2 = Math.imul(al9, bl6);
        mid = Math.imul(al9, bh6);
        mid = mid + Math.imul(ah9, bl6) | 0;
        hi2 = Math.imul(ah9, bh6);
        lo2 = lo2 + Math.imul(al8, bl7) | 0;
        mid = mid + Math.imul(al8, bh7) | 0;
        mid = mid + Math.imul(ah8, bl7) | 0;
        hi2 = hi2 + Math.imul(ah8, bh7) | 0;
        lo2 = lo2 + Math.imul(al7, bl8) | 0;
        mid = mid + Math.imul(al7, bh8) | 0;
        mid = mid + Math.imul(ah7, bl8) | 0;
        hi2 = hi2 + Math.imul(ah7, bh8) | 0;
        lo2 = lo2 + Math.imul(al6, bl9) | 0;
        mid = mid + Math.imul(al6, bh9) | 0;
        mid = mid + Math.imul(ah6, bl9) | 0;
        hi2 = hi2 + Math.imul(ah6, bh9) | 0;
        var w15 = (c3 + lo2 | 0) + ((mid & 8191) << 13) | 0;
        c3 = (hi2 + (mid >>> 13) | 0) + (w15 >>> 26) | 0;
        w15 &= 67108863;
        lo2 = Math.imul(al9, bl7);
        mid = Math.imul(al9, bh7);
        mid = mid + Math.imul(ah9, bl7) | 0;
        hi2 = Math.imul(ah9, bh7);
        lo2 = lo2 + Math.imul(al8, bl8) | 0;
        mid = mid + Math.imul(al8, bh8) | 0;
        mid = mid + Math.imul(ah8, bl8) | 0;
        hi2 = hi2 + Math.imul(ah8, bh8) | 0;
        lo2 = lo2 + Math.imul(al7, bl9) | 0;
        mid = mid + Math.imul(al7, bh9) | 0;
        mid = mid + Math.imul(ah7, bl9) | 0;
        hi2 = hi2 + Math.imul(ah7, bh9) | 0;
        var w16 = (c3 + lo2 | 0) + ((mid & 8191) << 13) | 0;
        c3 = (hi2 + (mid >>> 13) | 0) + (w16 >>> 26) | 0;
        w16 &= 67108863;
        lo2 = Math.imul(al9, bl8);
        mid = Math.imul(al9, bh8);
        mid = mid + Math.imul(ah9, bl8) | 0;
        hi2 = Math.imul(ah9, bh8);
        lo2 = lo2 + Math.imul(al8, bl9) | 0;
        mid = mid + Math.imul(al8, bh9) | 0;
        mid = mid + Math.imul(ah8, bl9) | 0;
        hi2 = hi2 + Math.imul(ah8, bh9) | 0;
        var w17 = (c3 + lo2 | 0) + ((mid & 8191) << 13) | 0;
        c3 = (hi2 + (mid >>> 13) | 0) + (w17 >>> 26) | 0;
        w17 &= 67108863;
        lo2 = Math.imul(al9, bl9);
        mid = Math.imul(al9, bh9);
        mid = mid + Math.imul(ah9, bl9) | 0;
        hi2 = Math.imul(ah9, bh9);
        var w18 = (c3 + lo2 | 0) + ((mid & 8191) << 13) | 0;
        c3 = (hi2 + (mid >>> 13) | 0) + (w18 >>> 26) | 0;
        w18 &= 67108863;
        o3[0] = w0;
        o3[1] = w1;
        o3[2] = w22;
        o3[3] = w32;
        o3[4] = w42;
        o3[5] = w5;
        o3[6] = w6;
        o3[7] = w7;
        o3[8] = w8;
        o3[9] = w9;
        o3[10] = w10;
        o3[11] = w11;
        o3[12] = w12;
        o3[13] = w13;
        o3[14] = w14;
        o3[15] = w15;
        o3[16] = w16;
        o3[17] = w17;
        o3[18] = w18;
        if (c3 !== 0) {
          o3[19] = c3;
          out.length++;
        }
        return out;
      };
      if (!Math.imul) {
        comb10MulTo = smallMulTo;
      }
      function bigMulTo(self2, num, out) {
        out.negative = num.negative ^ self2.negative;
        out.length = self2.length + num.length;
        var carry = 0;
        var hncarry = 0;
        for (var k3 = 0; k3 < out.length - 1; k3++) {
          var ncarry = hncarry;
          hncarry = 0;
          var rword = carry & 67108863;
          var maxJ = Math.min(k3, num.length - 1);
          for (var j4 = Math.max(0, k3 - self2.length + 1); j4 <= maxJ; j4++) {
            var i4 = k3 - j4;
            var a = self2.words[i4] | 0;
            var b3 = num.words[j4] | 0;
            var r2 = a * b3;
            var lo2 = r2 & 67108863;
            ncarry = ncarry + (r2 / 67108864 | 0) | 0;
            lo2 = lo2 + rword | 0;
            rword = lo2 & 67108863;
            ncarry = ncarry + (lo2 >>> 26) | 0;
            hncarry += ncarry >>> 26;
            ncarry &= 67108863;
          }
          out.words[k3] = rword;
          carry = ncarry;
          ncarry = hncarry;
        }
        if (carry !== 0) {
          out.words[k3] = carry;
        } else {
          out.length--;
        }
        return out._strip();
      }
      function jumboMulTo(self2, num, out) {
        return bigMulTo(self2, num, out);
      }
      BN2.prototype.mulTo = function mulTo(num, out) {
        var res;
        var len = this.length + num.length;
        if (this.length === 10 && num.length === 10) {
          res = comb10MulTo(this, num, out);
        } else if (len < 63) {
          res = smallMulTo(this, num, out);
        } else if (len < 1024) {
          res = bigMulTo(this, num, out);
        } else {
          res = jumboMulTo(this, num, out);
        }
        return res;
      };
      function FFTM(x3, y2) {
        this.x = x3;
        this.y = y2;
      }
      FFTM.prototype.makeRBT = function makeRBT(N3) {
        var t3 = new Array(N3);
        var l5 = BN2.prototype._countBits(N3) - 1;
        for (var i4 = 0; i4 < N3; i4++) {
          t3[i4] = this.revBin(i4, l5, N3);
        }
        return t3;
      };
      FFTM.prototype.revBin = function revBin(x3, l5, N3) {
        if (x3 === 0 || x3 === N3 - 1) return x3;
        var rb = 0;
        for (var i4 = 0; i4 < l5; i4++) {
          rb |= (x3 & 1) << l5 - i4 - 1;
          x3 >>= 1;
        }
        return rb;
      };
      FFTM.prototype.permute = function permute(rbt, rws, iws, rtws, itws, N3) {
        for (var i4 = 0; i4 < N3; i4++) {
          rtws[i4] = rws[rbt[i4]];
          itws[i4] = iws[rbt[i4]];
        }
      };
      FFTM.prototype.transform = function transform(rws, iws, rtws, itws, N3, rbt) {
        this.permute(rbt, rws, iws, rtws, itws, N3);
        for (var s2 = 1; s2 < N3; s2 <<= 1) {
          var l5 = s2 << 1;
          var rtwdf = Math.cos(2 * Math.PI / l5);
          var itwdf = Math.sin(2 * Math.PI / l5);
          for (var p4 = 0; p4 < N3; p4 += l5) {
            var rtwdf_ = rtwdf;
            var itwdf_ = itwdf;
            for (var j4 = 0; j4 < s2; j4++) {
              var re4 = rtws[p4 + j4];
              var ie3 = itws[p4 + j4];
              var ro2 = rtws[p4 + j4 + s2];
              var io2 = itws[p4 + j4 + s2];
              var rx = rtwdf_ * ro2 - itwdf_ * io2;
              io2 = rtwdf_ * io2 + itwdf_ * ro2;
              ro2 = rx;
              rtws[p4 + j4] = re4 + ro2;
              itws[p4 + j4] = ie3 + io2;
              rtws[p4 + j4 + s2] = re4 - ro2;
              itws[p4 + j4 + s2] = ie3 - io2;
              if (j4 !== l5) {
                rx = rtwdf * rtwdf_ - itwdf * itwdf_;
                itwdf_ = rtwdf * itwdf_ + itwdf * rtwdf_;
                rtwdf_ = rx;
              }
            }
          }
        }
      };
      FFTM.prototype.guessLen13b = function guessLen13b(n6, m4) {
        var N3 = Math.max(m4, n6) | 1;
        var odd = N3 & 1;
        var i4 = 0;
        for (N3 = N3 / 2 | 0; N3; N3 = N3 >>> 1) {
          i4++;
        }
        return 1 << i4 + 1 + odd;
      };
      FFTM.prototype.conjugate = function conjugate(rws, iws, N3) {
        if (N3 <= 1) return;
        for (var i4 = 0; i4 < N3 / 2; i4++) {
          var t3 = rws[i4];
          rws[i4] = rws[N3 - i4 - 1];
          rws[N3 - i4 - 1] = t3;
          t3 = iws[i4];
          iws[i4] = -iws[N3 - i4 - 1];
          iws[N3 - i4 - 1] = -t3;
        }
      };
      FFTM.prototype.normalize13b = function normalize13b(ws2, N3) {
        var carry = 0;
        for (var i4 = 0; i4 < N3 / 2; i4++) {
          var w5 = Math.round(ws2[2 * i4 + 1] / N3) * 8192 + Math.round(ws2[2 * i4] / N3) + carry;
          ws2[i4] = w5 & 67108863;
          if (w5 < 67108864) {
            carry = 0;
          } else {
            carry = w5 / 67108864 | 0;
          }
        }
        return ws2;
      };
      FFTM.prototype.convert13b = function convert13b(ws2, len, rws, N3) {
        var carry = 0;
        for (var i4 = 0; i4 < len; i4++) {
          carry = carry + (ws2[i4] | 0);
          rws[2 * i4] = carry & 8191;
          carry = carry >>> 13;
          rws[2 * i4 + 1] = carry & 8191;
          carry = carry >>> 13;
        }
        for (i4 = 2 * len; i4 < N3; ++i4) {
          rws[i4] = 0;
        }
        assert3(carry === 0);
        assert3((carry & ~8191) === 0);
      };
      FFTM.prototype.stub = function stub(N3) {
        var ph2 = new Array(N3);
        for (var i4 = 0; i4 < N3; i4++) {
          ph2[i4] = 0;
        }
        return ph2;
      };
      FFTM.prototype.mulp = function mulp(x3, y2, out) {
        var N3 = 2 * this.guessLen13b(x3.length, y2.length);
        var rbt = this.makeRBT(N3);
        var _2 = this.stub(N3);
        var rws = new Array(N3);
        var rwst = new Array(N3);
        var iwst = new Array(N3);
        var nrws = new Array(N3);
        var nrwst = new Array(N3);
        var niwst = new Array(N3);
        var rmws = out.words;
        rmws.length = N3;
        this.convert13b(x3.words, x3.length, rws, N3);
        this.convert13b(y2.words, y2.length, nrws, N3);
        this.transform(rws, _2, rwst, iwst, N3, rbt);
        this.transform(nrws, _2, nrwst, niwst, N3, rbt);
        for (var i4 = 0; i4 < N3; i4++) {
          var rx = rwst[i4] * nrwst[i4] - iwst[i4] * niwst[i4];
          iwst[i4] = rwst[i4] * niwst[i4] + iwst[i4] * nrwst[i4];
          rwst[i4] = rx;
        }
        this.conjugate(rwst, iwst, N3);
        this.transform(rwst, iwst, rmws, _2, N3, rbt);
        this.conjugate(rmws, _2, N3);
        this.normalize13b(rmws, N3);
        out.negative = x3.negative ^ y2.negative;
        out.length = x3.length + y2.length;
        return out._strip();
      };
      BN2.prototype.mul = function mul(num) {
        var out = new BN2(null);
        out.words = new Array(this.length + num.length);
        return this.mulTo(num, out);
      };
      BN2.prototype.mulf = function mulf(num) {
        var out = new BN2(null);
        out.words = new Array(this.length + num.length);
        return jumboMulTo(this, num, out);
      };
      BN2.prototype.imul = function imul(num) {
        return this.clone().mulTo(num, this);
      };
      BN2.prototype.imuln = function imuln(num) {
        var isNegNum = num < 0;
        if (isNegNum) num = -num;
        assert3(typeof num === "number");
        assert3(num < 67108864);
        var carry = 0;
        for (var i4 = 0; i4 < this.length; i4++) {
          var w5 = (this.words[i4] | 0) * num;
          var lo2 = (w5 & 67108863) + (carry & 67108863);
          carry >>= 26;
          carry += w5 / 67108864 | 0;
          carry += lo2 >>> 26;
          this.words[i4] = lo2 & 67108863;
        }
        if (carry !== 0) {
          this.words[i4] = carry;
          this.length++;
        }
        this.length = num === 0 ? 1 : this.length;
        return isNegNum ? this.ineg() : this;
      };
      BN2.prototype.muln = function muln(num) {
        return this.clone().imuln(num);
      };
      BN2.prototype.sqr = function sqr() {
        return this.mul(this);
      };
      BN2.prototype.isqr = function isqr() {
        return this.imul(this.clone());
      };
      BN2.prototype.pow = function pow3(num) {
        var w5 = toBitArray(num);
        if (w5.length === 0) return new BN2(1);
        var res = this;
        for (var i4 = 0; i4 < w5.length; i4++, res = res.sqr()) {
          if (w5[i4] !== 0) break;
        }
        if (++i4 < w5.length) {
          for (var q4 = res.sqr(); i4 < w5.length; i4++, q4 = q4.sqr()) {
            if (w5[i4] === 0) continue;
            res = res.mul(q4);
          }
        }
        return res;
      };
      BN2.prototype.iushln = function iushln(bits) {
        assert3(typeof bits === "number" && bits >= 0);
        var r2 = bits % 26;
        var s2 = (bits - r2) / 26;
        var carryMask = 67108863 >>> 26 - r2 << 26 - r2;
        var i4;
        if (r2 !== 0) {
          var carry = 0;
          for (i4 = 0; i4 < this.length; i4++) {
            var newCarry = this.words[i4] & carryMask;
            var c3 = (this.words[i4] | 0) - newCarry << r2;
            this.words[i4] = c3 | carry;
            carry = newCarry >>> 26 - r2;
          }
          if (carry) {
            this.words[i4] = carry;
            this.length++;
          }
        }
        if (s2 !== 0) {
          for (i4 = this.length - 1; i4 >= 0; i4--) {
            this.words[i4 + s2] = this.words[i4];
          }
          for (i4 = 0; i4 < s2; i4++) {
            this.words[i4] = 0;
          }
          this.length += s2;
        }
        return this._strip();
      };
      BN2.prototype.ishln = function ishln(bits) {
        assert3(this.negative === 0);
        return this.iushln(bits);
      };
      BN2.prototype.iushrn = function iushrn(bits, hint, extended) {
        assert3(typeof bits === "number" && bits >= 0);
        var h3;
        if (hint) {
          h3 = (hint - hint % 26) / 26;
        } else {
          h3 = 0;
        }
        var r2 = bits % 26;
        var s2 = Math.min((bits - r2) / 26, this.length);
        var mask2 = 67108863 ^ 67108863 >>> r2 << r2;
        var maskedWords = extended;
        h3 -= s2;
        h3 = Math.max(0, h3);
        if (maskedWords) {
          for (var i4 = 0; i4 < s2; i4++) {
            maskedWords.words[i4] = this.words[i4];
          }
          maskedWords.length = s2;
        }
        if (s2 === 0) {
        } else if (this.length > s2) {
          this.length -= s2;
          for (i4 = 0; i4 < this.length; i4++) {
            this.words[i4] = this.words[i4 + s2];
          }
        } else {
          this.words[0] = 0;
          this.length = 1;
        }
        var carry = 0;
        for (i4 = this.length - 1; i4 >= 0 && (carry !== 0 || i4 >= h3); i4--) {
          var word = this.words[i4] | 0;
          this.words[i4] = carry << 26 - r2 | word >>> r2;
          carry = word & mask2;
        }
        if (maskedWords && carry !== 0) {
          maskedWords.words[maskedWords.length++] = carry;
        }
        if (this.length === 0) {
          this.words[0] = 0;
          this.length = 1;
        }
        return this._strip();
      };
      BN2.prototype.ishrn = function ishrn(bits, hint, extended) {
        assert3(this.negative === 0);
        return this.iushrn(bits, hint, extended);
      };
      BN2.prototype.shln = function shln(bits) {
        return this.clone().ishln(bits);
      };
      BN2.prototype.ushln = function ushln(bits) {
        return this.clone().iushln(bits);
      };
      BN2.prototype.shrn = function shrn(bits) {
        return this.clone().ishrn(bits);
      };
      BN2.prototype.ushrn = function ushrn(bits) {
        return this.clone().iushrn(bits);
      };
      BN2.prototype.testn = function testn(bit) {
        assert3(typeof bit === "number" && bit >= 0);
        var r2 = bit % 26;
        var s2 = (bit - r2) / 26;
        var q4 = 1 << r2;
        if (this.length <= s2) return false;
        var w5 = this.words[s2];
        return !!(w5 & q4);
      };
      BN2.prototype.imaskn = function imaskn(bits) {
        assert3(typeof bits === "number" && bits >= 0);
        var r2 = bits % 26;
        var s2 = (bits - r2) / 26;
        assert3(this.negative === 0, "imaskn works only with positive numbers");
        if (this.length <= s2) {
          return this;
        }
        if (r2 !== 0) {
          s2++;
        }
        this.length = Math.min(s2, this.length);
        if (r2 !== 0) {
          var mask2 = 67108863 ^ 67108863 >>> r2 << r2;
          this.words[this.length - 1] &= mask2;
        }
        return this._strip();
      };
      BN2.prototype.maskn = function maskn(bits) {
        return this.clone().imaskn(bits);
      };
      BN2.prototype.iaddn = function iaddn(num) {
        assert3(typeof num === "number");
        assert3(num < 67108864);
        if (num < 0) return this.isubn(-num);
        if (this.negative !== 0) {
          if (this.length === 1 && (this.words[0] | 0) <= num) {
            this.words[0] = num - (this.words[0] | 0);
            this.negative = 0;
            return this;
          }
          this.negative = 0;
          this.isubn(num);
          this.negative = 1;
          return this;
        }
        return this._iaddn(num);
      };
      BN2.prototype._iaddn = function _iaddn(num) {
        this.words[0] += num;
        for (var i4 = 0; i4 < this.length && this.words[i4] >= 67108864; i4++) {
          this.words[i4] -= 67108864;
          if (i4 === this.length - 1) {
            this.words[i4 + 1] = 1;
          } else {
            this.words[i4 + 1]++;
          }
        }
        this.length = Math.max(this.length, i4 + 1);
        return this;
      };
      BN2.prototype.isubn = function isubn(num) {
        assert3(typeof num === "number");
        assert3(num < 67108864);
        if (num < 0) return this.iaddn(-num);
        if (this.negative !== 0) {
          this.negative = 0;
          this.iaddn(num);
          this.negative = 1;
          return this;
        }
        this.words[0] -= num;
        if (this.length === 1 && this.words[0] < 0) {
          this.words[0] = -this.words[0];
          this.negative = 1;
        } else {
          for (var i4 = 0; i4 < this.length && this.words[i4] < 0; i4++) {
            this.words[i4] += 67108864;
            this.words[i4 + 1] -= 1;
          }
        }
        return this._strip();
      };
      BN2.prototype.addn = function addn(num) {
        return this.clone().iaddn(num);
      };
      BN2.prototype.subn = function subn(num) {
        return this.clone().isubn(num);
      };
      BN2.prototype.iabs = function iabs() {
        this.negative = 0;
        return this;
      };
      BN2.prototype.abs = function abs() {
        return this.clone().iabs();
      };
      BN2.prototype._ishlnsubmul = function _ishlnsubmul(num, mul, shift) {
        var len = num.length + shift;
        var i4;
        this._expand(len);
        var w5;
        var carry = 0;
        for (i4 = 0; i4 < num.length; i4++) {
          w5 = (this.words[i4 + shift] | 0) + carry;
          var right = (num.words[i4] | 0) * mul;
          w5 -= right & 67108863;
          carry = (w5 >> 26) - (right / 67108864 | 0);
          this.words[i4 + shift] = w5 & 67108863;
        }
        for (; i4 < this.length - shift; i4++) {
          w5 = (this.words[i4 + shift] | 0) + carry;
          carry = w5 >> 26;
          this.words[i4 + shift] = w5 & 67108863;
        }
        if (carry === 0) return this._strip();
        assert3(carry === -1);
        carry = 0;
        for (i4 = 0; i4 < this.length; i4++) {
          w5 = -(this.words[i4] | 0) + carry;
          carry = w5 >> 26;
          this.words[i4] = w5 & 67108863;
        }
        this.negative = 1;
        return this._strip();
      };
      BN2.prototype._wordDiv = function _wordDiv(num, mode) {
        var shift = this.length - num.length;
        var a = this.clone();
        var b3 = num;
        var bhi = b3.words[b3.length - 1] | 0;
        var bhiBits = this._countBits(bhi);
        shift = 26 - bhiBits;
        if (shift !== 0) {
          b3 = b3.ushln(shift);
          a.iushln(shift);
          bhi = b3.words[b3.length - 1] | 0;
        }
        var m4 = a.length - b3.length;
        var q4;
        if (mode !== "mod") {
          q4 = new BN2(null);
          q4.length = m4 + 1;
          q4.words = new Array(q4.length);
          for (var i4 = 0; i4 < q4.length; i4++) {
            q4.words[i4] = 0;
          }
        }
        var diff = a.clone()._ishlnsubmul(b3, 1, m4);
        if (diff.negative === 0) {
          a = diff;
          if (q4) {
            q4.words[m4] = 1;
          }
        }
        for (var j4 = m4 - 1; j4 >= 0; j4--) {
          var qj = (a.words[b3.length + j4] | 0) * 67108864 + (a.words[b3.length + j4 - 1] | 0);
          qj = Math.min(qj / bhi | 0, 67108863);
          a._ishlnsubmul(b3, qj, j4);
          while (a.negative !== 0) {
            qj--;
            a.negative = 0;
            a._ishlnsubmul(b3, 1, j4);
            if (!a.isZero()) {
              a.negative ^= 1;
            }
          }
          if (q4) {
            q4.words[j4] = qj;
          }
        }
        if (q4) {
          q4._strip();
        }
        a._strip();
        if (mode !== "div" && shift !== 0) {
          a.iushrn(shift);
        }
        return {
          div: q4 || null,
          mod: a
        };
      };
      BN2.prototype.divmod = function divmod(num, mode, positive) {
        assert3(!num.isZero());
        if (this.isZero()) {
          return {
            div: new BN2(0),
            mod: new BN2(0)
          };
        }
        var div, mod2, res;
        if (this.negative !== 0 && num.negative === 0) {
          res = this.neg().divmod(num, mode);
          if (mode !== "mod") {
            div = res.div.neg();
          }
          if (mode !== "div") {
            mod2 = res.mod.neg();
            if (positive && mod2.negative !== 0) {
              mod2.iadd(num);
            }
          }
          return {
            div,
            mod: mod2
          };
        }
        if (this.negative === 0 && num.negative !== 0) {
          res = this.divmod(num.neg(), mode);
          if (mode !== "mod") {
            div = res.div.neg();
          }
          return {
            div,
            mod: res.mod
          };
        }
        if ((this.negative & num.negative) !== 0) {
          res = this.neg().divmod(num.neg(), mode);
          if (mode !== "div") {
            mod2 = res.mod.neg();
            if (positive && mod2.negative !== 0) {
              mod2.isub(num);
            }
          }
          return {
            div: res.div,
            mod: mod2
          };
        }
        if (num.length > this.length || this.cmp(num) < 0) {
          return {
            div: new BN2(0),
            mod: this
          };
        }
        if (num.length === 1) {
          if (mode === "div") {
            return {
              div: this.divn(num.words[0]),
              mod: null
            };
          }
          if (mode === "mod") {
            return {
              div: null,
              mod: new BN2(this.modrn(num.words[0]))
            };
          }
          return {
            div: this.divn(num.words[0]),
            mod: new BN2(this.modrn(num.words[0]))
          };
        }
        return this._wordDiv(num, mode);
      };
      BN2.prototype.div = function div(num) {
        return this.divmod(num, "div", false).div;
      };
      BN2.prototype.mod = function mod2(num) {
        return this.divmod(num, "mod", false).mod;
      };
      BN2.prototype.umod = function umod(num) {
        return this.divmod(num, "mod", true).mod;
      };
      BN2.prototype.divRound = function divRound(num) {
        var dm = this.divmod(num);
        if (dm.mod.isZero()) return dm.div;
        var mod2 = dm.div.negative !== 0 ? dm.mod.isub(num) : dm.mod;
        var half = num.ushrn(1);
        var r2 = num.andln(1);
        var cmp = mod2.cmp(half);
        if (cmp < 0 || r2 === 1 && cmp === 0) return dm.div;
        return dm.div.negative !== 0 ? dm.div.isubn(1) : dm.div.iaddn(1);
      };
      BN2.prototype.modrn = function modrn(num) {
        var isNegNum = num < 0;
        if (isNegNum) num = -num;
        assert3(num <= 67108863);
        var p4 = (1 << 26) % num;
        var acc = 0;
        for (var i4 = this.length - 1; i4 >= 0; i4--) {
          acc = (p4 * acc + (this.words[i4] | 0)) % num;
        }
        return isNegNum ? -acc : acc;
      };
      BN2.prototype.modn = function modn(num) {
        return this.modrn(num);
      };
      BN2.prototype.idivn = function idivn(num) {
        var isNegNum = num < 0;
        if (isNegNum) num = -num;
        assert3(num <= 67108863);
        var carry = 0;
        for (var i4 = this.length - 1; i4 >= 0; i4--) {
          var w5 = (this.words[i4] | 0) + carry * 67108864;
          this.words[i4] = w5 / num | 0;
          carry = w5 % num;
        }
        this._strip();
        return isNegNum ? this.ineg() : this;
      };
      BN2.prototype.divn = function divn(num) {
        return this.clone().idivn(num);
      };
      BN2.prototype.egcd = function egcd(p4) {
        assert3(p4.negative === 0);
        assert3(!p4.isZero());
        var x3 = this;
        var y2 = p4.clone();
        if (x3.negative !== 0) {
          x3 = x3.umod(p4);
        } else {
          x3 = x3.clone();
        }
        var A3 = new BN2(1);
        var B3 = new BN2(0);
        var C4 = new BN2(0);
        var D3 = new BN2(1);
        var g2 = 0;
        while (x3.isEven() && y2.isEven()) {
          x3.iushrn(1);
          y2.iushrn(1);
          ++g2;
        }
        var yp2 = y2.clone();
        var xp2 = x3.clone();
        while (!x3.isZero()) {
          for (var i4 = 0, im = 1; (x3.words[0] & im) === 0 && i4 < 26; ++i4, im <<= 1) ;
          if (i4 > 0) {
            x3.iushrn(i4);
            while (i4-- > 0) {
              if (A3.isOdd() || B3.isOdd()) {
                A3.iadd(yp2);
                B3.isub(xp2);
              }
              A3.iushrn(1);
              B3.iushrn(1);
            }
          }
          for (var j4 = 0, jm = 1; (y2.words[0] & jm) === 0 && j4 < 26; ++j4, jm <<= 1) ;
          if (j4 > 0) {
            y2.iushrn(j4);
            while (j4-- > 0) {
              if (C4.isOdd() || D3.isOdd()) {
                C4.iadd(yp2);
                D3.isub(xp2);
              }
              C4.iushrn(1);
              D3.iushrn(1);
            }
          }
          if (x3.cmp(y2) >= 0) {
            x3.isub(y2);
            A3.isub(C4);
            B3.isub(D3);
          } else {
            y2.isub(x3);
            C4.isub(A3);
            D3.isub(B3);
          }
        }
        return {
          a: C4,
          b: D3,
          gcd: y2.iushln(g2)
        };
      };
      BN2.prototype._invmp = function _invmp(p4) {
        assert3(p4.negative === 0);
        assert3(!p4.isZero());
        var a = this;
        var b3 = p4.clone();
        if (a.negative !== 0) {
          a = a.umod(p4);
        } else {
          a = a.clone();
        }
        var x1 = new BN2(1);
        var x22 = new BN2(0);
        var delta = b3.clone();
        while (a.cmpn(1) > 0 && b3.cmpn(1) > 0) {
          for (var i4 = 0, im = 1; (a.words[0] & im) === 0 && i4 < 26; ++i4, im <<= 1) ;
          if (i4 > 0) {
            a.iushrn(i4);
            while (i4-- > 0) {
              if (x1.isOdd()) {
                x1.iadd(delta);
              }
              x1.iushrn(1);
            }
          }
          for (var j4 = 0, jm = 1; (b3.words[0] & jm) === 0 && j4 < 26; ++j4, jm <<= 1) ;
          if (j4 > 0) {
            b3.iushrn(j4);
            while (j4-- > 0) {
              if (x22.isOdd()) {
                x22.iadd(delta);
              }
              x22.iushrn(1);
            }
          }
          if (a.cmp(b3) >= 0) {
            a.isub(b3);
            x1.isub(x22);
          } else {
            b3.isub(a);
            x22.isub(x1);
          }
        }
        var res;
        if (a.cmpn(1) === 0) {
          res = x1;
        } else {
          res = x22;
        }
        if (res.cmpn(0) < 0) {
          res.iadd(p4);
        }
        return res;
      };
      BN2.prototype.gcd = function gcd(num) {
        if (this.isZero()) return num.abs();
        if (num.isZero()) return this.abs();
        var a = this.clone();
        var b3 = num.clone();
        a.negative = 0;
        b3.negative = 0;
        for (var shift = 0; a.isEven() && b3.isEven(); shift++) {
          a.iushrn(1);
          b3.iushrn(1);
        }
        do {
          while (a.isEven()) {
            a.iushrn(1);
          }
          while (b3.isEven()) {
            b3.iushrn(1);
          }
          var r2 = a.cmp(b3);
          if (r2 < 0) {
            var t3 = a;
            a = b3;
            b3 = t3;
          } else if (r2 === 0 || b3.cmpn(1) === 0) {
            break;
          }
          a.isub(b3);
        } while (true);
        return b3.iushln(shift);
      };
      BN2.prototype.invm = function invm(num) {
        return this.egcd(num).a.umod(num);
      };
      BN2.prototype.isEven = function isEven() {
        return (this.words[0] & 1) === 0;
      };
      BN2.prototype.isOdd = function isOdd() {
        return (this.words[0] & 1) === 1;
      };
      BN2.prototype.andln = function andln(num) {
        return this.words[0] & num;
      };
      BN2.prototype.bincn = function bincn(bit) {
        assert3(typeof bit === "number");
        var r2 = bit % 26;
        var s2 = (bit - r2) / 26;
        var q4 = 1 << r2;
        if (this.length <= s2) {
          this._expand(s2 + 1);
          this.words[s2] |= q4;
          return this;
        }
        var carry = q4;
        for (var i4 = s2; carry !== 0 && i4 < this.length; i4++) {
          var w5 = this.words[i4] | 0;
          w5 += carry;
          carry = w5 >>> 26;
          w5 &= 67108863;
          this.words[i4] = w5;
        }
        if (carry !== 0) {
          this.words[i4] = carry;
          this.length++;
        }
        return this;
      };
      BN2.prototype.isZero = function isZero() {
        return this.length === 1 && this.words[0] === 0;
      };
      BN2.prototype.cmpn = function cmpn(num) {
        var negative = num < 0;
        if (this.negative !== 0 && !negative) return -1;
        if (this.negative === 0 && negative) return 1;
        this._strip();
        var res;
        if (this.length > 1) {
          res = 1;
        } else {
          if (negative) {
            num = -num;
          }
          assert3(num <= 67108863, "Number is too big");
          var w5 = this.words[0] | 0;
          res = w5 === num ? 0 : w5 < num ? -1 : 1;
        }
        if (this.negative !== 0) return -res | 0;
        return res;
      };
      BN2.prototype.cmp = function cmp(num) {
        if (this.negative !== 0 && num.negative === 0) return -1;
        if (this.negative === 0 && num.negative !== 0) return 1;
        var res = this.ucmp(num);
        if (this.negative !== 0) return -res | 0;
        return res;
      };
      BN2.prototype.ucmp = function ucmp(num) {
        if (this.length > num.length) return 1;
        if (this.length < num.length) return -1;
        var res = 0;
        for (var i4 = this.length - 1; i4 >= 0; i4--) {
          var a = this.words[i4] | 0;
          var b3 = num.words[i4] | 0;
          if (a === b3) continue;
          if (a < b3) {
            res = -1;
          } else if (a > b3) {
            res = 1;
          }
          break;
        }
        return res;
      };
      BN2.prototype.gtn = function gtn(num) {
        return this.cmpn(num) === 1;
      };
      BN2.prototype.gt = function gt3(num) {
        return this.cmp(num) === 1;
      };
      BN2.prototype.gten = function gten(num) {
        return this.cmpn(num) >= 0;
      };
      BN2.prototype.gte = function gte(num) {
        return this.cmp(num) >= 0;
      };
      BN2.prototype.ltn = function ltn(num) {
        return this.cmpn(num) === -1;
      };
      BN2.prototype.lt = function lt3(num) {
        return this.cmp(num) === -1;
      };
      BN2.prototype.lten = function lten(num) {
        return this.cmpn(num) <= 0;
      };
      BN2.prototype.lte = function lte(num) {
        return this.cmp(num) <= 0;
      };
      BN2.prototype.eqn = function eqn(num) {
        return this.cmpn(num) === 0;
      };
      BN2.prototype.eq = function eq(num) {
        return this.cmp(num) === 0;
      };
      BN2.red = function red(num) {
        return new Red(num);
      };
      BN2.prototype.toRed = function toRed(ctx) {
        assert3(!this.red, "Already a number in reduction context");
        assert3(this.negative === 0, "red works only with positives");
        return ctx.convertTo(this)._forceRed(ctx);
      };
      BN2.prototype.fromRed = function fromRed() {
        assert3(this.red, "fromRed works only with numbers in reduction context");
        return this.red.convertFrom(this);
      };
      BN2.prototype._forceRed = function _forceRed(ctx) {
        this.red = ctx;
        return this;
      };
      BN2.prototype.forceRed = function forceRed(ctx) {
        assert3(!this.red, "Already a number in reduction context");
        return this._forceRed(ctx);
      };
      BN2.prototype.redAdd = function redAdd(num) {
        assert3(this.red, "redAdd works only with red numbers");
        return this.red.add(this, num);
      };
      BN2.prototype.redIAdd = function redIAdd(num) {
        assert3(this.red, "redIAdd works only with red numbers");
        return this.red.iadd(this, num);
      };
      BN2.prototype.redSub = function redSub(num) {
        assert3(this.red, "redSub works only with red numbers");
        return this.red.sub(this, num);
      };
      BN2.prototype.redISub = function redISub(num) {
        assert3(this.red, "redISub works only with red numbers");
        return this.red.isub(this, num);
      };
      BN2.prototype.redShl = function redShl(num) {
        assert3(this.red, "redShl works only with red numbers");
        return this.red.shl(this, num);
      };
      BN2.prototype.redMul = function redMul(num) {
        assert3(this.red, "redMul works only with red numbers");
        this.red._verify2(this, num);
        return this.red.mul(this, num);
      };
      BN2.prototype.redIMul = function redIMul(num) {
        assert3(this.red, "redMul works only with red numbers");
        this.red._verify2(this, num);
        return this.red.imul(this, num);
      };
      BN2.prototype.redSqr = function redSqr() {
        assert3(this.red, "redSqr works only with red numbers");
        this.red._verify1(this);
        return this.red.sqr(this);
      };
      BN2.prototype.redISqr = function redISqr() {
        assert3(this.red, "redISqr works only with red numbers");
        this.red._verify1(this);
        return this.red.isqr(this);
      };
      BN2.prototype.redSqrt = function redSqrt() {
        assert3(this.red, "redSqrt works only with red numbers");
        this.red._verify1(this);
        return this.red.sqrt(this);
      };
      BN2.prototype.redInvm = function redInvm() {
        assert3(this.red, "redInvm works only with red numbers");
        this.red._verify1(this);
        return this.red.invm(this);
      };
      BN2.prototype.redNeg = function redNeg() {
        assert3(this.red, "redNeg works only with red numbers");
        this.red._verify1(this);
        return this.red.neg(this);
      };
      BN2.prototype.redPow = function redPow(num) {
        assert3(this.red && !num.red, "redPow(normalNum)");
        this.red._verify1(this);
        return this.red.pow(this, num);
      };
      var primes = {
        k256: null,
        p224: null,
        p192: null,
        p25519: null
      };
      function MPrime(name, p4) {
        this.name = name;
        this.p = new BN2(p4, 16);
        this.n = this.p.bitLength();
        this.k = new BN2(1).iushln(this.n).isub(this.p);
        this.tmp = this._tmp();
      }
      MPrime.prototype._tmp = function _tmp() {
        var tmp = new BN2(null);
        tmp.words = new Array(Math.ceil(this.n / 13));
        return tmp;
      };
      MPrime.prototype.ireduce = function ireduce(num) {
        var r2 = num;
        var rlen;
        do {
          this.split(r2, this.tmp);
          r2 = this.imulK(r2);
          r2 = r2.iadd(this.tmp);
          rlen = r2.bitLength();
        } while (rlen > this.n);
        var cmp = rlen < this.n ? -1 : r2.ucmp(this.p);
        if (cmp === 0) {
          r2.words[0] = 0;
          r2.length = 1;
        } else if (cmp > 0) {
          r2.isub(this.p);
        } else {
          if (r2.strip !== void 0) {
            r2.strip();
          } else {
            r2._strip();
          }
        }
        return r2;
      };
      MPrime.prototype.split = function split(input, out) {
        input.iushrn(this.n, 0, out);
      };
      MPrime.prototype.imulK = function imulK(num) {
        return num.imul(this.k);
      };
      function K256() {
        MPrime.call(
          this,
          "k256",
          "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f"
        );
      }
      inherits(K256, MPrime);
      K256.prototype.split = function split(input, output) {
        var mask2 = 4194303;
        var outLen = Math.min(input.length, 9);
        for (var i4 = 0; i4 < outLen; i4++) {
          output.words[i4] = input.words[i4];
        }
        output.length = outLen;
        if (input.length <= 9) {
          input.words[0] = 0;
          input.length = 1;
          return;
        }
        var prev = input.words[9];
        output.words[output.length++] = prev & mask2;
        for (i4 = 10; i4 < input.length; i4++) {
          var next = input.words[i4] | 0;
          input.words[i4 - 10] = (next & mask2) << 4 | prev >>> 22;
          prev = next;
        }
        prev >>>= 22;
        input.words[i4 - 10] = prev;
        if (prev === 0 && input.length > 10) {
          input.length -= 10;
        } else {
          input.length -= 9;
        }
      };
      K256.prototype.imulK = function imulK(num) {
        num.words[num.length] = 0;
        num.words[num.length + 1] = 0;
        num.length += 2;
        var lo2 = 0;
        for (var i4 = 0; i4 < num.length; i4++) {
          var w5 = num.words[i4] | 0;
          lo2 += w5 * 977;
          num.words[i4] = lo2 & 67108863;
          lo2 = w5 * 64 + (lo2 / 67108864 | 0);
        }
        if (num.words[num.length - 1] === 0) {
          num.length--;
          if (num.words[num.length - 1] === 0) {
            num.length--;
          }
        }
        return num;
      };
      function P224() {
        MPrime.call(
          this,
          "p224",
          "ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001"
        );
      }
      inherits(P224, MPrime);
      function P192() {
        MPrime.call(
          this,
          "p192",
          "ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff"
        );
      }
      inherits(P192, MPrime);
      function P25519() {
        MPrime.call(
          this,
          "25519",
          "7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed"
        );
      }
      inherits(P25519, MPrime);
      P25519.prototype.imulK = function imulK(num) {
        var carry = 0;
        for (var i4 = 0; i4 < num.length; i4++) {
          var hi2 = (num.words[i4] | 0) * 19 + carry;
          var lo2 = hi2 & 67108863;
          hi2 >>>= 26;
          num.words[i4] = lo2;
          carry = hi2;
        }
        if (carry !== 0) {
          num.words[num.length++] = carry;
        }
        return num;
      };
      BN2._prime = function prime(name) {
        if (primes[name]) return primes[name];
        var prime2;
        if (name === "k256") {
          prime2 = new K256();
        } else if (name === "p224") {
          prime2 = new P224();
        } else if (name === "p192") {
          prime2 = new P192();
        } else if (name === "p25519") {
          prime2 = new P25519();
        } else {
          throw new Error("Unknown prime " + name);
        }
        primes[name] = prime2;
        return prime2;
      };
      function Red(m4) {
        if (typeof m4 === "string") {
          var prime = BN2._prime(m4);
          this.m = prime.p;
          this.prime = prime;
        } else {
          assert3(m4.gtn(1), "modulus must be greater than 1");
          this.m = m4;
          this.prime = null;
        }
      }
      Red.prototype._verify1 = function _verify1(a) {
        assert3(a.negative === 0, "red works only with positives");
        assert3(a.red, "red works only with red numbers");
      };
      Red.prototype._verify2 = function _verify2(a, b3) {
        assert3((a.negative | b3.negative) === 0, "red works only with positives");
        assert3(
          a.red && a.red === b3.red,
          "red works only with red numbers"
        );
      };
      Red.prototype.imod = function imod(a) {
        if (this.prime) return this.prime.ireduce(a)._forceRed(this);
        move(a, a.umod(this.m)._forceRed(this));
        return a;
      };
      Red.prototype.neg = function neg(a) {
        if (a.isZero()) {
          return a.clone();
        }
        return this.m.sub(a)._forceRed(this);
      };
      Red.prototype.add = function add(a, b3) {
        this._verify2(a, b3);
        var res = a.add(b3);
        if (res.cmp(this.m) >= 0) {
          res.isub(this.m);
        }
        return res._forceRed(this);
      };
      Red.prototype.iadd = function iadd(a, b3) {
        this._verify2(a, b3);
        var res = a.iadd(b3);
        if (res.cmp(this.m) >= 0) {
          res.isub(this.m);
        }
        return res;
      };
      Red.prototype.sub = function sub(a, b3) {
        this._verify2(a, b3);
        var res = a.sub(b3);
        if (res.cmpn(0) < 0) {
          res.iadd(this.m);
        }
        return res._forceRed(this);
      };
      Red.prototype.isub = function isub(a, b3) {
        this._verify2(a, b3);
        var res = a.isub(b3);
        if (res.cmpn(0) < 0) {
          res.iadd(this.m);
        }
        return res;
      };
      Red.prototype.shl = function shl(a, num) {
        this._verify1(a);
        return this.imod(a.ushln(num));
      };
      Red.prototype.imul = function imul(a, b3) {
        this._verify2(a, b3);
        return this.imod(a.imul(b3));
      };
      Red.prototype.mul = function mul(a, b3) {
        this._verify2(a, b3);
        return this.imod(a.mul(b3));
      };
      Red.prototype.isqr = function isqr(a) {
        return this.imul(a, a.clone());
      };
      Red.prototype.sqr = function sqr(a) {
        return this.mul(a, a);
      };
      Red.prototype.sqrt = function sqrt(a) {
        if (a.isZero()) return a.clone();
        var mod3 = this.m.andln(3);
        assert3(mod3 % 2 === 1);
        if (mod3 === 3) {
          var pow3 = this.m.add(new BN2(1)).iushrn(2);
          return this.pow(a, pow3);
        }
        var q4 = this.m.subn(1);
        var s2 = 0;
        while (!q4.isZero() && q4.andln(1) === 0) {
          s2++;
          q4.iushrn(1);
        }
        assert3(!q4.isZero());
        var one = new BN2(1).toRed(this);
        var nOne = one.redNeg();
        var lpow = this.m.subn(1).iushrn(1);
        var z3 = this.m.bitLength();
        z3 = new BN2(2 * z3 * z3).toRed(this);
        while (this.pow(z3, lpow).cmp(nOne) !== 0) {
          z3.redIAdd(nOne);
        }
        var c3 = this.pow(z3, q4);
        var r2 = this.pow(a, q4.addn(1).iushrn(1));
        var t3 = this.pow(a, q4);
        var m4 = s2;
        while (t3.cmp(one) !== 0) {
          var tmp = t3;
          for (var i4 = 0; tmp.cmp(one) !== 0; i4++) {
            tmp = tmp.redSqr();
          }
          assert3(i4 < m4);
          var b3 = this.pow(c3, new BN2(1).iushln(m4 - i4 - 1));
          r2 = r2.redMul(b3);
          c3 = b3.redSqr();
          t3 = t3.redMul(c3);
          m4 = i4;
        }
        return r2;
      };
      Red.prototype.invm = function invm(a) {
        var inv = a._invmp(this.m);
        if (inv.negative !== 0) {
          inv.negative = 0;
          return this.imod(inv).redNeg();
        } else {
          return this.imod(inv);
        }
      };
      Red.prototype.pow = function pow3(a, num) {
        if (num.isZero()) return new BN2(1).toRed(this);
        if (num.cmpn(1) === 0) return a.clone();
        var windowSize = 4;
        var wnd = new Array(1 << windowSize);
        wnd[0] = new BN2(1).toRed(this);
        wnd[1] = a;
        for (var i4 = 2; i4 < wnd.length; i4++) {
          wnd[i4] = this.mul(wnd[i4 - 1], a);
        }
        var res = wnd[0];
        var current = 0;
        var currentLen = 0;
        var start = num.bitLength() % 26;
        if (start === 0) {
          start = 26;
        }
        for (i4 = num.length - 1; i4 >= 0; i4--) {
          var word = num.words[i4];
          for (var j4 = start - 1; j4 >= 0; j4--) {
            var bit = word >> j4 & 1;
            if (res !== wnd[0]) {
              res = this.sqr(res);
            }
            if (bit === 0 && current === 0) {
              currentLen = 0;
              continue;
            }
            current <<= 1;
            current |= bit;
            currentLen++;
            if (currentLen !== windowSize && (i4 !== 0 || j4 !== 0)) continue;
            res = this.mul(res, wnd[current]);
            currentLen = 0;
            current = 0;
          }
          start = 26;
        }
        return res;
      };
      Red.prototype.convertTo = function convertTo(num) {
        var r2 = num.umod(this.m);
        return r2 === num ? r2.clone() : r2;
      };
      Red.prototype.convertFrom = function convertFrom(num) {
        var res = num.clone();
        res.red = null;
        return res;
      };
      BN2.mont = function mont(num) {
        return new Mont(num);
      };
      function Mont(m4) {
        Red.call(this, m4);
        this.shift = this.m.bitLength();
        if (this.shift % 26 !== 0) {
          this.shift += 26 - this.shift % 26;
        }
        this.r = new BN2(1).iushln(this.shift);
        this.r2 = this.imod(this.r.sqr());
        this.rinv = this.r._invmp(this.m);
        this.minv = this.rinv.mul(this.r).isubn(1).div(this.m);
        this.minv = this.minv.umod(this.r);
        this.minv = this.r.sub(this.minv);
      }
      inherits(Mont, Red);
      Mont.prototype.convertTo = function convertTo(num) {
        return this.imod(num.ushln(this.shift));
      };
      Mont.prototype.convertFrom = function convertFrom(num) {
        var r2 = this.imod(num.mul(this.rinv));
        r2.red = null;
        return r2;
      };
      Mont.prototype.imul = function imul(a, b3) {
        if (a.isZero() || b3.isZero()) {
          a.words[0] = 0;
          a.length = 1;
          return a;
        }
        var t3 = a.imul(b3);
        var c3 = t3.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m);
        var u2 = t3.isub(c3).iushrn(this.shift);
        var res = u2;
        if (u2.cmp(this.m) >= 0) {
          res = u2.isub(this.m);
        } else if (u2.cmpn(0) < 0) {
          res = u2.iadd(this.m);
        }
        return res._forceRed(this);
      };
      Mont.prototype.mul = function mul(a, b3) {
        if (a.isZero() || b3.isZero()) return new BN2(0)._forceRed(this);
        var t3 = a.mul(b3);
        var c3 = t3.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m);
        var u2 = t3.isub(c3).iushrn(this.shift);
        var res = u2;
        if (u2.cmp(this.m) >= 0) {
          res = u2.isub(this.m);
        } else if (u2.cmpn(0) < 0) {
          res = u2.iadd(this.m);
        }
        return res._forceRed(this);
      };
      Mont.prototype.invm = function invm(a) {
        var res = this.imod(a._invmp(this.m).mul(this.r2));
        return res._forceRed(this);
      };
    })(typeof module === "undefined" || module, exports);
  }
});

// node_modules/safe-buffer/index.js
var require_safe_buffer = __commonJS({
  "node_modules/safe-buffer/index.js"(exports, module) {
    var buffer = require_buffer();
    var Buffer4 = buffer.Buffer;
    function copyProps(src, dst) {
      for (var key in src) {
        dst[key] = src[key];
      }
    }
    if (Buffer4.from && Buffer4.alloc && Buffer4.allocUnsafe && Buffer4.allocUnsafeSlow) {
      module.exports = buffer;
    } else {
      copyProps(buffer, exports);
      exports.Buffer = SafeBuffer;
    }
    function SafeBuffer(arg, encodingOrOffset, length) {
      return Buffer4(arg, encodingOrOffset, length);
    }
    SafeBuffer.prototype = Object.create(Buffer4.prototype);
    copyProps(Buffer4, SafeBuffer);
    SafeBuffer.from = function(arg, encodingOrOffset, length) {
      if (typeof arg === "number") {
        throw new TypeError("Argument must not be a number");
      }
      return Buffer4(arg, encodingOrOffset, length);
    };
    SafeBuffer.alloc = function(size, fill, encoding) {
      if (typeof size !== "number") {
        throw new TypeError("Argument must be a number");
      }
      var buf = Buffer4(size);
      if (fill !== void 0) {
        if (typeof encoding === "string") {
          buf.fill(fill, encoding);
        } else {
          buf.fill(fill);
        }
      } else {
        buf.fill(0);
      }
      return buf;
    };
    SafeBuffer.allocUnsafe = function(size) {
      if (typeof size !== "number") {
        throw new TypeError("Argument must be a number");
      }
      return Buffer4(size);
    };
    SafeBuffer.allocUnsafeSlow = function(size) {
      if (typeof size !== "number") {
        throw new TypeError("Argument must be a number");
      }
      return buffer.SlowBuffer(size);
    };
  }
});

// node_modules/@solana/web3.js/node_modules/base-x/src/index.js
var require_src = __commonJS({
  "node_modules/@solana/web3.js/node_modules/base-x/src/index.js"(exports, module) {
    "use strict";
    var _Buffer = require_safe_buffer().Buffer;
    function base(ALPHABET) {
      if (ALPHABET.length >= 255) {
        throw new TypeError("Alphabet too long");
      }
      var BASE_MAP = new Uint8Array(256);
      for (var j4 = 0; j4 < BASE_MAP.length; j4++) {
        BASE_MAP[j4] = 255;
      }
      for (var i4 = 0; i4 < ALPHABET.length; i4++) {
        var x3 = ALPHABET.charAt(i4);
        var xc2 = x3.charCodeAt(0);
        if (BASE_MAP[xc2] !== 255) {
          throw new TypeError(x3 + " is ambiguous");
        }
        BASE_MAP[xc2] = i4;
      }
      var BASE = ALPHABET.length;
      var LEADER = ALPHABET.charAt(0);
      var FACTOR = Math.log(BASE) / Math.log(256);
      var iFACTOR = Math.log(256) / Math.log(BASE);
      function encode3(source) {
        if (Array.isArray(source) || source instanceof Uint8Array) {
          source = _Buffer.from(source);
        }
        if (!_Buffer.isBuffer(source)) {
          throw new TypeError("Expected Buffer");
        }
        if (source.length === 0) {
          return "";
        }
        var zeroes = 0;
        var length = 0;
        var pbegin = 0;
        var pend = source.length;
        while (pbegin !== pend && source[pbegin] === 0) {
          pbegin++;
          zeroes++;
        }
        var size = (pend - pbegin) * iFACTOR + 1 >>> 0;
        var b58 = new Uint8Array(size);
        while (pbegin !== pend) {
          var carry = source[pbegin];
          var i5 = 0;
          for (var it1 = size - 1; (carry !== 0 || i5 < length) && it1 !== -1; it1--, i5++) {
            carry += 256 * b58[it1] >>> 0;
            b58[it1] = carry % BASE >>> 0;
            carry = carry / BASE >>> 0;
          }
          if (carry !== 0) {
            throw new Error("Non-zero carry");
          }
          length = i5;
          pbegin++;
        }
        var it22 = size - length;
        while (it22 !== size && b58[it22] === 0) {
          it22++;
        }
        var str = LEADER.repeat(zeroes);
        for (; it22 < size; ++it22) {
          str += ALPHABET.charAt(b58[it22]);
        }
        return str;
      }
      function decodeUnsafe(source) {
        if (typeof source !== "string") {
          throw new TypeError("Expected String");
        }
        if (source.length === 0) {
          return _Buffer.alloc(0);
        }
        var psz = 0;
        var zeroes = 0;
        var length = 0;
        while (source[psz] === LEADER) {
          zeroes++;
          psz++;
        }
        var size = (source.length - psz) * FACTOR + 1 >>> 0;
        var b256 = new Uint8Array(size);
        while (psz < source.length) {
          var charCode = source.charCodeAt(psz);
          if (charCode > 255) {
            return;
          }
          var carry = BASE_MAP[charCode];
          if (carry === 255) {
            return;
          }
          var i5 = 0;
          for (var it3 = size - 1; (carry !== 0 || i5 < length) && it3 !== -1; it3--, i5++) {
            carry += BASE * b256[it3] >>> 0;
            b256[it3] = carry % 256 >>> 0;
            carry = carry / 256 >>> 0;
          }
          if (carry !== 0) {
            throw new Error("Non-zero carry");
          }
          length = i5;
          psz++;
        }
        var it4 = size - length;
        while (it4 !== size && b256[it4] === 0) {
          it4++;
        }
        var vch = _Buffer.allocUnsafe(zeroes + (size - it4));
        vch.fill(0, 0, zeroes);
        var j5 = zeroes;
        while (it4 !== size) {
          vch[j5++] = b256[it4++];
        }
        return vch;
      }
      function decode4(string2) {
        var buffer = decodeUnsafe(string2);
        if (buffer) {
          return buffer;
        }
        throw new Error("Non-base" + BASE + " character");
      }
      return {
        encode: encode3,
        decodeUnsafe,
        decode: decode4
      };
    }
    module.exports = base;
  }
});

// node_modules/@solana/web3.js/node_modules/bs58/index.js
var require_bs58 = __commonJS({
  "node_modules/@solana/web3.js/node_modules/bs58/index.js"(exports, module) {
    var basex = require_src();
    var ALPHABET = "123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz";
    module.exports = basex(ALPHABET);
  }
});

// node_modules/borsh/node_modules/base-x/src/index.js
var require_src2 = __commonJS({
  "node_modules/borsh/node_modules/base-x/src/index.js"(exports, module) {
    "use strict";
    var _Buffer = require_safe_buffer().Buffer;
    function base(ALPHABET) {
      if (ALPHABET.length >= 255) {
        throw new TypeError("Alphabet too long");
      }
      var BASE_MAP = new Uint8Array(256);
      for (var j4 = 0; j4 < BASE_MAP.length; j4++) {
        BASE_MAP[j4] = 255;
      }
      for (var i4 = 0; i4 < ALPHABET.length; i4++) {
        var x3 = ALPHABET.charAt(i4);
        var xc2 = x3.charCodeAt(0);
        if (BASE_MAP[xc2] !== 255) {
          throw new TypeError(x3 + " is ambiguous");
        }
        BASE_MAP[xc2] = i4;
      }
      var BASE = ALPHABET.length;
      var LEADER = ALPHABET.charAt(0);
      var FACTOR = Math.log(BASE) / Math.log(256);
      var iFACTOR = Math.log(256) / Math.log(BASE);
      function encode3(source) {
        if (Array.isArray(source) || source instanceof Uint8Array) {
          source = _Buffer.from(source);
        }
        if (!_Buffer.isBuffer(source)) {
          throw new TypeError("Expected Buffer");
        }
        if (source.length === 0) {
          return "";
        }
        var zeroes = 0;
        var length = 0;
        var pbegin = 0;
        var pend = source.length;
        while (pbegin !== pend && source[pbegin] === 0) {
          pbegin++;
          zeroes++;
        }
        var size = (pend - pbegin) * iFACTOR + 1 >>> 0;
        var b58 = new Uint8Array(size);
        while (pbegin !== pend) {
          var carry = source[pbegin];
          var i5 = 0;
          for (var it1 = size - 1; (carry !== 0 || i5 < length) && it1 !== -1; it1--, i5++) {
            carry += 256 * b58[it1] >>> 0;
            b58[it1] = carry % BASE >>> 0;
            carry = carry / BASE >>> 0;
          }
          if (carry !== 0) {
            throw new Error("Non-zero carry");
          }
          length = i5;
          pbegin++;
        }
        var it22 = size - length;
        while (it22 !== size && b58[it22] === 0) {
          it22++;
        }
        var str = LEADER.repeat(zeroes);
        for (; it22 < size; ++it22) {
          str += ALPHABET.charAt(b58[it22]);
        }
        return str;
      }
      function decodeUnsafe(source) {
        if (typeof source !== "string") {
          throw new TypeError("Expected String");
        }
        if (source.length === 0) {
          return _Buffer.alloc(0);
        }
        var psz = 0;
        var zeroes = 0;
        var length = 0;
        while (source[psz] === LEADER) {
          zeroes++;
          psz++;
        }
        var size = (source.length - psz) * FACTOR + 1 >>> 0;
        var b256 = new Uint8Array(size);
        while (psz < source.length) {
          var charCode = source.charCodeAt(psz);
          if (charCode > 255) {
            return;
          }
          var carry = BASE_MAP[charCode];
          if (carry === 255) {
            return;
          }
          var i5 = 0;
          for (var it3 = size - 1; (carry !== 0 || i5 < length) && it3 !== -1; it3--, i5++) {
            carry += BASE * b256[it3] >>> 0;
            b256[it3] = carry % 256 >>> 0;
            carry = carry / 256 >>> 0;
          }
          if (carry !== 0) {
            throw new Error("Non-zero carry");
          }
          length = i5;
          psz++;
        }
        var it4 = size - length;
        while (it4 !== size && b256[it4] === 0) {
          it4++;
        }
        var vch = _Buffer.allocUnsafe(zeroes + (size - it4));
        vch.fill(0, 0, zeroes);
        var j5 = zeroes;
        while (it4 !== size) {
          vch[j5++] = b256[it4++];
        }
        return vch;
      }
      function decode4(string2) {
        var buffer = decodeUnsafe(string2);
        if (buffer) {
          return buffer;
        }
        throw new Error("Non-base" + BASE + " character");
      }
      return {
        encode: encode3,
        decodeUnsafe,
        decode: decode4
      };
    }
    module.exports = base;
  }
});

// node_modules/borsh/node_modules/bs58/index.js
var require_bs582 = __commonJS({
  "node_modules/borsh/node_modules/bs58/index.js"(exports, module) {
    var basex = require_src2();
    var ALPHABET = "123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz";
    module.exports = basex(ALPHABET);
  }
});

// node_modules/text-encoding-utf-8/src/encoding.js
var encoding_exports = {};
__export(encoding_exports, {
  TextDecoder: () => TextDecoder2,
  TextEncoder: () => TextEncoder2
});
function inRange(a, min, max) {
  return min <= a && a <= max;
}
function ToDictionary(o3) {
  if (o3 === void 0) return {};
  if (o3 === Object(o3)) return o3;
  throw TypeError("Could not convert argument to dictionary");
}
function stringToCodePoints(string2) {
  var s2 = String(string2);
  var n6 = s2.length;
  var i4 = 0;
  var u2 = [];
  while (i4 < n6) {
    var c3 = s2.charCodeAt(i4);
    if (c3 < 55296 || c3 > 57343) {
      u2.push(c3);
    } else if (56320 <= c3 && c3 <= 57343) {
      u2.push(65533);
    } else if (55296 <= c3 && c3 <= 56319) {
      if (i4 === n6 - 1) {
        u2.push(65533);
      } else {
        var d3 = string2.charCodeAt(i4 + 1);
        if (56320 <= d3 && d3 <= 57343) {
          var a = c3 & 1023;
          var b3 = d3 & 1023;
          u2.push(65536 + (a << 10) + b3);
          i4 += 1;
        } else {
          u2.push(65533);
        }
      }
    }
    i4 += 1;
  }
  return u2;
}
function codePointsToString(code_points) {
  var s2 = "";
  for (var i4 = 0; i4 < code_points.length; ++i4) {
    var cp2 = code_points[i4];
    if (cp2 <= 65535) {
      s2 += String.fromCharCode(cp2);
    } else {
      cp2 -= 65536;
      s2 += String.fromCharCode(
        (cp2 >> 10) + 55296,
        (cp2 & 1023) + 56320
      );
    }
  }
  return s2;
}
function Stream(tokens) {
  this.tokens = [].slice.call(tokens);
}
function decoderError(fatal, opt_code_point) {
  if (fatal)
    throw TypeError("Decoder error");
  return opt_code_point || 65533;
}
function Decoder2() {
}
function Encoder2() {
}
function TextDecoder2(encoding, options) {
  if (!(this instanceof TextDecoder2)) {
    return new TextDecoder2(encoding, options);
  }
  encoding = encoding !== void 0 ? String(encoding).toLowerCase() : DEFAULT_ENCODING;
  if (encoding !== DEFAULT_ENCODING) {
    throw new Error("Encoding not supported. Only utf-8 is supported");
  }
  options = ToDictionary(options);
  this._streaming = false;
  this._BOMseen = false;
  this._decoder = null;
  this._fatal = Boolean(options["fatal"]);
  this._ignoreBOM = Boolean(options["ignoreBOM"]);
  Object.defineProperty(this, "encoding", { value: "utf-8" });
  Object.defineProperty(this, "fatal", { value: this._fatal });
  Object.defineProperty(this, "ignoreBOM", { value: this._ignoreBOM });
}
function TextEncoder2(encoding, options) {
  if (!(this instanceof TextEncoder2))
    return new TextEncoder2(encoding, options);
  encoding = encoding !== void 0 ? String(encoding).toLowerCase() : DEFAULT_ENCODING;
  if (encoding !== DEFAULT_ENCODING) {
    throw new Error("Encoding not supported. Only utf-8 is supported");
  }
  options = ToDictionary(options);
  this._streaming = false;
  this._encoder = null;
  this._options = { fatal: Boolean(options["fatal"]) };
  Object.defineProperty(this, "encoding", { value: "utf-8" });
}
function UTF8Decoder(options) {
  var fatal = options.fatal;
  var utf8_code_point = 0, utf8_bytes_seen = 0, utf8_bytes_needed = 0, utf8_lower_boundary = 128, utf8_upper_boundary = 191;
  this.handler = function(stream, bite) {
    if (bite === end_of_stream && utf8_bytes_needed !== 0) {
      utf8_bytes_needed = 0;
      return decoderError(fatal);
    }
    if (bite === end_of_stream)
      return finished;
    if (utf8_bytes_needed === 0) {
      if (inRange(bite, 0, 127)) {
        return bite;
      }
      if (inRange(bite, 194, 223)) {
        utf8_bytes_needed = 1;
        utf8_code_point = bite - 192;
      } else if (inRange(bite, 224, 239)) {
        if (bite === 224)
          utf8_lower_boundary = 160;
        if (bite === 237)
          utf8_upper_boundary = 159;
        utf8_bytes_needed = 2;
        utf8_code_point = bite - 224;
      } else if (inRange(bite, 240, 244)) {
        if (bite === 240)
          utf8_lower_boundary = 144;
        if (bite === 244)
          utf8_upper_boundary = 143;
        utf8_bytes_needed = 3;
        utf8_code_point = bite - 240;
      } else {
        return decoderError(fatal);
      }
      utf8_code_point = utf8_code_point << 6 * utf8_bytes_needed;
      return null;
    }
    if (!inRange(bite, utf8_lower_boundary, utf8_upper_boundary)) {
      utf8_code_point = utf8_bytes_needed = utf8_bytes_seen = 0;
      utf8_lower_boundary = 128;
      utf8_upper_boundary = 191;
      stream.prepend(bite);
      return decoderError(fatal);
    }
    utf8_lower_boundary = 128;
    utf8_upper_boundary = 191;
    utf8_bytes_seen += 1;
    utf8_code_point += bite - 128 << 6 * (utf8_bytes_needed - utf8_bytes_seen);
    if (utf8_bytes_seen !== utf8_bytes_needed)
      return null;
    var code_point = utf8_code_point;
    utf8_code_point = utf8_bytes_needed = utf8_bytes_seen = 0;
    return code_point;
  };
}
function UTF8Encoder(options) {
  var fatal = options.fatal;
  this.handler = function(stream, code_point) {
    if (code_point === end_of_stream)
      return finished;
    if (inRange(code_point, 0, 127))
      return code_point;
    var count, offset2;
    if (inRange(code_point, 128, 2047)) {
      count = 1;
      offset2 = 192;
    } else if (inRange(code_point, 2048, 65535)) {
      count = 2;
      offset2 = 224;
    } else if (inRange(code_point, 65536, 1114111)) {
      count = 3;
      offset2 = 240;
    }
    var bytes = [(code_point >> 6 * count) + offset2];
    while (count > 0) {
      var temp = code_point >> 6 * (count - 1);
      bytes.push(128 | temp & 63);
      count -= 1;
    }
    return bytes;
  };
}
var end_of_stream, finished, DEFAULT_ENCODING;
var init_encoding = __esm({
  "node_modules/text-encoding-utf-8/src/encoding.js"() {
    "use strict";
    end_of_stream = -1;
    Stream.prototype = {
      /**
       * @return {boolean} True if end-of-stream has been hit.
       */
      endOfStream: function() {
        return !this.tokens.length;
      },
      /**
       * When a token is read from a stream, the first token in the
       * stream must be returned and subsequently removed, and
       * end-of-stream must be returned otherwise.
       *
       * @return {number} Get the next token from the stream, or
       * end_of_stream.
       */
      read: function() {
        if (!this.tokens.length)
          return end_of_stream;
        return this.tokens.shift();
      },
      /**
       * When one or more tokens are prepended to a stream, those tokens
       * must be inserted, in given order, before the first token in the
       * stream.
       *
       * @param {(number|!Array.<number>)} token The token(s) to prepend to the stream.
       */
      prepend: function(token) {
        if (Array.isArray(token)) {
          var tokens = (
            /**@type {!Array.<number>}*/
            token
          );
          while (tokens.length)
            this.tokens.unshift(tokens.pop());
        } else {
          this.tokens.unshift(token);
        }
      },
      /**
       * When one or more tokens are pushed to a stream, those tokens
       * must be inserted, in given order, after the last token in the
       * stream.
       *
       * @param {(number|!Array.<number>)} token The tokens(s) to prepend to the stream.
       */
      push: function(token) {
        if (Array.isArray(token)) {
          var tokens = (
            /**@type {!Array.<number>}*/
            token
          );
          while (tokens.length)
            this.tokens.push(tokens.shift());
        } else {
          this.tokens.push(token);
        }
      }
    };
    finished = -1;
    Decoder2.prototype = {
      /**
       * @param {Stream} stream The stream of bytes being decoded.
       * @param {number} bite The next byte read from the stream.
       * @return {?(number|!Array.<number>)} The next code point(s)
       *     decoded, or null if not enough data exists in the input
       *     stream to decode a complete code point, or |finished|.
       */
      handler: function(stream, bite) {
      }
    };
    Encoder2.prototype = {
      /**
       * @param {Stream} stream The stream of code points being encoded.
       * @param {number} code_point Next code point read from the stream.
       * @return {(number|!Array.<number>)} Byte(s) to emit, or |finished|.
       */
      handler: function(stream, code_point) {
      }
    };
    DEFAULT_ENCODING = "utf-8";
    TextDecoder2.prototype = {
      /**
       * @param {ArrayBufferView=} input The buffer of bytes to decode.
       * @param {Object=} options
       * @return {string} The decoded string.
       */
      decode: function decode3(input, options) {
        var bytes;
        if (typeof input === "object" && input instanceof ArrayBuffer) {
          bytes = new Uint8Array(input);
        } else if (typeof input === "object" && "buffer" in input && input.buffer instanceof ArrayBuffer) {
          bytes = new Uint8Array(
            input.buffer,
            input.byteOffset,
            input.byteLength
          );
        } else {
          bytes = new Uint8Array(0);
        }
        options = ToDictionary(options);
        if (!this._streaming) {
          this._decoder = new UTF8Decoder({ fatal: this._fatal });
          this._BOMseen = false;
        }
        this._streaming = Boolean(options["stream"]);
        var input_stream = new Stream(bytes);
        var code_points = [];
        var result;
        while (!input_stream.endOfStream()) {
          result = this._decoder.handler(input_stream, input_stream.read());
          if (result === finished)
            break;
          if (result === null)
            continue;
          if (Array.isArray(result))
            code_points.push.apply(
              code_points,
              /**@type {!Array.<number>}*/
              result
            );
          else
            code_points.push(result);
        }
        if (!this._streaming) {
          do {
            result = this._decoder.handler(input_stream, input_stream.read());
            if (result === finished)
              break;
            if (result === null)
              continue;
            if (Array.isArray(result))
              code_points.push.apply(
                code_points,
                /**@type {!Array.<number>}*/
                result
              );
            else
              code_points.push(result);
          } while (!input_stream.endOfStream());
          this._decoder = null;
        }
        if (code_points.length) {
          if (["utf-8"].indexOf(this.encoding) !== -1 && !this._ignoreBOM && !this._BOMseen) {
            if (code_points[0] === 65279) {
              this._BOMseen = true;
              code_points.shift();
            } else {
              this._BOMseen = true;
            }
          }
        }
        return codePointsToString(code_points);
      }
    };
    TextEncoder2.prototype = {
      /**
       * @param {string=} opt_string The string to encode.
       * @param {Object=} options
       * @return {Uint8Array} Encoded bytes, as a Uint8Array.
       */
      encode: function encode2(opt_string, options) {
        opt_string = opt_string ? String(opt_string) : "";
        options = ToDictionary(options);
        if (!this._streaming)
          this._encoder = new UTF8Encoder(this._options);
        this._streaming = Boolean(options["stream"]);
        var bytes = [];
        var input_stream = new Stream(stringToCodePoints(opt_string));
        var result;
        while (!input_stream.endOfStream()) {
          result = this._encoder.handler(input_stream, input_stream.read());
          if (result === finished)
            break;
          if (Array.isArray(result))
            bytes.push.apply(
              bytes,
              /**@type {!Array.<number>}*/
              result
            );
          else
            bytes.push(result);
        }
        if (!this._streaming) {
          while (true) {
            result = this._encoder.handler(input_stream, input_stream.read());
            if (result === finished)
              break;
            if (Array.isArray(result))
              bytes.push.apply(
                bytes,
                /**@type {!Array.<number>}*/
                result
              );
            else
              bytes.push(result);
          }
          this._encoder = null;
        }
        return new Uint8Array(bytes);
      }
    };
  }
});

// node_modules/borsh/lib/index.js
var require_lib = __commonJS({
  "node_modules/borsh/lib/index.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o3, m4, k3, k22) {
      if (k22 === void 0) k22 = k3;
      Object.defineProperty(o3, k22, { enumerable: true, get: function() {
        return m4[k3];
      } });
    } : function(o3, m4, k3, k22) {
      if (k22 === void 0) k22 = k3;
      o3[k22] = m4[k3];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o3, v2) {
      Object.defineProperty(o3, "default", { enumerable: true, value: v2 });
    } : function(o3, v2) {
      o3["default"] = v2;
    });
    var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
      var c3 = arguments.length, r2 = c3 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d3;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r2 = Reflect.decorate(decorators, target, key, desc);
      else for (var i4 = decorators.length - 1; i4 >= 0; i4--) if (d3 = decorators[i4]) r2 = (c3 < 3 ? d3(r2) : c3 > 3 ? d3(target, key, r2) : d3(target, key)) || r2;
      return c3 > 3 && r2 && Object.defineProperty(target, key, r2), r2;
    };
    var __importStar = exports && exports.__importStar || function(mod2) {
      if (mod2 && mod2.__esModule) return mod2;
      var result = {};
      if (mod2 != null) {
        for (var k3 in mod2) if (k3 !== "default" && Object.hasOwnProperty.call(mod2, k3)) __createBinding(result, mod2, k3);
      }
      __setModuleDefault(result, mod2);
      return result;
    };
    var __importDefault = exports && exports.__importDefault || function(mod2) {
      return mod2 && mod2.__esModule ? mod2 : { "default": mod2 };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.deserializeUnchecked = exports.deserialize = exports.serialize = exports.BinaryReader = exports.BinaryWriter = exports.BorshError = exports.baseDecode = exports.baseEncode = void 0;
    var bn_js_1 = __importDefault(require_bn());
    var bs58_1 = __importDefault(require_bs582());
    var encoding = __importStar((init_encoding(), __toCommonJS(encoding_exports)));
    var ResolvedTextDecoder = typeof TextDecoder !== "function" ? encoding.TextDecoder : TextDecoder;
    var textDecoder = new ResolvedTextDecoder("utf-8", { fatal: true });
    function baseEncode(value2) {
      if (typeof value2 === "string") {
        value2 = Buffer.from(value2, "utf8");
      }
      return bs58_1.default.encode(Buffer.from(value2));
    }
    exports.baseEncode = baseEncode;
    function baseDecode(value2) {
      return Buffer.from(bs58_1.default.decode(value2));
    }
    exports.baseDecode = baseDecode;
    var INITIAL_LENGTH = 1024;
    var BorshError = class extends Error {
      constructor(message) {
        super(message);
        this.fieldPath = [];
        this.originalMessage = message;
      }
      addToFieldPath(fieldName) {
        this.fieldPath.splice(0, 0, fieldName);
        this.message = this.originalMessage + ": " + this.fieldPath.join(".");
      }
    };
    exports.BorshError = BorshError;
    var BinaryWriter = class {
      constructor() {
        this.buf = Buffer.alloc(INITIAL_LENGTH);
        this.length = 0;
      }
      maybeResize() {
        if (this.buf.length < 16 + this.length) {
          this.buf = Buffer.concat([this.buf, Buffer.alloc(INITIAL_LENGTH)]);
        }
      }
      writeU8(value2) {
        this.maybeResize();
        this.buf.writeUInt8(value2, this.length);
        this.length += 1;
      }
      writeU16(value2) {
        this.maybeResize();
        this.buf.writeUInt16LE(value2, this.length);
        this.length += 2;
      }
      writeU32(value2) {
        this.maybeResize();
        this.buf.writeUInt32LE(value2, this.length);
        this.length += 4;
      }
      writeU64(value2) {
        this.maybeResize();
        this.writeBuffer(Buffer.from(new bn_js_1.default(value2).toArray("le", 8)));
      }
      writeU128(value2) {
        this.maybeResize();
        this.writeBuffer(Buffer.from(new bn_js_1.default(value2).toArray("le", 16)));
      }
      writeU256(value2) {
        this.maybeResize();
        this.writeBuffer(Buffer.from(new bn_js_1.default(value2).toArray("le", 32)));
      }
      writeU512(value2) {
        this.maybeResize();
        this.writeBuffer(Buffer.from(new bn_js_1.default(value2).toArray("le", 64)));
      }
      writeBuffer(buffer) {
        this.buf = Buffer.concat([
          Buffer.from(this.buf.subarray(0, this.length)),
          buffer,
          Buffer.alloc(INITIAL_LENGTH)
        ]);
        this.length += buffer.length;
      }
      writeString(str) {
        this.maybeResize();
        const b3 = Buffer.from(str, "utf8");
        this.writeU32(b3.length);
        this.writeBuffer(b3);
      }
      writeFixedArray(array2) {
        this.writeBuffer(Buffer.from(array2));
      }
      writeArray(array2, fn3) {
        this.maybeResize();
        this.writeU32(array2.length);
        for (const elem of array2) {
          this.maybeResize();
          fn3(elem);
        }
      }
      toArray() {
        return this.buf.subarray(0, this.length);
      }
    };
    exports.BinaryWriter = BinaryWriter;
    function handlingRangeError(target, propertyKey, propertyDescriptor) {
      const originalMethod = propertyDescriptor.value;
      propertyDescriptor.value = function(...args) {
        try {
          return originalMethod.apply(this, args);
        } catch (e9) {
          if (e9 instanceof RangeError) {
            const code = e9.code;
            if (["ERR_BUFFER_OUT_OF_BOUNDS", "ERR_OUT_OF_RANGE"].indexOf(code) >= 0) {
              throw new BorshError("Reached the end of buffer when deserializing");
            }
          }
          throw e9;
        }
      };
    }
    var BinaryReader = class {
      constructor(buf) {
        this.buf = buf;
        this.offset = 0;
      }
      readU8() {
        const value2 = this.buf.readUInt8(this.offset);
        this.offset += 1;
        return value2;
      }
      readU16() {
        const value2 = this.buf.readUInt16LE(this.offset);
        this.offset += 2;
        return value2;
      }
      readU32() {
        const value2 = this.buf.readUInt32LE(this.offset);
        this.offset += 4;
        return value2;
      }
      readU64() {
        const buf = this.readBuffer(8);
        return new bn_js_1.default(buf, "le");
      }
      readU128() {
        const buf = this.readBuffer(16);
        return new bn_js_1.default(buf, "le");
      }
      readU256() {
        const buf = this.readBuffer(32);
        return new bn_js_1.default(buf, "le");
      }
      readU512() {
        const buf = this.readBuffer(64);
        return new bn_js_1.default(buf, "le");
      }
      readBuffer(len) {
        if (this.offset + len > this.buf.length) {
          throw new BorshError(`Expected buffer length ${len} isn't within bounds`);
        }
        const result = this.buf.slice(this.offset, this.offset + len);
        this.offset += len;
        return result;
      }
      readString() {
        const len = this.readU32();
        const buf = this.readBuffer(len);
        try {
          return textDecoder.decode(buf);
        } catch (e9) {
          throw new BorshError(`Error decoding UTF-8 string: ${e9}`);
        }
      }
      readFixedArray(len) {
        return new Uint8Array(this.readBuffer(len));
      }
      readArray(fn3) {
        const len = this.readU32();
        const result = Array();
        for (let i4 = 0; i4 < len; ++i4) {
          result.push(fn3());
        }
        return result;
      }
    };
    __decorate([
      handlingRangeError
    ], BinaryReader.prototype, "readU8", null);
    __decorate([
      handlingRangeError
    ], BinaryReader.prototype, "readU16", null);
    __decorate([
      handlingRangeError
    ], BinaryReader.prototype, "readU32", null);
    __decorate([
      handlingRangeError
    ], BinaryReader.prototype, "readU64", null);
    __decorate([
      handlingRangeError
    ], BinaryReader.prototype, "readU128", null);
    __decorate([
      handlingRangeError
    ], BinaryReader.prototype, "readU256", null);
    __decorate([
      handlingRangeError
    ], BinaryReader.prototype, "readU512", null);
    __decorate([
      handlingRangeError
    ], BinaryReader.prototype, "readString", null);
    __decorate([
      handlingRangeError
    ], BinaryReader.prototype, "readFixedArray", null);
    __decorate([
      handlingRangeError
    ], BinaryReader.prototype, "readArray", null);
    exports.BinaryReader = BinaryReader;
    function capitalizeFirstLetter(string2) {
      return string2.charAt(0).toUpperCase() + string2.slice(1);
    }
    function serializeField(schema, fieldName, value2, fieldType, writer) {
      try {
        if (typeof fieldType === "string") {
          writer[`write${capitalizeFirstLetter(fieldType)}`](value2);
        } else if (fieldType instanceof Array) {
          if (typeof fieldType[0] === "number") {
            if (value2.length !== fieldType[0]) {
              throw new BorshError(`Expecting byte array of length ${fieldType[0]}, but got ${value2.length} bytes`);
            }
            writer.writeFixedArray(value2);
          } else if (fieldType.length === 2 && typeof fieldType[1] === "number") {
            if (value2.length !== fieldType[1]) {
              throw new BorshError(`Expecting byte array of length ${fieldType[1]}, but got ${value2.length} bytes`);
            }
            for (let i4 = 0; i4 < fieldType[1]; i4++) {
              serializeField(schema, null, value2[i4], fieldType[0], writer);
            }
          } else {
            writer.writeArray(value2, (item) => {
              serializeField(schema, fieldName, item, fieldType[0], writer);
            });
          }
        } else if (fieldType.kind !== void 0) {
          switch (fieldType.kind) {
            case "option": {
              if (value2 === null || value2 === void 0) {
                writer.writeU8(0);
              } else {
                writer.writeU8(1);
                serializeField(schema, fieldName, value2, fieldType.type, writer);
              }
              break;
            }
            case "map": {
              writer.writeU32(value2.size);
              value2.forEach((val, key) => {
                serializeField(schema, fieldName, key, fieldType.key, writer);
                serializeField(schema, fieldName, val, fieldType.value, writer);
              });
              break;
            }
            default:
              throw new BorshError(`FieldType ${fieldType} unrecognized`);
          }
        } else {
          serializeStruct(schema, value2, writer);
        }
      } catch (error) {
        if (error instanceof BorshError) {
          error.addToFieldPath(fieldName);
        }
        throw error;
      }
    }
    function serializeStruct(schema, obj, writer) {
      if (typeof obj.borshSerialize === "function") {
        obj.borshSerialize(writer);
        return;
      }
      const structSchema = schema.get(obj.constructor);
      if (!structSchema) {
        throw new BorshError(`Class ${obj.constructor.name} is missing in schema`);
      }
      if (structSchema.kind === "struct") {
        structSchema.fields.map(([fieldName, fieldType]) => {
          serializeField(schema, fieldName, obj[fieldName], fieldType, writer);
        });
      } else if (structSchema.kind === "enum") {
        const name = obj[structSchema.field];
        for (let idx = 0; idx < structSchema.values.length; ++idx) {
          const [fieldName, fieldType] = structSchema.values[idx];
          if (fieldName === name) {
            writer.writeU8(idx);
            serializeField(schema, fieldName, obj[fieldName], fieldType, writer);
            break;
          }
        }
      } else {
        throw new BorshError(`Unexpected schema kind: ${structSchema.kind} for ${obj.constructor.name}`);
      }
    }
    function serialize2(schema, obj, Writer = BinaryWriter) {
      const writer = new Writer();
      serializeStruct(schema, obj, writer);
      return writer.toArray();
    }
    exports.serialize = serialize2;
    function deserializeField(schema, fieldName, fieldType, reader) {
      try {
        if (typeof fieldType === "string") {
          return reader[`read${capitalizeFirstLetter(fieldType)}`]();
        }
        if (fieldType instanceof Array) {
          if (typeof fieldType[0] === "number") {
            return reader.readFixedArray(fieldType[0]);
          } else if (typeof fieldType[1] === "number") {
            const arr = [];
            for (let i4 = 0; i4 < fieldType[1]; i4++) {
              arr.push(deserializeField(schema, null, fieldType[0], reader));
            }
            return arr;
          } else {
            return reader.readArray(() => deserializeField(schema, fieldName, fieldType[0], reader));
          }
        }
        if (fieldType.kind === "option") {
          const option = reader.readU8();
          if (option) {
            return deserializeField(schema, fieldName, fieldType.type, reader);
          }
          return void 0;
        }
        if (fieldType.kind === "map") {
          let map = /* @__PURE__ */ new Map();
          const length = reader.readU32();
          for (let i4 = 0; i4 < length; i4++) {
            const key = deserializeField(schema, fieldName, fieldType.key, reader);
            const val = deserializeField(schema, fieldName, fieldType.value, reader);
            map.set(key, val);
          }
          return map;
        }
        return deserializeStruct(schema, fieldType, reader);
      } catch (error) {
        if (error instanceof BorshError) {
          error.addToFieldPath(fieldName);
        }
        throw error;
      }
    }
    function deserializeStruct(schema, classType, reader) {
      if (typeof classType.borshDeserialize === "function") {
        return classType.borshDeserialize(reader);
      }
      const structSchema = schema.get(classType);
      if (!structSchema) {
        throw new BorshError(`Class ${classType.name} is missing in schema`);
      }
      if (structSchema.kind === "struct") {
        const result = {};
        for (const [fieldName, fieldType] of schema.get(classType).fields) {
          result[fieldName] = deserializeField(schema, fieldName, fieldType, reader);
        }
        return new classType(result);
      }
      if (structSchema.kind === "enum") {
        const idx = reader.readU8();
        if (idx >= structSchema.values.length) {
          throw new BorshError(`Enum index: ${idx} is out of range`);
        }
        const [fieldName, fieldType] = structSchema.values[idx];
        const fieldValue = deserializeField(schema, fieldName, fieldType, reader);
        return new classType({ [fieldName]: fieldValue });
      }
      throw new BorshError(`Unexpected schema kind: ${structSchema.kind} for ${classType.constructor.name}`);
    }
    function deserialize2(schema, classType, buffer, Reader = BinaryReader) {
      const reader = new Reader(buffer);
      const result = deserializeStruct(schema, classType, reader);
      if (reader.offset < buffer.length) {
        throw new BorshError(`Unexpected ${buffer.length - reader.offset} bytes after deserialized data`);
      }
      return result;
    }
    exports.deserialize = deserialize2;
    function deserializeUnchecked2(schema, classType, buffer, Reader = BinaryReader) {
      const reader = new Reader(buffer);
      return deserializeStruct(schema, classType, reader);
    }
    exports.deserializeUnchecked = deserializeUnchecked2;
  }
});

// node_modules/@solana/buffer-layout/lib/Layout.js
var require_Layout = __commonJS({
  "node_modules/@solana/buffer-layout/lib/Layout.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.s16 = exports.s8 = exports.nu64be = exports.u48be = exports.u40be = exports.u32be = exports.u24be = exports.u16be = exports.nu64 = exports.u48 = exports.u40 = exports.u32 = exports.u24 = exports.u16 = exports.u8 = exports.offset = exports.greedy = exports.Constant = exports.UTF8 = exports.CString = exports.Blob = exports.Boolean = exports.BitField = exports.BitStructure = exports.VariantLayout = exports.Union = exports.UnionLayoutDiscriminator = exports.UnionDiscriminator = exports.Structure = exports.Sequence = exports.DoubleBE = exports.Double = exports.FloatBE = exports.Float = exports.NearInt64BE = exports.NearInt64 = exports.NearUInt64BE = exports.NearUInt64 = exports.IntBE = exports.Int = exports.UIntBE = exports.UInt = exports.OffsetLayout = exports.GreedyCount = exports.ExternalLayout = exports.bindConstructorLayout = exports.nameWithProperty = exports.Layout = exports.uint8ArrayToBuffer = exports.checkUint8Array = void 0;
    exports.constant = exports.utf8 = exports.cstr = exports.blob = exports.unionLayoutDiscriminator = exports.union = exports.seq = exports.bits = exports.struct = exports.f64be = exports.f64 = exports.f32be = exports.f32 = exports.ns64be = exports.s48be = exports.s40be = exports.s32be = exports.s24be = exports.s16be = exports.ns64 = exports.s48 = exports.s40 = exports.s32 = exports.s24 = void 0;
    var buffer_1 = require_buffer();
    function checkUint8Array(b3) {
      if (!(b3 instanceof Uint8Array)) {
        throw new TypeError("b must be a Uint8Array");
      }
    }
    exports.checkUint8Array = checkUint8Array;
    function uint8ArrayToBuffer(b3) {
      checkUint8Array(b3);
      return buffer_1.Buffer.from(b3.buffer, b3.byteOffset, b3.length);
    }
    exports.uint8ArrayToBuffer = uint8ArrayToBuffer;
    var Layout = class {
      constructor(span, property) {
        if (!Number.isInteger(span)) {
          throw new TypeError("span must be an integer");
        }
        this.span = span;
        this.property = property;
      }
      /** Function to create an Object into which decoded properties will
       * be written.
       *
       * Used only for layouts that {@link Layout#decode|decode} to Object
       * instances, which means:
       * * {@link Structure}
       * * {@link Union}
       * * {@link VariantLayout}
       * * {@link BitStructure}
       *
       * If left undefined the JavaScript representation of these layouts
       * will be Object instances.
       *
       * See {@link bindConstructorLayout}.
       */
      makeDestinationObject() {
        return {};
      }
      /**
       * Calculate the span of a specific instance of a layout.
       *
       * @param {Uint8Array} b - the buffer that contains an encoded instance.
       *
       * @param {Number} [offset] - the offset at which the encoded instance
       * starts.  If absent a zero offset is inferred.
       *
       * @return {Number} - the number of bytes covered by the layout
       * instance.  If this method is not overridden in a subclass the
       * definition-time constant {@link Layout#span|span} will be
       * returned.
       *
       * @throws {RangeError} - if the length of the value cannot be
       * determined.
       */
      getSpan(b3, offset2) {
        if (0 > this.span) {
          throw new RangeError("indeterminate span");
        }
        return this.span;
      }
      /**
       * Replicate the layout using a new property.
       *
       * This function must be used to get a structurally-equivalent layout
       * with a different name since all {@link Layout} instances are
       * immutable.
       *
       * **NOTE** This is a shallow copy.  All fields except {@link
       * Layout#property|property} are strictly equal to the origin layout.
       *
       * @param {String} property - the value for {@link
       * Layout#property|property} in the replica.
       *
       * @returns {Layout} - the copy with {@link Layout#property|property}
       * set to `property`.
       */
      replicate(property) {
        const rv = Object.create(this.constructor.prototype);
        Object.assign(rv, this);
        rv.property = property;
        return rv;
      }
      /**
       * Create an object from layout properties and an array of values.
       *
       * **NOTE** This function returns `undefined` if invoked on a layout
       * that does not return its value as an Object.  Objects are
       * returned for things that are a {@link Structure}, which includes
       * {@link VariantLayout|variant layouts} if they are structures, and
       * excludes {@link Union}s.  If you want this feature for a union
       * you must use {@link Union.getVariant|getVariant} to select the
       * desired layout.
       *
       * @param {Array} values - an array of values that correspond to the
       * default order for properties.  As with {@link Layout#decode|decode}
       * layout elements that have no property name are skipped when
       * iterating over the array values.  Only the top-level properties are
       * assigned; arguments are not assigned to properties of contained
       * layouts.  Any unused values are ignored.
       *
       * @return {(Object|undefined)}
       */
      fromArray(values) {
        return void 0;
      }
    };
    exports.Layout = Layout;
    function nameWithProperty(name, lo2) {
      if (lo2.property) {
        return name + "[" + lo2.property + "]";
      }
      return name;
    }
    exports.nameWithProperty = nameWithProperty;
    function bindConstructorLayout(Class, layout) {
      if ("function" !== typeof Class) {
        throw new TypeError("Class must be constructor");
      }
      if (Object.prototype.hasOwnProperty.call(Class, "layout_")) {
        throw new Error("Class is already bound to a layout");
      }
      if (!(layout && layout instanceof Layout)) {
        throw new TypeError("layout must be a Layout");
      }
      if (Object.prototype.hasOwnProperty.call(layout, "boundConstructor_")) {
        throw new Error("layout is already bound to a constructor");
      }
      Class.layout_ = layout;
      layout.boundConstructor_ = Class;
      layout.makeDestinationObject = () => new Class();
      Object.defineProperty(Class.prototype, "encode", {
        value(b3, offset2) {
          return layout.encode(this, b3, offset2);
        },
        writable: true
      });
      Object.defineProperty(Class, "decode", {
        value(b3, offset2) {
          return layout.decode(b3, offset2);
        },
        writable: true
      });
    }
    exports.bindConstructorLayout = bindConstructorLayout;
    var ExternalLayout = class extends Layout {
      /**
       * Return `true` iff the external layout decodes to an unsigned
       * integer layout.
       *
       * In that case it can be used as the source of {@link
       * Sequence#count|Sequence counts}, {@link Blob#length|Blob lengths},
       * or as {@link UnionLayoutDiscriminator#layout|external union
       * discriminators}.
       *
       * @abstract
       */
      isCount() {
        throw new Error("ExternalLayout is abstract");
      }
    };
    exports.ExternalLayout = ExternalLayout;
    var GreedyCount = class extends ExternalLayout {
      constructor(elementSpan = 1, property) {
        if (!Number.isInteger(elementSpan) || 0 >= elementSpan) {
          throw new TypeError("elementSpan must be a (positive) integer");
        }
        super(-1, property);
        this.elementSpan = elementSpan;
      }
      /** @override */
      isCount() {
        return true;
      }
      /** @override */
      decode(b3, offset2 = 0) {
        checkUint8Array(b3);
        const rem = b3.length - offset2;
        return Math.floor(rem / this.elementSpan);
      }
      /** @override */
      encode(src, b3, offset2) {
        return 0;
      }
    };
    exports.GreedyCount = GreedyCount;
    var OffsetLayout = class extends ExternalLayout {
      constructor(layout, offset2 = 0, property) {
        if (!(layout instanceof Layout)) {
          throw new TypeError("layout must be a Layout");
        }
        if (!Number.isInteger(offset2)) {
          throw new TypeError("offset must be integer or undefined");
        }
        super(layout.span, property || layout.property);
        this.layout = layout;
        this.offset = offset2;
      }
      /** @override */
      isCount() {
        return this.layout instanceof UInt || this.layout instanceof UIntBE;
      }
      /** @override */
      decode(b3, offset2 = 0) {
        return this.layout.decode(b3, offset2 + this.offset);
      }
      /** @override */
      encode(src, b3, offset2 = 0) {
        return this.layout.encode(src, b3, offset2 + this.offset);
      }
    };
    exports.OffsetLayout = OffsetLayout;
    var UInt = class extends Layout {
      constructor(span, property) {
        super(span, property);
        if (6 < this.span) {
          throw new RangeError("span must not exceed 6 bytes");
        }
      }
      /** @override */
      decode(b3, offset2 = 0) {
        return uint8ArrayToBuffer(b3).readUIntLE(offset2, this.span);
      }
      /** @override */
      encode(src, b3, offset2 = 0) {
        uint8ArrayToBuffer(b3).writeUIntLE(src, offset2, this.span);
        return this.span;
      }
    };
    exports.UInt = UInt;
    var UIntBE = class extends Layout {
      constructor(span, property) {
        super(span, property);
        if (6 < this.span) {
          throw new RangeError("span must not exceed 6 bytes");
        }
      }
      /** @override */
      decode(b3, offset2 = 0) {
        return uint8ArrayToBuffer(b3).readUIntBE(offset2, this.span);
      }
      /** @override */
      encode(src, b3, offset2 = 0) {
        uint8ArrayToBuffer(b3).writeUIntBE(src, offset2, this.span);
        return this.span;
      }
    };
    exports.UIntBE = UIntBE;
    var Int = class extends Layout {
      constructor(span, property) {
        super(span, property);
        if (6 < this.span) {
          throw new RangeError("span must not exceed 6 bytes");
        }
      }
      /** @override */
      decode(b3, offset2 = 0) {
        return uint8ArrayToBuffer(b3).readIntLE(offset2, this.span);
      }
      /** @override */
      encode(src, b3, offset2 = 0) {
        uint8ArrayToBuffer(b3).writeIntLE(src, offset2, this.span);
        return this.span;
      }
    };
    exports.Int = Int;
    var IntBE = class extends Layout {
      constructor(span, property) {
        super(span, property);
        if (6 < this.span) {
          throw new RangeError("span must not exceed 6 bytes");
        }
      }
      /** @override */
      decode(b3, offset2 = 0) {
        return uint8ArrayToBuffer(b3).readIntBE(offset2, this.span);
      }
      /** @override */
      encode(src, b3, offset2 = 0) {
        uint8ArrayToBuffer(b3).writeIntBE(src, offset2, this.span);
        return this.span;
      }
    };
    exports.IntBE = IntBE;
    var V2E32 = Math.pow(2, 32);
    function divmodInt64(src) {
      const hi32 = Math.floor(src / V2E32);
      const lo32 = src - hi32 * V2E32;
      return { hi32, lo32 };
    }
    function roundedInt64(hi32, lo32) {
      return hi32 * V2E32 + lo32;
    }
    var NearUInt64 = class extends Layout {
      constructor(property) {
        super(8, property);
      }
      /** @override */
      decode(b3, offset2 = 0) {
        const buffer = uint8ArrayToBuffer(b3);
        const lo32 = buffer.readUInt32LE(offset2);
        const hi32 = buffer.readUInt32LE(offset2 + 4);
        return roundedInt64(hi32, lo32);
      }
      /** @override */
      encode(src, b3, offset2 = 0) {
        const split = divmodInt64(src);
        const buffer = uint8ArrayToBuffer(b3);
        buffer.writeUInt32LE(split.lo32, offset2);
        buffer.writeUInt32LE(split.hi32, offset2 + 4);
        return 8;
      }
    };
    exports.NearUInt64 = NearUInt64;
    var NearUInt64BE = class extends Layout {
      constructor(property) {
        super(8, property);
      }
      /** @override */
      decode(b3, offset2 = 0) {
        const buffer = uint8ArrayToBuffer(b3);
        const hi32 = buffer.readUInt32BE(offset2);
        const lo32 = buffer.readUInt32BE(offset2 + 4);
        return roundedInt64(hi32, lo32);
      }
      /** @override */
      encode(src, b3, offset2 = 0) {
        const split = divmodInt64(src);
        const buffer = uint8ArrayToBuffer(b3);
        buffer.writeUInt32BE(split.hi32, offset2);
        buffer.writeUInt32BE(split.lo32, offset2 + 4);
        return 8;
      }
    };
    exports.NearUInt64BE = NearUInt64BE;
    var NearInt64 = class extends Layout {
      constructor(property) {
        super(8, property);
      }
      /** @override */
      decode(b3, offset2 = 0) {
        const buffer = uint8ArrayToBuffer(b3);
        const lo32 = buffer.readUInt32LE(offset2);
        const hi32 = buffer.readInt32LE(offset2 + 4);
        return roundedInt64(hi32, lo32);
      }
      /** @override */
      encode(src, b3, offset2 = 0) {
        const split = divmodInt64(src);
        const buffer = uint8ArrayToBuffer(b3);
        buffer.writeUInt32LE(split.lo32, offset2);
        buffer.writeInt32LE(split.hi32, offset2 + 4);
        return 8;
      }
    };
    exports.NearInt64 = NearInt64;
    var NearInt64BE = class extends Layout {
      constructor(property) {
        super(8, property);
      }
      /** @override */
      decode(b3, offset2 = 0) {
        const buffer = uint8ArrayToBuffer(b3);
        const hi32 = buffer.readInt32BE(offset2);
        const lo32 = buffer.readUInt32BE(offset2 + 4);
        return roundedInt64(hi32, lo32);
      }
      /** @override */
      encode(src, b3, offset2 = 0) {
        const split = divmodInt64(src);
        const buffer = uint8ArrayToBuffer(b3);
        buffer.writeInt32BE(split.hi32, offset2);
        buffer.writeUInt32BE(split.lo32, offset2 + 4);
        return 8;
      }
    };
    exports.NearInt64BE = NearInt64BE;
    var Float = class extends Layout {
      constructor(property) {
        super(4, property);
      }
      /** @override */
      decode(b3, offset2 = 0) {
        return uint8ArrayToBuffer(b3).readFloatLE(offset2);
      }
      /** @override */
      encode(src, b3, offset2 = 0) {
        uint8ArrayToBuffer(b3).writeFloatLE(src, offset2);
        return 4;
      }
    };
    exports.Float = Float;
    var FloatBE = class extends Layout {
      constructor(property) {
        super(4, property);
      }
      /** @override */
      decode(b3, offset2 = 0) {
        return uint8ArrayToBuffer(b3).readFloatBE(offset2);
      }
      /** @override */
      encode(src, b3, offset2 = 0) {
        uint8ArrayToBuffer(b3).writeFloatBE(src, offset2);
        return 4;
      }
    };
    exports.FloatBE = FloatBE;
    var Double = class extends Layout {
      constructor(property) {
        super(8, property);
      }
      /** @override */
      decode(b3, offset2 = 0) {
        return uint8ArrayToBuffer(b3).readDoubleLE(offset2);
      }
      /** @override */
      encode(src, b3, offset2 = 0) {
        uint8ArrayToBuffer(b3).writeDoubleLE(src, offset2);
        return 8;
      }
    };
    exports.Double = Double;
    var DoubleBE = class extends Layout {
      constructor(property) {
        super(8, property);
      }
      /** @override */
      decode(b3, offset2 = 0) {
        return uint8ArrayToBuffer(b3).readDoubleBE(offset2);
      }
      /** @override */
      encode(src, b3, offset2 = 0) {
        uint8ArrayToBuffer(b3).writeDoubleBE(src, offset2);
        return 8;
      }
    };
    exports.DoubleBE = DoubleBE;
    var Sequence = class extends Layout {
      constructor(elementLayout, count, property) {
        if (!(elementLayout instanceof Layout)) {
          throw new TypeError("elementLayout must be a Layout");
        }
        if (!(count instanceof ExternalLayout && count.isCount() || Number.isInteger(count) && 0 <= count)) {
          throw new TypeError("count must be non-negative integer or an unsigned integer ExternalLayout");
        }
        let span = -1;
        if (!(count instanceof ExternalLayout) && 0 < elementLayout.span) {
          span = count * elementLayout.span;
        }
        super(span, property);
        this.elementLayout = elementLayout;
        this.count = count;
      }
      /** @override */
      getSpan(b3, offset2 = 0) {
        if (0 <= this.span) {
          return this.span;
        }
        let span = 0;
        let count = this.count;
        if (count instanceof ExternalLayout) {
          count = count.decode(b3, offset2);
        }
        if (0 < this.elementLayout.span) {
          span = count * this.elementLayout.span;
        } else {
          let idx = 0;
          while (idx < count) {
            span += this.elementLayout.getSpan(b3, offset2 + span);
            ++idx;
          }
        }
        return span;
      }
      /** @override */
      decode(b3, offset2 = 0) {
        const rv = [];
        let i4 = 0;
        let count = this.count;
        if (count instanceof ExternalLayout) {
          count = count.decode(b3, offset2);
        }
        while (i4 < count) {
          rv.push(this.elementLayout.decode(b3, offset2));
          offset2 += this.elementLayout.getSpan(b3, offset2);
          i4 += 1;
        }
        return rv;
      }
      /** Implement {@link Layout#encode|encode} for {@link Sequence}.
       *
       * **NOTE** If `src` is shorter than {@link Sequence#count|count} then
       * the unused space in the buffer is left unchanged.  If `src` is
       * longer than {@link Sequence#count|count} the unneeded elements are
       * ignored.
       *
       * **NOTE** If {@link Layout#count|count} is an instance of {@link
       * ExternalLayout} then the length of `src` will be encoded as the
       * count after `src` is encoded. */
      encode(src, b3, offset2 = 0) {
        const elo = this.elementLayout;
        const span = src.reduce((span2, v2) => {
          return span2 + elo.encode(v2, b3, offset2 + span2);
        }, 0);
        if (this.count instanceof ExternalLayout) {
          this.count.encode(src.length, b3, offset2);
        }
        return span;
      }
    };
    exports.Sequence = Sequence;
    var Structure = class extends Layout {
      constructor(fields, property, decodePrefixes) {
        if (!(Array.isArray(fields) && fields.reduce((acc, v2) => acc && v2 instanceof Layout, true))) {
          throw new TypeError("fields must be array of Layout instances");
        }
        if ("boolean" === typeof property && void 0 === decodePrefixes) {
          decodePrefixes = property;
          property = void 0;
        }
        for (const fd2 of fields) {
          if (0 > fd2.span && void 0 === fd2.property) {
            throw new Error("fields cannot contain unnamed variable-length layout");
          }
        }
        let span = -1;
        try {
          span = fields.reduce((span2, fd2) => span2 + fd2.getSpan(), 0);
        } catch (e9) {
        }
        super(span, property);
        this.fields = fields;
        this.decodePrefixes = !!decodePrefixes;
      }
      /** @override */
      getSpan(b3, offset2 = 0) {
        if (0 <= this.span) {
          return this.span;
        }
        let span = 0;
        try {
          span = this.fields.reduce((span2, fd2) => {
            const fsp = fd2.getSpan(b3, offset2);
            offset2 += fsp;
            return span2 + fsp;
          }, 0);
        } catch (e9) {
          throw new RangeError("indeterminate span");
        }
        return span;
      }
      /** @override */
      decode(b3, offset2 = 0) {
        checkUint8Array(b3);
        const dest = this.makeDestinationObject();
        for (const fd2 of this.fields) {
          if (void 0 !== fd2.property) {
            dest[fd2.property] = fd2.decode(b3, offset2);
          }
          offset2 += fd2.getSpan(b3, offset2);
          if (this.decodePrefixes && b3.length === offset2) {
            break;
          }
        }
        return dest;
      }
      /** Implement {@link Layout#encode|encode} for {@link Structure}.
       *
       * If `src` is missing a property for a member with a defined {@link
       * Layout#property|property} the corresponding region of the buffer is
       * left unmodified. */
      encode(src, b3, offset2 = 0) {
        const firstOffset = offset2;
        let lastOffset = 0;
        let lastWrote = 0;
        for (const fd2 of this.fields) {
          let span = fd2.span;
          lastWrote = 0 < span ? span : 0;
          if (void 0 !== fd2.property) {
            const fv = src[fd2.property];
            if (void 0 !== fv) {
              lastWrote = fd2.encode(fv, b3, offset2);
              if (0 > span) {
                span = fd2.getSpan(b3, offset2);
              }
            }
          }
          lastOffset = offset2;
          offset2 += span;
        }
        return lastOffset + lastWrote - firstOffset;
      }
      /** @override */
      fromArray(values) {
        const dest = this.makeDestinationObject();
        for (const fd2 of this.fields) {
          if (void 0 !== fd2.property && 0 < values.length) {
            dest[fd2.property] = values.shift();
          }
        }
        return dest;
      }
      /**
       * Get access to the layout of a given property.
       *
       * @param {String} property - the structure member of interest.
       *
       * @return {Layout} - the layout associated with `property`, or
       * undefined if there is no such property.
       */
      layoutFor(property) {
        if ("string" !== typeof property) {
          throw new TypeError("property must be string");
        }
        for (const fd2 of this.fields) {
          if (fd2.property === property) {
            return fd2;
          }
        }
        return void 0;
      }
      /**
       * Get the offset of a structure member.
       *
       * @param {String} property - the structure member of interest.
       *
       * @return {Number} - the offset in bytes to the start of `property`
       * within the structure, or undefined if `property` is not a field
       * within the structure.  If the property is a member but follows a
       * variable-length structure member a negative number will be
       * returned.
       */
      offsetOf(property) {
        if ("string" !== typeof property) {
          throw new TypeError("property must be string");
        }
        let offset2 = 0;
        for (const fd2 of this.fields) {
          if (fd2.property === property) {
            return offset2;
          }
          if (0 > fd2.span) {
            offset2 = -1;
          } else if (0 <= offset2) {
            offset2 += fd2.span;
          }
        }
        return void 0;
      }
    };
    exports.Structure = Structure;
    var UnionDiscriminator = class {
      constructor(property) {
        this.property = property;
      }
      /** Analog to {@link Layout#decode|Layout decode} for union discriminators.
       *
       * The implementation of this method need not reference the buffer if
       * variant information is available through other means. */
      decode(b3, offset2) {
        throw new Error("UnionDiscriminator is abstract");
      }
      /** Analog to {@link Layout#decode|Layout encode} for union discriminators.
       *
       * The implementation of this method need not store the value if
       * variant information is maintained through other means. */
      encode(src, b3, offset2) {
        throw new Error("UnionDiscriminator is abstract");
      }
    };
    exports.UnionDiscriminator = UnionDiscriminator;
    var UnionLayoutDiscriminator = class extends UnionDiscriminator {
      constructor(layout, property) {
        if (!(layout instanceof ExternalLayout && layout.isCount())) {
          throw new TypeError("layout must be an unsigned integer ExternalLayout");
        }
        super(property || layout.property || "variant");
        this.layout = layout;
      }
      /** Delegate decoding to {@link UnionLayoutDiscriminator#layout|layout}. */
      decode(b3, offset2) {
        return this.layout.decode(b3, offset2);
      }
      /** Delegate encoding to {@link UnionLayoutDiscriminator#layout|layout}. */
      encode(src, b3, offset2) {
        return this.layout.encode(src, b3, offset2);
      }
    };
    exports.UnionLayoutDiscriminator = UnionLayoutDiscriminator;
    var Union = class extends Layout {
      constructor(discr, defaultLayout, property) {
        let discriminator;
        if (discr instanceof UInt || discr instanceof UIntBE) {
          discriminator = new UnionLayoutDiscriminator(new OffsetLayout(discr));
        } else if (discr instanceof ExternalLayout && discr.isCount()) {
          discriminator = new UnionLayoutDiscriminator(discr);
        } else if (!(discr instanceof UnionDiscriminator)) {
          throw new TypeError("discr must be a UnionDiscriminator or an unsigned integer layout");
        } else {
          discriminator = discr;
        }
        if (void 0 === defaultLayout) {
          defaultLayout = null;
        }
        if (!(null === defaultLayout || defaultLayout instanceof Layout)) {
          throw new TypeError("defaultLayout must be null or a Layout");
        }
        if (null !== defaultLayout) {
          if (0 > defaultLayout.span) {
            throw new Error("defaultLayout must have constant span");
          }
          if (void 0 === defaultLayout.property) {
            defaultLayout = defaultLayout.replicate("content");
          }
        }
        let span = -1;
        if (defaultLayout) {
          span = defaultLayout.span;
          if (0 <= span && (discr instanceof UInt || discr instanceof UIntBE)) {
            span += discriminator.layout.span;
          }
        }
        super(span, property);
        this.discriminator = discriminator;
        this.usesPrefixDiscriminator = discr instanceof UInt || discr instanceof UIntBE;
        this.defaultLayout = defaultLayout;
        this.registry = {};
        let boundGetSourceVariant = this.defaultGetSourceVariant.bind(this);
        this.getSourceVariant = function(src) {
          return boundGetSourceVariant(src);
        };
        this.configGetSourceVariant = function(gsv) {
          boundGetSourceVariant = gsv.bind(this);
        };
      }
      /** @override */
      getSpan(b3, offset2 = 0) {
        if (0 <= this.span) {
          return this.span;
        }
        const vlo = this.getVariant(b3, offset2);
        if (!vlo) {
          throw new Error("unable to determine span for unrecognized variant");
        }
        return vlo.getSpan(b3, offset2);
      }
      /**
       * Method to infer a registered Union variant compatible with `src`.
       *
       * The first satisfied rule in the following sequence defines the
       * return value:
       * * If `src` has properties matching the Union discriminator and
       *   the default layout, `undefined` is returned regardless of the
       *   value of the discriminator property (this ensures the default
       *   layout will be used);
       * * If `src` has a property matching the Union discriminator, the
       *   value of the discriminator identifies a registered variant, and
       *   either (a) the variant has no layout, or (b) `src` has the
       *   variant's property, then the variant is returned (because the
       *   source satisfies the constraints of the variant it identifies);
       * * If `src` does not have a property matching the Union
       *   discriminator, but does have a property matching a registered
       *   variant, then the variant is returned (because the source
       *   matches a variant without an explicit conflict);
       * * An error is thrown (because we either can't identify a variant,
       *   or we were explicitly told the variant but can't satisfy it).
       *
       * @param {Object} src - an object presumed to be compatible with
       * the content of the Union.
       *
       * @return {(undefined|VariantLayout)} - as described above.
       *
       * @throws {Error} - if `src` cannot be associated with a default or
       * registered variant.
       */
      defaultGetSourceVariant(src) {
        if (Object.prototype.hasOwnProperty.call(src, this.discriminator.property)) {
          if (this.defaultLayout && this.defaultLayout.property && Object.prototype.hasOwnProperty.call(src, this.defaultLayout.property)) {
            return void 0;
          }
          const vlo = this.registry[src[this.discriminator.property]];
          if (vlo && (!vlo.layout || vlo.property && Object.prototype.hasOwnProperty.call(src, vlo.property))) {
            return vlo;
          }
        } else {
          for (const tag in this.registry) {
            const vlo = this.registry[tag];
            if (vlo.property && Object.prototype.hasOwnProperty.call(src, vlo.property)) {
              return vlo;
            }
          }
        }
        throw new Error("unable to infer src variant");
      }
      /** Implement {@link Layout#decode|decode} for {@link Union}.
       *
       * If the variant is {@link Union#addVariant|registered} the return
       * value is an instance of that variant, with no explicit
       * discriminator.  Otherwise the {@link Union#defaultLayout|default
       * layout} is used to decode the content. */
      decode(b3, offset2 = 0) {
        let dest;
        const dlo = this.discriminator;
        const discr = dlo.decode(b3, offset2);
        const clo = this.registry[discr];
        if (void 0 === clo) {
          const defaultLayout = this.defaultLayout;
          let contentOffset = 0;
          if (this.usesPrefixDiscriminator) {
            contentOffset = dlo.layout.span;
          }
          dest = this.makeDestinationObject();
          dest[dlo.property] = discr;
          dest[defaultLayout.property] = defaultLayout.decode(b3, offset2 + contentOffset);
        } else {
          dest = clo.decode(b3, offset2);
        }
        return dest;
      }
      /** Implement {@link Layout#encode|encode} for {@link Union}.
       *
       * This API assumes the `src` object is consistent with the union's
       * {@link Union#defaultLayout|default layout}.  To encode variants
       * use the appropriate variant-specific {@link VariantLayout#encode}
       * method. */
      encode(src, b3, offset2 = 0) {
        const vlo = this.getSourceVariant(src);
        if (void 0 === vlo) {
          const dlo = this.discriminator;
          const clo = this.defaultLayout;
          let contentOffset = 0;
          if (this.usesPrefixDiscriminator) {
            contentOffset = dlo.layout.span;
          }
          dlo.encode(src[dlo.property], b3, offset2);
          return contentOffset + clo.encode(src[clo.property], b3, offset2 + contentOffset);
        }
        return vlo.encode(src, b3, offset2);
      }
      /** Register a new variant structure within a union.  The newly
       * created variant is returned.
       *
       * @param {Number} variant - initializer for {@link
       * VariantLayout#variant|variant}.
       *
       * @param {Layout} layout - initializer for {@link
       * VariantLayout#layout|layout}.
       *
       * @param {String} property - initializer for {@link
       * Layout#property|property}.
       *
       * @return {VariantLayout} */
      addVariant(variant, layout, property) {
        const rv = new VariantLayout(this, variant, layout, property);
        this.registry[variant] = rv;
        return rv;
      }
      /**
       * Get the layout associated with a registered variant.
       *
       * If `vb` does not produce a registered variant the function returns
       * `undefined`.
       *
       * @param {(Number|Uint8Array)} vb - either the variant number, or a
       * buffer from which the discriminator is to be read.
       *
       * @param {Number} offset - offset into `vb` for the start of the
       * union.  Used only when `vb` is an instance of {Uint8Array}.
       *
       * @return {({VariantLayout}|undefined)}
       */
      getVariant(vb, offset2 = 0) {
        let variant;
        if (vb instanceof Uint8Array) {
          variant = this.discriminator.decode(vb, offset2);
        } else {
          variant = vb;
        }
        return this.registry[variant];
      }
    };
    exports.Union = Union;
    var VariantLayout = class extends Layout {
      constructor(union2, variant, layout, property) {
        if (!(union2 instanceof Union)) {
          throw new TypeError("union must be a Union");
        }
        if (!Number.isInteger(variant) || 0 > variant) {
          throw new TypeError("variant must be a (non-negative) integer");
        }
        if ("string" === typeof layout && void 0 === property) {
          property = layout;
          layout = null;
        }
        if (layout) {
          if (!(layout instanceof Layout)) {
            throw new TypeError("layout must be a Layout");
          }
          if (null !== union2.defaultLayout && 0 <= layout.span && layout.span > union2.defaultLayout.span) {
            throw new Error("variant span exceeds span of containing union");
          }
          if ("string" !== typeof property) {
            throw new TypeError("variant must have a String property");
          }
        }
        let span = union2.span;
        if (0 > union2.span) {
          span = layout ? layout.span : 0;
          if (0 <= span && union2.usesPrefixDiscriminator) {
            span += union2.discriminator.layout.span;
          }
        }
        super(span, property);
        this.union = union2;
        this.variant = variant;
        this.layout = layout || null;
      }
      /** @override */
      getSpan(b3, offset2 = 0) {
        if (0 <= this.span) {
          return this.span;
        }
        let contentOffset = 0;
        if (this.union.usesPrefixDiscriminator) {
          contentOffset = this.union.discriminator.layout.span;
        }
        let span = 0;
        if (this.layout) {
          span = this.layout.getSpan(b3, offset2 + contentOffset);
        }
        return contentOffset + span;
      }
      /** @override */
      decode(b3, offset2 = 0) {
        const dest = this.makeDestinationObject();
        if (this !== this.union.getVariant(b3, offset2)) {
          throw new Error("variant mismatch");
        }
        let contentOffset = 0;
        if (this.union.usesPrefixDiscriminator) {
          contentOffset = this.union.discriminator.layout.span;
        }
        if (this.layout) {
          dest[this.property] = this.layout.decode(b3, offset2 + contentOffset);
        } else if (this.property) {
          dest[this.property] = true;
        } else if (this.union.usesPrefixDiscriminator) {
          dest[this.union.discriminator.property] = this.variant;
        }
        return dest;
      }
      /** @override */
      encode(src, b3, offset2 = 0) {
        let contentOffset = 0;
        if (this.union.usesPrefixDiscriminator) {
          contentOffset = this.union.discriminator.layout.span;
        }
        if (this.layout && !Object.prototype.hasOwnProperty.call(src, this.property)) {
          throw new TypeError("variant lacks property " + this.property);
        }
        this.union.discriminator.encode(this.variant, b3, offset2);
        let span = contentOffset;
        if (this.layout) {
          this.layout.encode(src[this.property], b3, offset2 + contentOffset);
          span += this.layout.getSpan(b3, offset2 + contentOffset);
          if (0 <= this.union.span && span > this.union.span) {
            throw new Error("encoded variant overruns containing union");
          }
        }
        return span;
      }
      /** Delegate {@link Layout#fromArray|fromArray} to {@link
       * VariantLayout#layout|layout}. */
      fromArray(values) {
        if (this.layout) {
          return this.layout.fromArray(values);
        }
        return void 0;
      }
    };
    exports.VariantLayout = VariantLayout;
    function fixBitwiseResult(v2) {
      if (0 > v2) {
        v2 += 4294967296;
      }
      return v2;
    }
    var BitStructure = class extends Layout {
      constructor(word, msb, property) {
        if (!(word instanceof UInt || word instanceof UIntBE)) {
          throw new TypeError("word must be a UInt or UIntBE layout");
        }
        if ("string" === typeof msb && void 0 === property) {
          property = msb;
          msb = false;
        }
        if (4 < word.span) {
          throw new RangeError("word cannot exceed 32 bits");
        }
        super(word.span, property);
        this.word = word;
        this.msb = !!msb;
        this.fields = [];
        let value2 = 0;
        this._packedSetValue = function(v2) {
          value2 = fixBitwiseResult(v2);
          return this;
        };
        this._packedGetValue = function() {
          return value2;
        };
      }
      /** @override */
      decode(b3, offset2 = 0) {
        const dest = this.makeDestinationObject();
        const value2 = this.word.decode(b3, offset2);
        this._packedSetValue(value2);
        for (const fd2 of this.fields) {
          if (void 0 !== fd2.property) {
            dest[fd2.property] = fd2.decode(b3);
          }
        }
        return dest;
      }
      /** Implement {@link Layout#encode|encode} for {@link BitStructure}.
       *
       * If `src` is missing a property for a member with a defined {@link
       * Layout#property|property} the corresponding region of the packed
       * value is left unmodified.  Unused bits are also left unmodified. */
      encode(src, b3, offset2 = 0) {
        const value2 = this.word.decode(b3, offset2);
        this._packedSetValue(value2);
        for (const fd2 of this.fields) {
          if (void 0 !== fd2.property) {
            const fv = src[fd2.property];
            if (void 0 !== fv) {
              fd2.encode(fv);
            }
          }
        }
        return this.word.encode(this._packedGetValue(), b3, offset2);
      }
      /** Register a new bitfield with a containing bit structure.  The
       * resulting bitfield is returned.
       *
       * @param {Number} bits - initializer for {@link BitField#bits|bits}.
       *
       * @param {string} property - initializer for {@link
       * Layout#property|property}.
       *
       * @return {BitField} */
      addField(bits, property) {
        const bf2 = new BitField(this, bits, property);
        this.fields.push(bf2);
        return bf2;
      }
      /** As with {@link BitStructure#addField|addField} for single-bit
       * fields with `boolean` value representation.
       *
       * @param {string} property - initializer for {@link
       * Layout#property|property}.
       *
       * @return {Boolean} */
      // `Boolean` conflicts with the native primitive type
      // eslint-disable-next-line @typescript-eslint/ban-types
      addBoolean(property) {
        const bf2 = new Boolean2(this, property);
        this.fields.push(bf2);
        return bf2;
      }
      /**
       * Get access to the bit field for a given property.
       *
       * @param {String} property - the bit field of interest.
       *
       * @return {BitField} - the field associated with `property`, or
       * undefined if there is no such property.
       */
      fieldFor(property) {
        if ("string" !== typeof property) {
          throw new TypeError("property must be string");
        }
        for (const fd2 of this.fields) {
          if (fd2.property === property) {
            return fd2;
          }
        }
        return void 0;
      }
    };
    exports.BitStructure = BitStructure;
    var BitField = class {
      constructor(container, bits, property) {
        if (!(container instanceof BitStructure)) {
          throw new TypeError("container must be a BitStructure");
        }
        if (!Number.isInteger(bits) || 0 >= bits) {
          throw new TypeError("bits must be positive integer");
        }
        const totalBits = 8 * container.span;
        const usedBits = container.fields.reduce((sum, fd2) => sum + fd2.bits, 0);
        if (bits + usedBits > totalBits) {
          throw new Error("bits too long for span remainder (" + (totalBits - usedBits) + " of " + totalBits + " remain)");
        }
        this.container = container;
        this.bits = bits;
        this.valueMask = (1 << bits) - 1;
        if (32 === bits) {
          this.valueMask = 4294967295;
        }
        this.start = usedBits;
        if (this.container.msb) {
          this.start = totalBits - usedBits - bits;
        }
        this.wordMask = fixBitwiseResult(this.valueMask << this.start);
        this.property = property;
      }
      /** Store a value into the corresponding subsequence of the containing
       * bit field. */
      decode(b3, offset2) {
        const word = this.container._packedGetValue();
        const wordValue = fixBitwiseResult(word & this.wordMask);
        const value2 = wordValue >>> this.start;
        return value2;
      }
      /** Store a value into the corresponding subsequence of the containing
       * bit field.
       *
       * **NOTE** This is not a specialization of {@link
       * Layout#encode|Layout.encode} and there is no return value. */
      encode(value2) {
        if ("number" !== typeof value2 || !Number.isInteger(value2) || value2 !== fixBitwiseResult(value2 & this.valueMask)) {
          throw new TypeError(nameWithProperty("BitField.encode", this) + " value must be integer not exceeding " + this.valueMask);
        }
        const word = this.container._packedGetValue();
        const wordValue = fixBitwiseResult(value2 << this.start);
        this.container._packedSetValue(fixBitwiseResult(word & ~this.wordMask) | wordValue);
      }
    };
    exports.BitField = BitField;
    var Boolean2 = class extends BitField {
      constructor(container, property) {
        super(container, 1, property);
      }
      /** Override {@link BitField#decode|decode} for {@link Boolean|Boolean}.
       *
       * @returns {boolean} */
      decode(b3, offset2) {
        return !!super.decode(b3, offset2);
      }
      /** @override */
      encode(value2) {
        if ("boolean" === typeof value2) {
          value2 = +value2;
        }
        super.encode(value2);
      }
    };
    exports.Boolean = Boolean2;
    var Blob2 = class extends Layout {
      constructor(length, property) {
        if (!(length instanceof ExternalLayout && length.isCount() || Number.isInteger(length) && 0 <= length)) {
          throw new TypeError("length must be positive integer or an unsigned integer ExternalLayout");
        }
        let span = -1;
        if (!(length instanceof ExternalLayout)) {
          span = length;
        }
        super(span, property);
        this.length = length;
      }
      /** @override */
      getSpan(b3, offset2) {
        let span = this.span;
        if (0 > span) {
          span = this.length.decode(b3, offset2);
        }
        return span;
      }
      /** @override */
      decode(b3, offset2 = 0) {
        let span = this.span;
        if (0 > span) {
          span = this.length.decode(b3, offset2);
        }
        return uint8ArrayToBuffer(b3).slice(offset2, offset2 + span);
      }
      /** Implement {@link Layout#encode|encode} for {@link Blob}.
       *
       * **NOTE** If {@link Layout#count|count} is an instance of {@link
       * ExternalLayout} then the length of `src` will be encoded as the
       * count after `src` is encoded. */
      encode(src, b3, offset2) {
        let span = this.length;
        if (this.length instanceof ExternalLayout) {
          span = src.length;
        }
        if (!(src instanceof Uint8Array && span === src.length)) {
          throw new TypeError(nameWithProperty("Blob.encode", this) + " requires (length " + span + ") Uint8Array as src");
        }
        if (offset2 + span > b3.length) {
          throw new RangeError("encoding overruns Uint8Array");
        }
        const srcBuffer = uint8ArrayToBuffer(src);
        uint8ArrayToBuffer(b3).write(srcBuffer.toString("hex"), offset2, span, "hex");
        if (this.length instanceof ExternalLayout) {
          this.length.encode(span, b3, offset2);
        }
        return span;
      }
    };
    exports.Blob = Blob2;
    var CString = class extends Layout {
      constructor(property) {
        super(-1, property);
      }
      /** @override */
      getSpan(b3, offset2 = 0) {
        checkUint8Array(b3);
        let idx = offset2;
        while (idx < b3.length && 0 !== b3[idx]) {
          idx += 1;
        }
        return 1 + idx - offset2;
      }
      /** @override */
      decode(b3, offset2 = 0) {
        const span = this.getSpan(b3, offset2);
        return uint8ArrayToBuffer(b3).slice(offset2, offset2 + span - 1).toString("utf-8");
      }
      /** @override */
      encode(src, b3, offset2 = 0) {
        if ("string" !== typeof src) {
          src = String(src);
        }
        const srcb = buffer_1.Buffer.from(src, "utf8");
        const span = srcb.length;
        if (offset2 + span > b3.length) {
          throw new RangeError("encoding overruns Buffer");
        }
        const buffer = uint8ArrayToBuffer(b3);
        srcb.copy(buffer, offset2);
        buffer[offset2 + span] = 0;
        return span + 1;
      }
    };
    exports.CString = CString;
    var UTF8 = class extends Layout {
      constructor(maxSpan, property) {
        if ("string" === typeof maxSpan && void 0 === property) {
          property = maxSpan;
          maxSpan = void 0;
        }
        if (void 0 === maxSpan) {
          maxSpan = -1;
        } else if (!Number.isInteger(maxSpan)) {
          throw new TypeError("maxSpan must be an integer");
        }
        super(-1, property);
        this.maxSpan = maxSpan;
      }
      /** @override */
      getSpan(b3, offset2 = 0) {
        checkUint8Array(b3);
        return b3.length - offset2;
      }
      /** @override */
      decode(b3, offset2 = 0) {
        const span = this.getSpan(b3, offset2);
        if (0 <= this.maxSpan && this.maxSpan < span) {
          throw new RangeError("text length exceeds maxSpan");
        }
        return uint8ArrayToBuffer(b3).slice(offset2, offset2 + span).toString("utf-8");
      }
      /** @override */
      encode(src, b3, offset2 = 0) {
        if ("string" !== typeof src) {
          src = String(src);
        }
        const srcb = buffer_1.Buffer.from(src, "utf8");
        const span = srcb.length;
        if (0 <= this.maxSpan && this.maxSpan < span) {
          throw new RangeError("text length exceeds maxSpan");
        }
        if (offset2 + span > b3.length) {
          throw new RangeError("encoding overruns Buffer");
        }
        srcb.copy(uint8ArrayToBuffer(b3), offset2);
        return span;
      }
    };
    exports.UTF8 = UTF8;
    var Constant = class extends Layout {
      constructor(value2, property) {
        super(0, property);
        this.value = value2;
      }
      /** @override */
      decode(b3, offset2) {
        return this.value;
      }
      /** @override */
      encode(src, b3, offset2) {
        return 0;
      }
    };
    exports.Constant = Constant;
    exports.greedy = (elementSpan, property) => new GreedyCount(elementSpan, property);
    exports.offset = (layout, offset2, property) => new OffsetLayout(layout, offset2, property);
    exports.u8 = (property) => new UInt(1, property);
    exports.u16 = (property) => new UInt(2, property);
    exports.u24 = (property) => new UInt(3, property);
    exports.u32 = (property) => new UInt(4, property);
    exports.u40 = (property) => new UInt(5, property);
    exports.u48 = (property) => new UInt(6, property);
    exports.nu64 = (property) => new NearUInt64(property);
    exports.u16be = (property) => new UIntBE(2, property);
    exports.u24be = (property) => new UIntBE(3, property);
    exports.u32be = (property) => new UIntBE(4, property);
    exports.u40be = (property) => new UIntBE(5, property);
    exports.u48be = (property) => new UIntBE(6, property);
    exports.nu64be = (property) => new NearUInt64BE(property);
    exports.s8 = (property) => new Int(1, property);
    exports.s16 = (property) => new Int(2, property);
    exports.s24 = (property) => new Int(3, property);
    exports.s32 = (property) => new Int(4, property);
    exports.s40 = (property) => new Int(5, property);
    exports.s48 = (property) => new Int(6, property);
    exports.ns64 = (property) => new NearInt64(property);
    exports.s16be = (property) => new IntBE(2, property);
    exports.s24be = (property) => new IntBE(3, property);
    exports.s32be = (property) => new IntBE(4, property);
    exports.s40be = (property) => new IntBE(5, property);
    exports.s48be = (property) => new IntBE(6, property);
    exports.ns64be = (property) => new NearInt64BE(property);
    exports.f32 = (property) => new Float(property);
    exports.f32be = (property) => new FloatBE(property);
    exports.f64 = (property) => new Double(property);
    exports.f64be = (property) => new DoubleBE(property);
    exports.struct = (fields, property, decodePrefixes) => new Structure(fields, property, decodePrefixes);
    exports.bits = (word, msb, property) => new BitStructure(word, msb, property);
    exports.seq = (elementLayout, count, property) => new Sequence(elementLayout, count, property);
    exports.union = (discr, defaultLayout, property) => new Union(discr, defaultLayout, property);
    exports.unionLayoutDiscriminator = (layout, property) => new UnionLayoutDiscriminator(layout, property);
    exports.blob = (length, property) => new Blob2(length, property);
    exports.cstr = (property) => new CString(property);
    exports.utf8 = (maxSpan, property) => new UTF8(maxSpan, property);
    exports.constant = (value2, property) => new Constant(value2, property);
  }
});

// node_modules/jayson/lib/generateRequest.js
var require_generateRequest = __commonJS({
  "node_modules/jayson/lib/generateRequest.js"(exports, module) {
    "use strict";
    var uuid = (init_esm_browser(), __toCommonJS(esm_browser_exports)).v4;
    var generateRequest = function(method, params, id2, options) {
      if (typeof method !== "string") {
        throw new TypeError(method + " must be a string");
      }
      options = options || {};
      const version2 = typeof options.version === "number" ? options.version : 2;
      if (version2 !== 1 && version2 !== 2) {
        throw new TypeError(version2 + " must be 1 or 2");
      }
      const request = {
        method
      };
      if (version2 === 2) {
        request.jsonrpc = "2.0";
      }
      if (params) {
        if (typeof params !== "object" && !Array.isArray(params)) {
          throw new TypeError(params + " must be an object, array or omitted");
        }
        request.params = params;
      }
      if (typeof id2 === "undefined") {
        const generator = typeof options.generator === "function" ? options.generator : function() {
          return uuid();
        };
        request.id = generator(request, options);
      } else if (version2 === 2 && id2 === null) {
        if (options.notificationIdNull) {
          request.id = null;
        }
      } else {
        request.id = id2;
      }
      return request;
    };
    module.exports = generateRequest;
  }
});

// node_modules/jayson/lib/client/browser/index.js
var require_browser2 = __commonJS({
  "node_modules/jayson/lib/client/browser/index.js"(exports, module) {
    "use strict";
    var uuid = (init_esm_browser(), __toCommonJS(esm_browser_exports)).v4;
    var generateRequest = require_generateRequest();
    var ClientBrowser = function(callServer, options) {
      if (!(this instanceof ClientBrowser)) {
        return new ClientBrowser(callServer, options);
      }
      if (!options) {
        options = {};
      }
      this.options = {
        reviver: typeof options.reviver !== "undefined" ? options.reviver : null,
        replacer: typeof options.replacer !== "undefined" ? options.replacer : null,
        generator: typeof options.generator !== "undefined" ? options.generator : function() {
          return uuid();
        },
        version: typeof options.version !== "undefined" ? options.version : 2,
        notificationIdNull: typeof options.notificationIdNull === "boolean" ? options.notificationIdNull : false
      };
      this.callServer = callServer;
    };
    module.exports = ClientBrowser;
    ClientBrowser.prototype.request = function(method, params, id2, callback) {
      const self2 = this;
      let request = null;
      const isBatch = Array.isArray(method) && typeof params === "function";
      if (this.options.version === 1 && isBatch) {
        throw new TypeError("JSON-RPC 1.0 does not support batching");
      }
      const isRaw = !isBatch && method && typeof method === "object" && typeof params === "function";
      if (isBatch || isRaw) {
        callback = params;
        request = method;
      } else {
        if (typeof id2 === "function") {
          callback = id2;
          id2 = void 0;
        }
        const hasCallback = typeof callback === "function";
        try {
          request = generateRequest(method, params, id2, {
            generator: this.options.generator,
            version: this.options.version,
            notificationIdNull: this.options.notificationIdNull
          });
        } catch (err) {
          if (hasCallback) {
            return callback(err);
          }
          throw err;
        }
        if (!hasCallback) {
          return request;
        }
      }
      let message;
      try {
        message = JSON.stringify(request, this.options.replacer);
      } catch (err) {
        return callback(err);
      }
      this.callServer(message, function(err, response) {
        self2._parseResponse(err, response, callback);
      });
      return request;
    };
    ClientBrowser.prototype._parseResponse = function(err, responseText, callback) {
      if (err) {
        callback(err);
        return;
      }
      if (!responseText) {
        return callback();
      }
      let response;
      try {
        response = JSON.parse(responseText, this.options.reviver);
      } catch (err2) {
        return callback(err2);
      }
      if (callback.length === 3) {
        if (Array.isArray(response)) {
          const isError = function(res) {
            return typeof res.error !== "undefined";
          };
          const isNotError = function(res) {
            return !isError(res);
          };
          return callback(null, response.filter(isError), response.filter(isNotError));
        } else {
          return callback(null, response.error, response.result);
        }
      }
      callback(null, response);
    };
  }
});

// node_modules/rpc-websockets/node_modules/eventemitter3/index.js
var require_eventemitter3 = __commonJS({
  "node_modules/rpc-websockets/node_modules/eventemitter3/index.js"(exports, module) {
    "use strict";
    var has = Object.prototype.hasOwnProperty;
    var prefix = "~";
    function Events() {
    }
    if (Object.create) {
      Events.prototype = /* @__PURE__ */ Object.create(null);
      if (!new Events().__proto__) prefix = false;
    }
    function EE(fn3, context, once) {
      this.fn = fn3;
      this.context = context;
      this.once = once || false;
    }
    function addListener(emitter, event, fn3, context, once) {
      if (typeof fn3 !== "function") {
        throw new TypeError("The listener must be a function");
      }
      var listener = new EE(fn3, context || emitter, once), evt = prefix ? prefix + event : event;
      if (!emitter._events[evt]) emitter._events[evt] = listener, emitter._eventsCount++;
      else if (!emitter._events[evt].fn) emitter._events[evt].push(listener);
      else emitter._events[evt] = [emitter._events[evt], listener];
      return emitter;
    }
    function clearEvent(emitter, evt) {
      if (--emitter._eventsCount === 0) emitter._events = new Events();
      else delete emitter._events[evt];
    }
    function EventEmitter2() {
      this._events = new Events();
      this._eventsCount = 0;
    }
    EventEmitter2.prototype.eventNames = function eventNames() {
      var names = [], events, name;
      if (this._eventsCount === 0) return names;
      for (name in events = this._events) {
        if (has.call(events, name)) names.push(prefix ? name.slice(1) : name);
      }
      if (Object.getOwnPropertySymbols) {
        return names.concat(Object.getOwnPropertySymbols(events));
      }
      return names;
    };
    EventEmitter2.prototype.listeners = function listeners(event) {
      var evt = prefix ? prefix + event : event, handlers = this._events[evt];
      if (!handlers) return [];
      if (handlers.fn) return [handlers.fn];
      for (var i4 = 0, l5 = handlers.length, ee3 = new Array(l5); i4 < l5; i4++) {
        ee3[i4] = handlers[i4].fn;
      }
      return ee3;
    };
    EventEmitter2.prototype.listenerCount = function listenerCount(event) {
      var evt = prefix ? prefix + event : event, listeners = this._events[evt];
      if (!listeners) return 0;
      if (listeners.fn) return 1;
      return listeners.length;
    };
    EventEmitter2.prototype.emit = function emit(event, a1, a2, a3, a4, a5) {
      var evt = prefix ? prefix + event : event;
      if (!this._events[evt]) return false;
      var listeners = this._events[evt], len = arguments.length, args, i4;
      if (listeners.fn) {
        if (listeners.once) this.removeListener(event, listeners.fn, void 0, true);
        switch (len) {
          case 1:
            return listeners.fn.call(listeners.context), true;
          case 2:
            return listeners.fn.call(listeners.context, a1), true;
          case 3:
            return listeners.fn.call(listeners.context, a1, a2), true;
          case 4:
            return listeners.fn.call(listeners.context, a1, a2, a3), true;
          case 5:
            return listeners.fn.call(listeners.context, a1, a2, a3, a4), true;
          case 6:
            return listeners.fn.call(listeners.context, a1, a2, a3, a4, a5), true;
        }
        for (i4 = 1, args = new Array(len - 1); i4 < len; i4++) {
          args[i4 - 1] = arguments[i4];
        }
        listeners.fn.apply(listeners.context, args);
      } else {
        var length = listeners.length, j4;
        for (i4 = 0; i4 < length; i4++) {
          if (listeners[i4].once) this.removeListener(event, listeners[i4].fn, void 0, true);
          switch (len) {
            case 1:
              listeners[i4].fn.call(listeners[i4].context);
              break;
            case 2:
              listeners[i4].fn.call(listeners[i4].context, a1);
              break;
            case 3:
              listeners[i4].fn.call(listeners[i4].context, a1, a2);
              break;
            case 4:
              listeners[i4].fn.call(listeners[i4].context, a1, a2, a3);
              break;
            default:
              if (!args) for (j4 = 1, args = new Array(len - 1); j4 < len; j4++) {
                args[j4 - 1] = arguments[j4];
              }
              listeners[i4].fn.apply(listeners[i4].context, args);
          }
        }
      }
      return true;
    };
    EventEmitter2.prototype.on = function on3(event, fn3, context) {
      return addListener(this, event, fn3, context, false);
    };
    EventEmitter2.prototype.once = function once(event, fn3, context) {
      return addListener(this, event, fn3, context, true);
    };
    EventEmitter2.prototype.removeListener = function removeListener(event, fn3, context, once) {
      var evt = prefix ? prefix + event : event;
      if (!this._events[evt]) return this;
      if (!fn3) {
        clearEvent(this, evt);
        return this;
      }
      var listeners = this._events[evt];
      if (listeners.fn) {
        if (listeners.fn === fn3 && (!once || listeners.once) && (!context || listeners.context === context)) {
          clearEvent(this, evt);
        }
      } else {
        for (var i4 = 0, events = [], length = listeners.length; i4 < length; i4++) {
          if (listeners[i4].fn !== fn3 || once && !listeners[i4].once || context && listeners[i4].context !== context) {
            events.push(listeners[i4]);
          }
        }
        if (events.length) this._events[evt] = events.length === 1 ? events[0] : events;
        else clearEvent(this, evt);
      }
      return this;
    };
    EventEmitter2.prototype.removeAllListeners = function removeAllListeners(event) {
      var evt;
      if (event) {
        evt = prefix ? prefix + event : event;
        if (this._events[evt]) clearEvent(this, evt);
      } else {
        this._events = new Events();
        this._eventsCount = 0;
      }
      return this;
    };
    EventEmitter2.prototype.off = EventEmitter2.prototype.removeListener;
    EventEmitter2.prototype.addListener = EventEmitter2.prototype.on;
    EventEmitter2.prefixed = prefix;
    EventEmitter2.EventEmitter = EventEmitter2;
    if ("undefined" !== typeof module) {
      module.exports = EventEmitter2;
    }
  }
});

// node_modules/@cartridge/controller/dist/provider-ClUbos7A.js
var T = "0.8.0";
var d = {
  version: T
};
var w = ((e9) => (e9.SUCCESS = "SUCCESS", e9.NOT_CONNECTED = "NOT_CONNECTED", e9.ERROR = "ERROR", e9.CANCELED = "CANCELED", e9.USER_INTERACTION_REQUIRED = "USER_INTERACTION_REQUIRED", e9))(w || {});
var l = ((e9) => (e9.PAYMASTER = "PAYMASTER", e9.CREDITS = "CREDITS", e9))(l || {});
var C2 = /* @__PURE__ */ new Set([
  "contracts",
  "messages",
  "target",
  "method",
  "name",
  "description",
  "types",
  "domain",
  "primaryType"
]);
function m(e9) {
  if (!C2.has(e9))
    throw new Error(`Invalid property name: ${e9}`);
}
function s(e9, t3) {
  return m(t3), e9[t3];
}
function Q2(e9) {
  return n2(e9).map((t3) => ({
    entrypoint: t3.entrypoint,
    contractAddress: addAddressPadding(t3.contractAddress),
    calldata: CallData.toHex(t3.calldata)
  }));
}
function x(e9) {
  return Array.isArray(e9) ? e9.reduce(
    (t3, M4) => {
      if (s(M4, "target")) {
        const N3 = getChecksumAddress(
          s(M4, "target")
        ), a = s(M4, "method"), r2 = s(
          t3,
          "contracts"
        ), c3 = {
          name: h(a),
          entrypoint: a,
          description: s(M4, "description")
        };
        if (N3 in r2) {
          const u2 = n2(r2[N3].methods);
          r2[N3] = {
            methods: [...u2, c3]
          };
        } else
          r2[N3] = {
            methods: [c3]
          };
      } else
        s(t3, "messages").push(M4);
      return t3;
    },
    { contracts: {}, messages: [] }
  ) : e9;
}
function U2(e9) {
  return [
    ...Object.entries(e9.contracts ?? {}).flatMap(
      ([t3, { methods: M4 }]) => n2(M4).map((N3) => ({
        target: t3,
        method: N3.entrypoint,
        authorized: N3.authorized
      }))
    ),
    ...(e9.messages ?? []).map((t3) => {
      const M4 = typedData_exports.getStructHash(
        t3.types,
        "StarknetDomain",
        t3.domain,
        TypedDataRevision.ACTIVE
      ), N3 = typedData_exports.getTypeHash(
        t3.types,
        t3.primaryType,
        TypedDataRevision.ACTIVE
      );
      return {
        scope_hash: hash_exports.computePoseidonHash(M4, N3),
        authorized: t3.authorized
      };
    })
  ];
}
function n2(e9) {
  return Array.isArray(e9) ? e9 : [e9];
}
function h(e9) {
  return e9.replace(/([a-z])([A-Z])/g, "$1 $2").replace(/_/g, " ").toLowerCase().replace(/^\w/, (t3) => t3.toUpperCase());
}
function k(e9) {
  const t3 = e9.pathname.split("/");
  if (e9.hostname === "localhost" || e9.hostname === "127.0.0.1" || e9.hostname === "0.0.0.0") {
    if (typeof XMLHttpRequest > "u")
      return console.warn(
        `Cannot make synchronous HTTP call in Node.js environment for ${e9.toString()}`
      ), shortString_exports.encodeShortString("LOCALHOST");
    const M4 = new XMLHttpRequest();
    M4.open("POST", e9.toString(), false), M4.setRequestHeader("Content-Type", "application/json");
    const N3 = JSON.stringify({
      jsonrpc: "2.0",
      method: "starknet_chainId",
      params: [],
      id: 1
    });
    try {
      if (M4.send(N3), M4.status === 200) {
        const a = JSON.parse(M4.responseText);
        if (a.result)
          return a.result;
      }
      throw new Error(
        `Failed to get chain ID from ${e9.toString()}: ${M4.status} ${M4.statusText}`
      );
    } catch (a) {
      throw new Error(`Failed to connect to ${e9.toString()}: ${a}`);
    }
  }
  if (t3.includes("starknet")) {
    if (t3.includes("mainnet"))
      return constants_exports.StarknetChainId.SN_MAIN;
    if (t3.includes("sepolia"))
      return constants_exports.StarknetChainId.SN_SEPOLIA;
  } else if (t3.length >= 3) {
    const M4 = t3[2];
    if (t3.includes("katana"))
      return shortString_exports.encodeShortString(
        `WP_${M4.toUpperCase().replace(/-/g, "_")}`
      );
    if (t3.includes("mainnet"))
      return shortString_exports.encodeShortString(
        `GG_${M4.toUpperCase().replace(/-/g, "_")}`
      );
  }
  throw new Error(`Chain ${e9.toString()} not supported`);
}
var j = class _j extends Error {
  constructor() {
    super("Not ready to connect"), Object.setPrototypeOf(this, _j.prototype);
  }
};
var f = "https://x.cartridge.gg";
var P = "https://profile.cartridge.gg";
var b = "https://api.cartridge.gg";
var O = {
  ACCOUNTS: "accounts"
};
var L2 = "data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iODAwIiBoZWlnaHQ9IjgwMCIgdmlld0JveD0iMCAwIDgwMCA4MDAiIGZpbGw9Im5vbmUiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyI+CjxnIGZpbHRlcj0idXJsKCNmaWx0ZXIwX2RfNTExMl83ODIpIj4KPHBhdGggZD0iTTQ2OS4yMzYgNzBDNDgyLjM5IDcwIDQ5My4wNTMgODAuNjYzIDQ5My4wNTMgOTMuODE2NFYxNDcuMTQ3TDUxNS4zMzggMTQ3LjE0N0w1MTUuNDI4IDE0Ny4xNDdMNTE1LjU1NCAxNDcuMTQ3TDUxNS44MjYgMTQ3LjE0OUM1MTYuMDE2IDE0Ny4xNTEgNTE2LjIyNSAxNDcuMTUzIDUxNi40NTEgMTQ3LjE1N0M1MTYuOTA0IDE0Ny4xNjQgNTE3LjQyOCAxNDcuMTc2IDUxOC4wMiAxNDcuMTk1QzUxOS4yMDEgMTQ3LjIzNCA1MjAuNjYgMTQ3LjMwNCA1MjIuMzYxIDE0Ny40MjRDNTI1Ljc0MSAxNDcuNjYzIDUzMC4xODUgMTQ4LjExNCA1MzUuMzYzIDE0OC45NjlDNTQ1LjAwMSAxNTAuNTYyIDU1OC41NTYgMTUzLjc4IDU3Mi45MTggMTYwLjYwM0w3MzAuNDIgMjI2LjY3MUw3MzIuMTAxIDIyNy41MDVDNzcxLjc4NyAyNDcuMTc3IDc4OS45OTMgMjg2LjI5NiA3ODkuOTkzIDMyMi4wMzZWNTg1Ljg2NUM3ODkuOTkzIDU4Ni4wNTQgNzg5Ljk5NCA1ODYuMjU0IDc4OS45OTQgNTg2LjQ2M0w3ODkuOTk2IDU4Ni45MTNDNzkwLjAzOCA1OTcuMDk2IDc5MC4xNjEgNjI2Ljk5NiA3NjQuMjMxIDY1Mi44MjNMNzE0Ljc2IDcwMi4wOTVMNzE0LjY0MSA3MDIuMjE1QzcwNC42MDEgNzEyLjI3NSA2OTIuMTIzIDcyMC42NTIgNjc2LjI4NCA3MjQuODc5QzY2NC4zOSA3MjguMDU0IDY1Mi44MjcgNzI3Ljk2NiA2NDguNjM3IDcyNy45MzRMNjQ4LjYxOSA3MjcuOTMzQzY0OC40MDkgNzI3LjkzMiA2NDguMjE5IDcyNy45MyA2NDguMDQ3IDcyNy45M0w2NDcuNzUyIDcyNy45MjlINDgwLjcyMUM0NzQuMDk0IDcyNy45MjkgNDY4LjcyMSA3MjIuNTU2IDQ2OC43MjEgNzE1LjkyOVY2NjguMzg4SDMyOC41ODZDMzI4LjU4NiA2NzIuNjI5IDMyOC41NzIgNjk4LjA1MiAzMjguNTYxIDcxNS45NDRDMzI4LjU1NyA3MjIuNTY5IDMyMy4xODYgNzI3LjkyOSAzMTYuNTYxIDcyNy45MjlIMTUyLjI0NkMxNTIuMTA0IDcyNy45MjkgMTUxLjk0MiA3MjcuOTI5IDE1MS43NjIgNzI3LjkzMUwxNTEuMzYyIDcyNy45MzRDMTQ3LjE3MiA3MjcuOTY2IDEzNS42MDkgNzI4LjA1NCAxMjMuNzE0IDcyNC44NzlDMTA3Ljg3MyA3MjAuNjUxIDk1LjM5MzggNzEyLjI3MiA4NS4zNTI5IDcwMi4yMUw4NS4yMzg2IDcwMi4wOTVMMzUuNjcgNjUyLjcyNUwzNS41NzIzIDY1Mi42MjdDOS44NjI0MiA2MjYuNzggOS45NjY3IDU5Ny4xODUgMTAuMDAzIDU4Ni44NzRDMTAuMDA0MyA1ODYuNTEzIDEwLjAwNTUgNTg2LjE3NyAxMC4wMDU1IDU4NS44NjVWMzIyLjAzNkMxMC4wMDU1IDI4Ni40MyAyOC4xNjYyIDI0Ny4xOTkgNjcuODk3NyAyMjcuNTA1TDY5LjU3OSAyMjYuNjcxTDIyNy4wODEgMTYwLjYwM0MyNDEuNDQzIDE1My43OCAyNTQuOTk4IDE1MC41NjIgMjY0LjYzNiAxNDguOTY5QzI2OS44MTQgMTQ4LjExNCAyNzQuMjU4IDE0Ny42NjMgMjc3LjYzOCAxNDcuNDI0QzI3OS4zMzggMTQ3LjMwNCAyODAuNzk4IDE0Ny4yMzQgMjgxLjk3OSAxNDcuMTk1QzI4Mi41NzEgMTQ3LjE3NiAyODMuMDk1IDE0Ny4xNjQgMjgzLjU0NyAxNDcuMTU3TDI4My45MTcgMTQ3LjE1MkwyODQuMTczIDE0Ny4xNDlMMjg0LjQ0NSAxNDcuMTQ3TDI4NC41NzEgMTQ3LjE0N0wyODQuNjYgMTQ3LjE0N0wzMDYuOTQyIDE0Ny4xNDdWOTMuODE2NEMzMDYuOTQyIDgwLjY2MyAzMTcuNjA1IDcwIDMzMC43NTggNzBINDY5LjIzNloiIGZpbGw9IiMxOTFBMUEiLz4KPHBhdGggZD0iTTM2Ni40ODMgMTI5LjU0SDQzMy41MTJWMjA2LjY4N0gzNjYuNDgzVjEyOS41NFoiIGZpbGw9IiNGQkNCNEEiLz4KPHBhdGggZD0iTTI2OS4wMSA2MDIuNDI5SDE0NC4wMDhDMTM1Ljc2OCA2MDIuNDI5IDEzNS43NjggNTk0LjE0NiAxMzUuNzY4IDU5NC4xNDZWMjgwLjg1QzEzNS43NjggMjgwLjg1IDEzNS43NjggMjcyLjY0NCAxNDQuMDA4IDI3Mi42NDRIMzY2LjQ4M0wzNjYuNDgzIDIwNi42ODdIMjg0LjY5QzI4NC42OSAyMDYuNjg3IDI2OC4xMzQgMjA2LjY4NyAyNTEuNTc5IDIxNC44OTNMOTQuMzQxNCAyODAuODVDNzcuNzg2MSAyODkuMDU3IDY5LjU0NjkgMzA1LjYyMyA2OS41NDY5IDMyMi4wMzVWNTg1Ljg2M0M2OS41NDY5IDU5NC4xNDcgNjkuNTQ2OSA2MDIuMzUzIDc3Ljc4NjEgNjEwLjYzNkwxMjcuNDUyIDY2MC4xMDRDMTM1LjY5MSA2NjguMzg3IDE0MS45MjggNjY4LjM4NyAxNTIuMjQ3IDY2OC4zODdIMjY5LjAyOUMyNjkuMDM3IDY0OC4zNCAyNjkuMDQ2IDYyNC42NTUgMjY5LjA1NCA2MDIuODg3SDUyOC4wMTNWNjY4LjM4N0g2NDcuNzUzQzY1OC4wNzEgNjY4LjM4NyA2NjQuMzA4IDY2OC4zODcgNjcyLjU0NyA2NjAuMTA0TDcyMi4yMTMgNjEwLjYzNkM3MzAuNDUzIDYwMi40MjkgNzMwLjQ1MyA1OTQuMTQ3IDczMC40NTMgNTg1Ljg2M1YzMjIuMDM1QzczMC40NTMgMzA1LjU0NiA3MjIuMjEzIDI4OS4wNTcgNzA1LjY1OCAyODAuODVMNTQ4LjQyMSAyMTQuODkzQzUzMS44NjUgMjA2LjY4NyA1MTUuMzEgMjA2LjY4NyA1MTUuMzEgMjA2LjY4N0g0MzMuNTEyTDQzMy41MTIgMjcyLjY0NEg2NTYuMDY5QzY2NC4zMDggMjcyLjY0NCA2NjQuMzA4IDI4MC44NSA2NjQuMzA4IDI4MC44NVY1OTQuMTQ2QzY2NC4zMDggNTk0LjE0NiA2NjQuMzA4IDYwMi40MjkgNjU2LjA2OSA2MDIuNDI5SDUyOC4yNjJWNTM3LjM5NkgyNjkuMDc1QzI2OS4wNzUgNTQzLjcwNyAyNjkuMDE3IDU5Ni45MTIgMjY5LjAxIDYwMi40MjlaIiBmaWxsPSIjRkJDQjRBIi8+CjxwYXRoIGQ9Ik0yNjkuMDA5IDQzNi4xNzJINTI4LjI2MlYzNzAuNjgxSDI2OS4wNzVDMjY5LjA3NSAzNzcuMzczIDI2OS4wMDkgNDM2Ljc4OCAyNjkuMDA5IDQzNi4xNzJaIiBmaWxsPSIjRkJDQjRBIi8+CjwvZz4KPGRlZnM+CjxmaWx0ZXIgaWQ9ImZpbHRlcjBfZF81MTEyXzc4MiIgeD0iLTQiIHk9IjAiIHdpZHRoPSI4MDgiIGhlaWdodD0iODA4IiBmaWx0ZXJVbml0cz0idXNlclNwYWNlT25Vc2UiIGNvbG9yLWludGVycG9sYXRpb24tZmlsdGVycz0ic1JHQiI+CjxmZUZsb29kIGZsb29kLW9wYWNpdHk9IjAiIHJlc3VsdD0iQmFja2dyb3VuZEltYWdlRml4Ii8+CjxmZUNvbG9yTWF0cml4IGluPSJTb3VyY2VBbHBoYSIgdHlwZT0ibWF0cml4IiB2YWx1ZXM9IjAgMCAwIDAgMCAwIDAgMCAwIDAgMCAwIDAgMCAwIDAgMCAwIDEyNyAwIiByZXN1bHQ9ImhhcmRBbHBoYSIvPgo8ZmVPZmZzZXQgZHk9IjQiLz4KPGZlR2F1c3NpYW5CbHVyIHN0ZERldmlhdGlvbj0iMiIvPgo8ZmVDb21wb3NpdGUgaW4yPSJoYXJkQWxwaGEiIG9wZXJhdG9yPSJvdXQiLz4KPGZlQ29sb3JNYXRyaXggdHlwZT0ibWF0cml4IiB2YWx1ZXM9IjAgMCAwIDAgMCAwIDAgMCAwIDAgMCAwIDAgMCAwIDAgMCAwIDAuMjUgMCIvPgo8ZmVCbGVuZCBtb2RlPSJub3JtYWwiIGluMj0iQmFja2dyb3VuZEltYWdlRml4IiByZXN1bHQ9ImVmZmVjdDFfZHJvcFNoYWRvd181MTEyXzc4MiIvPgo8ZmVCbGVuZCBtb2RlPSJub3JtYWwiIGluPSJTb3VyY2VHcmFwaGljIiBpbjI9ImVmZmVjdDFfZHJvcFNoYWRvd181MTEyXzc4MiIgcmVzdWx0PSJzaGFwZSIvPgo8L2ZpbHRlcj4KPC9kZWZzPgo8L3N2Zz4K";
function E() {
}
var S2 = class {
  constructor() {
    __publicField(this, "m_lastPromise", Promise.resolve());
  }
  /**
   * Acquire lock
   * @param [bypass=false] option to skip lock acquisition
   */
  async obtain(t3 = false) {
    let M4 = E;
    if (t3) return M4;
    const N3 = this.m_lastPromise;
    return this.m_lastPromise = new Promise((a) => M4 = a), await N3, M4;
  }
};
var p2 = new S2();
var Z = class {
  constructor() {
    __publicField(this, "id", "controller");
    __publicField(this, "name", "Controller");
    __publicField(this, "version", d.version);
    __publicField(this, "icon", L2);
    __publicField(this, "account");
    __publicField(this, "subscriptions", []);
    __publicField(this, "_probePromise", null);
    __publicField(this, "request", async (t3) => {
      switch (t3.type) {
        case "wallet_getPermissions":
          return await this.safeProbe(), this.account ? [O.ACCOUNTS] : [];
        case "wallet_requestAccounts": {
          if (this.account)
            return [this.account.address];
          const N3 = t3.params && t3.params.silent_mode;
          return this.account = await this.safeProbe(), !this.account && !N3 && (this.account = await this.connect()), this.account ? [this.account.address] : [];
        }
        case "wallet_watchAsset":
          throw {
            code: 63,
            message: "An unexpected error occurred",
            data: "wallet_watchAsset not implemented"
          };
        case "wallet_addStarknetChain": {
          let N3 = t3.params;
          return this.addStarknetChain(N3);
        }
        case "wallet_switchStarknetChain": {
          let N3 = t3.params;
          return this.switchStarknetChain(N3.chainId);
        }
        case "wallet_requestChainId":
          if (!this.account)
            throw {
              code: 63,
              message: "An unexpected error occurred",
              data: "Account not initialized"
            };
          return await this.account.getChainId();
        case "wallet_deploymentData":
          throw {
            code: 63,
            message: "An unexpected error occurred",
            data: "wallet_deploymentData not implemented"
          };
        case "wallet_addInvokeTransaction":
          if (!this.account)
            throw {
              code: 63,
              message: "An unexpected error occurred",
              data: "Account not initialized"
            };
          let M4 = t3.params;
          return await this.account.execute(
            M4.calls.map((N3) => ({
              contractAddress: N3.contract_address,
              entrypoint: N3.entry_point,
              calldata: N3.calldata
            }))
          );
        case "wallet_addDeclareTransaction":
          throw {
            code: 63,
            message: "An unexpected error occurred",
            data: "wallet_addDeclareTransaction not implemented"
          };
        case "wallet_signTypedData": {
          if (!this.account)
            throw {
              code: 63,
              message: "An unexpected error occurred",
              data: "Account not initialized"
            };
          return await this.account.signMessage(t3.params);
        }
        case "wallet_supportedSpecs":
          return [];
        case "wallet_supportedWalletApi":
          return [];
        default:
          throw {
            code: 63,
            message: "An unexpected error occurred",
            data: `Unknown RPC call type: ${t3.type}`
          };
      }
    });
    __publicField(this, "on", (t3, M4) => {
      if (t3 !== "accountsChanged" && t3 !== "networkChanged")
        throw new Error(`Unknown event: ${t3}`);
      this.subscriptions.push({ type: t3, handler: M4 });
    });
    __publicField(this, "off", (t3, M4) => {
      if (t3 !== "accountsChanged" && t3 !== "networkChanged")
        throw new Error(`Unknown event: ${t3}`);
      const N3 = this.subscriptions.findIndex(
        (a) => a.type === t3 && a.handler === M4
      );
      N3 >= 0 && this.subscriptions.splice(N3, 1);
    });
  }
  async safeProbe() {
    if (this.account)
      return this.account;
    if (this._probePromise)
      return this._probePromise;
    const t3 = await p2.obtain();
    return await new Promise(async (M4) => {
      try {
        this._probePromise = this.probe();
        const N3 = await this._probePromise;
        M4(N3);
      } finally {
        this._probePromise = null;
      }
    }).finally(() => {
      t3();
    });
  }
  emitNetworkChanged(t3) {
    this.subscriptions.filter((M4) => M4.type === "networkChanged").forEach((M4) => {
      M4.handler(t3);
    });
  }
  emitAccountsChanged(t3) {
    this.subscriptions.filter((M4) => M4.type === "accountsChanged").forEach((M4) => {
      M4.handler(t3);
    });
  }
};

// node_modules/starknetkit/dist/braavosMobile.js
var o = Object.defineProperty;
var l2 = (r2, e9, t3) => e9 in r2 ? o(r2, e9, { enumerable: true, configurable: true, writable: true, value: t3 }) : r2[e9] = t3;
var n3 = (r2, e9, t3) => (l2(r2, typeof e9 != "symbol" ? e9 + "" : e9, t3), t3);
var i = `<svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" width="32px" height="32px" viewBox="0 0 32 32" version="1.1">
    <defs>
    <clipPath id="clip1">
      <path d="M 5.332031 0 L 26.667969 0 C 29.613281 0 32 2.386719 32 5.332031 L 32 26.667969 C 32 29.613281 29.613281 32 26.667969 32 L 5.332031 32 C 2.386719 32 0 29.613281 0 26.667969 L 0 5.332031 C 0 2.386719 2.386719 0 5.332031 0 Z M 5.332031 0 "/>
    </clipPath>
    <linearGradient id="linear0" gradientUnits="userSpaceOnUse" x1="-9.552" y1="-6.444" x2="50.240002" y2="41.303001" gradientTransform="matrix(0.666667,0,0,0.666667,0,0)">
      <stop offset="0" style="stop-color:rgb(3.529412%,45.09804%,75.294119%);stop-opacity:1;"/>
      <stop offset="1" style="stop-color:rgb(10.980392%,28.627452%,87.058824%);stop-opacity:1;"/>
    </linearGradient>
    <clipPath id="clip2">
      <path d="M 7 4 L 25 4 L 25 15 L 7 15 Z M 7 4 "/>
    </clipPath>
    <clipPath id="clip3">
      <path d="M 5.332031 0 L 26.667969 0 C 29.613281 0 32 2.386719 32 5.332031 L 32 26.667969 C 32 29.613281 29.613281 32 26.667969 32 L 5.332031 32 C 2.386719 32 0 29.613281 0 26.667969 L 0 5.332031 C 0 2.386719 2.386719 0 5.332031 0 Z M 5.332031 0 "/>
    </clipPath>
    <clipPath id="clip4">
    	<path d="M 6 13 L 26 13 L 26 28 L 6 28 Z M 6 13 "/>
    </clipPath>
    <clipPath id="clip5">
      <path d="M 5.332031 0 L 26.667969 0 C 29.613281 0 32 2.386719 32 5.332031 L 32 26.667969 C 32 29.613281 29.613281 32 26.667969 32 L 5.332031 32 C 2.386719 32 0 29.613281 0 26.667969 L 0 5.332031 C 0 2.386719 2.386719 0 5.332031 0 Z M 5.332031 0 "/>
    </clipPath>
    </defs>
    <g id="surface1">
      <g clip-path="url(#clip1)" clip-rule="nonzero">
        <rect x="0" y="0" width="32" height="32" style="fill:url(#linear0);stroke:none;"/>
      </g>
    	<g clip-path="url(#clip2)" clip-rule="nonzero">
        <g clip-path="url(#clip3)" clip-rule="nonzero">
	        <path style=" stroke:none;fill-rule:nonzero;fill:rgb(100%,100%,100%);fill-opacity:1;" d="M 19.507812 6.320312 C 19.542969 6.378906 19.496094 6.453125 19.425781 6.453125 C 18.027344 6.453125 16.886719 7.5625 16.859375 8.941406 C 16.375 8.851562 15.878906 8.847656 15.390625 8.929688 C 15.359375 7.554688 14.222656 6.453125 12.824219 6.453125 C 12.757812 6.453125 12.710938 6.378906 12.746094 6.320312 C 13.453125 5.128906 14.738281 4.398438 16.125 4.398438 C 17.515625 4.394531 18.800781 5.125 19.507812 6.320312 M 23.65625 14.847656 C 24.132812 14.992188 24.585938 14.574219 24.402344 14.109375 C 23.066406 10.65625 19.109375 9.242188 16.105469 9.242188 C 13.097656 9.242188 9.054688 10.703125 7.804688 14.128906 C 7.632812 14.589844 8.082031 14.996094 8.550781 14.851562 L 15.75 12.648438 C 15.957031 12.582031 16.179688 12.582031 16.386719 12.644531 Z M 23.65625 14.847656 "/>
        </g>
    	</g>
    	<g clip-path="url(#clip4)" clip-rule="nonzero">
        <g clip-path="url(#clip5)" clip-rule="nonzero">
          <path style=" stroke:none;fill-rule:nonzero;fill:rgb(100%,100%,100%);fill-opacity:1;" d="M 7.734375 15.511719 L 15.757812 13.078125 C 15.964844 13.015625 16.183594 13.015625 16.390625 13.078125 L 24.464844 15.511719 C 25.136719 15.714844 25.597656 16.335938 25.597656 17.042969 L 25.597656 24.378906 C 25.566406 26.167969 23.960938 27.605469 22.167969 27.605469 L 19.195312 27.605469 C 19.054688 27.605469 18.917969 27.550781 18.820312 27.449219 C 18.71875 27.347656 18.664062 27.214844 18.664062 27.074219 L 18.664062 24.5 C 18.664062 23.488281 19.261719 22.570312 20.191406 22.164062 C 21.433594 21.621094 22.90625 20.886719 23.183594 19.410156 C 23.269531 18.933594 22.960938 18.472656 22.484375 18.378906 C 21.285156 18.140625 19.953125 18.230469 18.824219 18.734375 C 17.546875 19.308594 17.210938 20.257812 17.085938 21.539062 L 16.9375 22.914062 C 16.890625 23.335938 16.496094 23.65625 16.074219 23.65625 C 15.636719 23.65625 15.308594 23.324219 15.261719 22.886719 L 15.113281 21.539062 C 15.007812 20.441406 14.8125 19.378906 13.683594 18.875 C 12.390625 18.296875 11.09375 18.105469 9.714844 18.378906 C 9.238281 18.472656 8.929688 18.933594 9.015625 19.410156 C 9.296875 20.898438 10.757812 21.617188 12.007812 22.164062 C 12.9375 22.570312 13.535156 23.488281 13.535156 24.5 L 13.535156 27.074219 C 13.535156 27.367188 13.296875 27.605469 13.003906 27.605469 L 10.03125 27.605469 C 8.238281 27.605469 6.628906 26.167969 6.597656 24.378906 L 6.597656 17.039062 C 6.597656 16.335938 7.058594 15.714844 7.734375 15.511719 "/>
        </g>
    	</g>
    </g>
</svg>
`;
var c = class extends M {
  constructor() {
    super();
    n3(this, "_wallet", null);
  }
  available() {
    return true;
  }
  async ready() {
    return true;
  }
  get id() {
    return "braavosMobile";
  }
  get name() {
    return "Braavos (mobile)";
  }
  get icon() {
    return {
      dark: i,
      light: i
    };
  }
  get wallet() {
    throw new Error("not implemented");
  }
  async connect(t3 = {}) {
    return await this.ensureWallet(), {
      account: "",
      chainId: BigInt(0)
    };
  }
  async disconnect() {
    throw new Error("not implemented");
  }
  async account(t3) {
    throw new Error("not implemented");
  }
  async chainId() {
    throw new Error("not implemented");
  }
  async request(t3) {
    throw new Error("not implemented");
  }
  // needed, methods required by starknet-react. Otherwise an exception is throwd
  async initEventListener(t3) {
    throw new Error("not implemented");
  }
  // needed, methods required by starknet-react. Otherwise an exception is throwd
  async removeEventListener(t3) {
    throw new Error("not implemented");
  }
  async ensureWallet() {
    window.open(`https://link.braavos.app/dapp/${window.origin}`, "_blank");
  }
};

// node_modules/starknetkit/dist/fordefi.js
var e = "fordefi";
var i2 = class extends L {
  constructor(t3) {
    super({ options: { id: e, ...t3 } });
  }
  static getInjectedWallet() {
    return super.getInjectedWallet(e);
  }
  static isWalletInjected() {
    return super.isWalletInjected(e);
  }
};

// node_modules/starknetkit/dist/keplr.js
var e2 = "keplr";
var l3 = class extends L {
  constructor(t3) {
    super({ options: { id: e2, ...t3 } });
  }
  static getInjectedWallet() {
    return super.getInjectedWallet(e2);
  }
  static isWalletInjected() {
    return super.isWalletInjected(e2);
  }
};

// node_modules/starknetkit/dist/metamask.js
var t = "metamask";
var o2 = class extends L {
  constructor(e9) {
    super({ options: { id: t, ...e9 } });
  }
  static getInjectedWallet() {
    return super.getInjectedWallet(t);
  }
  static isWalletInjected() {
    return super.isWalletInjected(t);
  }
};

// node_modules/starknetkit/dist/starknetkit.js
var Q3 = () => {
  const a = navigator.userAgent.toLowerCase(), s2 = /android|webos|iphone|ipad|ipod|blackberry|windows phone/.test(a), o3 = "ontouchstart" in window || navigator.maxTouchPoints > 0, m4 = window.innerWidth <= 768;
  return s2 && (o3 || m4);
};
var q = () => typeof window < "u" ? /^((?!chrome|android).)*safari/i.test(navigator.userAgent) : false;
var P2 = ({
  argentMobileOptions: a,
  webWalletUrl: s2
}) => {
  const o3 = (
    // | StarknetkitCompoundConnector
    []
  );
  return o3.push(new p()), q() || (o3.push(new n()), o2.isWalletInjected() && o3.push(new o2()), i2.isWalletInjected() && o3.push(new i2()), l3.isWalletInjected() && o3.push(new l3())), Q3() && o3.push(new c()), o3;
};
var n4 = null;
var K = async ({
  modalMode: a = "canAsk",
  storeVersion: s2 = Pe(),
  modalTheme: o3,
  dappName: m4,
  resultType: p4 = "wallet",
  skipEmit: b3 = false,
  ...c3
}) => {
  const { webWalletUrl: M4 = fn, argentMobileOptions: v2 } = c3, { connectors: i4 } = c3;
  n4 = null;
  const d3 = !i4 || i4.length === 0 ? P2({
    argentMobileOptions: v2,
    webWalletUrl: M4
  }) : i4;
  b3 && (d3 == null ? void 0 : d3.map((t3) => {
    C(t3) && "connector" in t3 && "_options" in t3.connector && (t3.connector._options.shouldEmit = false);
  }));
  const f4 = localStorage.getItem("starknetLastConnectedWallet");
  if (a === "neverAsk")
    try {
      const t3 = Fe(d3, f4);
      let u2 = null;
      return t3 && p4 === "wallet" && (u2 = await t3.connect({
        onlyQRCode: true
      })), {
        connector: t3,
        wallet: (t3 == null ? void 0 : t3.wallet) ?? null,
        connectorData: u2
      };
    } catch (t3) {
      throw W(), new Error(t3);
    }
  const g2 = await main.getAvailableWallets(c3);
  if (a === "canAsk" && f4 && ((await main.getAuthorizedWallets(c3)).find((e9) => e9.id === f4) ?? g2.length === 1 ? g2[0] : void 0)) {
    const e9 = Fe(d3, f4);
    let l5 = null;
    return p4 === "wallet" && (l5 = await (e9 == null ? void 0 : e9.connect({
      onlyQRCode: true
    })) ?? null), e9 && (n4 = e9), {
      connector: n4,
      connectorData: l5,
      wallet: (e9 == null ? void 0 : e9.wallet) ?? null
    };
  }
  const L5 = (await main.getDiscoveryWallets(c3)).map(
    (t3) => t3.id.toLowerCase() === "argentx" ? {
      ...t3,
      name: "Ready Wallet (formerly Argent)"
    } : t3
  ), S5 = Ve({
    availableConnectors: d3,
    installedWallets: g2,
    discoveryWallets: L5,
    storeVersion: s2,
    customOrder: i4 ? (i4 == null ? void 0 : i4.length) > 0 : false
  });
  return new Promise((t3, u2) => {
    const e9 = new bl({
      target: wl(),
      props: {
        dappName: m4,
        callback: async (l5, D3 = false) => {
          try {
            if (!l5)
              throw new Error("Connector error");
            if (e9.$set({ selectedWallet: l5 }), !l5.installed) {
              e9.$set({ layout: Q.download });
              return;
            }
            if (n4 = S(
              l5.connector,
              D3
            ), p4 === "wallet") {
              n4 instanceof Re ? e9.$set({ layout: Q.qrCode }) : e9.$set({ layout: Q.connecting });
              const h3 = await (n4 == null ? void 0 : n4.connect({
                onlyQRCode: true
              })) ?? null;
              n4 !== null && U(n4.id), t3({
                connector: n4,
                connectorData: h3,
                wallet: (n4 == null ? void 0 : n4.wallet) ?? null
              }), e9.$set({ layout: Q.success }), setTimeout(() => e9.$destroy(), 500);
            } else
              t3({
                connector: n4,
                wallet: null,
                connectorData: null
              }), e9.$destroy();
          } catch (h3) {
            [Q.connecting, Q.qrCode].includes(e9.getLayout()) ? e9.$set({ layout: Q.loginFailure }) : u2(h3);
          }
        },
        theme: o3 === "system" ? null : o3 ?? null,
        modalWallets: S5
      }
    });
  });
};

// node_modules/@metamask/sdk/dist/browser/es/metamask-sdk.js
var import_cross_fetch = __toESM(require_browser_ponyfill());
var import_debug = __toESM(require_browser());
var import_sdk_analytics = __toESM(require_dist());
var import_eventemitter2 = __toESM(require_eventemitter2());
init_esm_browser();

// node_modules/engine.io-parser/build/esm/commons.js
var PACKET_TYPES = /* @__PURE__ */ Object.create(null);
PACKET_TYPES["open"] = "0";
PACKET_TYPES["close"] = "1";
PACKET_TYPES["ping"] = "2";
PACKET_TYPES["pong"] = "3";
PACKET_TYPES["message"] = "4";
PACKET_TYPES["upgrade"] = "5";
PACKET_TYPES["noop"] = "6";
var PACKET_TYPES_REVERSE = /* @__PURE__ */ Object.create(null);
Object.keys(PACKET_TYPES).forEach((key) => {
  PACKET_TYPES_REVERSE[PACKET_TYPES[key]] = key;
});
var ERROR_PACKET = { type: "error", data: "parser error" };

// node_modules/engine.io-parser/build/esm/encodePacket.browser.js
var withNativeBlob = typeof Blob === "function" || typeof Blob !== "undefined" && Object.prototype.toString.call(Blob) === "[object BlobConstructor]";
var withNativeArrayBuffer = typeof ArrayBuffer === "function";
var isView = (obj) => {
  return typeof ArrayBuffer.isView === "function" ? ArrayBuffer.isView(obj) : obj && obj.buffer instanceof ArrayBuffer;
};
var encodePacket = ({ type: type2, data }, supportsBinary, callback) => {
  if (withNativeBlob && data instanceof Blob) {
    if (supportsBinary) {
      return callback(data);
    } else {
      return encodeBlobAsBase64(data, callback);
    }
  } else if (withNativeArrayBuffer && (data instanceof ArrayBuffer || isView(data))) {
    if (supportsBinary) {
      return callback(data);
    } else {
      return encodeBlobAsBase64(new Blob([data]), callback);
    }
  }
  return callback(PACKET_TYPES[type2] + (data || ""));
};
var encodeBlobAsBase64 = (data, callback) => {
  const fileReader = new FileReader();
  fileReader.onload = function() {
    const content = fileReader.result.split(",")[1];
    callback("b" + (content || ""));
  };
  return fileReader.readAsDataURL(data);
};
function toArray(data) {
  if (data instanceof Uint8Array) {
    return data;
  } else if (data instanceof ArrayBuffer) {
    return new Uint8Array(data);
  } else {
    return new Uint8Array(data.buffer, data.byteOffset, data.byteLength);
  }
}
var TEXT_ENCODER;
function encodePacketToBinary(packet, callback) {
  if (withNativeBlob && packet.data instanceof Blob) {
    return packet.data.arrayBuffer().then(toArray).then(callback);
  } else if (withNativeArrayBuffer && (packet.data instanceof ArrayBuffer || isView(packet.data))) {
    return callback(toArray(packet.data));
  }
  encodePacket(packet, false, (encoded) => {
    if (!TEXT_ENCODER) {
      TEXT_ENCODER = new TextEncoder();
    }
    callback(TEXT_ENCODER.encode(encoded));
  });
}

// node_modules/engine.io-parser/build/esm/contrib/base64-arraybuffer.js
var chars = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
var lookup = typeof Uint8Array === "undefined" ? [] : new Uint8Array(256);
for (let i4 = 0; i4 < chars.length; i4++) {
  lookup[chars.charCodeAt(i4)] = i4;
}
var decode = (base64) => {
  let bufferLength = base64.length * 0.75, len = base64.length, i4, p4 = 0, encoded1, encoded2, encoded3, encoded4;
  if (base64[base64.length - 1] === "=") {
    bufferLength--;
    if (base64[base64.length - 2] === "=") {
      bufferLength--;
    }
  }
  const arraybuffer = new ArrayBuffer(bufferLength), bytes = new Uint8Array(arraybuffer);
  for (i4 = 0; i4 < len; i4 += 4) {
    encoded1 = lookup[base64.charCodeAt(i4)];
    encoded2 = lookup[base64.charCodeAt(i4 + 1)];
    encoded3 = lookup[base64.charCodeAt(i4 + 2)];
    encoded4 = lookup[base64.charCodeAt(i4 + 3)];
    bytes[p4++] = encoded1 << 2 | encoded2 >> 4;
    bytes[p4++] = (encoded2 & 15) << 4 | encoded3 >> 2;
    bytes[p4++] = (encoded3 & 3) << 6 | encoded4 & 63;
  }
  return arraybuffer;
};

// node_modules/engine.io-parser/build/esm/decodePacket.browser.js
var withNativeArrayBuffer2 = typeof ArrayBuffer === "function";
var decodePacket = (encodedPacket, binaryType) => {
  if (typeof encodedPacket !== "string") {
    return {
      type: "message",
      data: mapBinary(encodedPacket, binaryType)
    };
  }
  const type2 = encodedPacket.charAt(0);
  if (type2 === "b") {
    return {
      type: "message",
      data: decodeBase64Packet(encodedPacket.substring(1), binaryType)
    };
  }
  const packetType = PACKET_TYPES_REVERSE[type2];
  if (!packetType) {
    return ERROR_PACKET;
  }
  return encodedPacket.length > 1 ? {
    type: PACKET_TYPES_REVERSE[type2],
    data: encodedPacket.substring(1)
  } : {
    type: PACKET_TYPES_REVERSE[type2]
  };
};
var decodeBase64Packet = (data, binaryType) => {
  if (withNativeArrayBuffer2) {
    const decoded = decode(data);
    return mapBinary(decoded, binaryType);
  } else {
    return { base64: true, data };
  }
};
var mapBinary = (data, binaryType) => {
  switch (binaryType) {
    case "blob":
      if (data instanceof Blob) {
        return data;
      } else {
        return new Blob([data]);
      }
    case "arraybuffer":
    default:
      if (data instanceof ArrayBuffer) {
        return data;
      } else {
        return data.buffer;
      }
  }
};

// node_modules/engine.io-parser/build/esm/index.js
var SEPARATOR = String.fromCharCode(30);
var encodePayload = (packets, callback) => {
  const length = packets.length;
  const encodedPackets = new Array(length);
  let count = 0;
  packets.forEach((packet, i4) => {
    encodePacket(packet, false, (encodedPacket) => {
      encodedPackets[i4] = encodedPacket;
      if (++count === length) {
        callback(encodedPackets.join(SEPARATOR));
      }
    });
  });
};
var decodePayload = (encodedPayload, binaryType) => {
  const encodedPackets = encodedPayload.split(SEPARATOR);
  const packets = [];
  for (let i4 = 0; i4 < encodedPackets.length; i4++) {
    const decodedPacket = decodePacket(encodedPackets[i4], binaryType);
    packets.push(decodedPacket);
    if (decodedPacket.type === "error") {
      break;
    }
  }
  return packets;
};
function createPacketEncoderStream() {
  return new TransformStream({
    transform(packet, controller) {
      encodePacketToBinary(packet, (encodedPacket) => {
        const payloadLength = encodedPacket.length;
        let header;
        if (payloadLength < 126) {
          header = new Uint8Array(1);
          new DataView(header.buffer).setUint8(0, payloadLength);
        } else if (payloadLength < 65536) {
          header = new Uint8Array(3);
          const view = new DataView(header.buffer);
          view.setUint8(0, 126);
          view.setUint16(1, payloadLength);
        } else {
          header = new Uint8Array(9);
          const view = new DataView(header.buffer);
          view.setUint8(0, 127);
          view.setBigUint64(1, BigInt(payloadLength));
        }
        if (packet.data && typeof packet.data !== "string") {
          header[0] |= 128;
        }
        controller.enqueue(header);
        controller.enqueue(encodedPacket);
      });
    }
  });
}
var TEXT_DECODER;
function totalLength(chunks) {
  return chunks.reduce((acc, chunk) => acc + chunk.length, 0);
}
function concatChunks(chunks, size) {
  if (chunks[0].length === size) {
    return chunks.shift();
  }
  const buffer = new Uint8Array(size);
  let j4 = 0;
  for (let i4 = 0; i4 < size; i4++) {
    buffer[i4] = chunks[0][j4++];
    if (j4 === chunks[0].length) {
      chunks.shift();
      j4 = 0;
    }
  }
  if (chunks.length && j4 < chunks[0].length) {
    chunks[0] = chunks[0].slice(j4);
  }
  return buffer;
}
function createPacketDecoderStream(maxPayload, binaryType) {
  if (!TEXT_DECODER) {
    TEXT_DECODER = new TextDecoder();
  }
  const chunks = [];
  let state = 0;
  let expectedLength = -1;
  let isBinary2 = false;
  return new TransformStream({
    transform(chunk, controller) {
      chunks.push(chunk);
      while (true) {
        if (state === 0) {
          if (totalLength(chunks) < 1) {
            break;
          }
          const header = concatChunks(chunks, 1);
          isBinary2 = (header[0] & 128) === 128;
          expectedLength = header[0] & 127;
          if (expectedLength < 126) {
            state = 3;
          } else if (expectedLength === 126) {
            state = 1;
          } else {
            state = 2;
          }
        } else if (state === 1) {
          if (totalLength(chunks) < 2) {
            break;
          }
          const headerArray = concatChunks(chunks, 2);
          expectedLength = new DataView(headerArray.buffer, headerArray.byteOffset, headerArray.length).getUint16(0);
          state = 3;
        } else if (state === 2) {
          if (totalLength(chunks) < 8) {
            break;
          }
          const headerArray = concatChunks(chunks, 8);
          const view = new DataView(headerArray.buffer, headerArray.byteOffset, headerArray.length);
          const n6 = view.getUint32(0);
          if (n6 > Math.pow(2, 53 - 32) - 1) {
            controller.enqueue(ERROR_PACKET);
            break;
          }
          expectedLength = n6 * Math.pow(2, 32) + view.getUint32(4);
          state = 3;
        } else {
          if (totalLength(chunks) < expectedLength) {
            break;
          }
          const data = concatChunks(chunks, expectedLength);
          controller.enqueue(decodePacket(isBinary2 ? data : TEXT_DECODER.decode(data), binaryType));
          state = 0;
        }
        if (expectedLength === 0 || expectedLength > maxPayload) {
          controller.enqueue(ERROR_PACKET);
          break;
        }
      }
    }
  });
}
var protocol = 4;

// node_modules/@socket.io/component-emitter/lib/esm/index.js
function Emitter(obj) {
  if (obj) return mixin(obj);
}
function mixin(obj) {
  for (var key in Emitter.prototype) {
    obj[key] = Emitter.prototype[key];
  }
  return obj;
}
Emitter.prototype.on = Emitter.prototype.addEventListener = function(event, fn3) {
  this._callbacks = this._callbacks || {};
  (this._callbacks["$" + event] = this._callbacks["$" + event] || []).push(fn3);
  return this;
};
Emitter.prototype.once = function(event, fn3) {
  function on3() {
    this.off(event, on3);
    fn3.apply(this, arguments);
  }
  on3.fn = fn3;
  this.on(event, on3);
  return this;
};
Emitter.prototype.off = Emitter.prototype.removeListener = Emitter.prototype.removeAllListeners = Emitter.prototype.removeEventListener = function(event, fn3) {
  this._callbacks = this._callbacks || {};
  if (0 == arguments.length) {
    this._callbacks = {};
    return this;
  }
  var callbacks = this._callbacks["$" + event];
  if (!callbacks) return this;
  if (1 == arguments.length) {
    delete this._callbacks["$" + event];
    return this;
  }
  var cb;
  for (var i4 = 0; i4 < callbacks.length; i4++) {
    cb = callbacks[i4];
    if (cb === fn3 || cb.fn === fn3) {
      callbacks.splice(i4, 1);
      break;
    }
  }
  if (callbacks.length === 0) {
    delete this._callbacks["$" + event];
  }
  return this;
};
Emitter.prototype.emit = function(event) {
  this._callbacks = this._callbacks || {};
  var args = new Array(arguments.length - 1), callbacks = this._callbacks["$" + event];
  for (var i4 = 1; i4 < arguments.length; i4++) {
    args[i4 - 1] = arguments[i4];
  }
  if (callbacks) {
    callbacks = callbacks.slice(0);
    for (var i4 = 0, len = callbacks.length; i4 < len; ++i4) {
      callbacks[i4].apply(this, args);
    }
  }
  return this;
};
Emitter.prototype.emitReserved = Emitter.prototype.emit;
Emitter.prototype.listeners = function(event) {
  this._callbacks = this._callbacks || {};
  return this._callbacks["$" + event] || [];
};
Emitter.prototype.hasListeners = function(event) {
  return !!this.listeners(event).length;
};

// node_modules/engine.io-client/build/esm/globals.js
var nextTick = (() => {
  const isPromiseAvailable = typeof Promise === "function" && typeof Promise.resolve === "function";
  if (isPromiseAvailable) {
    return (cb) => Promise.resolve().then(cb);
  } else {
    return (cb, setTimeoutFn) => setTimeoutFn(cb, 0);
  }
})();
var globalThisShim = (() => {
  if (typeof self !== "undefined") {
    return self;
  } else if (typeof window !== "undefined") {
    return window;
  } else {
    return Function("return this")();
  }
})();
var defaultBinaryType = "arraybuffer";
function createCookieJar() {
}

// node_modules/engine.io-client/build/esm/util.js
function pick(obj, ...attr) {
  return attr.reduce((acc, k3) => {
    if (obj.hasOwnProperty(k3)) {
      acc[k3] = obj[k3];
    }
    return acc;
  }, {});
}
var NATIVE_SET_TIMEOUT = globalThisShim.setTimeout;
var NATIVE_CLEAR_TIMEOUT = globalThisShim.clearTimeout;
function installTimerFunctions(obj, opts) {
  if (opts.useNativeTimers) {
    obj.setTimeoutFn = NATIVE_SET_TIMEOUT.bind(globalThisShim);
    obj.clearTimeoutFn = NATIVE_CLEAR_TIMEOUT.bind(globalThisShim);
  } else {
    obj.setTimeoutFn = globalThisShim.setTimeout.bind(globalThisShim);
    obj.clearTimeoutFn = globalThisShim.clearTimeout.bind(globalThisShim);
  }
}
var BASE64_OVERHEAD = 1.33;
function byteLength(obj) {
  if (typeof obj === "string") {
    return utf8Length(obj);
  }
  return Math.ceil((obj.byteLength || obj.size) * BASE64_OVERHEAD);
}
function utf8Length(str) {
  let c3 = 0, length = 0;
  for (let i4 = 0, l5 = str.length; i4 < l5; i4++) {
    c3 = str.charCodeAt(i4);
    if (c3 < 128) {
      length += 1;
    } else if (c3 < 2048) {
      length += 2;
    } else if (c3 < 55296 || c3 >= 57344) {
      length += 3;
    } else {
      i4++;
      length += 4;
    }
  }
  return length;
}
function randomString() {
  return Date.now().toString(36).substring(3) + Math.random().toString(36).substring(2, 5);
}

// node_modules/engine.io-client/build/esm/contrib/parseqs.js
function encode(obj) {
  let str = "";
  for (let i4 in obj) {
    if (obj.hasOwnProperty(i4)) {
      if (str.length)
        str += "&";
      str += encodeURIComponent(i4) + "=" + encodeURIComponent(obj[i4]);
    }
  }
  return str;
}
function decode2(qs2) {
  let qry = {};
  let pairs = qs2.split("&");
  for (let i4 = 0, l5 = pairs.length; i4 < l5; i4++) {
    let pair = pairs[i4].split("=");
    qry[decodeURIComponent(pair[0])] = decodeURIComponent(pair[1]);
  }
  return qry;
}

// node_modules/engine.io-client/build/esm/transport.js
var TransportError = class extends Error {
  constructor(reason, description, context) {
    super(reason);
    this.description = description;
    this.context = context;
    this.type = "TransportError";
  }
};
var Transport = class extends Emitter {
  /**
   * Transport abstract constructor.
   *
   * @param {Object} opts - options
   * @protected
   */
  constructor(opts) {
    super();
    this.writable = false;
    installTimerFunctions(this, opts);
    this.opts = opts;
    this.query = opts.query;
    this.socket = opts.socket;
    this.supportsBinary = !opts.forceBase64;
  }
  /**
   * Emits an error.
   *
   * @param {String} reason
   * @param description
   * @param context - the error context
   * @return {Transport} for chaining
   * @protected
   */
  onError(reason, description, context) {
    super.emitReserved("error", new TransportError(reason, description, context));
    return this;
  }
  /**
   * Opens the transport.
   */
  open() {
    this.readyState = "opening";
    this.doOpen();
    return this;
  }
  /**
   * Closes the transport.
   */
  close() {
    if (this.readyState === "opening" || this.readyState === "open") {
      this.doClose();
      this.onClose();
    }
    return this;
  }
  /**
   * Sends multiple packets.
   *
   * @param {Array} packets
   */
  send(packets) {
    if (this.readyState === "open") {
      this.write(packets);
    } else {
    }
  }
  /**
   * Called upon open
   *
   * @protected
   */
  onOpen() {
    this.readyState = "open";
    this.writable = true;
    super.emitReserved("open");
  }
  /**
   * Called with data.
   *
   * @param {String} data
   * @protected
   */
  onData(data) {
    const packet = decodePacket(data, this.socket.binaryType);
    this.onPacket(packet);
  }
  /**
   * Called with a decoded packet.
   *
   * @protected
   */
  onPacket(packet) {
    super.emitReserved("packet", packet);
  }
  /**
   * Called upon close.
   *
   * @protected
   */
  onClose(details) {
    this.readyState = "closed";
    super.emitReserved("close", details);
  }
  /**
   * Pauses the transport, in order not to lose packets during an upgrade.
   *
   * @param onPause
   */
  pause(onPause) {
  }
  createUri(schema, query = {}) {
    return schema + "://" + this._hostname() + this._port() + this.opts.path + this._query(query);
  }
  _hostname() {
    const hostname = this.opts.hostname;
    return hostname.indexOf(":") === -1 ? hostname : "[" + hostname + "]";
  }
  _port() {
    if (this.opts.port && (this.opts.secure && Number(this.opts.port !== 443) || !this.opts.secure && Number(this.opts.port) !== 80)) {
      return ":" + this.opts.port;
    } else {
      return "";
    }
  }
  _query(query) {
    const encodedQuery = encode(query);
    return encodedQuery.length ? "?" + encodedQuery : "";
  }
};

// node_modules/engine.io-client/build/esm/transports/polling.js
var Polling = class extends Transport {
  constructor() {
    super(...arguments);
    this._polling = false;
  }
  get name() {
    return "polling";
  }
  /**
   * Opens the socket (triggers polling). We write a PING message to determine
   * when the transport is open.
   *
   * @protected
   */
  doOpen() {
    this._poll();
  }
  /**
   * Pauses polling.
   *
   * @param {Function} onPause - callback upon buffers are flushed and transport is paused
   * @package
   */
  pause(onPause) {
    this.readyState = "pausing";
    const pause = () => {
      this.readyState = "paused";
      onPause();
    };
    if (this._polling || !this.writable) {
      let total = 0;
      if (this._polling) {
        total++;
        this.once("pollComplete", function() {
          --total || pause();
        });
      }
      if (!this.writable) {
        total++;
        this.once("drain", function() {
          --total || pause();
        });
      }
    } else {
      pause();
    }
  }
  /**
   * Starts polling cycle.
   *
   * @private
   */
  _poll() {
    this._polling = true;
    this.doPoll();
    this.emitReserved("poll");
  }
  /**
   * Overloads onData to detect payloads.
   *
   * @protected
   */
  onData(data) {
    const callback = (packet) => {
      if ("opening" === this.readyState && packet.type === "open") {
        this.onOpen();
      }
      if ("close" === packet.type) {
        this.onClose({ description: "transport closed by the server" });
        return false;
      }
      this.onPacket(packet);
    };
    decodePayload(data, this.socket.binaryType).forEach(callback);
    if ("closed" !== this.readyState) {
      this._polling = false;
      this.emitReserved("pollComplete");
      if ("open" === this.readyState) {
        this._poll();
      } else {
      }
    }
  }
  /**
   * For polling, send a close packet.
   *
   * @protected
   */
  doClose() {
    const close = () => {
      this.write([{ type: "close" }]);
    };
    if ("open" === this.readyState) {
      close();
    } else {
      this.once("open", close);
    }
  }
  /**
   * Writes a packets payload.
   *
   * @param {Array} packets - data packets
   * @protected
   */
  write(packets) {
    this.writable = false;
    encodePayload(packets, (data) => {
      this.doWrite(data, () => {
        this.writable = true;
        this.emitReserved("drain");
      });
    });
  }
  /**
   * Generates uri for connection.
   *
   * @private
   */
  uri() {
    const schema = this.opts.secure ? "https" : "http";
    const query = this.query || {};
    if (false !== this.opts.timestampRequests) {
      query[this.opts.timestampParam] = randomString();
    }
    if (!this.supportsBinary && !query.sid) {
      query.b64 = 1;
    }
    return this.createUri(schema, query);
  }
};

// node_modules/engine.io-client/build/esm/contrib/has-cors.js
var value = false;
try {
  value = typeof XMLHttpRequest !== "undefined" && "withCredentials" in new XMLHttpRequest();
} catch (err) {
}
var hasCORS = value;

// node_modules/engine.io-client/build/esm/transports/polling-xhr.js
function empty() {
}
var BaseXHR = class extends Polling {
  /**
   * XHR Polling constructor.
   *
   * @param {Object} opts
   * @package
   */
  constructor(opts) {
    super(opts);
    if (typeof location !== "undefined") {
      const isSSL = "https:" === location.protocol;
      let port = location.port;
      if (!port) {
        port = isSSL ? "443" : "80";
      }
      this.xd = typeof location !== "undefined" && opts.hostname !== location.hostname || port !== opts.port;
    }
  }
  /**
   * Sends data.
   *
   * @param {String} data to send.
   * @param {Function} called upon flush.
   * @private
   */
  doWrite(data, fn3) {
    const req = this.request({
      method: "POST",
      data
    });
    req.on("success", fn3);
    req.on("error", (xhrStatus, context) => {
      this.onError("xhr post error", xhrStatus, context);
    });
  }
  /**
   * Starts a poll cycle.
   *
   * @private
   */
  doPoll() {
    const req = this.request();
    req.on("data", this.onData.bind(this));
    req.on("error", (xhrStatus, context) => {
      this.onError("xhr poll error", xhrStatus, context);
    });
    this.pollXhr = req;
  }
};
var Request = class _Request extends Emitter {
  /**
   * Request constructor
   *
   * @param {Object} options
   * @package
   */
  constructor(createRequest, uri, opts) {
    super();
    this.createRequest = createRequest;
    installTimerFunctions(this, opts);
    this._opts = opts;
    this._method = opts.method || "GET";
    this._uri = uri;
    this._data = void 0 !== opts.data ? opts.data : null;
    this._create();
  }
  /**
   * Creates the XHR object and sends the request.
   *
   * @private
   */
  _create() {
    var _a2;
    const opts = pick(this._opts, "agent", "pfx", "key", "passphrase", "cert", "ca", "ciphers", "rejectUnauthorized", "autoUnref");
    opts.xdomain = !!this._opts.xd;
    const xhr = this._xhr = this.createRequest(opts);
    try {
      xhr.open(this._method, this._uri, true);
      try {
        if (this._opts.extraHeaders) {
          xhr.setDisableHeaderCheck && xhr.setDisableHeaderCheck(true);
          for (let i4 in this._opts.extraHeaders) {
            if (this._opts.extraHeaders.hasOwnProperty(i4)) {
              xhr.setRequestHeader(i4, this._opts.extraHeaders[i4]);
            }
          }
        }
      } catch (e9) {
      }
      if ("POST" === this._method) {
        try {
          xhr.setRequestHeader("Content-type", "text/plain;charset=UTF-8");
        } catch (e9) {
        }
      }
      try {
        xhr.setRequestHeader("Accept", "*/*");
      } catch (e9) {
      }
      (_a2 = this._opts.cookieJar) === null || _a2 === void 0 ? void 0 : _a2.addCookies(xhr);
      if ("withCredentials" in xhr) {
        xhr.withCredentials = this._opts.withCredentials;
      }
      if (this._opts.requestTimeout) {
        xhr.timeout = this._opts.requestTimeout;
      }
      xhr.onreadystatechange = () => {
        var _a3;
        if (xhr.readyState === 3) {
          (_a3 = this._opts.cookieJar) === null || _a3 === void 0 ? void 0 : _a3.parseCookies(
            // @ts-ignore
            xhr.getResponseHeader("set-cookie")
          );
        }
        if (4 !== xhr.readyState)
          return;
        if (200 === xhr.status || 1223 === xhr.status) {
          this._onLoad();
        } else {
          this.setTimeoutFn(() => {
            this._onError(typeof xhr.status === "number" ? xhr.status : 0);
          }, 0);
        }
      };
      xhr.send(this._data);
    } catch (e9) {
      this.setTimeoutFn(() => {
        this._onError(e9);
      }, 0);
      return;
    }
    if (typeof document !== "undefined") {
      this._index = _Request.requestsCount++;
      _Request.requests[this._index] = this;
    }
  }
  /**
   * Called upon error.
   *
   * @private
   */
  _onError(err) {
    this.emitReserved("error", err, this._xhr);
    this._cleanup(true);
  }
  /**
   * Cleans up house.
   *
   * @private
   */
  _cleanup(fromError) {
    if ("undefined" === typeof this._xhr || null === this._xhr) {
      return;
    }
    this._xhr.onreadystatechange = empty;
    if (fromError) {
      try {
        this._xhr.abort();
      } catch (e9) {
      }
    }
    if (typeof document !== "undefined") {
      delete _Request.requests[this._index];
    }
    this._xhr = null;
  }
  /**
   * Called upon load.
   *
   * @private
   */
  _onLoad() {
    const data = this._xhr.responseText;
    if (data !== null) {
      this.emitReserved("data", data);
      this.emitReserved("success");
      this._cleanup();
    }
  }
  /**
   * Aborts the request.
   *
   * @package
   */
  abort() {
    this._cleanup();
  }
};
Request.requestsCount = 0;
Request.requests = {};
if (typeof document !== "undefined") {
  if (typeof attachEvent === "function") {
    attachEvent("onunload", unloadHandler);
  } else if (typeof addEventListener === "function") {
    const terminationEvent = "onpagehide" in globalThisShim ? "pagehide" : "unload";
    addEventListener(terminationEvent, unloadHandler, false);
  }
}
function unloadHandler() {
  for (let i4 in Request.requests) {
    if (Request.requests.hasOwnProperty(i4)) {
      Request.requests[i4].abort();
    }
  }
}
var hasXHR2 = function() {
  const xhr = newRequest({
    xdomain: false
  });
  return xhr && xhr.responseType !== null;
}();
var XHR = class extends BaseXHR {
  constructor(opts) {
    super(opts);
    const forceBase64 = opts && opts.forceBase64;
    this.supportsBinary = hasXHR2 && !forceBase64;
  }
  request(opts = {}) {
    Object.assign(opts, { xd: this.xd }, this.opts);
    return new Request(newRequest, this.uri(), opts);
  }
};
function newRequest(opts) {
  const xdomain = opts.xdomain;
  try {
    if ("undefined" !== typeof XMLHttpRequest && (!xdomain || hasCORS)) {
      return new XMLHttpRequest();
    }
  } catch (e9) {
  }
  if (!xdomain) {
    try {
      return new globalThisShim[["Active"].concat("Object").join("X")]("Microsoft.XMLHTTP");
    } catch (e9) {
    }
  }
}

// node_modules/engine.io-client/build/esm/transports/websocket.js
var isReactNative = typeof navigator !== "undefined" && typeof navigator.product === "string" && navigator.product.toLowerCase() === "reactnative";
var BaseWS = class extends Transport {
  get name() {
    return "websocket";
  }
  doOpen() {
    const uri = this.uri();
    const protocols = this.opts.protocols;
    const opts = isReactNative ? {} : pick(this.opts, "agent", "perMessageDeflate", "pfx", "key", "passphrase", "cert", "ca", "ciphers", "rejectUnauthorized", "localAddress", "protocolVersion", "origin", "maxPayload", "family", "checkServerIdentity");
    if (this.opts.extraHeaders) {
      opts.headers = this.opts.extraHeaders;
    }
    try {
      this.ws = this.createSocket(uri, protocols, opts);
    } catch (err) {
      return this.emitReserved("error", err);
    }
    this.ws.binaryType = this.socket.binaryType;
    this.addEventListeners();
  }
  /**
   * Adds event listeners to the socket
   *
   * @private
   */
  addEventListeners() {
    this.ws.onopen = () => {
      if (this.opts.autoUnref) {
        this.ws._socket.unref();
      }
      this.onOpen();
    };
    this.ws.onclose = (closeEvent) => this.onClose({
      description: "websocket connection closed",
      context: closeEvent
    });
    this.ws.onmessage = (ev) => this.onData(ev.data);
    this.ws.onerror = (e9) => this.onError("websocket error", e9);
  }
  write(packets) {
    this.writable = false;
    for (let i4 = 0; i4 < packets.length; i4++) {
      const packet = packets[i4];
      const lastPacket = i4 === packets.length - 1;
      encodePacket(packet, this.supportsBinary, (data) => {
        try {
          this.doWrite(packet, data);
        } catch (e9) {
        }
        if (lastPacket) {
          nextTick(() => {
            this.writable = true;
            this.emitReserved("drain");
          }, this.setTimeoutFn);
        }
      });
    }
  }
  doClose() {
    if (typeof this.ws !== "undefined") {
      this.ws.onerror = () => {
      };
      this.ws.close();
      this.ws = null;
    }
  }
  /**
   * Generates uri for connection.
   *
   * @private
   */
  uri() {
    const schema = this.opts.secure ? "wss" : "ws";
    const query = this.query || {};
    if (this.opts.timestampRequests) {
      query[this.opts.timestampParam] = randomString();
    }
    if (!this.supportsBinary) {
      query.b64 = 1;
    }
    return this.createUri(schema, query);
  }
};
var WebSocketCtor = globalThisShim.WebSocket || globalThisShim.MozWebSocket;
var WS = class extends BaseWS {
  createSocket(uri, protocols, opts) {
    return !isReactNative ? protocols ? new WebSocketCtor(uri, protocols) : new WebSocketCtor(uri) : new WebSocketCtor(uri, protocols, opts);
  }
  doWrite(_packet, data) {
    this.ws.send(data);
  }
};

// node_modules/engine.io-client/build/esm/transports/webtransport.js
var WT = class extends Transport {
  get name() {
    return "webtransport";
  }
  doOpen() {
    try {
      this._transport = new WebTransport(this.createUri("https"), this.opts.transportOptions[this.name]);
    } catch (err) {
      return this.emitReserved("error", err);
    }
    this._transport.closed.then(() => {
      this.onClose();
    }).catch((err) => {
      this.onError("webtransport error", err);
    });
    this._transport.ready.then(() => {
      this._transport.createBidirectionalStream().then((stream) => {
        const decoderStream = createPacketDecoderStream(Number.MAX_SAFE_INTEGER, this.socket.binaryType);
        const reader = stream.readable.pipeThrough(decoderStream).getReader();
        const encoderStream = createPacketEncoderStream();
        encoderStream.readable.pipeTo(stream.writable);
        this._writer = encoderStream.writable.getWriter();
        const read = () => {
          reader.read().then(({ done, value: value2 }) => {
            if (done) {
              return;
            }
            this.onPacket(value2);
            read();
          }).catch((err) => {
          });
        };
        read();
        const packet = { type: "open" };
        if (this.query.sid) {
          packet.data = `{"sid":"${this.query.sid}"}`;
        }
        this._writer.write(packet).then(() => this.onOpen());
      });
    });
  }
  write(packets) {
    this.writable = false;
    for (let i4 = 0; i4 < packets.length; i4++) {
      const packet = packets[i4];
      const lastPacket = i4 === packets.length - 1;
      this._writer.write(packet).then(() => {
        if (lastPacket) {
          nextTick(() => {
            this.writable = true;
            this.emitReserved("drain");
          }, this.setTimeoutFn);
        }
      });
    }
  }
  doClose() {
    var _a2;
    (_a2 = this._transport) === null || _a2 === void 0 ? void 0 : _a2.close();
  }
};

// node_modules/engine.io-client/build/esm/transports/index.js
var transports = {
  websocket: WS,
  webtransport: WT,
  polling: XHR
};

// node_modules/engine.io-client/build/esm/contrib/parseuri.js
var re = /^(?:(?![^:@\/?#]+:[^:@\/]*@)(http|https|ws|wss):\/\/)?((?:(([^:@\/?#]*)(?::([^:@\/?#]*))?)?@)?((?:[a-f0-9]{0,4}:){2,7}[a-f0-9]{0,4}|[^:\/?#]*)(?::(\d*))?)(((\/(?:[^?#](?![^?#\/]*\.[^?#\/.]+(?:[?#]|$)))*\/?)?([^?#\/]*))(?:\?([^#]*))?(?:#(.*))?)/;
var parts = [
  "source",
  "protocol",
  "authority",
  "userInfo",
  "user",
  "password",
  "host",
  "port",
  "relative",
  "path",
  "directory",
  "file",
  "query",
  "anchor"
];
function parse2(str) {
  if (str.length > 8e3) {
    throw "URI too long";
  }
  const src = str, b3 = str.indexOf("["), e9 = str.indexOf("]");
  if (b3 != -1 && e9 != -1) {
    str = str.substring(0, b3) + str.substring(b3, e9).replace(/:/g, ";") + str.substring(e9, str.length);
  }
  let m4 = re.exec(str || ""), uri = {}, i4 = 14;
  while (i4--) {
    uri[parts[i4]] = m4[i4] || "";
  }
  if (b3 != -1 && e9 != -1) {
    uri.source = src;
    uri.host = uri.host.substring(1, uri.host.length - 1).replace(/;/g, ":");
    uri.authority = uri.authority.replace("[", "").replace("]", "").replace(/;/g, ":");
    uri.ipv6uri = true;
  }
  uri.pathNames = pathNames(uri, uri["path"]);
  uri.queryKey = queryKey(uri, uri["query"]);
  return uri;
}
function pathNames(obj, path) {
  const regx = /\/{2,9}/g, names = path.replace(regx, "/").split("/");
  if (path.slice(0, 1) == "/" || path.length === 0) {
    names.splice(0, 1);
  }
  if (path.slice(-1) == "/") {
    names.splice(names.length - 1, 1);
  }
  return names;
}
function queryKey(uri, query) {
  const data = {};
  query.replace(/(?:^|&)([^&=]*)=?([^&]*)/g, function($0, $1, $2) {
    if ($1) {
      data[$1] = $2;
    }
  });
  return data;
}

// node_modules/engine.io-client/build/esm/socket.js
var withEventListeners = typeof addEventListener === "function" && typeof removeEventListener === "function";
var OFFLINE_EVENT_LISTENERS = [];
if (withEventListeners) {
  addEventListener("offline", () => {
    OFFLINE_EVENT_LISTENERS.forEach((listener) => listener());
  }, false);
}
var SocketWithoutUpgrade = class _SocketWithoutUpgrade extends Emitter {
  /**
   * Socket constructor.
   *
   * @param {String|Object} uri - uri or options
   * @param {Object} opts - options
   */
  constructor(uri, opts) {
    super();
    this.binaryType = defaultBinaryType;
    this.writeBuffer = [];
    this._prevBufferLen = 0;
    this._pingInterval = -1;
    this._pingTimeout = -1;
    this._maxPayload = -1;
    this._pingTimeoutTime = Infinity;
    if (uri && "object" === typeof uri) {
      opts = uri;
      uri = null;
    }
    if (uri) {
      const parsedUri = parse2(uri);
      opts.hostname = parsedUri.host;
      opts.secure = parsedUri.protocol === "https" || parsedUri.protocol === "wss";
      opts.port = parsedUri.port;
      if (parsedUri.query)
        opts.query = parsedUri.query;
    } else if (opts.host) {
      opts.hostname = parse2(opts.host).host;
    }
    installTimerFunctions(this, opts);
    this.secure = null != opts.secure ? opts.secure : typeof location !== "undefined" && "https:" === location.protocol;
    if (opts.hostname && !opts.port) {
      opts.port = this.secure ? "443" : "80";
    }
    this.hostname = opts.hostname || (typeof location !== "undefined" ? location.hostname : "localhost");
    this.port = opts.port || (typeof location !== "undefined" && location.port ? location.port : this.secure ? "443" : "80");
    this.transports = [];
    this._transportsByName = {};
    opts.transports.forEach((t3) => {
      const transportName = t3.prototype.name;
      this.transports.push(transportName);
      this._transportsByName[transportName] = t3;
    });
    this.opts = Object.assign({
      path: "/engine.io",
      agent: false,
      withCredentials: false,
      upgrade: true,
      timestampParam: "t",
      rememberUpgrade: false,
      addTrailingSlash: true,
      rejectUnauthorized: true,
      perMessageDeflate: {
        threshold: 1024
      },
      transportOptions: {},
      closeOnBeforeunload: false
    }, opts);
    this.opts.path = this.opts.path.replace(/\/$/, "") + (this.opts.addTrailingSlash ? "/" : "");
    if (typeof this.opts.query === "string") {
      this.opts.query = decode2(this.opts.query);
    }
    if (withEventListeners) {
      if (this.opts.closeOnBeforeunload) {
        this._beforeunloadEventListener = () => {
          if (this.transport) {
            this.transport.removeAllListeners();
            this.transport.close();
          }
        };
        addEventListener("beforeunload", this._beforeunloadEventListener, false);
      }
      if (this.hostname !== "localhost") {
        this._offlineEventListener = () => {
          this._onClose("transport close", {
            description: "network connection lost"
          });
        };
        OFFLINE_EVENT_LISTENERS.push(this._offlineEventListener);
      }
    }
    if (this.opts.withCredentials) {
      this._cookieJar = createCookieJar();
    }
    this._open();
  }
  /**
   * Creates transport of the given type.
   *
   * @param {String} name - transport name
   * @return {Transport}
   * @private
   */
  createTransport(name) {
    const query = Object.assign({}, this.opts.query);
    query.EIO = protocol;
    query.transport = name;
    if (this.id)
      query.sid = this.id;
    const opts = Object.assign({}, this.opts, {
      query,
      socket: this,
      hostname: this.hostname,
      secure: this.secure,
      port: this.port
    }, this.opts.transportOptions[name]);
    return new this._transportsByName[name](opts);
  }
  /**
   * Initializes transport to use and starts probe.
   *
   * @private
   */
  _open() {
    if (this.transports.length === 0) {
      this.setTimeoutFn(() => {
        this.emitReserved("error", "No transports available");
      }, 0);
      return;
    }
    const transportName = this.opts.rememberUpgrade && _SocketWithoutUpgrade.priorWebsocketSuccess && this.transports.indexOf("websocket") !== -1 ? "websocket" : this.transports[0];
    this.readyState = "opening";
    const transport = this.createTransport(transportName);
    transport.open();
    this.setTransport(transport);
  }
  /**
   * Sets the current transport. Disables the existing one (if any).
   *
   * @private
   */
  setTransport(transport) {
    if (this.transport) {
      this.transport.removeAllListeners();
    }
    this.transport = transport;
    transport.on("drain", this._onDrain.bind(this)).on("packet", this._onPacket.bind(this)).on("error", this._onError.bind(this)).on("close", (reason) => this._onClose("transport close", reason));
  }
  /**
   * Called when connection is deemed open.
   *
   * @private
   */
  onOpen() {
    this.readyState = "open";
    _SocketWithoutUpgrade.priorWebsocketSuccess = "websocket" === this.transport.name;
    this.emitReserved("open");
    this.flush();
  }
  /**
   * Handles a packet.
   *
   * @private
   */
  _onPacket(packet) {
    if ("opening" === this.readyState || "open" === this.readyState || "closing" === this.readyState) {
      this.emitReserved("packet", packet);
      this.emitReserved("heartbeat");
      switch (packet.type) {
        case "open":
          this.onHandshake(JSON.parse(packet.data));
          break;
        case "ping":
          this._sendPacket("pong");
          this.emitReserved("ping");
          this.emitReserved("pong");
          this._resetPingTimeout();
          break;
        case "error":
          const err = new Error("server error");
          err.code = packet.data;
          this._onError(err);
          break;
        case "message":
          this.emitReserved("data", packet.data);
          this.emitReserved("message", packet.data);
          break;
      }
    } else {
    }
  }
  /**
   * Called upon handshake completion.
   *
   * @param {Object} data - handshake obj
   * @private
   */
  onHandshake(data) {
    this.emitReserved("handshake", data);
    this.id = data.sid;
    this.transport.query.sid = data.sid;
    this._pingInterval = data.pingInterval;
    this._pingTimeout = data.pingTimeout;
    this._maxPayload = data.maxPayload;
    this.onOpen();
    if ("closed" === this.readyState)
      return;
    this._resetPingTimeout();
  }
  /**
   * Sets and resets ping timeout timer based on server pings.
   *
   * @private
   */
  _resetPingTimeout() {
    this.clearTimeoutFn(this._pingTimeoutTimer);
    const delay = this._pingInterval + this._pingTimeout;
    this._pingTimeoutTime = Date.now() + delay;
    this._pingTimeoutTimer = this.setTimeoutFn(() => {
      this._onClose("ping timeout");
    }, delay);
    if (this.opts.autoUnref) {
      this._pingTimeoutTimer.unref();
    }
  }
  /**
   * Called on `drain` event
   *
   * @private
   */
  _onDrain() {
    this.writeBuffer.splice(0, this._prevBufferLen);
    this._prevBufferLen = 0;
    if (0 === this.writeBuffer.length) {
      this.emitReserved("drain");
    } else {
      this.flush();
    }
  }
  /**
   * Flush write buffers.
   *
   * @private
   */
  flush() {
    if ("closed" !== this.readyState && this.transport.writable && !this.upgrading && this.writeBuffer.length) {
      const packets = this._getWritablePackets();
      this.transport.send(packets);
      this._prevBufferLen = packets.length;
      this.emitReserved("flush");
    }
  }
  /**
   * Ensure the encoded size of the writeBuffer is below the maxPayload value sent by the server (only for HTTP
   * long-polling)
   *
   * @private
   */
  _getWritablePackets() {
    const shouldCheckPayloadSize = this._maxPayload && this.transport.name === "polling" && this.writeBuffer.length > 1;
    if (!shouldCheckPayloadSize) {
      return this.writeBuffer;
    }
    let payloadSize = 1;
    for (let i4 = 0; i4 < this.writeBuffer.length; i4++) {
      const data = this.writeBuffer[i4].data;
      if (data) {
        payloadSize += byteLength(data);
      }
      if (i4 > 0 && payloadSize > this._maxPayload) {
        return this.writeBuffer.slice(0, i4);
      }
      payloadSize += 2;
    }
    return this.writeBuffer;
  }
  /**
   * Checks whether the heartbeat timer has expired but the socket has not yet been notified.
   *
   * Note: this method is private for now because it does not really fit the WebSocket API, but if we put it in the
   * `write()` method then the message would not be buffered by the Socket.IO client.
   *
   * @return {boolean}
   * @private
   */
  /* private */
  _hasPingExpired() {
    if (!this._pingTimeoutTime)
      return true;
    const hasExpired = Date.now() > this._pingTimeoutTime;
    if (hasExpired) {
      this._pingTimeoutTime = 0;
      nextTick(() => {
        this._onClose("ping timeout");
      }, this.setTimeoutFn);
    }
    return hasExpired;
  }
  /**
   * Sends a message.
   *
   * @param {String} msg - message.
   * @param {Object} options.
   * @param {Function} fn - callback function.
   * @return {Socket} for chaining.
   */
  write(msg, options, fn3) {
    this._sendPacket("message", msg, options, fn3);
    return this;
  }
  /**
   * Sends a message. Alias of {@link Socket#write}.
   *
   * @param {String} msg - message.
   * @param {Object} options.
   * @param {Function} fn - callback function.
   * @return {Socket} for chaining.
   */
  send(msg, options, fn3) {
    this._sendPacket("message", msg, options, fn3);
    return this;
  }
  /**
   * Sends a packet.
   *
   * @param {String} type: packet type.
   * @param {String} data.
   * @param {Object} options.
   * @param {Function} fn - callback function.
   * @private
   */
  _sendPacket(type2, data, options, fn3) {
    if ("function" === typeof data) {
      fn3 = data;
      data = void 0;
    }
    if ("function" === typeof options) {
      fn3 = options;
      options = null;
    }
    if ("closing" === this.readyState || "closed" === this.readyState) {
      return;
    }
    options = options || {};
    options.compress = false !== options.compress;
    const packet = {
      type: type2,
      data,
      options
    };
    this.emitReserved("packetCreate", packet);
    this.writeBuffer.push(packet);
    if (fn3)
      this.once("flush", fn3);
    this.flush();
  }
  /**
   * Closes the connection.
   */
  close() {
    const close = () => {
      this._onClose("forced close");
      this.transport.close();
    };
    const cleanupAndClose = () => {
      this.off("upgrade", cleanupAndClose);
      this.off("upgradeError", cleanupAndClose);
      close();
    };
    const waitForUpgrade = () => {
      this.once("upgrade", cleanupAndClose);
      this.once("upgradeError", cleanupAndClose);
    };
    if ("opening" === this.readyState || "open" === this.readyState) {
      this.readyState = "closing";
      if (this.writeBuffer.length) {
        this.once("drain", () => {
          if (this.upgrading) {
            waitForUpgrade();
          } else {
            close();
          }
        });
      } else if (this.upgrading) {
        waitForUpgrade();
      } else {
        close();
      }
    }
    return this;
  }
  /**
   * Called upon transport error
   *
   * @private
   */
  _onError(err) {
    _SocketWithoutUpgrade.priorWebsocketSuccess = false;
    if (this.opts.tryAllTransports && this.transports.length > 1 && this.readyState === "opening") {
      this.transports.shift();
      return this._open();
    }
    this.emitReserved("error", err);
    this._onClose("transport error", err);
  }
  /**
   * Called upon transport close.
   *
   * @private
   */
  _onClose(reason, description) {
    if ("opening" === this.readyState || "open" === this.readyState || "closing" === this.readyState) {
      this.clearTimeoutFn(this._pingTimeoutTimer);
      this.transport.removeAllListeners("close");
      this.transport.close();
      this.transport.removeAllListeners();
      if (withEventListeners) {
        if (this._beforeunloadEventListener) {
          removeEventListener("beforeunload", this._beforeunloadEventListener, false);
        }
        if (this._offlineEventListener) {
          const i4 = OFFLINE_EVENT_LISTENERS.indexOf(this._offlineEventListener);
          if (i4 !== -1) {
            OFFLINE_EVENT_LISTENERS.splice(i4, 1);
          }
        }
      }
      this.readyState = "closed";
      this.id = null;
      this.emitReserved("close", reason, description);
      this.writeBuffer = [];
      this._prevBufferLen = 0;
    }
  }
};
SocketWithoutUpgrade.protocol = protocol;
var SocketWithUpgrade = class extends SocketWithoutUpgrade {
  constructor() {
    super(...arguments);
    this._upgrades = [];
  }
  onOpen() {
    super.onOpen();
    if ("open" === this.readyState && this.opts.upgrade) {
      for (let i4 = 0; i4 < this._upgrades.length; i4++) {
        this._probe(this._upgrades[i4]);
      }
    }
  }
  /**
   * Probes a transport.
   *
   * @param {String} name - transport name
   * @private
   */
  _probe(name) {
    let transport = this.createTransport(name);
    let failed = false;
    SocketWithoutUpgrade.priorWebsocketSuccess = false;
    const onTransportOpen = () => {
      if (failed)
        return;
      transport.send([{ type: "ping", data: "probe" }]);
      transport.once("packet", (msg) => {
        if (failed)
          return;
        if ("pong" === msg.type && "probe" === msg.data) {
          this.upgrading = true;
          this.emitReserved("upgrading", transport);
          if (!transport)
            return;
          SocketWithoutUpgrade.priorWebsocketSuccess = "websocket" === transport.name;
          this.transport.pause(() => {
            if (failed)
              return;
            if ("closed" === this.readyState)
              return;
            cleanup();
            this.setTransport(transport);
            transport.send([{ type: "upgrade" }]);
            this.emitReserved("upgrade", transport);
            transport = null;
            this.upgrading = false;
            this.flush();
          });
        } else {
          const err = new Error("probe error");
          err.transport = transport.name;
          this.emitReserved("upgradeError", err);
        }
      });
    };
    function freezeTransport() {
      if (failed)
        return;
      failed = true;
      cleanup();
      transport.close();
      transport = null;
    }
    const onerror = (err) => {
      const error = new Error("probe error: " + err);
      error.transport = transport.name;
      freezeTransport();
      this.emitReserved("upgradeError", error);
    };
    function onTransportClose() {
      onerror("transport closed");
    }
    function onclose() {
      onerror("socket closed");
    }
    function onupgrade(to2) {
      if (transport && to2.name !== transport.name) {
        freezeTransport();
      }
    }
    const cleanup = () => {
      transport.removeListener("open", onTransportOpen);
      transport.removeListener("error", onerror);
      transport.removeListener("close", onTransportClose);
      this.off("close", onclose);
      this.off("upgrading", onupgrade);
    };
    transport.once("open", onTransportOpen);
    transport.once("error", onerror);
    transport.once("close", onTransportClose);
    this.once("close", onclose);
    this.once("upgrading", onupgrade);
    if (this._upgrades.indexOf("webtransport") !== -1 && name !== "webtransport") {
      this.setTimeoutFn(() => {
        if (!failed) {
          transport.open();
        }
      }, 200);
    } else {
      transport.open();
    }
  }
  onHandshake(data) {
    this._upgrades = this._filterUpgrades(data.upgrades);
    super.onHandshake(data);
  }
  /**
   * Filters upgrades, returning only those matching client transports.
   *
   * @param {Array} upgrades - server upgrades
   * @private
   */
  _filterUpgrades(upgrades) {
    const filteredUpgrades = [];
    for (let i4 = 0; i4 < upgrades.length; i4++) {
      if (~this.transports.indexOf(upgrades[i4]))
        filteredUpgrades.push(upgrades[i4]);
    }
    return filteredUpgrades;
  }
};
var Socket = class extends SocketWithUpgrade {
  constructor(uri, opts = {}) {
    const o3 = typeof uri === "object" ? uri : opts;
    if (!o3.transports || o3.transports && typeof o3.transports[0] === "string") {
      o3.transports = (o3.transports || ["polling", "websocket", "webtransport"]).map((transportName) => transports[transportName]).filter((t3) => !!t3);
    }
    super(uri, o3);
  }
};

// node_modules/engine.io-client/build/esm/index.js
var protocol2 = Socket.protocol;

// node_modules/socket.io-client/build/esm/url.js
function url(uri, path = "", loc) {
  let obj = uri;
  loc = loc || typeof location !== "undefined" && location;
  if (null == uri)
    uri = loc.protocol + "//" + loc.host;
  if (typeof uri === "string") {
    if ("/" === uri.charAt(0)) {
      if ("/" === uri.charAt(1)) {
        uri = loc.protocol + uri;
      } else {
        uri = loc.host + uri;
      }
    }
    if (!/^(https?|wss?):\/\//.test(uri)) {
      if ("undefined" !== typeof loc) {
        uri = loc.protocol + "//" + uri;
      } else {
        uri = "https://" + uri;
      }
    }
    obj = parse2(uri);
  }
  if (!obj.port) {
    if (/^(http|ws)$/.test(obj.protocol)) {
      obj.port = "80";
    } else if (/^(http|ws)s$/.test(obj.protocol)) {
      obj.port = "443";
    }
  }
  obj.path = obj.path || "/";
  const ipv6 = obj.host.indexOf(":") !== -1;
  const host = ipv6 ? "[" + obj.host + "]" : obj.host;
  obj.id = obj.protocol + "://" + host + ":" + obj.port + path;
  obj.href = obj.protocol + "://" + host + (loc && loc.port === obj.port ? "" : ":" + obj.port);
  return obj;
}

// node_modules/socket.io-parser/build/esm/index.js
var esm_exports = {};
__export(esm_exports, {
  Decoder: () => Decoder,
  Encoder: () => Encoder,
  PacketType: () => PacketType,
  protocol: () => protocol3
});

// node_modules/socket.io-parser/build/esm/is-binary.js
var withNativeArrayBuffer3 = typeof ArrayBuffer === "function";
var isView2 = (obj) => {
  return typeof ArrayBuffer.isView === "function" ? ArrayBuffer.isView(obj) : obj.buffer instanceof ArrayBuffer;
};
var toString = Object.prototype.toString;
var withNativeBlob2 = typeof Blob === "function" || typeof Blob !== "undefined" && toString.call(Blob) === "[object BlobConstructor]";
var withNativeFile = typeof File === "function" || typeof File !== "undefined" && toString.call(File) === "[object FileConstructor]";
function isBinary(obj) {
  return withNativeArrayBuffer3 && (obj instanceof ArrayBuffer || isView2(obj)) || withNativeBlob2 && obj instanceof Blob || withNativeFile && obj instanceof File;
}
function hasBinary(obj, toJSON) {
  if (!obj || typeof obj !== "object") {
    return false;
  }
  if (Array.isArray(obj)) {
    for (let i4 = 0, l5 = obj.length; i4 < l5; i4++) {
      if (hasBinary(obj[i4])) {
        return true;
      }
    }
    return false;
  }
  if (isBinary(obj)) {
    return true;
  }
  if (obj.toJSON && typeof obj.toJSON === "function" && arguments.length === 1) {
    return hasBinary(obj.toJSON(), true);
  }
  for (const key in obj) {
    if (Object.prototype.hasOwnProperty.call(obj, key) && hasBinary(obj[key])) {
      return true;
    }
  }
  return false;
}

// node_modules/socket.io-parser/build/esm/binary.js
function deconstructPacket(packet) {
  const buffers = [];
  const packetData = packet.data;
  const pack = packet;
  pack.data = _deconstructPacket(packetData, buffers);
  pack.attachments = buffers.length;
  return { packet: pack, buffers };
}
function _deconstructPacket(data, buffers) {
  if (!data)
    return data;
  if (isBinary(data)) {
    const placeholder = { _placeholder: true, num: buffers.length };
    buffers.push(data);
    return placeholder;
  } else if (Array.isArray(data)) {
    const newData = new Array(data.length);
    for (let i4 = 0; i4 < data.length; i4++) {
      newData[i4] = _deconstructPacket(data[i4], buffers);
    }
    return newData;
  } else if (typeof data === "object" && !(data instanceof Date)) {
    const newData = {};
    for (const key in data) {
      if (Object.prototype.hasOwnProperty.call(data, key)) {
        newData[key] = _deconstructPacket(data[key], buffers);
      }
    }
    return newData;
  }
  return data;
}
function reconstructPacket(packet, buffers) {
  packet.data = _reconstructPacket(packet.data, buffers);
  delete packet.attachments;
  return packet;
}
function _reconstructPacket(data, buffers) {
  if (!data)
    return data;
  if (data && data._placeholder === true) {
    const isIndexValid = typeof data.num === "number" && data.num >= 0 && data.num < buffers.length;
    if (isIndexValid) {
      return buffers[data.num];
    } else {
      throw new Error("illegal attachments");
    }
  } else if (Array.isArray(data)) {
    for (let i4 = 0; i4 < data.length; i4++) {
      data[i4] = _reconstructPacket(data[i4], buffers);
    }
  } else if (typeof data === "object") {
    for (const key in data) {
      if (Object.prototype.hasOwnProperty.call(data, key)) {
        data[key] = _reconstructPacket(data[key], buffers);
      }
    }
  }
  return data;
}

// node_modules/socket.io-parser/build/esm/index.js
var RESERVED_EVENTS = [
  "connect",
  "connect_error",
  "disconnect",
  "disconnecting",
  "newListener",
  "removeListener"
  // used by the Node.js EventEmitter
];
var protocol3 = 5;
var PacketType;
(function(PacketType2) {
  PacketType2[PacketType2["CONNECT"] = 0] = "CONNECT";
  PacketType2[PacketType2["DISCONNECT"] = 1] = "DISCONNECT";
  PacketType2[PacketType2["EVENT"] = 2] = "EVENT";
  PacketType2[PacketType2["ACK"] = 3] = "ACK";
  PacketType2[PacketType2["CONNECT_ERROR"] = 4] = "CONNECT_ERROR";
  PacketType2[PacketType2["BINARY_EVENT"] = 5] = "BINARY_EVENT";
  PacketType2[PacketType2["BINARY_ACK"] = 6] = "BINARY_ACK";
})(PacketType || (PacketType = {}));
var Encoder = class {
  /**
   * Encoder constructor
   *
   * @param {function} replacer - custom replacer to pass down to JSON.parse
   */
  constructor(replacer) {
    this.replacer = replacer;
  }
  /**
   * Encode a packet as a single string if non-binary, or as a
   * buffer sequence, depending on packet type.
   *
   * @param {Object} obj - packet object
   */
  encode(obj) {
    if (obj.type === PacketType.EVENT || obj.type === PacketType.ACK) {
      if (hasBinary(obj)) {
        return this.encodeAsBinary({
          type: obj.type === PacketType.EVENT ? PacketType.BINARY_EVENT : PacketType.BINARY_ACK,
          nsp: obj.nsp,
          data: obj.data,
          id: obj.id
        });
      }
    }
    return [this.encodeAsString(obj)];
  }
  /**
   * Encode packet as string.
   */
  encodeAsString(obj) {
    let str = "" + obj.type;
    if (obj.type === PacketType.BINARY_EVENT || obj.type === PacketType.BINARY_ACK) {
      str += obj.attachments + "-";
    }
    if (obj.nsp && "/" !== obj.nsp) {
      str += obj.nsp + ",";
    }
    if (null != obj.id) {
      str += obj.id;
    }
    if (null != obj.data) {
      str += JSON.stringify(obj.data, this.replacer);
    }
    return str;
  }
  /**
   * Encode packet as 'buffer sequence' by removing blobs, and
   * deconstructing packet into object with placeholders and
   * a list of buffers.
   */
  encodeAsBinary(obj) {
    const deconstruction = deconstructPacket(obj);
    const pack = this.encodeAsString(deconstruction.packet);
    const buffers = deconstruction.buffers;
    buffers.unshift(pack);
    return buffers;
  }
};
function isObject(value2) {
  return Object.prototype.toString.call(value2) === "[object Object]";
}
var Decoder = class _Decoder extends Emitter {
  /**
   * Decoder constructor
   *
   * @param {function} reviver - custom reviver to pass down to JSON.stringify
   */
  constructor(reviver) {
    super();
    this.reviver = reviver;
  }
  /**
   * Decodes an encoded packet string into packet JSON.
   *
   * @param {String} obj - encoded packet
   */
  add(obj) {
    let packet;
    if (typeof obj === "string") {
      if (this.reconstructor) {
        throw new Error("got plaintext data when reconstructing a packet");
      }
      packet = this.decodeString(obj);
      const isBinaryEvent = packet.type === PacketType.BINARY_EVENT;
      if (isBinaryEvent || packet.type === PacketType.BINARY_ACK) {
        packet.type = isBinaryEvent ? PacketType.EVENT : PacketType.ACK;
        this.reconstructor = new BinaryReconstructor(packet);
        if (packet.attachments === 0) {
          super.emitReserved("decoded", packet);
        }
      } else {
        super.emitReserved("decoded", packet);
      }
    } else if (isBinary(obj) || obj.base64) {
      if (!this.reconstructor) {
        throw new Error("got binary data when not reconstructing a packet");
      } else {
        packet = this.reconstructor.takeBinaryData(obj);
        if (packet) {
          this.reconstructor = null;
          super.emitReserved("decoded", packet);
        }
      }
    } else {
      throw new Error("Unknown type: " + obj);
    }
  }
  /**
   * Decode a packet String (JSON data)
   *
   * @param {String} str
   * @return {Object} packet
   */
  decodeString(str) {
    let i4 = 0;
    const p4 = {
      type: Number(str.charAt(0))
    };
    if (PacketType[p4.type] === void 0) {
      throw new Error("unknown packet type " + p4.type);
    }
    if (p4.type === PacketType.BINARY_EVENT || p4.type === PacketType.BINARY_ACK) {
      const start = i4 + 1;
      while (str.charAt(++i4) !== "-" && i4 != str.length) {
      }
      const buf = str.substring(start, i4);
      if (buf != Number(buf) || str.charAt(i4) !== "-") {
        throw new Error("Illegal attachments");
      }
      p4.attachments = Number(buf);
    }
    if ("/" === str.charAt(i4 + 1)) {
      const start = i4 + 1;
      while (++i4) {
        const c3 = str.charAt(i4);
        if ("," === c3)
          break;
        if (i4 === str.length)
          break;
      }
      p4.nsp = str.substring(start, i4);
    } else {
      p4.nsp = "/";
    }
    const next = str.charAt(i4 + 1);
    if ("" !== next && Number(next) == next) {
      const start = i4 + 1;
      while (++i4) {
        const c3 = str.charAt(i4);
        if (null == c3 || Number(c3) != c3) {
          --i4;
          break;
        }
        if (i4 === str.length)
          break;
      }
      p4.id = Number(str.substring(start, i4 + 1));
    }
    if (str.charAt(++i4)) {
      const payload = this.tryParse(str.substr(i4));
      if (_Decoder.isPayloadValid(p4.type, payload)) {
        p4.data = payload;
      } else {
        throw new Error("invalid payload");
      }
    }
    return p4;
  }
  tryParse(str) {
    try {
      return JSON.parse(str, this.reviver);
    } catch (e9) {
      return false;
    }
  }
  static isPayloadValid(type2, payload) {
    switch (type2) {
      case PacketType.CONNECT:
        return isObject(payload);
      case PacketType.DISCONNECT:
        return payload === void 0;
      case PacketType.CONNECT_ERROR:
        return typeof payload === "string" || isObject(payload);
      case PacketType.EVENT:
      case PacketType.BINARY_EVENT:
        return Array.isArray(payload) && (typeof payload[0] === "number" || typeof payload[0] === "string" && RESERVED_EVENTS.indexOf(payload[0]) === -1);
      case PacketType.ACK:
      case PacketType.BINARY_ACK:
        return Array.isArray(payload);
    }
  }
  /**
   * Deallocates a parser's resources
   */
  destroy() {
    if (this.reconstructor) {
      this.reconstructor.finishedReconstruction();
      this.reconstructor = null;
    }
  }
};
var BinaryReconstructor = class {
  constructor(packet) {
    this.packet = packet;
    this.buffers = [];
    this.reconPack = packet;
  }
  /**
   * Method to be called when binary data received from connection
   * after a BINARY_EVENT packet.
   *
   * @param {Buffer | ArrayBuffer} binData - the raw binary data received
   * @return {null | Object} returns null if more binary data is expected or
   *   a reconstructed packet object if all buffers have been received.
   */
  takeBinaryData(binData) {
    this.buffers.push(binData);
    if (this.buffers.length === this.reconPack.attachments) {
      const packet = reconstructPacket(this.reconPack, this.buffers);
      this.finishedReconstruction();
      return packet;
    }
    return null;
  }
  /**
   * Cleans up binary packet reconstruction variables.
   */
  finishedReconstruction() {
    this.reconPack = null;
    this.buffers = [];
  }
};

// node_modules/socket.io-client/build/esm/on.js
function on(obj, ev, fn3) {
  obj.on(ev, fn3);
  return function subDestroy() {
    obj.off(ev, fn3);
  };
}

// node_modules/socket.io-client/build/esm/socket.js
var RESERVED_EVENTS2 = Object.freeze({
  connect: 1,
  connect_error: 1,
  disconnect: 1,
  disconnecting: 1,
  // EventEmitter reserved events: https://nodejs.org/api/events.html#events_event_newlistener
  newListener: 1,
  removeListener: 1
});
var Socket2 = class extends Emitter {
  /**
   * `Socket` constructor.
   */
  constructor(io2, nsp, opts) {
    super();
    this.connected = false;
    this.recovered = false;
    this.receiveBuffer = [];
    this.sendBuffer = [];
    this._queue = [];
    this._queueSeq = 0;
    this.ids = 0;
    this.acks = {};
    this.flags = {};
    this.io = io2;
    this.nsp = nsp;
    if (opts && opts.auth) {
      this.auth = opts.auth;
    }
    this._opts = Object.assign({}, opts);
    if (this.io._autoConnect)
      this.open();
  }
  /**
   * Whether the socket is currently disconnected
   *
   * @example
   * const socket = io();
   *
   * socket.on("connect", () => {
   *   console.log(socket.disconnected); // false
   * });
   *
   * socket.on("disconnect", () => {
   *   console.log(socket.disconnected); // true
   * });
   */
  get disconnected() {
    return !this.connected;
  }
  /**
   * Subscribe to open, close and packet events
   *
   * @private
   */
  subEvents() {
    if (this.subs)
      return;
    const io2 = this.io;
    this.subs = [
      on(io2, "open", this.onopen.bind(this)),
      on(io2, "packet", this.onpacket.bind(this)),
      on(io2, "error", this.onerror.bind(this)),
      on(io2, "close", this.onclose.bind(this))
    ];
  }
  /**
   * Whether the Socket will try to reconnect when its Manager connects or reconnects.
   *
   * @example
   * const socket = io();
   *
   * console.log(socket.active); // true
   *
   * socket.on("disconnect", (reason) => {
   *   if (reason === "io server disconnect") {
   *     // the disconnection was initiated by the server, you need to manually reconnect
   *     console.log(socket.active); // false
   *   }
   *   // else the socket will automatically try to reconnect
   *   console.log(socket.active); // true
   * });
   */
  get active() {
    return !!this.subs;
  }
  /**
   * "Opens" the socket.
   *
   * @example
   * const socket = io({
   *   autoConnect: false
   * });
   *
   * socket.connect();
   */
  connect() {
    if (this.connected)
      return this;
    this.subEvents();
    if (!this.io["_reconnecting"])
      this.io.open();
    if ("open" === this.io._readyState)
      this.onopen();
    return this;
  }
  /**
   * Alias for {@link connect()}.
   */
  open() {
    return this.connect();
  }
  /**
   * Sends a `message` event.
   *
   * This method mimics the WebSocket.send() method.
   *
   * @see https://developer.mozilla.org/en-US/docs/Web/API/WebSocket/send
   *
   * @example
   * socket.send("hello");
   *
   * // this is equivalent to
   * socket.emit("message", "hello");
   *
   * @return self
   */
  send(...args) {
    args.unshift("message");
    this.emit.apply(this, args);
    return this;
  }
  /**
   * Override `emit`.
   * If the event is in `events`, it's emitted normally.
   *
   * @example
   * socket.emit("hello", "world");
   *
   * // all serializable datastructures are supported (no need to call JSON.stringify)
   * socket.emit("hello", 1, "2", { 3: ["4"], 5: Uint8Array.from([6]) });
   *
   * // with an acknowledgement from the server
   * socket.emit("hello", "world", (val) => {
   *   // ...
   * });
   *
   * @return self
   */
  emit(ev, ...args) {
    var _a2, _b, _c2;
    if (RESERVED_EVENTS2.hasOwnProperty(ev)) {
      throw new Error('"' + ev.toString() + '" is a reserved event name');
    }
    args.unshift(ev);
    if (this._opts.retries && !this.flags.fromQueue && !this.flags.volatile) {
      this._addToQueue(args);
      return this;
    }
    const packet = {
      type: PacketType.EVENT,
      data: args
    };
    packet.options = {};
    packet.options.compress = this.flags.compress !== false;
    if ("function" === typeof args[args.length - 1]) {
      const id2 = this.ids++;
      const ack = args.pop();
      this._registerAckCallback(id2, ack);
      packet.id = id2;
    }
    const isTransportWritable = (_b = (_a2 = this.io.engine) === null || _a2 === void 0 ? void 0 : _a2.transport) === null || _b === void 0 ? void 0 : _b.writable;
    const isConnected = this.connected && !((_c2 = this.io.engine) === null || _c2 === void 0 ? void 0 : _c2._hasPingExpired());
    const discardPacket = this.flags.volatile && !isTransportWritable;
    if (discardPacket) {
    } else if (isConnected) {
      this.notifyOutgoingListeners(packet);
      this.packet(packet);
    } else {
      this.sendBuffer.push(packet);
    }
    this.flags = {};
    return this;
  }
  /**
   * @private
   */
  _registerAckCallback(id2, ack) {
    var _a2;
    const timeout = (_a2 = this.flags.timeout) !== null && _a2 !== void 0 ? _a2 : this._opts.ackTimeout;
    if (timeout === void 0) {
      this.acks[id2] = ack;
      return;
    }
    const timer = this.io.setTimeoutFn(() => {
      delete this.acks[id2];
      for (let i4 = 0; i4 < this.sendBuffer.length; i4++) {
        if (this.sendBuffer[i4].id === id2) {
          this.sendBuffer.splice(i4, 1);
        }
      }
      ack.call(this, new Error("operation has timed out"));
    }, timeout);
    const fn3 = (...args) => {
      this.io.clearTimeoutFn(timer);
      ack.apply(this, args);
    };
    fn3.withError = true;
    this.acks[id2] = fn3;
  }
  /**
   * Emits an event and waits for an acknowledgement
   *
   * @example
   * // without timeout
   * const response = await socket.emitWithAck("hello", "world");
   *
   * // with a specific timeout
   * try {
   *   const response = await socket.timeout(1000).emitWithAck("hello", "world");
   * } catch (err) {
   *   // the server did not acknowledge the event in the given delay
   * }
   *
   * @return a Promise that will be fulfilled when the server acknowledges the event
   */
  emitWithAck(ev, ...args) {
    return new Promise((resolve, reject) => {
      const fn3 = (arg1, arg2) => {
        return arg1 ? reject(arg1) : resolve(arg2);
      };
      fn3.withError = true;
      args.push(fn3);
      this.emit(ev, ...args);
    });
  }
  /**
   * Add the packet to the queue.
   * @param args
   * @private
   */
  _addToQueue(args) {
    let ack;
    if (typeof args[args.length - 1] === "function") {
      ack = args.pop();
    }
    const packet = {
      id: this._queueSeq++,
      tryCount: 0,
      pending: false,
      args,
      flags: Object.assign({ fromQueue: true }, this.flags)
    };
    args.push((err, ...responseArgs) => {
      if (packet !== this._queue[0]) {
        return;
      }
      const hasError = err !== null;
      if (hasError) {
        if (packet.tryCount > this._opts.retries) {
          this._queue.shift();
          if (ack) {
            ack(err);
          }
        }
      } else {
        this._queue.shift();
        if (ack) {
          ack(null, ...responseArgs);
        }
      }
      packet.pending = false;
      return this._drainQueue();
    });
    this._queue.push(packet);
    this._drainQueue();
  }
  /**
   * Send the first packet of the queue, and wait for an acknowledgement from the server.
   * @param force - whether to resend a packet that has not been acknowledged yet
   *
   * @private
   */
  _drainQueue(force = false) {
    if (!this.connected || this._queue.length === 0) {
      return;
    }
    const packet = this._queue[0];
    if (packet.pending && !force) {
      return;
    }
    packet.pending = true;
    packet.tryCount++;
    this.flags = packet.flags;
    this.emit.apply(this, packet.args);
  }
  /**
   * Sends a packet.
   *
   * @param packet
   * @private
   */
  packet(packet) {
    packet.nsp = this.nsp;
    this.io._packet(packet);
  }
  /**
   * Called upon engine `open`.
   *
   * @private
   */
  onopen() {
    if (typeof this.auth == "function") {
      this.auth((data) => {
        this._sendConnectPacket(data);
      });
    } else {
      this._sendConnectPacket(this.auth);
    }
  }
  /**
   * Sends a CONNECT packet to initiate the Socket.IO session.
   *
   * @param data
   * @private
   */
  _sendConnectPacket(data) {
    this.packet({
      type: PacketType.CONNECT,
      data: this._pid ? Object.assign({ pid: this._pid, offset: this._lastOffset }, data) : data
    });
  }
  /**
   * Called upon engine or manager `error`.
   *
   * @param err
   * @private
   */
  onerror(err) {
    if (!this.connected) {
      this.emitReserved("connect_error", err);
    }
  }
  /**
   * Called upon engine `close`.
   *
   * @param reason
   * @param description
   * @private
   */
  onclose(reason, description) {
    this.connected = false;
    delete this.id;
    this.emitReserved("disconnect", reason, description);
    this._clearAcks();
  }
  /**
   * Clears the acknowledgement handlers upon disconnection, since the client will never receive an acknowledgement from
   * the server.
   *
   * @private
   */
  _clearAcks() {
    Object.keys(this.acks).forEach((id2) => {
      const isBuffered = this.sendBuffer.some((packet) => String(packet.id) === id2);
      if (!isBuffered) {
        const ack = this.acks[id2];
        delete this.acks[id2];
        if (ack.withError) {
          ack.call(this, new Error("socket has been disconnected"));
        }
      }
    });
  }
  /**
   * Called with socket packet.
   *
   * @param packet
   * @private
   */
  onpacket(packet) {
    const sameNamespace = packet.nsp === this.nsp;
    if (!sameNamespace)
      return;
    switch (packet.type) {
      case PacketType.CONNECT:
        if (packet.data && packet.data.sid) {
          this.onconnect(packet.data.sid, packet.data.pid);
        } else {
          this.emitReserved("connect_error", new Error("It seems you are trying to reach a Socket.IO server in v2.x with a v3.x client, but they are not compatible (more information here: https://socket.io/docs/v3/migrating-from-2-x-to-3-0/)"));
        }
        break;
      case PacketType.EVENT:
      case PacketType.BINARY_EVENT:
        this.onevent(packet);
        break;
      case PacketType.ACK:
      case PacketType.BINARY_ACK:
        this.onack(packet);
        break;
      case PacketType.DISCONNECT:
        this.ondisconnect();
        break;
      case PacketType.CONNECT_ERROR:
        this.destroy();
        const err = new Error(packet.data.message);
        err.data = packet.data.data;
        this.emitReserved("connect_error", err);
        break;
    }
  }
  /**
   * Called upon a server event.
   *
   * @param packet
   * @private
   */
  onevent(packet) {
    const args = packet.data || [];
    if (null != packet.id) {
      args.push(this.ack(packet.id));
    }
    if (this.connected) {
      this.emitEvent(args);
    } else {
      this.receiveBuffer.push(Object.freeze(args));
    }
  }
  emitEvent(args) {
    if (this._anyListeners && this._anyListeners.length) {
      const listeners = this._anyListeners.slice();
      for (const listener of listeners) {
        listener.apply(this, args);
      }
    }
    super.emit.apply(this, args);
    if (this._pid && args.length && typeof args[args.length - 1] === "string") {
      this._lastOffset = args[args.length - 1];
    }
  }
  /**
   * Produces an ack callback to emit with an event.
   *
   * @private
   */
  ack(id2) {
    const self2 = this;
    let sent = false;
    return function(...args) {
      if (sent)
        return;
      sent = true;
      self2.packet({
        type: PacketType.ACK,
        id: id2,
        data: args
      });
    };
  }
  /**
   * Called upon a server acknowledgement.
   *
   * @param packet
   * @private
   */
  onack(packet) {
    const ack = this.acks[packet.id];
    if (typeof ack !== "function") {
      return;
    }
    delete this.acks[packet.id];
    if (ack.withError) {
      packet.data.unshift(null);
    }
    ack.apply(this, packet.data);
  }
  /**
   * Called upon server connect.
   *
   * @private
   */
  onconnect(id2, pid) {
    this.id = id2;
    this.recovered = pid && this._pid === pid;
    this._pid = pid;
    this.connected = true;
    this.emitBuffered();
    this.emitReserved("connect");
    this._drainQueue(true);
  }
  /**
   * Emit buffered events (received and emitted).
   *
   * @private
   */
  emitBuffered() {
    this.receiveBuffer.forEach((args) => this.emitEvent(args));
    this.receiveBuffer = [];
    this.sendBuffer.forEach((packet) => {
      this.notifyOutgoingListeners(packet);
      this.packet(packet);
    });
    this.sendBuffer = [];
  }
  /**
   * Called upon server disconnect.
   *
   * @private
   */
  ondisconnect() {
    this.destroy();
    this.onclose("io server disconnect");
  }
  /**
   * Called upon forced client/server side disconnections,
   * this method ensures the manager stops tracking us and
   * that reconnections don't get triggered for this.
   *
   * @private
   */
  destroy() {
    if (this.subs) {
      this.subs.forEach((subDestroy) => subDestroy());
      this.subs = void 0;
    }
    this.io["_destroy"](this);
  }
  /**
   * Disconnects the socket manually. In that case, the socket will not try to reconnect.
   *
   * If this is the last active Socket instance of the {@link Manager}, the low-level connection will be closed.
   *
   * @example
   * const socket = io();
   *
   * socket.on("disconnect", (reason) => {
   *   // console.log(reason); prints "io client disconnect"
   * });
   *
   * socket.disconnect();
   *
   * @return self
   */
  disconnect() {
    if (this.connected) {
      this.packet({ type: PacketType.DISCONNECT });
    }
    this.destroy();
    if (this.connected) {
      this.onclose("io client disconnect");
    }
    return this;
  }
  /**
   * Alias for {@link disconnect()}.
   *
   * @return self
   */
  close() {
    return this.disconnect();
  }
  /**
   * Sets the compress flag.
   *
   * @example
   * socket.compress(false).emit("hello");
   *
   * @param compress - if `true`, compresses the sending data
   * @return self
   */
  compress(compress) {
    this.flags.compress = compress;
    return this;
  }
  /**
   * Sets a modifier for a subsequent event emission that the event message will be dropped when this socket is not
   * ready to send messages.
   *
   * @example
   * socket.volatile.emit("hello"); // the server may or may not receive it
   *
   * @returns self
   */
  get volatile() {
    this.flags.volatile = true;
    return this;
  }
  /**
   * Sets a modifier for a subsequent event emission that the callback will be called with an error when the
   * given number of milliseconds have elapsed without an acknowledgement from the server:
   *
   * @example
   * socket.timeout(5000).emit("my-event", (err) => {
   *   if (err) {
   *     // the server did not acknowledge the event in the given delay
   *   }
   * });
   *
   * @returns self
   */
  timeout(timeout) {
    this.flags.timeout = timeout;
    return this;
  }
  /**
   * Adds a listener that will be fired when any event is emitted. The event name is passed as the first argument to the
   * callback.
   *
   * @example
   * socket.onAny((event, ...args) => {
   *   console.log(`got ${event}`);
   * });
   *
   * @param listener
   */
  onAny(listener) {
    this._anyListeners = this._anyListeners || [];
    this._anyListeners.push(listener);
    return this;
  }
  /**
   * Adds a listener that will be fired when any event is emitted. The event name is passed as the first argument to the
   * callback. The listener is added to the beginning of the listeners array.
   *
   * @example
   * socket.prependAny((event, ...args) => {
   *   console.log(`got event ${event}`);
   * });
   *
   * @param listener
   */
  prependAny(listener) {
    this._anyListeners = this._anyListeners || [];
    this._anyListeners.unshift(listener);
    return this;
  }
  /**
   * Removes the listener that will be fired when any event is emitted.
   *
   * @example
   * const catchAllListener = (event, ...args) => {
   *   console.log(`got event ${event}`);
   * }
   *
   * socket.onAny(catchAllListener);
   *
   * // remove a specific listener
   * socket.offAny(catchAllListener);
   *
   * // or remove all listeners
   * socket.offAny();
   *
   * @param listener
   */
  offAny(listener) {
    if (!this._anyListeners) {
      return this;
    }
    if (listener) {
      const listeners = this._anyListeners;
      for (let i4 = 0; i4 < listeners.length; i4++) {
        if (listener === listeners[i4]) {
          listeners.splice(i4, 1);
          return this;
        }
      }
    } else {
      this._anyListeners = [];
    }
    return this;
  }
  /**
   * Returns an array of listeners that are listening for any event that is specified. This array can be manipulated,
   * e.g. to remove listeners.
   */
  listenersAny() {
    return this._anyListeners || [];
  }
  /**
   * Adds a listener that will be fired when any event is emitted. The event name is passed as the first argument to the
   * callback.
   *
   * Note: acknowledgements sent to the server are not included.
   *
   * @example
   * socket.onAnyOutgoing((event, ...args) => {
   *   console.log(`sent event ${event}`);
   * });
   *
   * @param listener
   */
  onAnyOutgoing(listener) {
    this._anyOutgoingListeners = this._anyOutgoingListeners || [];
    this._anyOutgoingListeners.push(listener);
    return this;
  }
  /**
   * Adds a listener that will be fired when any event is emitted. The event name is passed as the first argument to the
   * callback. The listener is added to the beginning of the listeners array.
   *
   * Note: acknowledgements sent to the server are not included.
   *
   * @example
   * socket.prependAnyOutgoing((event, ...args) => {
   *   console.log(`sent event ${event}`);
   * });
   *
   * @param listener
   */
  prependAnyOutgoing(listener) {
    this._anyOutgoingListeners = this._anyOutgoingListeners || [];
    this._anyOutgoingListeners.unshift(listener);
    return this;
  }
  /**
   * Removes the listener that will be fired when any event is emitted.
   *
   * @example
   * const catchAllListener = (event, ...args) => {
   *   console.log(`sent event ${event}`);
   * }
   *
   * socket.onAnyOutgoing(catchAllListener);
   *
   * // remove a specific listener
   * socket.offAnyOutgoing(catchAllListener);
   *
   * // or remove all listeners
   * socket.offAnyOutgoing();
   *
   * @param [listener] - the catch-all listener (optional)
   */
  offAnyOutgoing(listener) {
    if (!this._anyOutgoingListeners) {
      return this;
    }
    if (listener) {
      const listeners = this._anyOutgoingListeners;
      for (let i4 = 0; i4 < listeners.length; i4++) {
        if (listener === listeners[i4]) {
          listeners.splice(i4, 1);
          return this;
        }
      }
    } else {
      this._anyOutgoingListeners = [];
    }
    return this;
  }
  /**
   * Returns an array of listeners that are listening for any event that is specified. This array can be manipulated,
   * e.g. to remove listeners.
   */
  listenersAnyOutgoing() {
    return this._anyOutgoingListeners || [];
  }
  /**
   * Notify the listeners for each packet sent
   *
   * @param packet
   *
   * @private
   */
  notifyOutgoingListeners(packet) {
    if (this._anyOutgoingListeners && this._anyOutgoingListeners.length) {
      const listeners = this._anyOutgoingListeners.slice();
      for (const listener of listeners) {
        listener.apply(this, packet.data);
      }
    }
  }
};

// node_modules/socket.io-client/build/esm/contrib/backo2.js
function Backoff(opts) {
  opts = opts || {};
  this.ms = opts.min || 100;
  this.max = opts.max || 1e4;
  this.factor = opts.factor || 2;
  this.jitter = opts.jitter > 0 && opts.jitter <= 1 ? opts.jitter : 0;
  this.attempts = 0;
}
Backoff.prototype.duration = function() {
  var ms2 = this.ms * Math.pow(this.factor, this.attempts++);
  if (this.jitter) {
    var rand = Math.random();
    var deviation = Math.floor(rand * this.jitter * ms2);
    ms2 = (Math.floor(rand * 10) & 1) == 0 ? ms2 - deviation : ms2 + deviation;
  }
  return Math.min(ms2, this.max) | 0;
};
Backoff.prototype.reset = function() {
  this.attempts = 0;
};
Backoff.prototype.setMin = function(min) {
  this.ms = min;
};
Backoff.prototype.setMax = function(max) {
  this.max = max;
};
Backoff.prototype.setJitter = function(jitter) {
  this.jitter = jitter;
};

// node_modules/socket.io-client/build/esm/manager.js
var Manager = class extends Emitter {
  constructor(uri, opts) {
    var _a2;
    super();
    this.nsps = {};
    this.subs = [];
    if (uri && "object" === typeof uri) {
      opts = uri;
      uri = void 0;
    }
    opts = opts || {};
    opts.path = opts.path || "/socket.io";
    this.opts = opts;
    installTimerFunctions(this, opts);
    this.reconnection(opts.reconnection !== false);
    this.reconnectionAttempts(opts.reconnectionAttempts || Infinity);
    this.reconnectionDelay(opts.reconnectionDelay || 1e3);
    this.reconnectionDelayMax(opts.reconnectionDelayMax || 5e3);
    this.randomizationFactor((_a2 = opts.randomizationFactor) !== null && _a2 !== void 0 ? _a2 : 0.5);
    this.backoff = new Backoff({
      min: this.reconnectionDelay(),
      max: this.reconnectionDelayMax(),
      jitter: this.randomizationFactor()
    });
    this.timeout(null == opts.timeout ? 2e4 : opts.timeout);
    this._readyState = "closed";
    this.uri = uri;
    const _parser = opts.parser || esm_exports;
    this.encoder = new _parser.Encoder();
    this.decoder = new _parser.Decoder();
    this._autoConnect = opts.autoConnect !== false;
    if (this._autoConnect)
      this.open();
  }
  reconnection(v2) {
    if (!arguments.length)
      return this._reconnection;
    this._reconnection = !!v2;
    if (!v2) {
      this.skipReconnect = true;
    }
    return this;
  }
  reconnectionAttempts(v2) {
    if (v2 === void 0)
      return this._reconnectionAttempts;
    this._reconnectionAttempts = v2;
    return this;
  }
  reconnectionDelay(v2) {
    var _a2;
    if (v2 === void 0)
      return this._reconnectionDelay;
    this._reconnectionDelay = v2;
    (_a2 = this.backoff) === null || _a2 === void 0 ? void 0 : _a2.setMin(v2);
    return this;
  }
  randomizationFactor(v2) {
    var _a2;
    if (v2 === void 0)
      return this._randomizationFactor;
    this._randomizationFactor = v2;
    (_a2 = this.backoff) === null || _a2 === void 0 ? void 0 : _a2.setJitter(v2);
    return this;
  }
  reconnectionDelayMax(v2) {
    var _a2;
    if (v2 === void 0)
      return this._reconnectionDelayMax;
    this._reconnectionDelayMax = v2;
    (_a2 = this.backoff) === null || _a2 === void 0 ? void 0 : _a2.setMax(v2);
    return this;
  }
  timeout(v2) {
    if (!arguments.length)
      return this._timeout;
    this._timeout = v2;
    return this;
  }
  /**
   * Starts trying to reconnect if reconnection is enabled and we have not
   * started reconnecting yet
   *
   * @private
   */
  maybeReconnectOnOpen() {
    if (!this._reconnecting && this._reconnection && this.backoff.attempts === 0) {
      this.reconnect();
    }
  }
  /**
   * Sets the current transport `socket`.
   *
   * @param {Function} fn - optional, callback
   * @return self
   * @public
   */
  open(fn3) {
    if (~this._readyState.indexOf("open"))
      return this;
    this.engine = new Socket(this.uri, this.opts);
    const socket = this.engine;
    const self2 = this;
    this._readyState = "opening";
    this.skipReconnect = false;
    const openSubDestroy = on(socket, "open", function() {
      self2.onopen();
      fn3 && fn3();
    });
    const onError = (err) => {
      this.cleanup();
      this._readyState = "closed";
      this.emitReserved("error", err);
      if (fn3) {
        fn3(err);
      } else {
        this.maybeReconnectOnOpen();
      }
    };
    const errorSub = on(socket, "error", onError);
    if (false !== this._timeout) {
      const timeout = this._timeout;
      const timer = this.setTimeoutFn(() => {
        openSubDestroy();
        onError(new Error("timeout"));
        socket.close();
      }, timeout);
      if (this.opts.autoUnref) {
        timer.unref();
      }
      this.subs.push(() => {
        this.clearTimeoutFn(timer);
      });
    }
    this.subs.push(openSubDestroy);
    this.subs.push(errorSub);
    return this;
  }
  /**
   * Alias for open()
   *
   * @return self
   * @public
   */
  connect(fn3) {
    return this.open(fn3);
  }
  /**
   * Called upon transport open.
   *
   * @private
   */
  onopen() {
    this.cleanup();
    this._readyState = "open";
    this.emitReserved("open");
    const socket = this.engine;
    this.subs.push(
      on(socket, "ping", this.onping.bind(this)),
      on(socket, "data", this.ondata.bind(this)),
      on(socket, "error", this.onerror.bind(this)),
      on(socket, "close", this.onclose.bind(this)),
      // @ts-ignore
      on(this.decoder, "decoded", this.ondecoded.bind(this))
    );
  }
  /**
   * Called upon a ping.
   *
   * @private
   */
  onping() {
    this.emitReserved("ping");
  }
  /**
   * Called with data.
   *
   * @private
   */
  ondata(data) {
    try {
      this.decoder.add(data);
    } catch (e9) {
      this.onclose("parse error", e9);
    }
  }
  /**
   * Called when parser fully decodes a packet.
   *
   * @private
   */
  ondecoded(packet) {
    nextTick(() => {
      this.emitReserved("packet", packet);
    }, this.setTimeoutFn);
  }
  /**
   * Called upon socket error.
   *
   * @private
   */
  onerror(err) {
    this.emitReserved("error", err);
  }
  /**
   * Creates a new socket for the given `nsp`.
   *
   * @return {Socket}
   * @public
   */
  socket(nsp, opts) {
    let socket = this.nsps[nsp];
    if (!socket) {
      socket = new Socket2(this, nsp, opts);
      this.nsps[nsp] = socket;
    } else if (this._autoConnect && !socket.active) {
      socket.connect();
    }
    return socket;
  }
  /**
   * Called upon a socket close.
   *
   * @param socket
   * @private
   */
  _destroy(socket) {
    const nsps = Object.keys(this.nsps);
    for (const nsp of nsps) {
      const socket2 = this.nsps[nsp];
      if (socket2.active) {
        return;
      }
    }
    this._close();
  }
  /**
   * Writes a packet.
   *
   * @param packet
   * @private
   */
  _packet(packet) {
    const encodedPackets = this.encoder.encode(packet);
    for (let i4 = 0; i4 < encodedPackets.length; i4++) {
      this.engine.write(encodedPackets[i4], packet.options);
    }
  }
  /**
   * Clean up transport subscriptions and packet buffer.
   *
   * @private
   */
  cleanup() {
    this.subs.forEach((subDestroy) => subDestroy());
    this.subs.length = 0;
    this.decoder.destroy();
  }
  /**
   * Close the current socket.
   *
   * @private
   */
  _close() {
    this.skipReconnect = true;
    this._reconnecting = false;
    this.onclose("forced close");
  }
  /**
   * Alias for close()
   *
   * @private
   */
  disconnect() {
    return this._close();
  }
  /**
   * Called when:
   *
   * - the low-level engine is closed
   * - the parser encountered a badly formatted packet
   * - all sockets are disconnected
   *
   * @private
   */
  onclose(reason, description) {
    var _a2;
    this.cleanup();
    (_a2 = this.engine) === null || _a2 === void 0 ? void 0 : _a2.close();
    this.backoff.reset();
    this._readyState = "closed";
    this.emitReserved("close", reason, description);
    if (this._reconnection && !this.skipReconnect) {
      this.reconnect();
    }
  }
  /**
   * Attempt a reconnection.
   *
   * @private
   */
  reconnect() {
    if (this._reconnecting || this.skipReconnect)
      return this;
    const self2 = this;
    if (this.backoff.attempts >= this._reconnectionAttempts) {
      this.backoff.reset();
      this.emitReserved("reconnect_failed");
      this._reconnecting = false;
    } else {
      const delay = this.backoff.duration();
      this._reconnecting = true;
      const timer = this.setTimeoutFn(() => {
        if (self2.skipReconnect)
          return;
        this.emitReserved("reconnect_attempt", self2.backoff.attempts);
        if (self2.skipReconnect)
          return;
        self2.open((err) => {
          if (err) {
            self2._reconnecting = false;
            self2.reconnect();
            this.emitReserved("reconnect_error", err);
          } else {
            self2.onreconnect();
          }
        });
      }, delay);
      if (this.opts.autoUnref) {
        timer.unref();
      }
      this.subs.push(() => {
        this.clearTimeoutFn(timer);
      });
    }
  }
  /**
   * Called upon successful reconnect.
   *
   * @private
   */
  onreconnect() {
    const attempt = this.backoff.attempts;
    this._reconnecting = false;
    this.backoff.reset();
    this.emitReserved("reconnect", attempt);
  }
};

// node_modules/socket.io-client/build/esm/index.js
var cache = {};
function lookup2(uri, opts) {
  if (typeof uri === "object") {
    opts = uri;
    uri = void 0;
  }
  opts = opts || {};
  const parsed = url(uri, opts.path || "/socket.io");
  const source = parsed.source;
  const id2 = parsed.id;
  const path = parsed.path;
  const sameNamespace = cache[id2] && path in cache[id2]["nsps"];
  const newConnection = opts.forceNew || opts["force new connection"] || false === opts.multiplex || sameNamespace;
  let io2;
  if (newConnection) {
    io2 = new Manager(source, opts);
  } else {
    if (!cache[id2]) {
      cache[id2] = new Manager(source, opts);
    }
    io2 = cache[id2];
  }
  if (parsed.query && !opts.query) {
    opts.query = parsed.queryKey;
  }
  return io2.socket(parsed.path, opts);
}
Object.assign(lookup2, {
  Manager,
  Socket: Socket2,
  io: lookup2,
  connect: lookup2
});

// import("./**/*.entry.js") in node_modules/@metamask/sdk/dist/browser/es/metamask-sdk.js
var globImport_entry_js = __glob({});

// node_modules/@metamask/sdk/dist/browser/es/metamask-sdk.js
function c2(e9, t3, n6, r2) {
  return new (n6 || (n6 = Promise))(function(i4, o3) {
    function s2(e10) {
      try {
        c3(r2.next(e10));
      } catch (e11) {
        o3(e11);
      }
    }
    function a(e10) {
      try {
        c3(r2.throw(e10));
      } catch (e11) {
        o3(e11);
      }
    }
    function c3(e10) {
      var t4;
      e10.done ? i4(e10.value) : (t4 = e10.value, t4 instanceof n6 ? t4 : new n6(function(e11) {
        e11(t4);
      })).then(s2, a);
    }
    c3((r2 = r2.apply(e9, t3 || [])).next());
  });
}
var l4 = "undefined" != typeof global ? global : "undefined" != typeof self ? self : "undefined" != typeof window ? window : {};
var d2 = [];
var u = [];
var h2 = "undefined" != typeof Uint8Array ? Uint8Array : Array;
var f3 = false;
function p3() {
  f3 = true;
  for (var e9 = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/", t3 = 0; t3 < 64; ++t3) d2[t3] = e9[t3], u[e9.charCodeAt(t3)] = t3;
  u["-".charCodeAt(0)] = 62, u["_".charCodeAt(0)] = 63;
}
function g(e9, t3, n6) {
  for (var r2, i4, o3 = [], s2 = t3; s2 < n6; s2 += 3) r2 = (e9[s2] << 16) + (e9[s2 + 1] << 8) + e9[s2 + 2], o3.push(d2[(i4 = r2) >> 18 & 63] + d2[i4 >> 12 & 63] + d2[i4 >> 6 & 63] + d2[63 & i4]);
  return o3.join("");
}
function m2(e9) {
  var t3;
  f3 || p3();
  for (var n6 = e9.length, r2 = n6 % 3, i4 = "", o3 = [], s2 = 16383, a = 0, c3 = n6 - r2; a < c3; a += s2) o3.push(g(e9, a, a + s2 > c3 ? c3 : a + s2));
  return 1 === r2 ? (t3 = e9[n6 - 1], i4 += d2[t3 >> 2], i4 += d2[t3 << 4 & 63], i4 += "==") : 2 === r2 && (t3 = (e9[n6 - 2] << 8) + e9[n6 - 1], i4 += d2[t3 >> 10], i4 += d2[t3 >> 4 & 63], i4 += d2[t3 << 2 & 63], i4 += "="), o3.push(i4), o3.join("");
}
function y(e9, t3, n6, r2, i4) {
  var o3, s2, a = 8 * i4 - r2 - 1, c3 = (1 << a) - 1, l5 = c3 >> 1, d3 = -7, u2 = n6 ? i4 - 1 : 0, h3 = n6 ? -1 : 1, f4 = e9[t3 + u2];
  for (u2 += h3, o3 = f4 & (1 << -d3) - 1, f4 >>= -d3, d3 += a; d3 > 0; o3 = 256 * o3 + e9[t3 + u2], u2 += h3, d3 -= 8) ;
  for (s2 = o3 & (1 << -d3) - 1, o3 >>= -d3, d3 += r2; d3 > 0; s2 = 256 * s2 + e9[t3 + u2], u2 += h3, d3 -= 8) ;
  if (0 === o3) o3 = 1 - l5;
  else {
    if (o3 === c3) return s2 ? NaN : 1 / 0 * (f4 ? -1 : 1);
    s2 += Math.pow(2, r2), o3 -= l5;
  }
  return (f4 ? -1 : 1) * s2 * Math.pow(2, o3 - r2);
}
function v(e9, t3, n6, r2, i4, o3) {
  var s2, a, c3, l5 = 8 * o3 - i4 - 1, d3 = (1 << l5) - 1, u2 = d3 >> 1, h3 = 23 === i4 ? Math.pow(2, -24) - Math.pow(2, -77) : 0, f4 = r2 ? 0 : o3 - 1, p4 = r2 ? 1 : -1, g2 = t3 < 0 || 0 === t3 && 1 / t3 < 0 ? 1 : 0;
  for (t3 = Math.abs(t3), isNaN(t3) || t3 === 1 / 0 ? (a = isNaN(t3) ? 1 : 0, s2 = d3) : (s2 = Math.floor(Math.log(t3) / Math.LN2), t3 * (c3 = Math.pow(2, -s2)) < 1 && (s2--, c3 *= 2), (t3 += s2 + u2 >= 1 ? h3 / c3 : h3 * Math.pow(2, 1 - u2)) * c3 >= 2 && (s2++, c3 /= 2), s2 + u2 >= d3 ? (a = 0, s2 = d3) : s2 + u2 >= 1 ? (a = (t3 * c3 - 1) * Math.pow(2, i4), s2 += u2) : (a = t3 * Math.pow(2, u2 - 1) * Math.pow(2, i4), s2 = 0)); i4 >= 8; e9[n6 + f4] = 255 & a, f4 += p4, a /= 256, i4 -= 8) ;
  for (s2 = s2 << i4 | a, l5 += i4; l5 > 0; e9[n6 + f4] = 255 & s2, f4 += p4, s2 /= 256, l5 -= 8) ;
  e9[n6 + f4 - p4] |= 128 * g2;
}
var b2 = {}.toString;
var w3 = Array.isArray || function(e9) {
  return "[object Array]" == b2.call(e9);
};
C3.TYPED_ARRAY_SUPPORT = void 0 === l4.TYPED_ARRAY_SUPPORT || l4.TYPED_ARRAY_SUPPORT;
var E2 = S3();
function S3() {
  return C3.TYPED_ARRAY_SUPPORT ? 2147483647 : 1073741823;
}
function _(e9, t3) {
  if (S3() < t3) throw new RangeError("Invalid typed array length");
  return C3.TYPED_ARRAY_SUPPORT ? (e9 = new Uint8Array(t3)).__proto__ = C3.prototype : (null === e9 && (e9 = new C3(t3)), e9.length = t3), e9;
}
function C3(e9, t3, n6) {
  if (!(C3.TYPED_ARRAY_SUPPORT || this instanceof C3)) return new C3(e9, t3, n6);
  if ("number" == typeof e9) {
    if ("string" == typeof t3) throw new Error("If encoding is specified then the first argument must be a string");
    return x2(this, e9);
  }
  return k2(this, e9, t3, n6);
}
function k2(e9, t3, n6, r2) {
  if ("number" == typeof t3) throw new TypeError('"value" argument must not be a number');
  return "undefined" != typeof ArrayBuffer && t3 instanceof ArrayBuffer ? function(e10, t4, n7, r3) {
    if (t4.byteLength, n7 < 0 || t4.byteLength < n7) throw new RangeError("'offset' is out of bounds");
    if (t4.byteLength < n7 + (r3 || 0)) throw new RangeError("'length' is out of bounds");
    t4 = void 0 === n7 && void 0 === r3 ? new Uint8Array(t4) : void 0 === r3 ? new Uint8Array(t4, n7) : new Uint8Array(t4, n7, r3);
    C3.TYPED_ARRAY_SUPPORT ? (e10 = t4).__proto__ = C3.prototype : e10 = M2(e10, t4);
    return e10;
  }(e9, t3, n6, r2) : "string" == typeof t3 ? function(e10, t4, n7) {
    "string" == typeof n7 && "" !== n7 || (n7 = "utf8");
    if (!C3.isEncoding(n7)) throw new TypeError('"encoding" must be a valid string encoding');
    var r3 = 0 | R(t4, n7);
    e10 = _(e10, r3);
    var i4 = e10.write(t4, n7);
    i4 !== r3 && (e10 = e10.slice(0, i4));
    return e10;
  }(e9, t3, n6) : function(e10, t4) {
    if (T2(t4)) {
      var n7 = 0 | I(t4.length);
      return 0 === (e10 = _(e10, n7)).length || t4.copy(e10, 0, 0, n7), e10;
    }
    if (t4) {
      if ("undefined" != typeof ArrayBuffer && t4.buffer instanceof ArrayBuffer || "length" in t4) return "number" != typeof t4.length || (r3 = t4.length) != r3 ? _(e10, 0) : M2(e10, t4);
      if ("Buffer" === t4.type && w3(t4.data)) return M2(e10, t4.data);
    }
    var r3;
    throw new TypeError("First argument must be a string, Buffer, ArrayBuffer, Array, or array-like object.");
  }(e9, t3);
}
function A(e9) {
  if ("number" != typeof e9) throw new TypeError('"size" argument must be a number');
  if (e9 < 0) throw new RangeError('"size" argument must not be negative');
}
function x2(e9, t3) {
  if (A(t3), e9 = _(e9, t3 < 0 ? 0 : 0 | I(t3)), !C3.TYPED_ARRAY_SUPPORT) for (var n6 = 0; n6 < t3; ++n6) e9[n6] = 0;
  return e9;
}
function M2(e9, t3) {
  var n6 = t3.length < 0 ? 0 : 0 | I(t3.length);
  e9 = _(e9, n6);
  for (var r2 = 0; r2 < n6; r2 += 1) e9[r2] = 255 & t3[r2];
  return e9;
}
function I(e9) {
  if (e9 >= S3()) throw new RangeError("Attempt to allocate Buffer larger than maximum size: 0x" + S3().toString(16) + " bytes");
  return 0 | e9;
}
function T2(e9) {
  return !(null == e9 || !e9._isBuffer);
}
function R(e9, t3) {
  if (T2(e9)) return e9.length;
  if ("undefined" != typeof ArrayBuffer && "function" == typeof ArrayBuffer.isView && (ArrayBuffer.isView(e9) || e9 instanceof ArrayBuffer)) return e9.byteLength;
  "string" != typeof e9 && (e9 = "" + e9);
  var n6 = e9.length;
  if (0 === n6) return 0;
  for (var r2 = false; ; ) switch (t3) {
    case "ascii":
    case "latin1":
    case "binary":
      return n6;
    case "utf8":
    case "utf-8":
    case void 0:
      return ie(e9).length;
    case "ucs2":
    case "ucs-2":
    case "utf16le":
    case "utf-16le":
      return 2 * n6;
    case "hex":
      return n6 >>> 1;
    case "base64":
      return oe(e9).length;
    default:
      if (r2) return ie(e9).length;
      t3 = ("" + t3).toLowerCase(), r2 = true;
  }
}
function P3(e9, t3, n6) {
  var r2 = false;
  if ((void 0 === t3 || t3 < 0) && (t3 = 0), t3 > this.length) return "";
  if ((void 0 === n6 || n6 > this.length) && (n6 = this.length), n6 <= 0) return "";
  if ((n6 >>>= 0) <= (t3 >>>= 0)) return "";
  for (e9 || (e9 = "utf8"); ; ) switch (e9) {
    case "hex":
      return V(this, t3, n6);
    case "utf8":
    case "utf-8":
      return F(this, t3, n6);
    case "ascii":
      return q2(this, t3, n6);
    case "latin1":
    case "binary":
      return W2(this, t3, n6);
    case "base64":
      return H(this, t3, n6);
    case "ucs2":
    case "ucs-2":
    case "utf16le":
    case "utf-16le":
      return G(this, t3, n6);
    default:
      if (r2) throw new TypeError("Unknown encoding: " + e9);
      e9 = (e9 + "").toLowerCase(), r2 = true;
  }
}
function O2(e9, t3, n6) {
  var r2 = e9[t3];
  e9[t3] = e9[n6], e9[n6] = r2;
}
function N(e9, t3, n6, r2, i4) {
  if (0 === e9.length) return -1;
  if ("string" == typeof n6 ? (r2 = n6, n6 = 0) : n6 > 2147483647 ? n6 = 2147483647 : n6 < -2147483648 && (n6 = -2147483648), n6 = +n6, isNaN(n6) && (n6 = i4 ? 0 : e9.length - 1), n6 < 0 && (n6 = e9.length + n6), n6 >= e9.length) {
    if (i4) return -1;
    n6 = e9.length - 1;
  } else if (n6 < 0) {
    if (!i4) return -1;
    n6 = 0;
  }
  if ("string" == typeof t3 && (t3 = C3.from(t3, r2)), T2(t3)) return 0 === t3.length ? -1 : L3(e9, t3, n6, r2, i4);
  if ("number" == typeof t3) return t3 &= 255, C3.TYPED_ARRAY_SUPPORT && "function" == typeof Uint8Array.prototype.indexOf ? i4 ? Uint8Array.prototype.indexOf.call(e9, t3, n6) : Uint8Array.prototype.lastIndexOf.call(e9, t3, n6) : L3(e9, [t3], n6, r2, i4);
  throw new TypeError("val must be string, number or Buffer");
}
function L3(e9, t3, n6, r2, i4) {
  var o3, s2 = 1, a = e9.length, c3 = t3.length;
  if (void 0 !== r2 && ("ucs2" === (r2 = String(r2).toLowerCase()) || "ucs-2" === r2 || "utf16le" === r2 || "utf-16le" === r2)) {
    if (e9.length < 2 || t3.length < 2) return -1;
    s2 = 2, a /= 2, c3 /= 2, n6 /= 2;
  }
  function l5(e10, t4) {
    return 1 === s2 ? e10[t4] : e10.readUInt16BE(t4 * s2);
  }
  if (i4) {
    var d3 = -1;
    for (o3 = n6; o3 < a; o3++) if (l5(e9, o3) === l5(t3, -1 === d3 ? 0 : o3 - d3)) {
      if (-1 === d3 && (d3 = o3), o3 - d3 + 1 === c3) return d3 * s2;
    } else -1 !== d3 && (o3 -= o3 - d3), d3 = -1;
  } else for (n6 + c3 > a && (n6 = a - c3), o3 = n6; o3 >= 0; o3--) {
    for (var u2 = true, h3 = 0; h3 < c3; h3++) if (l5(e9, o3 + h3) !== l5(t3, h3)) {
      u2 = false;
      break;
    }
    if (u2) return o3;
  }
  return -1;
}
function D(e9, t3, n6, r2) {
  n6 = Number(n6) || 0;
  var i4 = e9.length - n6;
  r2 ? (r2 = Number(r2)) > i4 && (r2 = i4) : r2 = i4;
  var o3 = t3.length;
  if (o3 % 2 != 0) throw new TypeError("Invalid hex string");
  r2 > o3 / 2 && (r2 = o3 / 2);
  for (var s2 = 0; s2 < r2; ++s2) {
    var a = parseInt(t3.substr(2 * s2, 2), 16);
    if (isNaN(a)) return s2;
    e9[n6 + s2] = a;
  }
  return s2;
}
function $(e9, t3, n6, r2) {
  return se(ie(t3, e9.length - n6), e9, n6, r2);
}
function B(e9, t3, n6, r2) {
  return se(function(e10) {
    for (var t4 = [], n7 = 0; n7 < e10.length; ++n7) t4.push(255 & e10.charCodeAt(n7));
    return t4;
  }(t3), e9, n6, r2);
}
function K2(e9, t3, n6, r2) {
  return B(e9, t3, n6, r2);
}
function j2(e9, t3, n6, r2) {
  return se(oe(t3), e9, n6, r2);
}
function U3(e9, t3, n6, r2) {
  return se(function(e10, t4) {
    for (var n7, r3, i4, o3 = [], s2 = 0; s2 < e10.length && !((t4 -= 2) < 0); ++s2) r3 = (n7 = e10.charCodeAt(s2)) >> 8, i4 = n7 % 256, o3.push(i4), o3.push(r3);
    return o3;
  }(t3, e9.length - n6), e9, n6, r2);
}
function H(e9, t3, n6) {
  return 0 === t3 && n6 === e9.length ? m2(e9) : m2(e9.slice(t3, n6));
}
function F(e9, t3, n6) {
  n6 = Math.min(e9.length, n6);
  for (var r2 = [], i4 = t3; i4 < n6; ) {
    var o3, s2, a, c3, l5 = e9[i4], d3 = null, u2 = l5 > 239 ? 4 : l5 > 223 ? 3 : l5 > 191 ? 2 : 1;
    if (i4 + u2 <= n6) switch (u2) {
      case 1:
        l5 < 128 && (d3 = l5);
        break;
      case 2:
        128 == (192 & (o3 = e9[i4 + 1])) && (c3 = (31 & l5) << 6 | 63 & o3) > 127 && (d3 = c3);
        break;
      case 3:
        o3 = e9[i4 + 1], s2 = e9[i4 + 2], 128 == (192 & o3) && 128 == (192 & s2) && (c3 = (15 & l5) << 12 | (63 & o3) << 6 | 63 & s2) > 2047 && (c3 < 55296 || c3 > 57343) && (d3 = c3);
        break;
      case 4:
        o3 = e9[i4 + 1], s2 = e9[i4 + 2], a = e9[i4 + 3], 128 == (192 & o3) && 128 == (192 & s2) && 128 == (192 & a) && (c3 = (15 & l5) << 18 | (63 & o3) << 12 | (63 & s2) << 6 | 63 & a) > 65535 && c3 < 1114112 && (d3 = c3);
    }
    null === d3 ? (d3 = 65533, u2 = 1) : d3 > 65535 && (d3 -= 65536, r2.push(d3 >>> 10 & 1023 | 55296), d3 = 56320 | 1023 & d3), r2.push(d3), i4 += u2;
  }
  return function(e10) {
    var t4 = e10.length;
    if (t4 <= z) return String.fromCharCode.apply(String, e10);
    var n7 = "", r3 = 0;
    for (; r3 < t4; ) n7 += String.fromCharCode.apply(String, e10.slice(r3, r3 += z));
    return n7;
  }(r2);
}
C3.poolSize = 8192, C3._augment = function(e9) {
  return e9.__proto__ = C3.prototype, e9;
}, C3.from = function(e9, t3, n6) {
  return k2(null, e9, t3, n6);
}, C3.TYPED_ARRAY_SUPPORT && (C3.prototype.__proto__ = Uint8Array.prototype, C3.__proto__ = Uint8Array, "undefined" != typeof Symbol && Symbol.species && C3[Symbol.species]), C3.alloc = function(e9, t3, n6) {
  return function(e10, t4, n7, r2) {
    return A(t4), t4 <= 0 ? _(e10, t4) : void 0 !== n7 ? "string" == typeof r2 ? _(e10, t4).fill(n7, r2) : _(e10, t4).fill(n7) : _(e10, t4);
  }(null, e9, t3, n6);
}, C3.allocUnsafe = function(e9) {
  return x2(null, e9);
}, C3.allocUnsafeSlow = function(e9) {
  return x2(null, e9);
}, C3.isBuffer = ae, C3.compare = function(e9, t3) {
  if (!T2(e9) || !T2(t3)) throw new TypeError("Arguments must be Buffers");
  if (e9 === t3) return 0;
  for (var n6 = e9.length, r2 = t3.length, i4 = 0, o3 = Math.min(n6, r2); i4 < o3; ++i4) if (e9[i4] !== t3[i4]) {
    n6 = e9[i4], r2 = t3[i4];
    break;
  }
  return n6 < r2 ? -1 : r2 < n6 ? 1 : 0;
}, C3.isEncoding = function(e9) {
  switch (String(e9).toLowerCase()) {
    case "hex":
    case "utf8":
    case "utf-8":
    case "ascii":
    case "latin1":
    case "binary":
    case "base64":
    case "ucs2":
    case "ucs-2":
    case "utf16le":
    case "utf-16le":
      return true;
    default:
      return false;
  }
}, C3.concat = function(e9, t3) {
  if (!w3(e9)) throw new TypeError('"list" argument must be an Array of Buffers');
  if (0 === e9.length) return C3.alloc(0);
  var n6;
  if (void 0 === t3) for (t3 = 0, n6 = 0; n6 < e9.length; ++n6) t3 += e9[n6].length;
  var r2 = C3.allocUnsafe(t3), i4 = 0;
  for (n6 = 0; n6 < e9.length; ++n6) {
    var o3 = e9[n6];
    if (!T2(o3)) throw new TypeError('"list" argument must be an Array of Buffers');
    o3.copy(r2, i4), i4 += o3.length;
  }
  return r2;
}, C3.byteLength = R, C3.prototype._isBuffer = true, C3.prototype.swap16 = function() {
  var e9 = this.length;
  if (e9 % 2 != 0) throw new RangeError("Buffer size must be a multiple of 16-bits");
  for (var t3 = 0; t3 < e9; t3 += 2) O2(this, t3, t3 + 1);
  return this;
}, C3.prototype.swap32 = function() {
  var e9 = this.length;
  if (e9 % 4 != 0) throw new RangeError("Buffer size must be a multiple of 32-bits");
  for (var t3 = 0; t3 < e9; t3 += 4) O2(this, t3, t3 + 3), O2(this, t3 + 1, t3 + 2);
  return this;
}, C3.prototype.swap64 = function() {
  var e9 = this.length;
  if (e9 % 8 != 0) throw new RangeError("Buffer size must be a multiple of 64-bits");
  for (var t3 = 0; t3 < e9; t3 += 8) O2(this, t3, t3 + 7), O2(this, t3 + 1, t3 + 6), O2(this, t3 + 2, t3 + 5), O2(this, t3 + 3, t3 + 4);
  return this;
}, C3.prototype.toString = function() {
  var e9 = 0 | this.length;
  return 0 === e9 ? "" : 0 === arguments.length ? F(this, 0, e9) : P3.apply(this, arguments);
}, C3.prototype.equals = function(e9) {
  if (!T2(e9)) throw new TypeError("Argument must be a Buffer");
  return this === e9 || 0 === C3.compare(this, e9);
}, C3.prototype.inspect = function() {
  var e9 = "";
  return this.length > 0 && (e9 = this.toString("hex", 0, 50).match(/.{2}/g).join(" "), this.length > 50 && (e9 += " ... ")), "<Buffer " + e9 + ">";
}, C3.prototype.compare = function(e9, t3, n6, r2, i4) {
  if (!T2(e9)) throw new TypeError("Argument must be a Buffer");
  if (void 0 === t3 && (t3 = 0), void 0 === n6 && (n6 = e9 ? e9.length : 0), void 0 === r2 && (r2 = 0), void 0 === i4 && (i4 = this.length), t3 < 0 || n6 > e9.length || r2 < 0 || i4 > this.length) throw new RangeError("out of range index");
  if (r2 >= i4 && t3 >= n6) return 0;
  if (r2 >= i4) return -1;
  if (t3 >= n6) return 1;
  if (this === e9) return 0;
  for (var o3 = (i4 >>>= 0) - (r2 >>>= 0), s2 = (n6 >>>= 0) - (t3 >>>= 0), a = Math.min(o3, s2), c3 = this.slice(r2, i4), l5 = e9.slice(t3, n6), d3 = 0; d3 < a; ++d3) if (c3[d3] !== l5[d3]) {
    o3 = c3[d3], s2 = l5[d3];
    break;
  }
  return o3 < s2 ? -1 : s2 < o3 ? 1 : 0;
}, C3.prototype.includes = function(e9, t3, n6) {
  return -1 !== this.indexOf(e9, t3, n6);
}, C3.prototype.indexOf = function(e9, t3, n6) {
  return N(this, e9, t3, n6, true);
}, C3.prototype.lastIndexOf = function(e9, t3, n6) {
  return N(this, e9, t3, n6, false);
}, C3.prototype.write = function(e9, t3, n6, r2) {
  if (void 0 === t3) r2 = "utf8", n6 = this.length, t3 = 0;
  else if (void 0 === n6 && "string" == typeof t3) r2 = t3, n6 = this.length, t3 = 0;
  else {
    if (!isFinite(t3)) throw new Error("Buffer.write(string, encoding, offset[, length]) is no longer supported");
    t3 |= 0, isFinite(n6) ? (n6 |= 0, void 0 === r2 && (r2 = "utf8")) : (r2 = n6, n6 = void 0);
  }
  var i4 = this.length - t3;
  if ((void 0 === n6 || n6 > i4) && (n6 = i4), e9.length > 0 && (n6 < 0 || t3 < 0) || t3 > this.length) throw new RangeError("Attempt to write outside buffer bounds");
  r2 || (r2 = "utf8");
  for (var o3 = false; ; ) switch (r2) {
    case "hex":
      return D(this, e9, t3, n6);
    case "utf8":
    case "utf-8":
      return $(this, e9, t3, n6);
    case "ascii":
      return B(this, e9, t3, n6);
    case "latin1":
    case "binary":
      return K2(this, e9, t3, n6);
    case "base64":
      return j2(this, e9, t3, n6);
    case "ucs2":
    case "ucs-2":
    case "utf16le":
    case "utf-16le":
      return U3(this, e9, t3, n6);
    default:
      if (o3) throw new TypeError("Unknown encoding: " + r2);
      r2 = ("" + r2).toLowerCase(), o3 = true;
  }
}, C3.prototype.toJSON = function() {
  return { type: "Buffer", data: Array.prototype.slice.call(this._arr || this, 0) };
};
var z = 4096;
function q2(e9, t3, n6) {
  var r2 = "";
  n6 = Math.min(e9.length, n6);
  for (var i4 = t3; i4 < n6; ++i4) r2 += String.fromCharCode(127 & e9[i4]);
  return r2;
}
function W2(e9, t3, n6) {
  var r2 = "";
  n6 = Math.min(e9.length, n6);
  for (var i4 = t3; i4 < n6; ++i4) r2 += String.fromCharCode(e9[i4]);
  return r2;
}
function V(e9, t3, n6) {
  var r2 = e9.length;
  (!t3 || t3 < 0) && (t3 = 0), (!n6 || n6 < 0 || n6 > r2) && (n6 = r2);
  for (var i4 = "", o3 = t3; o3 < n6; ++o3) i4 += re2(e9[o3]);
  return i4;
}
function G(e9, t3, n6) {
  for (var r2 = e9.slice(t3, n6), i4 = "", o3 = 0; o3 < r2.length; o3 += 2) i4 += String.fromCharCode(r2[o3] + 256 * r2[o3 + 1]);
  return i4;
}
function Y(e9, t3, n6) {
  if (e9 % 1 != 0 || e9 < 0) throw new RangeError("offset is not uint");
  if (e9 + t3 > n6) throw new RangeError("Trying to access beyond buffer length");
}
function Z2(e9, t3, n6, r2, i4, o3) {
  if (!T2(e9)) throw new TypeError('"buffer" argument must be a Buffer instance');
  if (t3 > i4 || t3 < o3) throw new RangeError('"value" argument is out of bounds');
  if (n6 + r2 > e9.length) throw new RangeError("Index out of range");
}
function J(e9, t3, n6, r2) {
  t3 < 0 && (t3 = 65535 + t3 + 1);
  for (var i4 = 0, o3 = Math.min(e9.length - n6, 2); i4 < o3; ++i4) e9[n6 + i4] = (t3 & 255 << 8 * (r2 ? i4 : 1 - i4)) >>> 8 * (r2 ? i4 : 1 - i4);
}
function Q4(e9, t3, n6, r2) {
  t3 < 0 && (t3 = 4294967295 + t3 + 1);
  for (var i4 = 0, o3 = Math.min(e9.length - n6, 4); i4 < o3; ++i4) e9[n6 + i4] = t3 >>> 8 * (r2 ? i4 : 3 - i4) & 255;
}
function X(e9, t3, n6, r2, i4, o3) {
  if (n6 + r2 > e9.length) throw new RangeError("Index out of range");
  if (n6 < 0) throw new RangeError("Index out of range");
}
function ee(e9, t3, n6, r2, i4) {
  return i4 || X(e9, 0, n6, 4), v(e9, t3, n6, r2, 23, 4), n6 + 4;
}
function te(e9, t3, n6, r2, i4) {
  return i4 || X(e9, 0, n6, 8), v(e9, t3, n6, r2, 52, 8), n6 + 8;
}
C3.prototype.slice = function(e9, t3) {
  var n6, r2 = this.length;
  if ((e9 = ~~e9) < 0 ? (e9 += r2) < 0 && (e9 = 0) : e9 > r2 && (e9 = r2), (t3 = void 0 === t3 ? r2 : ~~t3) < 0 ? (t3 += r2) < 0 && (t3 = 0) : t3 > r2 && (t3 = r2), t3 < e9 && (t3 = e9), C3.TYPED_ARRAY_SUPPORT) (n6 = this.subarray(e9, t3)).__proto__ = C3.prototype;
  else {
    var i4 = t3 - e9;
    n6 = new C3(i4, void 0);
    for (var o3 = 0; o3 < i4; ++o3) n6[o3] = this[o3 + e9];
  }
  return n6;
}, C3.prototype.readUIntLE = function(e9, t3, n6) {
  e9 |= 0, t3 |= 0, n6 || Y(e9, t3, this.length);
  for (var r2 = this[e9], i4 = 1, o3 = 0; ++o3 < t3 && (i4 *= 256); ) r2 += this[e9 + o3] * i4;
  return r2;
}, C3.prototype.readUIntBE = function(e9, t3, n6) {
  e9 |= 0, t3 |= 0, n6 || Y(e9, t3, this.length);
  for (var r2 = this[e9 + --t3], i4 = 1; t3 > 0 && (i4 *= 256); ) r2 += this[e9 + --t3] * i4;
  return r2;
}, C3.prototype.readUInt8 = function(e9, t3) {
  return t3 || Y(e9, 1, this.length), this[e9];
}, C3.prototype.readUInt16LE = function(e9, t3) {
  return t3 || Y(e9, 2, this.length), this[e9] | this[e9 + 1] << 8;
}, C3.prototype.readUInt16BE = function(e9, t3) {
  return t3 || Y(e9, 2, this.length), this[e9] << 8 | this[e9 + 1];
}, C3.prototype.readUInt32LE = function(e9, t3) {
  return t3 || Y(e9, 4, this.length), (this[e9] | this[e9 + 1] << 8 | this[e9 + 2] << 16) + 16777216 * this[e9 + 3];
}, C3.prototype.readUInt32BE = function(e9, t3) {
  return t3 || Y(e9, 4, this.length), 16777216 * this[e9] + (this[e9 + 1] << 16 | this[e9 + 2] << 8 | this[e9 + 3]);
}, C3.prototype.readIntLE = function(e9, t3, n6) {
  e9 |= 0, t3 |= 0, n6 || Y(e9, t3, this.length);
  for (var r2 = this[e9], i4 = 1, o3 = 0; ++o3 < t3 && (i4 *= 256); ) r2 += this[e9 + o3] * i4;
  return r2 >= (i4 *= 128) && (r2 -= Math.pow(2, 8 * t3)), r2;
}, C3.prototype.readIntBE = function(e9, t3, n6) {
  e9 |= 0, t3 |= 0, n6 || Y(e9, t3, this.length);
  for (var r2 = t3, i4 = 1, o3 = this[e9 + --r2]; r2 > 0 && (i4 *= 256); ) o3 += this[e9 + --r2] * i4;
  return o3 >= (i4 *= 128) && (o3 -= Math.pow(2, 8 * t3)), o3;
}, C3.prototype.readInt8 = function(e9, t3) {
  return t3 || Y(e9, 1, this.length), 128 & this[e9] ? -1 * (255 - this[e9] + 1) : this[e9];
}, C3.prototype.readInt16LE = function(e9, t3) {
  t3 || Y(e9, 2, this.length);
  var n6 = this[e9] | this[e9 + 1] << 8;
  return 32768 & n6 ? 4294901760 | n6 : n6;
}, C3.prototype.readInt16BE = function(e9, t3) {
  t3 || Y(e9, 2, this.length);
  var n6 = this[e9 + 1] | this[e9] << 8;
  return 32768 & n6 ? 4294901760 | n6 : n6;
}, C3.prototype.readInt32LE = function(e9, t3) {
  return t3 || Y(e9, 4, this.length), this[e9] | this[e9 + 1] << 8 | this[e9 + 2] << 16 | this[e9 + 3] << 24;
}, C3.prototype.readInt32BE = function(e9, t3) {
  return t3 || Y(e9, 4, this.length), this[e9] << 24 | this[e9 + 1] << 16 | this[e9 + 2] << 8 | this[e9 + 3];
}, C3.prototype.readFloatLE = function(e9, t3) {
  return t3 || Y(e9, 4, this.length), y(this, e9, true, 23, 4);
}, C3.prototype.readFloatBE = function(e9, t3) {
  return t3 || Y(e9, 4, this.length), y(this, e9, false, 23, 4);
}, C3.prototype.readDoubleLE = function(e9, t3) {
  return t3 || Y(e9, 8, this.length), y(this, e9, true, 52, 8);
}, C3.prototype.readDoubleBE = function(e9, t3) {
  return t3 || Y(e9, 8, this.length), y(this, e9, false, 52, 8);
}, C3.prototype.writeUIntLE = function(e9, t3, n6, r2) {
  (e9 = +e9, t3 |= 0, n6 |= 0, r2) || Z2(this, e9, t3, n6, Math.pow(2, 8 * n6) - 1, 0);
  var i4 = 1, o3 = 0;
  for (this[t3] = 255 & e9; ++o3 < n6 && (i4 *= 256); ) this[t3 + o3] = e9 / i4 & 255;
  return t3 + n6;
}, C3.prototype.writeUIntBE = function(e9, t3, n6, r2) {
  (e9 = +e9, t3 |= 0, n6 |= 0, r2) || Z2(this, e9, t3, n6, Math.pow(2, 8 * n6) - 1, 0);
  var i4 = n6 - 1, o3 = 1;
  for (this[t3 + i4] = 255 & e9; --i4 >= 0 && (o3 *= 256); ) this[t3 + i4] = e9 / o3 & 255;
  return t3 + n6;
}, C3.prototype.writeUInt8 = function(e9, t3, n6) {
  return e9 = +e9, t3 |= 0, n6 || Z2(this, e9, t3, 1, 255, 0), C3.TYPED_ARRAY_SUPPORT || (e9 = Math.floor(e9)), this[t3] = 255 & e9, t3 + 1;
}, C3.prototype.writeUInt16LE = function(e9, t3, n6) {
  return e9 = +e9, t3 |= 0, n6 || Z2(this, e9, t3, 2, 65535, 0), C3.TYPED_ARRAY_SUPPORT ? (this[t3] = 255 & e9, this[t3 + 1] = e9 >>> 8) : J(this, e9, t3, true), t3 + 2;
}, C3.prototype.writeUInt16BE = function(e9, t3, n6) {
  return e9 = +e9, t3 |= 0, n6 || Z2(this, e9, t3, 2, 65535, 0), C3.TYPED_ARRAY_SUPPORT ? (this[t3] = e9 >>> 8, this[t3 + 1] = 255 & e9) : J(this, e9, t3, false), t3 + 2;
}, C3.prototype.writeUInt32LE = function(e9, t3, n6) {
  return e9 = +e9, t3 |= 0, n6 || Z2(this, e9, t3, 4, 4294967295, 0), C3.TYPED_ARRAY_SUPPORT ? (this[t3 + 3] = e9 >>> 24, this[t3 + 2] = e9 >>> 16, this[t3 + 1] = e9 >>> 8, this[t3] = 255 & e9) : Q4(this, e9, t3, true), t3 + 4;
}, C3.prototype.writeUInt32BE = function(e9, t3, n6) {
  return e9 = +e9, t3 |= 0, n6 || Z2(this, e9, t3, 4, 4294967295, 0), C3.TYPED_ARRAY_SUPPORT ? (this[t3] = e9 >>> 24, this[t3 + 1] = e9 >>> 16, this[t3 + 2] = e9 >>> 8, this[t3 + 3] = 255 & e9) : Q4(this, e9, t3, false), t3 + 4;
}, C3.prototype.writeIntLE = function(e9, t3, n6, r2) {
  if (e9 = +e9, t3 |= 0, !r2) {
    var i4 = Math.pow(2, 8 * n6 - 1);
    Z2(this, e9, t3, n6, i4 - 1, -i4);
  }
  var o3 = 0, s2 = 1, a = 0;
  for (this[t3] = 255 & e9; ++o3 < n6 && (s2 *= 256); ) e9 < 0 && 0 === a && 0 !== this[t3 + o3 - 1] && (a = 1), this[t3 + o3] = (e9 / s2 >> 0) - a & 255;
  return t3 + n6;
}, C3.prototype.writeIntBE = function(e9, t3, n6, r2) {
  if (e9 = +e9, t3 |= 0, !r2) {
    var i4 = Math.pow(2, 8 * n6 - 1);
    Z2(this, e9, t3, n6, i4 - 1, -i4);
  }
  var o3 = n6 - 1, s2 = 1, a = 0;
  for (this[t3 + o3] = 255 & e9; --o3 >= 0 && (s2 *= 256); ) e9 < 0 && 0 === a && 0 !== this[t3 + o3 + 1] && (a = 1), this[t3 + o3] = (e9 / s2 >> 0) - a & 255;
  return t3 + n6;
}, C3.prototype.writeInt8 = function(e9, t3, n6) {
  return e9 = +e9, t3 |= 0, n6 || Z2(this, e9, t3, 1, 127, -128), C3.TYPED_ARRAY_SUPPORT || (e9 = Math.floor(e9)), e9 < 0 && (e9 = 255 + e9 + 1), this[t3] = 255 & e9, t3 + 1;
}, C3.prototype.writeInt16LE = function(e9, t3, n6) {
  return e9 = +e9, t3 |= 0, n6 || Z2(this, e9, t3, 2, 32767, -32768), C3.TYPED_ARRAY_SUPPORT ? (this[t3] = 255 & e9, this[t3 + 1] = e9 >>> 8) : J(this, e9, t3, true), t3 + 2;
}, C3.prototype.writeInt16BE = function(e9, t3, n6) {
  return e9 = +e9, t3 |= 0, n6 || Z2(this, e9, t3, 2, 32767, -32768), C3.TYPED_ARRAY_SUPPORT ? (this[t3] = e9 >>> 8, this[t3 + 1] = 255 & e9) : J(this, e9, t3, false), t3 + 2;
}, C3.prototype.writeInt32LE = function(e9, t3, n6) {
  return e9 = +e9, t3 |= 0, n6 || Z2(this, e9, t3, 4, 2147483647, -2147483648), C3.TYPED_ARRAY_SUPPORT ? (this[t3] = 255 & e9, this[t3 + 1] = e9 >>> 8, this[t3 + 2] = e9 >>> 16, this[t3 + 3] = e9 >>> 24) : Q4(this, e9, t3, true), t3 + 4;
}, C3.prototype.writeInt32BE = function(e9, t3, n6) {
  return e9 = +e9, t3 |= 0, n6 || Z2(this, e9, t3, 4, 2147483647, -2147483648), e9 < 0 && (e9 = 4294967295 + e9 + 1), C3.TYPED_ARRAY_SUPPORT ? (this[t3] = e9 >>> 24, this[t3 + 1] = e9 >>> 16, this[t3 + 2] = e9 >>> 8, this[t3 + 3] = 255 & e9) : Q4(this, e9, t3, false), t3 + 4;
}, C3.prototype.writeFloatLE = function(e9, t3, n6) {
  return ee(this, e9, t3, true, n6);
}, C3.prototype.writeFloatBE = function(e9, t3, n6) {
  return ee(this, e9, t3, false, n6);
}, C3.prototype.writeDoubleLE = function(e9, t3, n6) {
  return te(this, e9, t3, true, n6);
}, C3.prototype.writeDoubleBE = function(e9, t3, n6) {
  return te(this, e9, t3, false, n6);
}, C3.prototype.copy = function(e9, t3, n6, r2) {
  if (n6 || (n6 = 0), r2 || 0 === r2 || (r2 = this.length), t3 >= e9.length && (t3 = e9.length), t3 || (t3 = 0), r2 > 0 && r2 < n6 && (r2 = n6), r2 === n6) return 0;
  if (0 === e9.length || 0 === this.length) return 0;
  if (t3 < 0) throw new RangeError("targetStart out of bounds");
  if (n6 < 0 || n6 >= this.length) throw new RangeError("sourceStart out of bounds");
  if (r2 < 0) throw new RangeError("sourceEnd out of bounds");
  r2 > this.length && (r2 = this.length), e9.length - t3 < r2 - n6 && (r2 = e9.length - t3 + n6);
  var i4, o3 = r2 - n6;
  if (this === e9 && n6 < t3 && t3 < r2) for (i4 = o3 - 1; i4 >= 0; --i4) e9[i4 + t3] = this[i4 + n6];
  else if (o3 < 1e3 || !C3.TYPED_ARRAY_SUPPORT) for (i4 = 0; i4 < o3; ++i4) e9[i4 + t3] = this[i4 + n6];
  else Uint8Array.prototype.set.call(e9, this.subarray(n6, n6 + o3), t3);
  return o3;
}, C3.prototype.fill = function(e9, t3, n6, r2) {
  if ("string" == typeof e9) {
    if ("string" == typeof t3 ? (r2 = t3, t3 = 0, n6 = this.length) : "string" == typeof n6 && (r2 = n6, n6 = this.length), 1 === e9.length) {
      var i4 = e9.charCodeAt(0);
      i4 < 256 && (e9 = i4);
    }
    if (void 0 !== r2 && "string" != typeof r2) throw new TypeError("encoding must be a string");
    if ("string" == typeof r2 && !C3.isEncoding(r2)) throw new TypeError("Unknown encoding: " + r2);
  } else "number" == typeof e9 && (e9 &= 255);
  if (t3 < 0 || this.length < t3 || this.length < n6) throw new RangeError("Out of range index");
  if (n6 <= t3) return this;
  var o3;
  if (t3 >>>= 0, n6 = void 0 === n6 ? this.length : n6 >>> 0, e9 || (e9 = 0), "number" == typeof e9) for (o3 = t3; o3 < n6; ++o3) this[o3] = e9;
  else {
    var s2 = T2(e9) ? e9 : ie(new C3(e9, r2).toString()), a = s2.length;
    for (o3 = 0; o3 < n6 - t3; ++o3) this[o3 + t3] = s2[o3 % a];
  }
  return this;
};
var ne = /[^+\/0-9A-Za-z-_]/g;
function re2(e9) {
  return e9 < 16 ? "0" + e9.toString(16) : e9.toString(16);
}
function ie(e9, t3) {
  var n6;
  t3 = t3 || 1 / 0;
  for (var r2 = e9.length, i4 = null, o3 = [], s2 = 0; s2 < r2; ++s2) {
    if ((n6 = e9.charCodeAt(s2)) > 55295 && n6 < 57344) {
      if (!i4) {
        if (n6 > 56319) {
          (t3 -= 3) > -1 && o3.push(239, 191, 189);
          continue;
        }
        if (s2 + 1 === r2) {
          (t3 -= 3) > -1 && o3.push(239, 191, 189);
          continue;
        }
        i4 = n6;
        continue;
      }
      if (n6 < 56320) {
        (t3 -= 3) > -1 && o3.push(239, 191, 189), i4 = n6;
        continue;
      }
      n6 = 65536 + (i4 - 55296 << 10 | n6 - 56320);
    } else i4 && (t3 -= 3) > -1 && o3.push(239, 191, 189);
    if (i4 = null, n6 < 128) {
      if ((t3 -= 1) < 0) break;
      o3.push(n6);
    } else if (n6 < 2048) {
      if ((t3 -= 2) < 0) break;
      o3.push(n6 >> 6 | 192, 63 & n6 | 128);
    } else if (n6 < 65536) {
      if ((t3 -= 3) < 0) break;
      o3.push(n6 >> 12 | 224, n6 >> 6 & 63 | 128, 63 & n6 | 128);
    } else {
      if (!(n6 < 1114112)) throw new Error("Invalid code point");
      if ((t3 -= 4) < 0) break;
      o3.push(n6 >> 18 | 240, n6 >> 12 & 63 | 128, n6 >> 6 & 63 | 128, 63 & n6 | 128);
    }
  }
  return o3;
}
function oe(e9) {
  return function(e10) {
    var t3, n6, r2, i4, o3, s2;
    f3 || p3();
    var a = e10.length;
    if (a % 4 > 0) throw new Error("Invalid string. Length must be a multiple of 4");
    o3 = "=" === e10[a - 2] ? 2 : "=" === e10[a - 1] ? 1 : 0, s2 = new h2(3 * a / 4 - o3), r2 = o3 > 0 ? a - 4 : a;
    var c3 = 0;
    for (t3 = 0, n6 = 0; t3 < r2; t3 += 4, n6 += 3) i4 = u[e10.charCodeAt(t3)] << 18 | u[e10.charCodeAt(t3 + 1)] << 12 | u[e10.charCodeAt(t3 + 2)] << 6 | u[e10.charCodeAt(t3 + 3)], s2[c3++] = i4 >> 16 & 255, s2[c3++] = i4 >> 8 & 255, s2[c3++] = 255 & i4;
    return 2 === o3 ? (i4 = u[e10.charCodeAt(t3)] << 2 | u[e10.charCodeAt(t3 + 1)] >> 4, s2[c3++] = 255 & i4) : 1 === o3 && (i4 = u[e10.charCodeAt(t3)] << 10 | u[e10.charCodeAt(t3 + 1)] << 4 | u[e10.charCodeAt(t3 + 2)] >> 2, s2[c3++] = i4 >> 8 & 255, s2[c3++] = 255 & i4), s2;
  }(function(e10) {
    if ((e10 = function(e11) {
      return e11.trim ? e11.trim() : e11.replace(/^\s+|\s+$/g, "");
    }(e10).replace(ne, "")).length < 2) return "";
    for (; e10.length % 4 != 0; ) e10 += "=";
    return e10;
  }(e9));
}
function se(e9, t3, n6, r2) {
  for (var i4 = 0; i4 < r2 && !(i4 + n6 >= t3.length || i4 >= e9.length); ++i4) t3[i4 + n6] = e9[i4];
  return i4;
}
function ae(e9) {
  return null != e9 && (!!e9._isBuffer || ce(e9) || function(e10) {
    return "function" == typeof e10.readFloatLE && "function" == typeof e10.slice && ce(e10.slice(0, 0));
  }(e9));
}
function ce(e9) {
  return !!e9.constructor && "function" == typeof e9.constructor.isBuffer && e9.constructor.isBuffer(e9);
}
var le = Object.freeze({ __proto__: null, Buffer: C3, INSPECT_MAX_BYTES: 50, SlowBuffer: function(e9) {
  return +e9 != e9 && (e9 = 0), C3.alloc(+e9);
}, isBuffer: ae, kMaxLength: E2 });
var de = "undefined" != typeof globalThis ? globalThis : "undefined" != typeof window ? window : "undefined" != typeof global ? global : "undefined" != typeof self ? self : {};
function ue(e9) {
  return e9 && e9.__esModule && Object.prototype.hasOwnProperty.call(e9, "default") ? e9.default : e9;
}
function he(e9) {
  if (e9.__esModule) return e9;
  var t3 = e9.default;
  if ("function" == typeof t3) {
    var n6 = function e10() {
      return this instanceof e10 ? Reflect.construct(t3, arguments, this.constructor) : t3.apply(this, arguments);
    };
    n6.prototype = t3.prototype;
  } else n6 = {};
  return Object.defineProperty(n6, "__esModule", { value: true }), Object.keys(e9).forEach(function(t4) {
    var r2 = Object.getOwnPropertyDescriptor(e9, t4);
    Object.defineProperty(n6, t4, r2.get ? r2 : { enumerable: true, get: function() {
      return e9[t4];
    } });
  }), n6;
}
var fe = {};
var pe = {};
var ge = {};
function me(e9) {
  if (!Number.isSafeInteger(e9) || e9 < 0) throw new Error(`positive integer expected, not ${e9}`);
}
function ye(e9) {
  if ("boolean" != typeof e9) throw new Error(`boolean expected, not ${e9}`);
}
function ve(e9) {
  return e9 instanceof Uint8Array || null != e9 && "object" == typeof e9 && "Uint8Array" === e9.constructor.name;
}
function be(e9, ...t3) {
  if (!ve(e9)) throw new Error("Uint8Array expected");
  if (t3.length > 0 && !t3.includes(e9.length)) throw new Error(`Uint8Array expected of length ${t3}, not of length=${e9.length}`);
}
function we(e9) {
  if ("function" != typeof e9 || "function" != typeof e9.create) throw new Error("hash must be wrapped by utils.wrapConstructor");
  me(e9.outputLen), me(e9.blockLen);
}
function Ee(e9, t3 = true) {
  if (e9.destroyed) throw new Error("Hash instance has been destroyed");
  if (t3 && e9.finished) throw new Error("Hash#digest() has already been called");
}
function Se(e9, t3) {
  be(e9);
  const n6 = t3.outputLen;
  if (e9.length < n6) throw new Error(`digestInto() expects output buffer of length at least ${n6}`);
}
Object.defineProperty(ge, "__esModule", { value: true }), ge.isBytes = ve, ge.number = me, ge.bool = ye, ge.bytes = be, ge.hash = we, ge.exists = Ee, ge.output = Se;
var _e = { number: me, bool: ye, bytes: be, hash: we, exists: Ee, output: Se };
ge.default = _e, function(e9) {
  Object.defineProperty(e9, "__esModule", { value: true }), e9.wrapCipher = e9.Hash = e9.nextTick = e9.isLE = e9.createView = e9.u32 = e9.u16 = e9.u8 = void 0, e9.bytesToHex = r2, e9.hexToBytes = s2, e9.hexToNumber = a, e9.bytesToNumberBE = function(e10) {
    return a(r2(e10));
  }, e9.numberToBytesBE = function(e10, t4) {
    return s2(e10.toString(16).padStart(2 * t4, "0"));
  }, e9.asyncLoop = async function(t4, n7, r3) {
    let i5 = Date.now();
    for (let o4 = 0; o4 < t4; o4++) {
      r3(o4);
      const t5 = Date.now() - i5;
      t5 >= 0 && t5 < n7 || (await (0, e9.nextTick)(), i5 += t5);
    }
  }, e9.utf8ToBytes = c3, e9.bytesToUtf8 = function(e10) {
    return new TextDecoder().decode(e10);
  }, e9.toBytes = function(e10) {
    if ("string" == typeof e10) e10 = c3(e10);
    else {
      if (!(0, t3.isBytes)(e10)) throw new Error("Uint8Array expected, got " + typeof e10);
      e10 = d3(e10);
    }
    return e10;
  }, e9.concatBytes = function(...e10) {
    let n7 = 0;
    for (let r4 = 0; r4 < e10.length; r4++) {
      const i5 = e10[r4];
      (0, t3.bytes)(i5), n7 += i5.length;
    }
    const r3 = new Uint8Array(n7);
    for (let t4 = 0, n8 = 0; t4 < e10.length; t4++) {
      const i5 = e10[t4];
      r3.set(i5, n8), n8 += i5.length;
    }
    return r3;
  }, e9.checkOpts = function(e10, t4) {
    if (null == t4 || "object" != typeof t4) throw new Error("options must be defined");
    return Object.assign(e10, t4);
  }, e9.equalBytes = function(e10, t4) {
    if (e10.length !== t4.length) return false;
    let n7 = 0;
    for (let r3 = 0; r3 < e10.length; r3++) n7 |= e10[r3] ^ t4[r3];
    return 0 === n7;
  }, e9.setBigUint64 = l5, e9.u64Lengths = function(t4, n7) {
    const r3 = new Uint8Array(16), i5 = (0, e9.createView)(r3);
    return l5(i5, 0, BigInt(n7 ? n7.length : 0), true), l5(i5, 8, BigInt(t4.length), true), r3;
  }, e9.isAligned32 = function(e10) {
    return e10.byteOffset % 4 == 0;
  }, e9.copyBytes = d3, e9.clean = function(...e10) {
    for (let t4 = 0; t4 < e10.length; t4++) e10[t4].fill(0);
  };
  const t3 = ge;
  e9.u8 = (e10) => new Uint8Array(e10.buffer, e10.byteOffset, e10.byteLength);
  e9.u16 = (e10) => new Uint16Array(e10.buffer, e10.byteOffset, Math.floor(e10.byteLength / 2));
  e9.u32 = (e10) => new Uint32Array(e10.buffer, e10.byteOffset, Math.floor(e10.byteLength / 4));
  if (e9.createView = (e10) => new DataView(e10.buffer, e10.byteOffset, e10.byteLength), e9.isLE = 68 === new Uint8Array(new Uint32Array([287454020]).buffer)[0], !e9.isLE) throw new Error("Non little-endian hardware is not supported");
  const n6 = Array.from({ length: 256 }, (e10, t4) => t4.toString(16).padStart(2, "0"));
  function r2(e10) {
    (0, t3.bytes)(e10);
    let r3 = "";
    for (let t4 = 0; t4 < e10.length; t4++) r3 += n6[e10[t4]];
    return r3;
  }
  const i4 = { _0: 48, _9: 57, _A: 65, _F: 70, _a: 97, _f: 102 };
  function o3(e10) {
    return e10 >= i4._0 && e10 <= i4._9 ? e10 - i4._0 : e10 >= i4._A && e10 <= i4._F ? e10 - (i4._A - 10) : e10 >= i4._a && e10 <= i4._f ? e10 - (i4._a - 10) : void 0;
  }
  function s2(e10) {
    if ("string" != typeof e10) throw new Error("hex string expected, got " + typeof e10);
    const t4 = e10.length, n7 = t4 / 2;
    if (t4 % 2) throw new Error("padded hex string expected, got unpadded hex of length " + t4);
    const r3 = new Uint8Array(n7);
    for (let t5 = 0, i5 = 0; t5 < n7; t5++, i5 += 2) {
      const n8 = o3(e10.charCodeAt(i5)), s3 = o3(e10.charCodeAt(i5 + 1));
      if (void 0 === n8 || void 0 === s3) {
        const t6 = e10[i5] + e10[i5 + 1];
        throw new Error('hex string expected, got non-hex character "' + t6 + '" at index ' + i5);
      }
      r3[t5] = 16 * n8 + s3;
    }
    return r3;
  }
  function a(e10) {
    if ("string" != typeof e10) throw new Error("hex string expected, got " + typeof e10);
    return BigInt("" === e10 ? "0" : `0x${e10}`);
  }
  function c3(e10) {
    if ("string" != typeof e10) throw new Error("string expected, got " + typeof e10);
    return new Uint8Array(new TextEncoder().encode(e10));
  }
  e9.nextTick = async () => {
  };
  e9.Hash = class {
  };
  function l5(e10, t4, n7, r3) {
    if ("function" == typeof e10.setBigUint64) return e10.setBigUint64(t4, n7, r3);
    const i5 = BigInt(32), o4 = BigInt(4294967295), s3 = Number(n7 >> i5 & o4), a2 = Number(n7 & o4), c4 = r3 ? 4 : 0, l6 = r3 ? 0 : 4;
    e10.setUint32(t4 + c4, s3, r3), e10.setUint32(t4 + l6, a2, r3);
  }
  function d3(e10) {
    return Uint8Array.from(e10);
  }
  e9.wrapCipher = (e10, t4) => (Object.assign(t4, e10), t4);
}(pe);
var Ce = {};
var ke = {};
Object.defineProperty(ke, "__esModule", { value: true }), ke.AEAD_TAG_LENGTH = ke.XCHACHA20_NONCE_LENGTH = ke.CURVE25519_PUBLIC_KEY_SIZE = ke.ETH_PUBLIC_KEY_SIZE = ke.UNCOMPRESSED_PUBLIC_KEY_SIZE = ke.COMPRESSED_PUBLIC_KEY_SIZE = ke.SECRET_KEY_LENGTH = void 0, ke.SECRET_KEY_LENGTH = 32, ke.COMPRESSED_PUBLIC_KEY_SIZE = 33, ke.UNCOMPRESSED_PUBLIC_KEY_SIZE = 65, ke.ETH_PUBLIC_KEY_SIZE = 64, ke.CURVE25519_PUBLIC_KEY_SIZE = 32, ke.XCHACHA20_NONCE_LENGTH = 24, ke.AEAD_TAG_LENGTH = 16, function(e9) {
  Object.defineProperty(e9, "__esModule", { value: true }), e9.ephemeralKeySize = e9.symmetricNonceLength = e9.symmetricAlgorithm = e9.isHkdfKeyCompressed = e9.isEphemeralKeyCompressed = e9.ellipticCurve = e9.ECIES_CONFIG = void 0;
  var t3 = ke, n6 = function() {
    this.ellipticCurve = "secp256k1", this.isEphemeralKeyCompressed = false, this.isHkdfKeyCompressed = false, this.symmetricAlgorithm = "aes-256-gcm", this.symmetricNonceLength = 16;
  };
  e9.ECIES_CONFIG = new n6();
  e9.ellipticCurve = function() {
    return e9.ECIES_CONFIG.ellipticCurve;
  };
  e9.isEphemeralKeyCompressed = function() {
    return e9.ECIES_CONFIG.isEphemeralKeyCompressed;
  };
  e9.isHkdfKeyCompressed = function() {
    return e9.ECIES_CONFIG.isHkdfKeyCompressed;
  };
  e9.symmetricAlgorithm = function() {
    return e9.ECIES_CONFIG.symmetricAlgorithm;
  };
  e9.symmetricNonceLength = function() {
    return e9.ECIES_CONFIG.symmetricNonceLength;
  };
  e9.ephemeralKeySize = function() {
    var n7 = { secp256k1: e9.ECIES_CONFIG.isEphemeralKeyCompressed ? t3.COMPRESSED_PUBLIC_KEY_SIZE : t3.UNCOMPRESSED_PUBLIC_KEY_SIZE, x25519: t3.CURVE25519_PUBLIC_KEY_SIZE, ed25519: t3.CURVE25519_PUBLIC_KEY_SIZE };
    if (e9.ECIES_CONFIG.ellipticCurve in n7) return n7[e9.ECIES_CONFIG.ellipticCurve];
    throw new Error("Not implemented");
  };
}(Ce);
var Ae = {};
var xe = {};
var Me = {};
var Ie = {};
var Te = {};
var Re2 = {};
Object.defineProperty(Re2, "__esModule", { value: true }), Re2.crypto = void 0, Re2.crypto = "object" == typeof globalThis && "crypto" in globalThis ? globalThis.crypto : void 0, function(e9) {
  Object.defineProperty(e9, "__esModule", { value: true }), e9.gcm = e9.ctr = e9.cbc = e9.utils = void 0, e9.randomBytes = i4, e9.getWebcryptoSubtle = o3, e9.managedNonce = function(e10) {
    return (0, n6.number)(e10.nonceLength), (t4, ...n7) => ({ encrypt(o4, ...s3) {
      const { nonceLength: a2 } = e10, c3 = i4(a2), l5 = e10(t4, c3, ...n7).encrypt(o4, ...s3), d3 = (0, r2.concatBytes)(c3, l5);
      return l5.fill(0), d3;
    }, decrypt(r3, ...i5) {
      const { nonceLength: o4 } = e10, s3 = r3.subarray(0, o4), a2 = r3.subarray(o4);
      return e10(t4, s3, ...n7).decrypt(a2, ...i5);
    } });
  };
  const t3 = Re2, n6 = ge, r2 = pe;
  function i4(e10 = 32) {
    if (t3.crypto && "function" == typeof t3.crypto.getRandomValues) return t3.crypto.getRandomValues(new Uint8Array(e10));
    if (t3.crypto && "function" == typeof t3.crypto.randomBytes) return t3.crypto.randomBytes(e10);
    throw new Error("crypto.getRandomValues must be defined");
  }
  function o3() {
    if (t3.crypto && "object" == typeof t3.crypto.subtle && null != t3.crypto.subtle) return t3.crypto.subtle;
    throw new Error("crypto.subtle must be defined");
  }
  e9.utils = { async encrypt(e10, t4, n7, r3) {
    const i5 = o3(), s3 = await i5.importKey("raw", e10, t4, true, ["encrypt"]), a2 = await i5.encrypt(n7, s3, r3);
    return new Uint8Array(a2);
  }, async decrypt(e10, t4, n7, r3) {
    const i5 = o3(), s3 = await i5.importKey("raw", e10, t4, true, ["decrypt"]), a2 = await i5.decrypt(n7, s3, r3);
    return new Uint8Array(a2);
  } };
  const s2 = { CBC: "AES-CBC", CTR: "AES-CTR", GCM: "AES-GCM" };
  function a(t4) {
    return (r3, i5, o4) => {
      (0, n6.bytes)(r3), (0, n6.bytes)(i5);
      const a2 = { name: t4, length: 8 * r3.length }, c3 = function(e10, t5, n7) {
        if (e10 === s2.CBC) return { name: s2.CBC, iv: t5 };
        if (e10 === s2.CTR) return { name: s2.CTR, counter: t5, length: 64 };
        if (e10 === s2.GCM) return n7 ? { name: s2.GCM, iv: t5, additionalData: n7 } : { name: s2.GCM, iv: t5 };
        throw new Error("unknown aes block mode");
      }(t4, i5, o4);
      return { encrypt: (t5) => ((0, n6.bytes)(t5), e9.utils.encrypt(r3, a2, c3, t5)), decrypt: (t5) => ((0, n6.bytes)(t5), e9.utils.decrypt(r3, a2, c3, t5)) };
    };
  }
  e9.cbc = a(s2.CBC), e9.ctr = a(s2.CTR), e9.gcm = a(s2.GCM);
}(Te);
var Pe2 = {};
var Oe = {};
var Ne = {};
var Le = {};
function De(e9) {
  if (!Number.isSafeInteger(e9) || e9 < 0) throw new Error(`positive integer expected, not ${e9}`);
}
function $e(e9) {
  if ("boolean" != typeof e9) throw new Error(`boolean expected, not ${e9}`);
}
function Be(e9) {
  return e9 instanceof Uint8Array || null != e9 && "object" == typeof e9 && "Uint8Array" === e9.constructor.name;
}
function Ke(e9, ...t3) {
  if (!Be(e9)) throw new Error("Uint8Array expected");
  if (t3.length > 0 && !t3.includes(e9.length)) throw new Error(`Uint8Array expected of length ${t3}, not of length=${e9.length}`);
}
function je(e9) {
  if ("function" != typeof e9 || "function" != typeof e9.create) throw new Error("Hash should be wrapped by utils.wrapConstructor");
  De(e9.outputLen), De(e9.blockLen);
}
function Ue(e9, t3 = true) {
  if (e9.destroyed) throw new Error("Hash instance has been destroyed");
  if (t3 && e9.finished) throw new Error("Hash#digest() has already been called");
}
function He(e9, t3) {
  Ke(e9);
  const n6 = t3.outputLen;
  if (e9.length < n6) throw new Error(`digestInto() expects output buffer of length at least ${n6}`);
}
Object.defineProperty(Le, "__esModule", { value: true }), Le.isBytes = Be, Le.number = De, Le.bool = $e, Le.bytes = Ke, Le.hash = je, Le.exists = Ue, Le.output = He;
var Fe2 = { number: De, bool: $e, bytes: Ke, hash: je, exists: Ue, output: He };
Le.default = Fe2;
var ze = {};
var qe = {};
Object.defineProperty(qe, "__esModule", { value: true }), qe.crypto = void 0, qe.crypto = "object" == typeof globalThis && "crypto" in globalThis ? globalThis.crypto : void 0, function(e9) {
  Object.defineProperty(e9, "__esModule", { value: true }), e9.Hash = e9.nextTick = e9.byteSwapIfBE = e9.byteSwap = e9.isLE = e9.rotl = e9.rotr = e9.createView = e9.u32 = e9.u8 = void 0, e9.isBytes = function(e10) {
    return e10 instanceof Uint8Array || null != e10 && "object" == typeof e10 && "Uint8Array" === e10.constructor.name;
  }, e9.byteSwap32 = function(t4) {
    for (let n7 = 0; n7 < t4.length; n7++) t4[n7] = (0, e9.byteSwap)(t4[n7]);
  }, e9.bytesToHex = function(e10) {
    (0, n6.bytes)(e10);
    let t4 = "";
    for (let n7 = 0; n7 < e10.length; n7++) t4 += r2[e10[n7]];
    return t4;
  }, e9.hexToBytes = function(e10) {
    if ("string" != typeof e10) throw new Error("hex string expected, got " + typeof e10);
    const t4 = e10.length, n7 = t4 / 2;
    if (t4 % 2) throw new Error("padded hex string expected, got unpadded hex of length " + t4);
    const r3 = new Uint8Array(n7);
    for (let t5 = 0, i5 = 0; t5 < n7; t5++, i5 += 2) {
      const n8 = o3(e10.charCodeAt(i5)), s3 = o3(e10.charCodeAt(i5 + 1));
      if (void 0 === n8 || void 0 === s3) {
        const t6 = e10[i5] + e10[i5 + 1];
        throw new Error('hex string expected, got non-hex character "' + t6 + '" at index ' + i5);
      }
      r3[t5] = 16 * n8 + s3;
    }
    return r3;
  }, e9.asyncLoop = async function(t4, n7, r3) {
    let i5 = Date.now();
    for (let o4 = 0; o4 < t4; o4++) {
      r3(o4);
      const t5 = Date.now() - i5;
      t5 >= 0 && t5 < n7 || (await (0, e9.nextTick)(), i5 += t5);
    }
  }, e9.utf8ToBytes = s2, e9.toBytes = a, e9.concatBytes = function(...e10) {
    let t4 = 0;
    for (let r4 = 0; r4 < e10.length; r4++) {
      const i5 = e10[r4];
      (0, n6.bytes)(i5), t4 += i5.length;
    }
    const r3 = new Uint8Array(t4);
    for (let t5 = 0, n7 = 0; t5 < e10.length; t5++) {
      const i5 = e10[t5];
      r3.set(i5, n7), n7 += i5.length;
    }
    return r3;
  }, e9.checkOpts = function(e10, t4) {
    if (void 0 !== t4 && "[object Object]" !== c3.call(t4)) throw new Error("Options should be object or undefined");
    return Object.assign(e10, t4);
  }, e9.wrapConstructor = function(e10) {
    const t4 = (t5) => e10().update(a(t5)).digest(), n7 = e10();
    return t4.outputLen = n7.outputLen, t4.blockLen = n7.blockLen, t4.create = () => e10(), t4;
  }, e9.wrapConstructorWithOpts = function(e10) {
    const t4 = (t5, n8) => e10(n8).update(a(t5)).digest(), n7 = e10({});
    return t4.outputLen = n7.outputLen, t4.blockLen = n7.blockLen, t4.create = (t5) => e10(t5), t4;
  }, e9.wrapXOFConstructorWithOpts = function(e10) {
    const t4 = (t5, n8) => e10(n8).update(a(t5)).digest(), n7 = e10({});
    return t4.outputLen = n7.outputLen, t4.blockLen = n7.blockLen, t4.create = (t5) => e10(t5), t4;
  }, e9.randomBytes = function(e10 = 32) {
    if (t3.crypto && "function" == typeof t3.crypto.getRandomValues) return t3.crypto.getRandomValues(new Uint8Array(e10));
    if (t3.crypto && "function" == typeof t3.crypto.randomBytes) return t3.crypto.randomBytes(e10);
    throw new Error("crypto.getRandomValues must be defined");
  };
  const t3 = qe, n6 = Le;
  e9.u8 = (e10) => new Uint8Array(e10.buffer, e10.byteOffset, e10.byteLength);
  e9.u32 = (e10) => new Uint32Array(e10.buffer, e10.byteOffset, Math.floor(e10.byteLength / 4));
  e9.createView = (e10) => new DataView(e10.buffer, e10.byteOffset, e10.byteLength);
  e9.rotr = (e10, t4) => e10 << 32 - t4 | e10 >>> t4;
  e9.rotl = (e10, t4) => e10 << t4 | e10 >>> 32 - t4 >>> 0, e9.isLE = 68 === new Uint8Array(new Uint32Array([287454020]).buffer)[0];
  e9.byteSwap = (e10) => e10 << 24 & 4278190080 | e10 << 8 & 16711680 | e10 >>> 8 & 65280 | e10 >>> 24 & 255, e9.byteSwapIfBE = e9.isLE ? (e10) => e10 : (t4) => (0, e9.byteSwap)(t4);
  const r2 = Array.from({ length: 256 }, (e10, t4) => t4.toString(16).padStart(2, "0"));
  const i4 = { _0: 48, _9: 57, _A: 65, _F: 70, _a: 97, _f: 102 };
  function o3(e10) {
    return e10 >= i4._0 && e10 <= i4._9 ? e10 - i4._0 : e10 >= i4._A && e10 <= i4._F ? e10 - (i4._A - 10) : e10 >= i4._a && e10 <= i4._f ? e10 - (i4._a - 10) : void 0;
  }
  function s2(e10) {
    if ("string" != typeof e10) throw new Error("utf8ToBytes expected string, got " + typeof e10);
    return new Uint8Array(new TextEncoder().encode(e10));
  }
  function a(e10) {
    return "string" == typeof e10 && (e10 = s2(e10)), (0, n6.bytes)(e10), e10;
  }
  e9.nextTick = async () => {
  };
  e9.Hash = class {
    clone() {
      return this._cloneInto();
    }
  };
  const c3 = {}.toString;
}(ze), Object.defineProperty(Ne, "__esModule", { value: true }), Ne.HashMD = Ne.Maj = Ne.Chi = void 0;
var We = Le;
var Ve2 = ze;
Ne.Chi = (e9, t3, n6) => e9 & t3 ^ ~e9 & n6;
Ne.Maj = (e9, t3, n6) => e9 & t3 ^ e9 & n6 ^ t3 & n6;
Ne.HashMD = class extends Ve2.Hash {
  constructor(e9, t3, n6, r2) {
    super(), this.blockLen = e9, this.outputLen = t3, this.padOffset = n6, this.isLE = r2, this.finished = false, this.length = 0, this.pos = 0, this.destroyed = false, this.buffer = new Uint8Array(e9), this.view = (0, Ve2.createView)(this.buffer);
  }
  update(e9) {
    (0, We.exists)(this);
    const { view: t3, buffer: n6, blockLen: r2 } = this, i4 = (e9 = (0, Ve2.toBytes)(e9)).length;
    for (let o3 = 0; o3 < i4; ) {
      const s2 = Math.min(r2 - this.pos, i4 - o3);
      if (s2 !== r2) n6.set(e9.subarray(o3, o3 + s2), this.pos), this.pos += s2, o3 += s2, this.pos === r2 && (this.process(t3, 0), this.pos = 0);
      else {
        const t4 = (0, Ve2.createView)(e9);
        for (; r2 <= i4 - o3; o3 += r2) this.process(t4, o3);
      }
    }
    return this.length += e9.length, this.roundClean(), this;
  }
  digestInto(e9) {
    (0, We.exists)(this), (0, We.output)(e9, this), this.finished = true;
    const { buffer: t3, view: n6, blockLen: r2, isLE: i4 } = this;
    let { pos: o3 } = this;
    t3[o3++] = 128, this.buffer.subarray(o3).fill(0), this.padOffset > r2 - o3 && (this.process(n6, 0), o3 = 0);
    for (let e10 = o3; e10 < r2; e10++) t3[e10] = 0;
    !function(e10, t4, n7, r3) {
      if ("function" == typeof e10.setBigUint64) return e10.setBigUint64(t4, n7, r3);
      const i5 = BigInt(32), o4 = BigInt(4294967295), s3 = Number(n7 >> i5 & o4), a2 = Number(n7 & o4), c4 = r3 ? 4 : 0, l6 = r3 ? 0 : 4;
      e10.setUint32(t4 + c4, s3, r3), e10.setUint32(t4 + l6, a2, r3);
    }(n6, r2 - 8, BigInt(8 * this.length), i4), this.process(n6, 0);
    const s2 = (0, Ve2.createView)(e9), a = this.outputLen;
    if (a % 4) throw new Error("_sha2: outputLen should be aligned to 32bit");
    const c3 = a / 4, l5 = this.get();
    if (c3 > l5.length) throw new Error("_sha2: outputLen bigger than state");
    for (let e10 = 0; e10 < c3; e10++) s2.setUint32(4 * e10, l5[e10], i4);
  }
  digest() {
    const { buffer: e9, outputLen: t3 } = this;
    this.digestInto(e9);
    const n6 = e9.slice(0, t3);
    return this.destroy(), n6;
  }
  _cloneInto(e9) {
    e9 || (e9 = new this.constructor()), e9.set(...this.get());
    const { blockLen: t3, buffer: n6, length: r2, finished: i4, destroyed: o3, pos: s2 } = this;
    return e9.length = r2, e9.pos = s2, e9.finished = i4, e9.destroyed = o3, r2 % t3 && e9.buffer.set(n6), e9;
  }
};
var Ge = {};
Object.defineProperty(Ge, "__esModule", { value: true }), Ge.add5L = Ge.add5H = Ge.add4H = Ge.add4L = Ge.add3H = Ge.add3L = Ge.rotlBL = Ge.rotlBH = Ge.rotlSL = Ge.rotlSH = Ge.rotr32L = Ge.rotr32H = Ge.rotrBL = Ge.rotrBH = Ge.rotrSL = Ge.rotrSH = Ge.shrSL = Ge.shrSH = Ge.toBig = void 0, Ge.fromBig = Je, Ge.split = Qe, Ge.add = ht;
var Ye = BigInt(2 ** 32 - 1);
var Ze = BigInt(32);
function Je(e9, t3 = false) {
  return t3 ? { h: Number(e9 & Ye), l: Number(e9 >> Ze & Ye) } : { h: 0 | Number(e9 >> Ze & Ye), l: 0 | Number(e9 & Ye) };
}
function Qe(e9, t3 = false) {
  let n6 = new Uint32Array(e9.length), r2 = new Uint32Array(e9.length);
  for (let i4 = 0; i4 < e9.length; i4++) {
    const { h: o3, l: s2 } = Je(e9[i4], t3);
    [n6[i4], r2[i4]] = [o3, s2];
  }
  return [n6, r2];
}
var Xe = (e9, t3) => BigInt(e9 >>> 0) << Ze | BigInt(t3 >>> 0);
Ge.toBig = Xe;
var et = (e9, t3, n6) => e9 >>> n6;
Ge.shrSH = et;
var tt = (e9, t3, n6) => e9 << 32 - n6 | t3 >>> n6;
Ge.shrSL = tt;
var nt = (e9, t3, n6) => e9 >>> n6 | t3 << 32 - n6;
Ge.rotrSH = nt;
var rt = (e9, t3, n6) => e9 << 32 - n6 | t3 >>> n6;
Ge.rotrSL = rt;
var it = (e9, t3, n6) => e9 << 64 - n6 | t3 >>> n6 - 32;
Ge.rotrBH = it;
var ot = (e9, t3, n6) => e9 >>> n6 - 32 | t3 << 64 - n6;
Ge.rotrBL = ot;
var st = (e9, t3) => t3;
Ge.rotr32H = st;
var at = (e9, t3) => e9;
Ge.rotr32L = at;
var ct = (e9, t3, n6) => e9 << n6 | t3 >>> 32 - n6;
Ge.rotlSH = ct;
var lt = (e9, t3, n6) => t3 << n6 | e9 >>> 32 - n6;
Ge.rotlSL = lt;
var dt = (e9, t3, n6) => t3 << n6 - 32 | e9 >>> 64 - n6;
Ge.rotlBH = dt;
var ut = (e9, t3, n6) => e9 << n6 - 32 | t3 >>> 64 - n6;
function ht(e9, t3, n6, r2) {
  const i4 = (t3 >>> 0) + (r2 >>> 0);
  return { h: e9 + n6 + (i4 / 2 ** 32 | 0) | 0, l: 0 | i4 };
}
Ge.rotlBL = ut;
var ft = (e9, t3, n6) => (e9 >>> 0) + (t3 >>> 0) + (n6 >>> 0);
Ge.add3L = ft;
var pt = (e9, t3, n6, r2) => t3 + n6 + r2 + (e9 / 2 ** 32 | 0) | 0;
Ge.add3H = pt;
var gt = (e9, t3, n6, r2) => (e9 >>> 0) + (t3 >>> 0) + (n6 >>> 0) + (r2 >>> 0);
Ge.add4L = gt;
var mt = (e9, t3, n6, r2, i4) => t3 + n6 + r2 + i4 + (e9 / 2 ** 32 | 0) | 0;
Ge.add4H = mt;
var yt = (e9, t3, n6, r2, i4) => (e9 >>> 0) + (t3 >>> 0) + (n6 >>> 0) + (r2 >>> 0) + (i4 >>> 0);
Ge.add5L = yt;
var vt = (e9, t3, n6, r2, i4, o3) => t3 + n6 + r2 + i4 + o3 + (e9 / 2 ** 32 | 0) | 0;
Ge.add5H = vt;
var bt = { fromBig: Je, split: Qe, toBig: Xe, shrSH: et, shrSL: tt, rotrSH: nt, rotrSL: rt, rotrBH: it, rotrBL: ot, rotr32H: st, rotr32L: at, rotlSH: ct, rotlSL: lt, rotlBH: dt, rotlBL: ut, add: ht, add3L: ft, add3H: pt, add4L: gt, add4H: mt, add5H: vt, add5L: yt };
Ge.default = bt, Object.defineProperty(Oe, "__esModule", { value: true }), Oe.sha384 = Oe.sha512_256 = Oe.sha512_224 = Oe.sha512 = Oe.SHA384 = Oe.SHA512_256 = Oe.SHA512_224 = Oe.SHA512 = void 0;
var wt = Ne;
var Et = Ge;
var St = ze;
var [_t, Ct] = (() => Et.default.split(["0x428a2f98d728ae22", "0x7137449123ef65cd", "0xb5c0fbcfec4d3b2f", "0xe9b5dba58189dbbc", "0x3956c25bf348b538", "0x59f111f1b605d019", "0x923f82a4af194f9b", "0xab1c5ed5da6d8118", "0xd807aa98a3030242", "0x12835b0145706fbe", "0x243185be4ee4b28c", "0x550c7dc3d5ffb4e2", "0x72be5d74f27b896f", "0x80deb1fe3b1696b1", "0x9bdc06a725c71235", "0xc19bf174cf692694", "0xe49b69c19ef14ad2", "0xefbe4786384f25e3", "0x0fc19dc68b8cd5b5", "0x240ca1cc77ac9c65", "0x2de92c6f592b0275", "0x4a7484aa6ea6e483", "0x5cb0a9dcbd41fbd4", "0x76f988da831153b5", "0x983e5152ee66dfab", "0xa831c66d2db43210", "0xb00327c898fb213f", "0xbf597fc7beef0ee4", "0xc6e00bf33da88fc2", "0xd5a79147930aa725", "0x06ca6351e003826f", "0x142929670a0e6e70", "0x27b70a8546d22ffc", "0x2e1b21385c26c926", "0x4d2c6dfc5ac42aed", "0x53380d139d95b3df", "0x650a73548baf63de", "0x766a0abb3c77b2a8", "0x81c2c92e47edaee6", "0x92722c851482353b", "0xa2bfe8a14cf10364", "0xa81a664bbc423001", "0xc24b8b70d0f89791", "0xc76c51a30654be30", "0xd192e819d6ef5218", "0xd69906245565a910", "0xf40e35855771202a", "0x106aa07032bbd1b8", "0x19a4c116b8d2d0c8", "0x1e376c085141ab53", "0x2748774cdf8eeb99", "0x34b0bcb5e19b48a8", "0x391c0cb3c5c95a63", "0x4ed8aa4ae3418acb", "0x5b9cca4f7763e373", "0x682e6ff3d6b2b8a3", "0x748f82ee5defb2fc", "0x78a5636f43172f60", "0x84c87814a1f0ab72", "0x8cc702081a6439ec", "0x90befffa23631e28", "0xa4506cebde82bde9", "0xbef9a3f7b2c67915", "0xc67178f2e372532b", "0xca273eceea26619c", "0xd186b8c721c0c207", "0xeada7dd6cde0eb1e", "0xf57d4f7fee6ed178", "0x06f067aa72176fba", "0x0a637dc5a2c898a6", "0x113f9804bef90dae", "0x1b710b35131c471b", "0x28db77f523047d84", "0x32caab7b40c72493", "0x3c9ebe0a15c9bebc", "0x431d67c49c100d4c", "0x4cc5d4becb3e42b6", "0x597f299cfc657e2a", "0x5fcb6fab3ad6faec", "0x6c44198c4a475817"].map((e9) => BigInt(e9))))();
var kt = new Uint32Array(80);
var At = new Uint32Array(80);
var xt = class extends wt.HashMD {
  constructor() {
    super(128, 64, 16, false), this.Ah = 1779033703, this.Al = -205731576, this.Bh = -1150833019, this.Bl = -2067093701, this.Ch = 1013904242, this.Cl = -23791573, this.Dh = -1521486534, this.Dl = 1595750129, this.Eh = 1359893119, this.El = -1377402159, this.Fh = -1694144372, this.Fl = 725511199, this.Gh = 528734635, this.Gl = -79577749, this.Hh = 1541459225, this.Hl = 327033209;
  }
  get() {
    const { Ah: e9, Al: t3, Bh: n6, Bl: r2, Ch: i4, Cl: o3, Dh: s2, Dl: a, Eh: c3, El: l5, Fh: d3, Fl: u2, Gh: h3, Gl: f4, Hh: p4, Hl: g2 } = this;
    return [e9, t3, n6, r2, i4, o3, s2, a, c3, l5, d3, u2, h3, f4, p4, g2];
  }
  set(e9, t3, n6, r2, i4, o3, s2, a, c3, l5, d3, u2, h3, f4, p4, g2) {
    this.Ah = 0 | e9, this.Al = 0 | t3, this.Bh = 0 | n6, this.Bl = 0 | r2, this.Ch = 0 | i4, this.Cl = 0 | o3, this.Dh = 0 | s2, this.Dl = 0 | a, this.Eh = 0 | c3, this.El = 0 | l5, this.Fh = 0 | d3, this.Fl = 0 | u2, this.Gh = 0 | h3, this.Gl = 0 | f4, this.Hh = 0 | p4, this.Hl = 0 | g2;
  }
  process(e9, t3) {
    for (let n7 = 0; n7 < 16; n7++, t3 += 4) kt[n7] = e9.getUint32(t3), At[n7] = e9.getUint32(t3 += 4);
    for (let e10 = 16; e10 < 80; e10++) {
      const t4 = 0 | kt[e10 - 15], n7 = 0 | At[e10 - 15], r3 = Et.default.rotrSH(t4, n7, 1) ^ Et.default.rotrSH(t4, n7, 8) ^ Et.default.shrSH(t4, n7, 7), i5 = Et.default.rotrSL(t4, n7, 1) ^ Et.default.rotrSL(t4, n7, 8) ^ Et.default.shrSL(t4, n7, 7), o4 = 0 | kt[e10 - 2], s3 = 0 | At[e10 - 2], a2 = Et.default.rotrSH(o4, s3, 19) ^ Et.default.rotrBH(o4, s3, 61) ^ Et.default.shrSH(o4, s3, 6), c4 = Et.default.rotrSL(o4, s3, 19) ^ Et.default.rotrBL(o4, s3, 61) ^ Et.default.shrSL(o4, s3, 6), l6 = Et.default.add4L(i5, c4, At[e10 - 7], At[e10 - 16]), d4 = Et.default.add4H(l6, r3, a2, kt[e10 - 7], kt[e10 - 16]);
      kt[e10] = 0 | d4, At[e10] = 0 | l6;
    }
    let { Ah: n6, Al: r2, Bh: i4, Bl: o3, Ch: s2, Cl: a, Dh: c3, Dl: l5, Eh: d3, El: u2, Fh: h3, Fl: f4, Gh: p4, Gl: g2, Hh: m4, Hl: y2 } = this;
    for (let e10 = 0; e10 < 80; e10++) {
      const t4 = Et.default.rotrSH(d3, u2, 14) ^ Et.default.rotrSH(d3, u2, 18) ^ Et.default.rotrBH(d3, u2, 41), v2 = Et.default.rotrSL(d3, u2, 14) ^ Et.default.rotrSL(d3, u2, 18) ^ Et.default.rotrBL(d3, u2, 41), b3 = d3 & h3 ^ ~d3 & p4, w5 = u2 & f4 ^ ~u2 & g2, E4 = Et.default.add5L(y2, v2, w5, Ct[e10], At[e10]), S5 = Et.default.add5H(E4, m4, t4, b3, _t[e10], kt[e10]), _2 = 0 | E4, C4 = Et.default.rotrSH(n6, r2, 28) ^ Et.default.rotrBH(n6, r2, 34) ^ Et.default.rotrBH(n6, r2, 39), k3 = Et.default.rotrSL(n6, r2, 28) ^ Et.default.rotrBL(n6, r2, 34) ^ Et.default.rotrBL(n6, r2, 39), A3 = n6 & i4 ^ n6 & s2 ^ i4 & s2, x3 = r2 & o3 ^ r2 & a ^ o3 & a;
      m4 = 0 | p4, y2 = 0 | g2, p4 = 0 | h3, g2 = 0 | f4, h3 = 0 | d3, f4 = 0 | u2, { h: d3, l: u2 } = Et.default.add(0 | c3, 0 | l5, 0 | S5, 0 | _2), c3 = 0 | s2, l5 = 0 | a, s2 = 0 | i4, a = 0 | o3, i4 = 0 | n6, o3 = 0 | r2;
      const M4 = Et.default.add3L(_2, k3, x3);
      n6 = Et.default.add3H(M4, S5, C4, A3), r2 = 0 | M4;
    }
    ({ h: n6, l: r2 } = Et.default.add(0 | this.Ah, 0 | this.Al, 0 | n6, 0 | r2)), { h: i4, l: o3 } = Et.default.add(0 | this.Bh, 0 | this.Bl, 0 | i4, 0 | o3), { h: s2, l: a } = Et.default.add(0 | this.Ch, 0 | this.Cl, 0 | s2, 0 | a), { h: c3, l: l5 } = Et.default.add(0 | this.Dh, 0 | this.Dl, 0 | c3, 0 | l5), { h: d3, l: u2 } = Et.default.add(0 | this.Eh, 0 | this.El, 0 | d3, 0 | u2), { h: h3, l: f4 } = Et.default.add(0 | this.Fh, 0 | this.Fl, 0 | h3, 0 | f4), { h: p4, l: g2 } = Et.default.add(0 | this.Gh, 0 | this.Gl, 0 | p4, 0 | g2), { h: m4, l: y2 } = Et.default.add(0 | this.Hh, 0 | this.Hl, 0 | m4, 0 | y2), this.set(n6, r2, i4, o3, s2, a, c3, l5, d3, u2, h3, f4, p4, g2, m4, y2);
  }
  roundClean() {
    kt.fill(0), At.fill(0);
  }
  destroy() {
    this.buffer.fill(0), this.set(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);
  }
};
Oe.SHA512 = xt;
var Mt = class extends xt {
  constructor() {
    super(), this.Ah = -1942145080, this.Al = 424955298, this.Bh = 1944164710, this.Bl = -1982016298, this.Ch = 502970286, this.Cl = 855612546, this.Dh = 1738396948, this.Dl = 1479516111, this.Eh = 258812777, this.El = 2077511080, this.Fh = 2011393907, this.Fl = 79989058, this.Gh = 1067287976, this.Gl = 1780299464, this.Hh = 286451373, this.Hl = -1848208735, this.outputLen = 28;
  }
};
Oe.SHA512_224 = Mt;
var It = class extends xt {
  constructor() {
    super(), this.Ah = 573645204, this.Al = -64227540, this.Bh = -1621794909, this.Bl = -934517566, this.Ch = 596883563, this.Cl = 1867755857, this.Dh = -1774684391, this.Dl = 1497426621, this.Eh = -1775747358, this.El = -1467023389, this.Fh = -1101128155, this.Fl = 1401305490, this.Gh = 721525244, this.Gl = 746961066, this.Hh = 246885852, this.Hl = -2117784414, this.outputLen = 32;
  }
};
Oe.SHA512_256 = It;
var Tt = class extends xt {
  constructor() {
    super(), this.Ah = -876896931, this.Al = -1056596264, this.Bh = 1654270250, this.Bl = 914150663, this.Ch = -1856437926, this.Cl = 812702999, this.Dh = 355462360, this.Dl = -150054599, this.Eh = 1731405415, this.El = -4191439, this.Fh = -1900787065, this.Fl = 1750603025, this.Gh = -619958771, this.Gl = 1694076839, this.Hh = 1203062813, this.Hl = -1090891868, this.outputLen = 48;
  }
};
Oe.SHA384 = Tt, Oe.sha512 = (0, St.wrapConstructor)(() => new xt()), Oe.sha512_224 = (0, St.wrapConstructor)(() => new Mt()), Oe.sha512_256 = (0, St.wrapConstructor)(() => new It()), Oe.sha384 = (0, St.wrapConstructor)(() => new Tt());
var Rt = {};
var Pt = {};
var Ot = {};
var Nt = {};
Object.defineProperty(Nt, "__esModule", { value: true }), Nt.notImplemented = Nt.bitMask = void 0, Nt.isBytes = Bt, Nt.abytes = Kt, Nt.abool = function(e9, t3) {
  if ("boolean" != typeof t3) throw new Error(`${e9} must be valid boolean, got "${t3}".`);
}, Nt.bytesToHex = Ut, Nt.numberToHexUnpadded = Ht, Nt.hexToNumber = Ft, Nt.hexToBytes = Wt, Nt.bytesToNumberBE = function(e9) {
  return Ft(Ut(e9));
}, Nt.bytesToNumberLE = function(e9) {
  return Kt(e9), Ft(Ut(Uint8Array.from(e9).reverse()));
}, Nt.numberToBytesBE = Vt, Nt.numberToBytesLE = function(e9, t3) {
  return Vt(e9, t3).reverse();
}, Nt.numberToVarBytesBE = function(e9) {
  return Wt(Ht(e9));
}, Nt.ensureBytes = function(e9, t3, n6) {
  let r2;
  if ("string" == typeof t3) try {
    r2 = Wt(t3);
  } catch (n7) {
    throw new Error(`${e9} must be valid hex string, got "${t3}". Cause: ${n7}`);
  }
  else {
    if (!Bt(t3)) throw new Error(`${e9} must be hex string or Uint8Array`);
    r2 = Uint8Array.from(t3);
  }
  const i4 = r2.length;
  if ("number" == typeof n6 && i4 !== n6) throw new Error(`${e9} expected ${n6} bytes, got ${i4}`);
  return r2;
}, Nt.concatBytes = Gt, Nt.equalBytes = function(e9, t3) {
  if (e9.length !== t3.length) return false;
  let n6 = 0;
  for (let r2 = 0; r2 < e9.length; r2++) n6 |= e9[r2] ^ t3[r2];
  return 0 === n6;
}, Nt.utf8ToBytes = function(e9) {
  if ("string" != typeof e9) throw new Error("utf8ToBytes expected string, got " + typeof e9);
  return new Uint8Array(new TextEncoder().encode(e9));
}, Nt.inRange = Zt, Nt.aInRange = function(e9, t3, n6, r2) {
  if (!Zt(t3, n6, r2)) throw new Error(`expected valid ${e9}: ${n6} <= n < ${r2}, got ${typeof t3} ${t3}`);
}, Nt.bitLen = function(e9) {
  let t3;
  for (t3 = 0; e9 > Lt; e9 >>= Dt, t3 += 1) ;
  return t3;
}, Nt.bitGet = function(e9, t3) {
  return e9 >> BigInt(t3) & Dt;
}, Nt.bitSet = function(e9, t3, n6) {
  return e9 | (n6 ? Dt : Lt) << BigInt(t3);
}, Nt.createHmacDrbg = function(e9, t3, n6) {
  if ("number" != typeof e9 || e9 < 2) throw new Error("hashLen must be a number");
  if ("number" != typeof t3 || t3 < 2) throw new Error("qByteLen must be a number");
  if ("function" != typeof n6) throw new Error("hmacFn must be a function");
  let r2 = Jt(e9), i4 = Jt(e9), o3 = 0;
  const s2 = () => {
    r2.fill(1), i4.fill(0), o3 = 0;
  }, a = (...e10) => n6(i4, r2, ...e10), c3 = (e10 = Jt()) => {
    i4 = a(Qt([0]), e10), r2 = a(), 0 !== e10.length && (i4 = a(Qt([1]), e10), r2 = a());
  }, l5 = () => {
    if (o3++ >= 1e3) throw new Error("drbg: tried 1000 values");
    let e10 = 0;
    const n7 = [];
    for (; e10 < t3; ) {
      r2 = a();
      const t4 = r2.slice();
      n7.push(t4), e10 += r2.length;
    }
    return Gt(...n7);
  };
  return (e10, t4) => {
    let n7;
    for (s2(), c3(e10); !(n7 = t4(l5())); ) c3();
    return s2(), n7;
  };
}, Nt.validateObject = function(e9, t3, n6 = {}) {
  const r2 = (t4, n7, r3) => {
    const i4 = Xt[n7];
    if ("function" != typeof i4) throw new Error(`Invalid validator "${n7}", expected function`);
    const o3 = e9[t4];
    if (!(r3 && void 0 === o3 || i4(o3, e9))) throw new Error(`Invalid param ${String(t4)}=${o3} (${typeof o3}), expected ${n7}`);
  };
  for (const [e10, n7] of Object.entries(t3)) r2(e10, n7, false);
  for (const [e10, t4] of Object.entries(n6)) r2(e10, t4, true);
  return e9;
}, Nt.memoized = function(e9) {
  const t3 = /* @__PURE__ */ new WeakMap();
  return (n6, ...r2) => {
    const i4 = t3.get(n6);
    if (void 0 !== i4) return i4;
    const o3 = e9(n6, ...r2);
    return t3.set(n6, o3), o3;
  };
};
var Lt = BigInt(0);
var Dt = BigInt(1);
var $t = BigInt(2);
function Bt(e9) {
  return e9 instanceof Uint8Array || null != e9 && "object" == typeof e9 && "Uint8Array" === e9.constructor.name;
}
function Kt(e9) {
  if (!Bt(e9)) throw new Error("Uint8Array expected");
}
var jt = Array.from({ length: 256 }, (e9, t3) => t3.toString(16).padStart(2, "0"));
function Ut(e9) {
  Kt(e9);
  let t3 = "";
  for (let n6 = 0; n6 < e9.length; n6++) t3 += jt[e9[n6]];
  return t3;
}
function Ht(e9) {
  const t3 = e9.toString(16);
  return 1 & t3.length ? `0${t3}` : t3;
}
function Ft(e9) {
  if ("string" != typeof e9) throw new Error("hex string expected, got " + typeof e9);
  return BigInt("" === e9 ? "0" : `0x${e9}`);
}
var zt = { _0: 48, _9: 57, _A: 65, _F: 70, _a: 97, _f: 102 };
function qt(e9) {
  return e9 >= zt._0 && e9 <= zt._9 ? e9 - zt._0 : e9 >= zt._A && e9 <= zt._F ? e9 - (zt._A - 10) : e9 >= zt._a && e9 <= zt._f ? e9 - (zt._a - 10) : void 0;
}
function Wt(e9) {
  if ("string" != typeof e9) throw new Error("hex string expected, got " + typeof e9);
  const t3 = e9.length, n6 = t3 / 2;
  if (t3 % 2) throw new Error("padded hex string expected, got unpadded hex of length " + t3);
  const r2 = new Uint8Array(n6);
  for (let t4 = 0, i4 = 0; t4 < n6; t4++, i4 += 2) {
    const n7 = qt(e9.charCodeAt(i4)), o3 = qt(e9.charCodeAt(i4 + 1));
    if (void 0 === n7 || void 0 === o3) {
      const t5 = e9[i4] + e9[i4 + 1];
      throw new Error('hex string expected, got non-hex character "' + t5 + '" at index ' + i4);
    }
    r2[t4] = 16 * n7 + o3;
  }
  return r2;
}
function Vt(e9, t3) {
  return Wt(e9.toString(16).padStart(2 * t3, "0"));
}
function Gt(...e9) {
  let t3 = 0;
  for (let n7 = 0; n7 < e9.length; n7++) {
    const r2 = e9[n7];
    Kt(r2), t3 += r2.length;
  }
  const n6 = new Uint8Array(t3);
  for (let t4 = 0, r2 = 0; t4 < e9.length; t4++) {
    const i4 = e9[t4];
    n6.set(i4, r2), r2 += i4.length;
  }
  return n6;
}
var Yt = (e9) => "bigint" == typeof e9 && Lt <= e9;
function Zt(e9, t3, n6) {
  return Yt(e9) && Yt(t3) && Yt(n6) && t3 <= e9 && e9 < n6;
}
Nt.bitMask = (e9) => ($t << BigInt(e9 - 1)) - Dt;
var Jt = (e9) => new Uint8Array(e9);
var Qt = (e9) => Uint8Array.from(e9);
var Xt = { bigint: (e9) => "bigint" == typeof e9, function: (e9) => "function" == typeof e9, boolean: (e9) => "boolean" == typeof e9, string: (e9) => "string" == typeof e9, stringOrUint8Array: (e9) => "string" == typeof e9 || Bt(e9), isSafeInteger: (e9) => Number.isSafeInteger(e9), array: (e9) => Array.isArray(e9), field: (e9, t3) => t3.Fp.isValid(e9), hash: (e9) => "function" == typeof e9 && Number.isSafeInteger(e9.outputLen) };
Nt.notImplemented = () => {
  throw new Error("not implemented");
}, Object.defineProperty(Ot, "__esModule", { value: true }), Ot.isNegativeLE = void 0, Ot.mod = ln, Ot.pow = dn, Ot.pow2 = function(e9, t3, n6) {
  let r2 = e9;
  for (; t3-- > tn; ) r2 *= r2, r2 %= n6;
  return r2;
}, Ot.invert = un, Ot.tonelliShanks = hn, Ot.FpSqrt = fn2, Ot.validateField = function(e9) {
  const t3 = pn.reduce((e10, t4) => (e10[t4] = "function", e10), { ORDER: "bigint", MASK: "bigint", BYTES: "isSafeInteger", BITS: "isSafeInteger" });
  return (0, en.validateObject)(e9, t3);
}, Ot.FpPow = gn, Ot.FpInvertBatch = mn, Ot.FpDiv = function(e9, t3, n6) {
  return e9.mul(t3, "bigint" == typeof n6 ? un(n6, e9.ORDER) : e9.inv(n6));
}, Ot.FpLegendre = yn, Ot.FpIsSquare = function(e9) {
  const t3 = yn(e9.ORDER);
  return (n6) => {
    const r2 = t3(e9, n6);
    return e9.eql(r2, e9.ZERO) || e9.eql(r2, e9.ONE);
  };
}, Ot.nLength = vn, Ot.Field = function(e9, t3, n6 = false, r2 = {}) {
  if (e9 <= tn) throw new Error(`Expected Field ORDER > 0, got ${e9}`);
  const { nBitLength: i4, nByteLength: o3 } = vn(e9, t3);
  if (o3 > 2048) throw new Error("Field lengths over 2048 bytes are not supported");
  const s2 = fn2(e9), a = Object.freeze({ ORDER: e9, BITS: i4, BYTES: o3, MASK: (0, en.bitMask)(i4), ZERO: tn, ONE: nn, create: (t4) => ln(t4, e9), isValid: (t4) => {
    if ("bigint" != typeof t4) throw new Error("Invalid field element: expected bigint, got " + typeof t4);
    return tn <= t4 && t4 < e9;
  }, is0: (e10) => e10 === tn, isOdd: (e10) => (e10 & nn) === nn, neg: (t4) => ln(-t4, e9), eql: (e10, t4) => e10 === t4, sqr: (t4) => ln(t4 * t4, e9), add: (t4, n7) => ln(t4 + n7, e9), sub: (t4, n7) => ln(t4 - n7, e9), mul: (t4, n7) => ln(t4 * n7, e9), pow: (e10, t4) => gn(a, e10, t4), div: (t4, n7) => ln(t4 * un(n7, e9), e9), sqrN: (e10) => e10 * e10, addN: (e10, t4) => e10 + t4, subN: (e10, t4) => e10 - t4, mulN: (e10, t4) => e10 * t4, inv: (t4) => un(t4, e9), sqrt: r2.sqrt || ((e10) => s2(a, e10)), invertBatch: (e10) => mn(a, e10), cmov: (e10, t4, n7) => n7 ? t4 : e10, toBytes: (e10) => n6 ? (0, en.numberToBytesLE)(e10, o3) : (0, en.numberToBytesBE)(e10, o3), fromBytes: (e10) => {
    if (e10.length !== o3) throw new Error(`Fp.fromBytes: expected ${o3}, got ${e10.length}`);
    return n6 ? (0, en.bytesToNumberLE)(e10) : (0, en.bytesToNumberBE)(e10);
  } });
  return Object.freeze(a);
}, Ot.FpSqrtOdd = function(e9, t3) {
  if (!e9.isOdd) throw new Error("Field doesn't have isOdd");
  const n6 = e9.sqrt(t3);
  return e9.isOdd(n6) ? n6 : e9.neg(n6);
}, Ot.FpSqrtEven = function(e9, t3) {
  if (!e9.isOdd) throw new Error("Field doesn't have isOdd");
  const n6 = e9.sqrt(t3);
  return e9.isOdd(n6) ? e9.neg(n6) : n6;
}, Ot.hashToPrivateScalar = function(e9, t3, n6 = false) {
  e9 = (0, en.ensureBytes)("privateHash", e9);
  const r2 = e9.length, i4 = vn(t3).nByteLength + 8;
  if (i4 < 24 || r2 < i4 || r2 > 1024) throw new Error(`hashToPrivateScalar: expected ${i4}-1024 bytes of input, got ${r2}`);
  const o3 = n6 ? (0, en.bytesToNumberLE)(e9) : (0, en.bytesToNumberBE)(e9);
  return ln(o3, t3 - nn) + nn;
}, Ot.getFieldBytesLength = bn, Ot.getMinHashLength = wn, Ot.mapHashToField = function(e9, t3, n6 = false) {
  const r2 = e9.length, i4 = bn(t3), o3 = wn(t3);
  if (r2 < 16 || r2 < o3 || r2 > 1024) throw new Error(`expected ${o3}-1024 bytes of input, got ${r2}`);
  const s2 = ln(n6 ? (0, en.bytesToNumberBE)(e9) : (0, en.bytesToNumberLE)(e9), t3 - nn) + nn;
  return n6 ? (0, en.numberToBytesLE)(s2, i4) : (0, en.numberToBytesBE)(s2, i4);
};
var en = Nt;
var tn = BigInt(0);
var nn = BigInt(1);
var rn = BigInt(2);
var on2 = BigInt(3);
var sn = BigInt(4);
var an = BigInt(5);
var cn = BigInt(8);
function ln(e9, t3) {
  const n6 = e9 % t3;
  return n6 >= tn ? n6 : t3 + n6;
}
function dn(e9, t3, n6) {
  if (n6 <= tn || t3 < tn) throw new Error("Expected power/modulo > 0");
  if (n6 === nn) return tn;
  let r2 = nn;
  for (; t3 > tn; ) t3 & nn && (r2 = r2 * e9 % n6), e9 = e9 * e9 % n6, t3 >>= nn;
  return r2;
}
function un(e9, t3) {
  if (e9 === tn || t3 <= tn) throw new Error(`invert: expected positive integers, got n=${e9} mod=${t3}`);
  let n6 = ln(e9, t3), r2 = t3, i4 = tn, o3 = nn;
  for (; n6 !== tn; ) {
    const e10 = r2 % n6, t4 = i4 - o3 * (r2 / n6);
    r2 = n6, n6 = e10, i4 = o3, o3 = t4;
  }
  if (r2 !== nn) throw new Error("invert: does not exist");
  return ln(i4, t3);
}
function hn(e9) {
  const t3 = (e9 - nn) / rn;
  let n6, r2, i4;
  for (n6 = e9 - nn, r2 = 0; n6 % rn === tn; n6 /= rn, r2++) ;
  for (i4 = rn; i4 < e9 && dn(i4, t3, e9) !== e9 - nn; i4++) ;
  if (1 === r2) {
    const t4 = (e9 + nn) / sn;
    return function(e10, n7) {
      const r3 = e10.pow(n7, t4);
      if (!e10.eql(e10.sqr(r3), n7)) throw new Error("Cannot find square root");
      return r3;
    };
  }
  const o3 = (n6 + nn) / rn;
  return function(e10, s2) {
    if (e10.pow(s2, t3) === e10.neg(e10.ONE)) throw new Error("Cannot find square root");
    let a = r2, c3 = e10.pow(e10.mul(e10.ONE, i4), n6), l5 = e10.pow(s2, o3), d3 = e10.pow(s2, n6);
    for (; !e10.eql(d3, e10.ONE); ) {
      if (e10.eql(d3, e10.ZERO)) return e10.ZERO;
      let t4 = 1;
      for (let n8 = e10.sqr(d3); t4 < a && !e10.eql(n8, e10.ONE); t4++) n8 = e10.sqr(n8);
      const n7 = e10.pow(c3, nn << BigInt(a - t4 - 1));
      c3 = e10.sqr(n7), l5 = e10.mul(l5, n7), d3 = e10.mul(d3, c3), a = t4;
    }
    return l5;
  };
}
function fn2(e9) {
  if (e9 % sn === on2) {
    const t3 = (e9 + nn) / sn;
    return function(e10, n6) {
      const r2 = e10.pow(n6, t3);
      if (!e10.eql(e10.sqr(r2), n6)) throw new Error("Cannot find square root");
      return r2;
    };
  }
  if (e9 % cn === an) {
    const t3 = (e9 - an) / cn;
    return function(e10, n6) {
      const r2 = e10.mul(n6, rn), i4 = e10.pow(r2, t3), o3 = e10.mul(n6, i4), s2 = e10.mul(e10.mul(o3, rn), i4), a = e10.mul(o3, e10.sub(s2, e10.ONE));
      if (!e10.eql(e10.sqr(a), n6)) throw new Error("Cannot find square root");
      return a;
    };
  }
  return hn(e9);
}
BigInt(9), BigInt(16);
Ot.isNegativeLE = (e9, t3) => (ln(e9, t3) & nn) === nn;
var pn = ["create", "isValid", "is0", "neg", "inv", "sqrt", "sqr", "eql", "add", "sub", "mul", "pow", "div", "addN", "subN", "mulN", "sqrN"];
function gn(e9, t3, n6) {
  if (n6 < tn) throw new Error("Expected power > 0");
  if (n6 === tn) return e9.ONE;
  if (n6 === nn) return t3;
  let r2 = e9.ONE, i4 = t3;
  for (; n6 > tn; ) n6 & nn && (r2 = e9.mul(r2, i4)), i4 = e9.sqr(i4), n6 >>= nn;
  return r2;
}
function mn(e9, t3) {
  const n6 = new Array(t3.length), r2 = t3.reduce((t4, r3, i5) => e9.is0(r3) ? t4 : (n6[i5] = t4, e9.mul(t4, r3)), e9.ONE), i4 = e9.inv(r2);
  return t3.reduceRight((t4, r3, i5) => e9.is0(r3) ? t4 : (n6[i5] = e9.mul(t4, n6[i5]), e9.mul(t4, r3)), i4), n6;
}
function yn(e9) {
  const t3 = (e9 - nn) / rn;
  return (e10, n6) => e10.pow(n6, t3);
}
function vn(e9, t3) {
  const n6 = void 0 !== t3 ? t3 : e9.toString(2).length;
  return { nBitLength: n6, nByteLength: Math.ceil(n6 / 8) };
}
function bn(e9) {
  if ("bigint" != typeof e9) throw new Error("field order must be bigint");
  const t3 = e9.toString(2).length;
  return Math.ceil(t3 / 8);
}
function wn(e9) {
  const t3 = bn(e9);
  return t3 + Math.ceil(t3 / 2);
}
Object.defineProperty(Pt, "__esModule", { value: true }), Pt.wNAF = function(e9, t3) {
  const n6 = (e10, t4) => {
    const n7 = t4.negate();
    return e10 ? n7 : t4;
  }, r2 = (e10) => {
    if (!Number.isSafeInteger(e10) || e10 <= 0 || e10 > t3) throw new Error(`Wrong window size=${e10}, should be [1..${t3}]`);
  }, i4 = (e10) => {
    r2(e10);
    return { windows: Math.ceil(t3 / e10) + 1, windowSize: 2 ** (e10 - 1) };
  };
  return { constTimeNegate: n6, unsafeLadder(t4, n7) {
    let r3 = e9.ZERO, i5 = t4;
    for (; n7 > _n; ) n7 & Cn && (r3 = r3.add(i5)), i5 = i5.double(), n7 >>= Cn;
    return r3;
  }, precomputeWindow(e10, t4) {
    const { windows: n7, windowSize: r3 } = i4(t4), o3 = [];
    let s2 = e10, a = s2;
    for (let e11 = 0; e11 < n7; e11++) {
      a = s2, o3.push(a);
      for (let e12 = 1; e12 < r3; e12++) a = a.add(s2), o3.push(a);
      s2 = a.double();
    }
    return o3;
  }, wNAF(t4, r3, o3) {
    const { windows: s2, windowSize: a } = i4(t4);
    let c3 = e9.ZERO, l5 = e9.BASE;
    const d3 = BigInt(2 ** t4 - 1), u2 = 2 ** t4, h3 = BigInt(t4);
    for (let e10 = 0; e10 < s2; e10++) {
      const t5 = e10 * a;
      let i5 = Number(o3 & d3);
      o3 >>= h3, i5 > a && (i5 -= u2, o3 += Cn);
      const s3 = t5, f4 = t5 + Math.abs(i5) - 1, p4 = e10 % 2 != 0, g2 = i5 < 0;
      0 === i5 ? l5 = l5.add(n6(p4, r3[s3])) : c3 = c3.add(n6(g2, r3[f4]));
    }
    return { p: c3, f: l5 };
  }, wNAFCached(e10, t4, n7) {
    const r3 = An.get(e10) || 1;
    let i5 = kn.get(e10);
    return i5 || (i5 = this.precomputeWindow(e10, r3), 1 !== r3 && kn.set(e10, n7(i5))), this.wNAF(r3, i5, t4);
  }, setWindowSize(e10, t4) {
    r2(t4), An.set(e10, t4), kn.delete(e10);
  } };
}, Pt.pippenger = function(e9, t3, n6, r2) {
  if (!Array.isArray(n6) || !Array.isArray(r2) || r2.length !== n6.length) throw new Error("arrays of points and scalars must have equal length");
  r2.forEach((e10, n7) => {
    if (!t3.isValid(e10)) throw new Error(`wrong scalar at index ${n7}`);
  }), n6.forEach((t4, n7) => {
    if (!(t4 instanceof e9)) throw new Error(`wrong point at index ${n7}`);
  });
  const i4 = (0, Sn.bitLen)(BigInt(n6.length)), o3 = i4 > 12 ? i4 - 3 : i4 > 4 ? i4 - 2 : i4 ? 2 : 1, s2 = (1 << o3) - 1, a = new Array(s2 + 1).fill(e9.ZERO), c3 = Math.floor((t3.BITS - 1) / o3) * o3;
  let l5 = e9.ZERO;
  for (let t4 = c3; t4 >= 0; t4 -= o3) {
    a.fill(e9.ZERO);
    for (let e10 = 0; e10 < r2.length; e10++) {
      const i6 = r2[e10], o4 = Number(i6 >> BigInt(t4) & BigInt(s2));
      a[o4] = a[o4].add(n6[e10]);
    }
    let i5 = e9.ZERO;
    for (let t5 = a.length - 1, n7 = e9.ZERO; t5 > 0; t5--) n7 = n7.add(a[t5]), i5 = i5.add(n7);
    if (l5 = l5.add(i5), 0 !== t4) for (let e10 = 0; e10 < o3; e10++) l5 = l5.double();
  }
  return l5;
}, Pt.validateBasic = function(e9) {
  return (0, En.validateField)(e9.Fp), (0, Sn.validateObject)(e9, { n: "bigint", h: "bigint", Gx: "field", Gy: "field" }, { nBitLength: "isSafeInteger", nByteLength: "isSafeInteger" }), Object.freeze({ ...(0, En.nLength)(e9.n, e9.nBitLength), ...e9, p: e9.Fp.ORDER });
};
var En = Ot;
var Sn = Nt;
var _n = BigInt(0);
var Cn = BigInt(1);
var kn = /* @__PURE__ */ new WeakMap();
var An = /* @__PURE__ */ new WeakMap();
Object.defineProperty(Rt, "__esModule", { value: true }), Rt.twistedEdwards = function(e9) {
  const t3 = function(e10) {
    const t4 = (0, xn.validateBasic)(e10);
    return In.validateObject(e10, { hash: "function", a: "bigint", d: "bigint", randomBytes: "function" }, { adjustScalarBytes: "function", domain: "function", uvRatio: "function", mapToCurve: "function" }), Object.freeze({ ...t4 });
  }(e9), { Fp: n6, n: r2, prehash: i4, hash: o3, randomBytes: s2, nByteLength: a, h: c3 } = t3, l5 = On << BigInt(8 * a) - Pn, d3 = n6.create, u2 = (0, Mn.Field)(t3.n, t3.nBitLength), h3 = t3.uvRatio || ((e10, t4) => {
    try {
      return { isValid: true, value: n6.sqrt(e10 * n6.inv(t4)) };
    } catch (e11) {
      return { isValid: false, value: Rn };
    }
  }), f4 = t3.adjustScalarBytes || ((e10) => e10), p4 = t3.domain || ((e10, t4, n7) => {
    if ((0, Tn.abool)("phflag", n7), t4.length || n7) throw new Error("Contexts/pre-hash are not supported");
    return e10;
  });
  function g2(e10, t4) {
    In.aInRange("coordinate " + e10, t4, Rn, l5);
  }
  function m4(e10) {
    if (!(e10 instanceof b3)) throw new Error("ExtendedPoint expected");
  }
  const y2 = (0, Tn.memoized)((e10, t4) => {
    const { ex: r3, ey: i5, ez: o4 } = e10, s3 = e10.is0();
    null == t4 && (t4 = s3 ? Nn : n6.inv(o4));
    const a2 = d3(r3 * t4), c4 = d3(i5 * t4), l6 = d3(o4 * t4);
    if (s3) return { x: Rn, y: Pn };
    if (l6 !== Pn) throw new Error("invZ was invalid");
    return { x: a2, y: c4 };
  }), v2 = (0, Tn.memoized)((e10) => {
    const { a: n7, d: r3 } = t3;
    if (e10.is0()) throw new Error("bad point: ZERO");
    const { ex: i5, ey: o4, ez: s3, et: a2 } = e10, c4 = d3(i5 * i5), l6 = d3(o4 * o4), u3 = d3(s3 * s3), h4 = d3(u3 * u3), f5 = d3(c4 * n7);
    if (d3(u3 * d3(f5 + l6)) !== d3(h4 + d3(r3 * d3(c4 * l6)))) throw new Error("bad point: equation left != right (1)");
    if (d3(i5 * o4) !== d3(s3 * a2)) throw new Error("bad point: equation left != right (2)");
    return true;
  });
  class b3 {
    constructor(e10, t4, n7, r3) {
      this.ex = e10, this.ey = t4, this.ez = n7, this.et = r3, g2("x", e10), g2("y", t4), g2("z", n7), g2("t", r3), Object.freeze(this);
    }
    get x() {
      return this.toAffine().x;
    }
    get y() {
      return this.toAffine().y;
    }
    static fromAffine(e10) {
      if (e10 instanceof b3) throw new Error("extended point not allowed");
      const { x: t4, y: n7 } = e10 || {};
      return g2("x", t4), g2("y", n7), new b3(t4, n7, Pn, d3(t4 * n7));
    }
    static normalizeZ(e10) {
      const t4 = n6.invertBatch(e10.map((e11) => e11.ez));
      return e10.map((e11, n7) => e11.toAffine(t4[n7])).map(b3.fromAffine);
    }
    static msm(e10, t4) {
      return (0, xn.pippenger)(b3, u2, e10, t4);
    }
    _setWindowSize(e10) {
      S5.setWindowSize(this, e10);
    }
    assertValidity() {
      v2(this);
    }
    equals(e10) {
      m4(e10);
      const { ex: t4, ey: n7, ez: r3 } = this, { ex: i5, ey: o4, ez: s3 } = e10, a2 = d3(t4 * s3), c4 = d3(i5 * r3), l6 = d3(n7 * s3), u3 = d3(o4 * r3);
      return a2 === c4 && l6 === u3;
    }
    is0() {
      return this.equals(b3.ZERO);
    }
    negate() {
      return new b3(d3(-this.ex), this.ey, this.ez, d3(-this.et));
    }
    double() {
      const { a: e10 } = t3, { ex: n7, ey: r3, ez: i5 } = this, o4 = d3(n7 * n7), s3 = d3(r3 * r3), a2 = d3(On * d3(i5 * i5)), c4 = d3(e10 * o4), l6 = n7 + r3, u3 = d3(d3(l6 * l6) - o4 - s3), h4 = c4 + s3, f5 = h4 - a2, p5 = c4 - s3, g3 = d3(u3 * f5), m5 = d3(h4 * p5), y3 = d3(u3 * p5), v6 = d3(f5 * h4);
      return new b3(g3, m5, v6, y3);
    }
    add(e10) {
      m4(e10);
      const { a: n7, d: r3 } = t3, { ex: i5, ey: o4, ez: s3, et: a2 } = this, { ex: c4, ey: l6, ez: u3, et: h4 } = e10;
      if (n7 === BigInt(-1)) {
        const e11 = d3((o4 - i5) * (l6 + c4)), t4 = d3((o4 + i5) * (l6 - c4)), n8 = d3(t4 - e11);
        if (n8 === Rn) return this.double();
        const r4 = d3(s3 * On * h4), f6 = d3(a2 * On * u3), p6 = f6 + r4, g4 = t4 + e11, m5 = f6 - r4, y4 = d3(p6 * n8), v7 = d3(g4 * m5), w7 = d3(p6 * m5), E6 = d3(n8 * g4);
        return new b3(y4, v7, E6, w7);
      }
      const f5 = d3(i5 * c4), p5 = d3(o4 * l6), g3 = d3(a2 * r3 * h4), y3 = d3(s3 * u3), v6 = d3((i5 + o4) * (c4 + l6) - f5 - p5), w6 = y3 - g3, E5 = y3 + g3, S6 = d3(p5 - n7 * f5), _3 = d3(v6 * w6), C5 = d3(E5 * S6), k4 = d3(v6 * S6), A4 = d3(w6 * E5);
      return new b3(_3, C5, A4, k4);
    }
    subtract(e10) {
      return this.add(e10.negate());
    }
    wNAF(e10) {
      return S5.wNAFCached(this, e10, b3.normalizeZ);
    }
    multiply(e10) {
      const t4 = e10;
      In.aInRange("scalar", t4, Pn, r2);
      const { p: n7, f: i5 } = this.wNAF(t4);
      return b3.normalizeZ([n7, i5])[0];
    }
    multiplyUnsafe(e10) {
      const t4 = e10;
      return In.aInRange("scalar", t4, Rn, r2), t4 === Rn ? E4 : this.equals(E4) || t4 === Pn ? this : this.equals(w5) ? this.wNAF(t4).p : S5.unsafeLadder(this, t4);
    }
    isSmallOrder() {
      return this.multiplyUnsafe(c3).is0();
    }
    isTorsionFree() {
      return S5.unsafeLadder(this, r2).is0();
    }
    toAffine(e10) {
      return y2(this, e10);
    }
    clearCofactor() {
      const { h: e10 } = t3;
      return e10 === Pn ? this : this.multiplyUnsafe(e10);
    }
    static fromHex(e10, r3 = false) {
      const { d: i5, a: o4 } = t3, s3 = n6.BYTES;
      e10 = (0, Tn.ensureBytes)("pointHex", e10, s3), (0, Tn.abool)("zip215", r3);
      const a2 = e10.slice(), c4 = e10[s3 - 1];
      a2[s3 - 1] = -129 & c4;
      const u3 = In.bytesToNumberLE(a2), f5 = r3 ? l5 : n6.ORDER;
      In.aInRange("pointHex.y", u3, Rn, f5);
      const p5 = d3(u3 * u3), g3 = d3(p5 - Pn), m5 = d3(i5 * p5 - o4);
      let { isValid: y3, value: v6 } = h3(g3, m5);
      if (!y3) throw new Error("Point.fromHex: invalid y coordinate");
      const w6 = (v6 & Pn) === Pn, E5 = 0 != (128 & c4);
      if (!r3 && v6 === Rn && E5) throw new Error("Point.fromHex: x=0 and x_0=1");
      return E5 !== w6 && (v6 = d3(-v6)), b3.fromAffine({ x: v6, y: u3 });
    }
    static fromPrivateKey(e10) {
      return k3(e10).point;
    }
    toRawBytes() {
      const { x: e10, y: t4 } = this.toAffine(), r3 = In.numberToBytesLE(t4, n6.BYTES);
      return r3[r3.length - 1] |= e10 & Pn ? 128 : 0, r3;
    }
    toHex() {
      return In.bytesToHex(this.toRawBytes());
    }
  }
  b3.BASE = new b3(t3.Gx, t3.Gy, Pn, d3(t3.Gx * t3.Gy)), b3.ZERO = new b3(Rn, Pn, Pn, Rn);
  const { BASE: w5, ZERO: E4 } = b3, S5 = (0, xn.wNAF)(b3, 8 * a);
  function _2(e10) {
    return (0, Mn.mod)(e10, r2);
  }
  function C4(e10) {
    return _2(In.bytesToNumberLE(e10));
  }
  function k3(e10) {
    const t4 = a;
    e10 = (0, Tn.ensureBytes)("private key", e10, t4);
    const n7 = (0, Tn.ensureBytes)("hashed private key", o3(e10), 2 * t4), r3 = f4(n7.slice(0, t4)), i5 = n7.slice(t4, 2 * t4), s3 = C4(r3), c4 = w5.multiply(s3), l6 = c4.toRawBytes();
    return { head: r3, prefix: i5, scalar: s3, point: c4, pointBytes: l6 };
  }
  function A3(e10 = new Uint8Array(), ...t4) {
    const n7 = In.concatBytes(...t4);
    return C4(o3(p4(n7, (0, Tn.ensureBytes)("context", e10), !!i4)));
  }
  const x3 = Ln;
  w5._setWindowSize(8);
  const M4 = { getExtendedPublicKey: k3, randomPrivateKey: () => s2(n6.BYTES), precompute: (e10 = 8, t4 = b3.BASE) => (t4._setWindowSize(e10), t4.multiply(BigInt(3)), t4) };
  return { CURVE: t3, getPublicKey: function(e10) {
    return k3(e10).pointBytes;
  }, sign: function(e10, t4, o4 = {}) {
    e10 = (0, Tn.ensureBytes)("message", e10), i4 && (e10 = i4(e10));
    const { prefix: s3, scalar: c4, pointBytes: l6 } = k3(t4), d4 = A3(o4.context, s3, e10), u3 = w5.multiply(d4).toRawBytes(), h4 = _2(d4 + A3(o4.context, u3, l6, e10) * c4);
    In.aInRange("signature.s", h4, Rn, r2);
    const f5 = In.concatBytes(u3, In.numberToBytesLE(h4, n6.BYTES));
    return (0, Tn.ensureBytes)("result", f5, 2 * a);
  }, verify: function(e10, t4, r3, o4 = x3) {
    const { context: s3, zip215: a2 } = o4, c4 = n6.BYTES;
    e10 = (0, Tn.ensureBytes)("signature", e10, 2 * c4), t4 = (0, Tn.ensureBytes)("message", t4), void 0 !== a2 && (0, Tn.abool)("zip215", a2), i4 && (t4 = i4(t4));
    const l6 = In.bytesToNumberLE(e10.slice(c4, 2 * c4));
    let d4, u3, h4;
    try {
      d4 = b3.fromHex(r3, a2), u3 = b3.fromHex(e10.slice(0, c4), a2), h4 = w5.multiplyUnsafe(l6);
    } catch (e11) {
      return false;
    }
    if (!a2 && d4.isSmallOrder()) return false;
    const f5 = A3(s3, u3.toRawBytes(), d4.toRawBytes(), t4);
    return u3.add(d4.multiplyUnsafe(f5)).subtract(h4).clearCofactor().equals(b3.ZERO);
  }, ExtendedPoint: b3, utils: M4 };
};
var xn = Pt;
var Mn = Ot;
var In = Nt;
var Tn = Nt;
var Rn = BigInt(0);
var Pn = BigInt(1);
var On = BigInt(2);
var Nn = BigInt(8);
var Ln = { zip215: true };
var Dn = {};
Object.defineProperty(Dn, "__esModule", { value: true }), Dn.expand_message_xmd = Fn, Dn.expand_message_xof = zn, Dn.hash_to_field = qn, Dn.isogenyMap = function(e9, t3) {
  const n6 = t3.map((e10) => Array.from(e10).reverse());
  return (t4, r2) => {
    const [i4, o3, s2, a] = n6.map((n7) => n7.reduce((n8, r3) => e9.add(e9.mul(n8, t4), r3)));
    return t4 = e9.div(i4, o3), r2 = e9.mul(r2, e9.div(s2, a)), { x: t4, y: r2 };
  };
}, Dn.createHasher = function(e9, t3, n6) {
  if ("function" != typeof t3) throw new Error("mapToCurve() must be defined");
  return { hashToCurve(r2, i4) {
    const o3 = qn(r2, 2, { ...n6, DST: n6.DST, ...i4 }), s2 = e9.fromAffine(t3(o3[0])), a = e9.fromAffine(t3(o3[1])), c3 = s2.add(a).clearCofactor();
    return c3.assertValidity(), c3;
  }, encodeToCurve(r2, i4) {
    const o3 = qn(r2, 1, { ...n6, DST: n6.encodeDST, ...i4 }), s2 = e9.fromAffine(t3(o3[0])).clearCofactor();
    return s2.assertValidity(), s2;
  }, mapToCurve(n7) {
    if (!Array.isArray(n7)) throw new Error("mapToCurve: expected array of bigints");
    for (const e10 of n7) if ("bigint" != typeof e10) throw new Error(`mapToCurve: expected array of bigints, got ${e10} in array`);
    const r2 = e9.fromAffine(t3(n7)).clearCofactor();
    return r2.assertValidity(), r2;
  } };
};
var $n = Ot;
var Bn = Nt;
var Kn = Bn.bytesToNumberBE;
function jn(e9, t3) {
  if (Hn(e9), Hn(t3), e9 < 0 || e9 >= 1 << 8 * t3) throw new Error(`bad I2OSP call: value=${e9} length=${t3}`);
  const n6 = Array.from({ length: t3 }).fill(0);
  for (let r2 = t3 - 1; r2 >= 0; r2--) n6[r2] = 255 & e9, e9 >>>= 8;
  return new Uint8Array(n6);
}
function Un(e9, t3) {
  const n6 = new Uint8Array(e9.length);
  for (let r2 = 0; r2 < e9.length; r2++) n6[r2] = e9[r2] ^ t3[r2];
  return n6;
}
function Hn(e9) {
  if (!Number.isSafeInteger(e9)) throw new Error("number expected");
}
function Fn(e9, t3, n6, r2) {
  (0, Bn.abytes)(e9), (0, Bn.abytes)(t3), Hn(n6), t3.length > 255 && (t3 = r2((0, Bn.concatBytes)((0, Bn.utf8ToBytes)("H2C-OVERSIZE-DST-"), t3)));
  const { outputLen: i4, blockLen: o3 } = r2, s2 = Math.ceil(n6 / i4);
  if (n6 > 65535 || s2 > 255) throw new Error("expand_message_xmd: invalid lenInBytes");
  const a = (0, Bn.concatBytes)(t3, jn(t3.length, 1)), c3 = jn(0, o3), l5 = jn(n6, 2), d3 = new Array(s2), u2 = r2((0, Bn.concatBytes)(c3, e9, l5, jn(0, 1), a));
  d3[0] = r2((0, Bn.concatBytes)(u2, jn(1, 1), a));
  for (let e10 = 1; e10 <= s2; e10++) {
    const t4 = [Un(u2, d3[e10 - 1]), jn(e10 + 1, 1), a];
    d3[e10] = r2((0, Bn.concatBytes)(...t4));
  }
  return (0, Bn.concatBytes)(...d3).slice(0, n6);
}
function zn(e9, t3, n6, r2, i4) {
  if ((0, Bn.abytes)(e9), (0, Bn.abytes)(t3), Hn(n6), t3.length > 255) {
    const e10 = Math.ceil(2 * r2 / 8);
    t3 = i4.create({ dkLen: e10 }).update((0, Bn.utf8ToBytes)("H2C-OVERSIZE-DST-")).update(t3).digest();
  }
  if (n6 > 65535 || t3.length > 255) throw new Error("expand_message_xof: invalid lenInBytes");
  return i4.create({ dkLen: n6 }).update(e9).update(jn(n6, 2)).update(t3).update(jn(t3.length, 1)).digest();
}
function qn(e9, t3, n6) {
  (0, Bn.validateObject)(n6, { DST: "stringOrUint8Array", p: "bigint", m: "isSafeInteger", k: "isSafeInteger", hash: "hash" });
  const { p: r2, k: i4, m: o3, hash: s2, expand: a, DST: c3 } = n6;
  (0, Bn.abytes)(e9), Hn(t3);
  const l5 = "string" == typeof c3 ? (0, Bn.utf8ToBytes)(c3) : c3, d3 = r2.toString(2).length, u2 = Math.ceil((d3 + i4) / 8), h3 = t3 * o3 * u2;
  let f4;
  if ("xmd" === a) f4 = Fn(e9, l5, h3, s2);
  else if ("xof" === a) f4 = zn(e9, l5, h3, i4, s2);
  else {
    if ("_internal_pass" !== a) throw new Error('expand must be "xmd" or "xof"');
    f4 = e9;
  }
  const p4 = new Array(t3);
  for (let e10 = 0; e10 < t3; e10++) {
    const t4 = new Array(o3);
    for (let n7 = 0; n7 < o3; n7++) {
      const i5 = u2 * (n7 + e10 * o3), s3 = f4.subarray(i5, i5 + u2);
      t4[n7] = (0, $n.mod)(Kn(s3), r2);
    }
    p4[e10] = t4;
  }
  return p4;
}
var Wn = {};
Object.defineProperty(Wn, "__esModule", { value: true }), Wn.montgomery = function(e9) {
  const t3 = function(e10) {
    return (0, Gn.validateObject)(e10, { a: "bigint" }, { montgomeryBits: "isSafeInteger", nByteLength: "isSafeInteger", adjustScalarBytes: "function", domain: "function", powPminus2: "function", Gu: "bigint" }), Object.freeze({ ...e10 });
  }(e9), { P: n6 } = t3, r2 = (e10) => (0, Vn.mod)(e10, n6), i4 = t3.montgomeryBits, o3 = Math.ceil(i4 / 8), s2 = t3.nByteLength, a = t3.adjustScalarBytes || ((e10) => e10), c3 = t3.powPminus2 || ((e10) => (0, Vn.pow)(e10, n6 - BigInt(2), n6));
  function l5(e10, t4, n7) {
    const i5 = r2(e10 * (t4 - n7));
    return [t4 = r2(t4 - i5), n7 = r2(n7 + i5)];
  }
  const d3 = (t3.a - BigInt(2)) / BigInt(4);
  function u2(e10) {
    return (0, Gn.numberToBytesLE)(r2(e10), o3);
  }
  function h3(e10, t4) {
    const h4 = function(e11) {
      const t5 = (0, Gn.ensureBytes)("u coordinate", e11, o3);
      return 32 === s2 && (t5[31] &= 127), (0, Gn.bytesToNumberLE)(t5);
    }(t4), f5 = function(e11) {
      const t5 = (0, Gn.ensureBytes)("scalar", e11), n7 = t5.length;
      if (n7 !== o3 && n7 !== s2) throw new Error(`Expected ${o3} or ${s2} bytes, got ${n7}`);
      return (0, Gn.bytesToNumberLE)(a(t5));
    }(e10), p5 = function(e11, t5) {
      (0, Gn.aInRange)("u", e11, Yn, n6), (0, Gn.aInRange)("scalar", t5, Yn, n6);
      const o4 = t5, s3 = e11;
      let a2, u3 = Zn, h5 = Yn, f6 = e11, p6 = Zn, g2 = Yn;
      for (let e12 = BigInt(i4 - 1); e12 >= Yn; e12--) {
        const t6 = o4 >> e12 & Zn;
        g2 ^= t6, a2 = l5(g2, u3, f6), u3 = a2[0], f6 = a2[1], a2 = l5(g2, h5, p6), h5 = a2[0], p6 = a2[1], g2 = t6;
        const n7 = u3 + h5, i5 = r2(n7 * n7), c4 = u3 - h5, m5 = r2(c4 * c4), y2 = i5 - m5, v2 = f6 + p6, b3 = r2((f6 - p6) * n7), w5 = r2(v2 * c4), E4 = b3 + w5, S5 = b3 - w5;
        f6 = r2(E4 * E4), p6 = r2(s3 * r2(S5 * S5)), u3 = r2(i5 * m5), h5 = r2(y2 * (i5 + r2(d3 * y2)));
      }
      a2 = l5(g2, u3, f6), u3 = a2[0], f6 = a2[1], a2 = l5(g2, h5, p6), h5 = a2[0], p6 = a2[1];
      const m4 = c3(h5);
      return r2(u3 * m4);
    }(h4, f5);
    if (p5 === Yn) throw new Error("Invalid private or public key received");
    return u2(p5);
  }
  const f4 = u2(t3.Gu);
  function p4(e10) {
    return h3(e10, f4);
  }
  return { scalarMult: h3, scalarMultBase: p4, getSharedSecret: (e10, t4) => h3(e10, t4), getPublicKey: (e10) => p4(e10), utils: { randomPrivateKey: () => t3.randomBytes(t3.nByteLength) }, GuBytes: f4 };
};
var Vn = Ot;
var Gn = Nt;
var Yn = BigInt(0);
var Zn = BigInt(1);
!function(e9) {
  Object.defineProperty(e9, "__esModule", { value: true }), e9.hash_to_ristretto255 = e9.hashToRistretto255 = e9.RistrettoPoint = e9.encodeToCurve = e9.hashToCurve = e9.edwardsToMontgomery = e9.x25519 = e9.ed25519ph = e9.ed25519ctx = e9.ed25519 = e9.ED25519_TORSION_SUBGROUP = void 0, e9.edwardsToMontgomeryPub = S5, e9.edwardsToMontgomeryPriv = function(e10) {
    const t4 = w5.hash(e10.subarray(0, 32));
    return w5.adjustScalarBytes(t4).subarray(0, 32);
  };
  const t3 = Oe, n6 = ze, r2 = Rt, i4 = Dn, o3 = Ot, s2 = Wn, a = Nt, c3 = BigInt("57896044618658097711785492504343953926634992332820282019728792003956564819949"), l5 = BigInt("19681161376707505956807079304988542015446066515923890162744021073123829784752"), d3 = BigInt(0), u2 = BigInt(1), h3 = BigInt(2), f4 = BigInt(3), p4 = BigInt(5), g2 = BigInt(8);
  function m4(e10) {
    const t4 = BigInt(10), n7 = BigInt(20), r3 = BigInt(40), i5 = BigInt(80), s3 = c3, a2 = e10 * e10 % s3 * e10 % s3, l6 = (0, o3.pow2)(a2, h3, s3) * a2 % s3, d4 = (0, o3.pow2)(l6, u2, s3) * e10 % s3, f5 = (0, o3.pow2)(d4, p4, s3) * d4 % s3, g3 = (0, o3.pow2)(f5, t4, s3) * f5 % s3, m5 = (0, o3.pow2)(g3, n7, s3) * g3 % s3, y3 = (0, o3.pow2)(m5, r3, s3) * m5 % s3, v6 = (0, o3.pow2)(y3, i5, s3) * y3 % s3, b4 = (0, o3.pow2)(v6, i5, s3) * y3 % s3, w6 = (0, o3.pow2)(b4, t4, s3) * f5 % s3;
    return { pow_p_5_8: (0, o3.pow2)(w6, h3, s3) * e10 % s3, b2: a2 };
  }
  function y2(e10) {
    return e10[0] &= 248, e10[31] &= 127, e10[31] |= 64, e10;
  }
  function v2(e10, t4) {
    const n7 = c3, r3 = (0, o3.mod)(t4 * t4 * t4, n7), i5 = m4(e10 * (0, o3.mod)(r3 * r3 * t4, n7)).pow_p_5_8;
    let s3 = (0, o3.mod)(e10 * r3 * i5, n7);
    const a2 = (0, o3.mod)(t4 * s3 * s3, n7), d4 = s3, u3 = (0, o3.mod)(s3 * l5, n7), h4 = a2 === e10, f5 = a2 === (0, o3.mod)(-e10, n7), p5 = a2 === (0, o3.mod)(-e10 * l5, n7);
    return h4 && (s3 = d4), (f5 || p5) && (s3 = u3), (0, o3.isNegativeLE)(s3, n7) && (s3 = (0, o3.mod)(-s3, n7)), { isValid: h4 || f5, value: s3 };
  }
  e9.ED25519_TORSION_SUBGROUP = ["0100000000000000000000000000000000000000000000000000000000000000", "c7176a703d4dd84fba3c0b760d10670f2a2053fa2c39ccc64ec7fd7792ac037a", "0000000000000000000000000000000000000000000000000000000000000080", "26e8958fc2b227b045c3f489f2ef98f0d5dfac05d3c63339b13802886d53fc05", "ecffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff7f", "26e8958fc2b227b045c3f489f2ef98f0d5dfac05d3c63339b13802886d53fc85", "0000000000000000000000000000000000000000000000000000000000000000", "c7176a703d4dd84fba3c0b760d10670f2a2053fa2c39ccc64ec7fd7792ac03fa"];
  const b3 = (() => (0, o3.Field)(c3, void 0, true))(), w5 = (() => ({ a: BigInt(-1), d: BigInt("37095705934669439343138083508754565189542113879843219016388785533085940283555"), Fp: b3, n: BigInt("7237005577332262213973186563042994240857116359379907606001950938285454250989"), h: g2, Gx: BigInt("15112221349535400772501151409588531511454012693041857206046113283949847762202"), Gy: BigInt("46316835694926478169428394003475163141307993866256225615783033603165251855960"), hash: t3.sha512, randomBytes: n6.randomBytes, adjustScalarBytes: y2, uvRatio: v2 }))();
  function E4(e10, t4, r3) {
    if (t4.length > 255) throw new Error("Context is too big");
    return (0, n6.concatBytes)((0, n6.utf8ToBytes)("SigEd25519 no Ed25519 collisions"), new Uint8Array([r3 ? 1 : 0, t4.length]), t4, e10);
  }
  function S5(t4) {
    const { y: n7 } = e9.ed25519.ExtendedPoint.fromHex(t4), r3 = BigInt(1);
    return b3.toBytes(b3.create((r3 + n7) * b3.inv(r3 - n7)));
  }
  e9.ed25519 = (0, r2.twistedEdwards)(w5), e9.ed25519ctx = (0, r2.twistedEdwards)({ ...w5, domain: E4 }), e9.ed25519ph = (0, r2.twistedEdwards)(Object.assign({}, w5, { domain: E4, prehash: t3.sha512 })), e9.x25519 = (0, s2.montgomery)({ P: c3, a: BigInt(486662), montgomeryBits: 255, nByteLength: 32, Gu: BigInt(9), powPminus2: (e10) => {
    const t4 = c3, { pow_p_5_8: n7, b2: r3 } = m4(e10);
    return (0, o3.mod)((0, o3.pow2)(n7, f4, t4) * r3, t4);
  }, adjustScalarBytes: y2, randomBytes: n6.randomBytes }), e9.edwardsToMontgomery = S5;
  const _2 = (() => (b3.ORDER + f4) / g2)(), C4 = (() => b3.pow(h3, _2))(), k3 = (() => b3.sqrt(b3.neg(b3.ONE)))();
  const A3 = (() => (0, o3.FpSqrtEven)(b3, b3.neg(BigInt(486664))))();
  function x3(e10) {
    const { xMn: t4, xMd: n7, yMn: r3, yMd: i5 } = function(e11) {
      const t5 = (b3.ORDER - p4) / g2, n8 = BigInt(486662);
      let r4 = b3.sqr(e11);
      r4 = b3.mul(r4, h3);
      let i6 = b3.add(r4, b3.ONE), o5 = b3.neg(n8), s4 = b3.sqr(i6), a3 = b3.mul(s4, i6), c5 = b3.mul(r4, n8);
      c5 = b3.mul(c5, o5), c5 = b3.add(c5, s4), c5 = b3.mul(c5, o5);
      let l7 = b3.sqr(a3);
      s4 = b3.sqr(l7), l7 = b3.mul(l7, a3), l7 = b3.mul(l7, c5), s4 = b3.mul(s4, l7);
      let d5 = b3.pow(s4, t5);
      d5 = b3.mul(d5, l7);
      let f6 = b3.mul(d5, k3);
      s4 = b3.sqr(d5), s4 = b3.mul(s4, a3);
      let m5 = b3.eql(s4, c5), y3 = b3.cmov(f6, d5, m5), v6 = b3.mul(o5, r4), w6 = b3.mul(d5, e11);
      w6 = b3.mul(w6, C4);
      let E5 = b3.mul(w6, k3), S6 = b3.mul(c5, r4);
      s4 = b3.sqr(w6), s4 = b3.mul(s4, a3);
      let _3 = b3.eql(s4, S6), A4 = b3.cmov(E5, w6, _3);
      s4 = b3.sqr(y3), s4 = b3.mul(s4, a3);
      let x4 = b3.eql(s4, c5), M5 = b3.cmov(v6, o5, x4), I3 = b3.cmov(A4, y3, x4), T4 = b3.isOdd(I3);
      return I3 = b3.cmov(I3, b3.neg(I3), x4 !== T4), { xMn: M5, xMd: i6, yMn: I3, yMd: u2 };
    }(e10);
    let o4 = b3.mul(t4, i5);
    o4 = b3.mul(o4, A3);
    let s3 = b3.mul(n7, r3), a2 = b3.sub(t4, n7), c4 = b3.add(t4, n7), l6 = b3.mul(s3, c4), d4 = b3.eql(l6, b3.ZERO);
    o4 = b3.cmov(o4, b3.ZERO, d4), s3 = b3.cmov(s3, b3.ONE, d4), a2 = b3.cmov(a2, b3.ONE, d4), c4 = b3.cmov(c4, b3.ONE, d4);
    const f5 = b3.invertBatch([s3, c4]);
    return { x: b3.mul(o4, f5[0]), y: b3.mul(a2, f5[1]) };
  }
  const M4 = (() => (0, i4.createHasher)(e9.ed25519.ExtendedPoint, (e10) => x3(e10[0]), { DST: "edwards25519_XMD:SHA-512_ELL2_RO_", encodeDST: "edwards25519_XMD:SHA-512_ELL2_NU_", p: b3.ORDER, m: 1, k: 128, expand: "xmd", hash: t3.sha512 }))();
  function I2(e10) {
    if (!(e10 instanceof K4)) throw new Error("RistrettoPoint expected");
  }
  e9.hashToCurve = M4.hashToCurve, e9.encodeToCurve = M4.encodeToCurve;
  const T3 = l5, R3 = BigInt("25063068953384623474111414158702152701244531502492656460079210482610430750235"), P5 = BigInt("54469307008909316920995813868745141605393597292927456921205312896311721017578"), O4 = BigInt("1159843021668779879193775521855586647937357759715417654439879720876111806838"), N3 = BigInt("40440834346308536858101042469323190826248399146238708352240133220865137265952"), L5 = (e10) => v2(u2, e10), D3 = BigInt("0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff"), $2 = (t4) => e9.ed25519.CURVE.Fp.create((0, a.bytesToNumberLE)(t4) & D3);
  function B3(t4) {
    const { d: n7 } = e9.ed25519.CURVE, r3 = e9.ed25519.CURVE.Fp.ORDER, i5 = e9.ed25519.CURVE.Fp.create, s3 = i5(T3 * t4 * t4), a2 = i5((s3 + u2) * O4);
    let c4 = BigInt(-1);
    const l6 = i5((c4 - n7 * s3) * i5(s3 + n7));
    let { isValid: d4, value: h4 } = v2(a2, l6), f5 = i5(h4 * t4);
    (0, o3.isNegativeLE)(f5, r3) || (f5 = i5(-f5)), d4 || (h4 = f5), d4 || (c4 = s3);
    const p5 = i5(c4 * (s3 - u2) * N3 - l6), g3 = h4 * h4, m5 = i5((h4 + h4) * l6), y3 = i5(p5 * R3), b4 = i5(u2 - g3), w6 = i5(u2 + g3);
    return new e9.ed25519.ExtendedPoint(i5(m5 * w6), i5(b4 * y3), i5(y3 * w6), i5(m5 * b4));
  }
  class K4 {
    constructor(e10) {
      this.ep = e10;
    }
    static fromAffine(t4) {
      return new K4(e9.ed25519.ExtendedPoint.fromAffine(t4));
    }
    static hashToCurve(e10) {
      e10 = (0, a.ensureBytes)("ristrettoHash", e10, 64);
      const t4 = B3($2(e10.slice(0, 32))), n7 = B3($2(e10.slice(32, 64)));
      return new K4(t4.add(n7));
    }
    static fromHex(t4) {
      t4 = (0, a.ensureBytes)("ristrettoHex", t4, 32);
      const { a: n7, d: r3 } = e9.ed25519.CURVE, i5 = e9.ed25519.CURVE.Fp.ORDER, s3 = e9.ed25519.CURVE.Fp.create, c4 = "RistrettoPoint.fromHex: the hex is not valid encoding of RistrettoPoint", l6 = $2(t4);
      if (!(0, a.equalBytes)((0, a.numberToBytesLE)(l6, 32), t4) || (0, o3.isNegativeLE)(l6, i5)) throw new Error(c4);
      const h4 = s3(l6 * l6), f5 = s3(u2 + n7 * h4), p5 = s3(u2 - n7 * h4), g3 = s3(f5 * f5), m5 = s3(p5 * p5), y3 = s3(n7 * r3 * g3 - m5), { isValid: v6, value: b4 } = L5(s3(y3 * m5)), w6 = s3(b4 * p5), E5 = s3(b4 * w6 * y3);
      let S6 = s3((l6 + l6) * w6);
      (0, o3.isNegativeLE)(S6, i5) && (S6 = s3(-S6));
      const _3 = s3(f5 * E5), C5 = s3(S6 * _3);
      if (!v6 || (0, o3.isNegativeLE)(C5, i5) || _3 === d3) throw new Error(c4);
      return new K4(new e9.ed25519.ExtendedPoint(S6, _3, u2, C5));
    }
    toRawBytes() {
      let { ex: t4, ey: n7, ez: r3, et: i5 } = this.ep;
      const s3 = e9.ed25519.CURVE.Fp.ORDER, c4 = e9.ed25519.CURVE.Fp.create, l6 = c4(c4(r3 + n7) * c4(r3 - n7)), d4 = c4(t4 * n7), u3 = c4(d4 * d4), { value: h4 } = L5(c4(l6 * u3)), f5 = c4(h4 * l6), p5 = c4(h4 * d4), g3 = c4(f5 * p5 * i5);
      let m5;
      if ((0, o3.isNegativeLE)(i5 * g3, s3)) {
        let e10 = c4(n7 * T3), r4 = c4(t4 * T3);
        t4 = e10, n7 = r4, m5 = c4(f5 * P5);
      } else m5 = p5;
      (0, o3.isNegativeLE)(t4 * g3, s3) && (n7 = c4(-n7));
      let y3 = c4((r3 - n7) * m5);
      return (0, o3.isNegativeLE)(y3, s3) && (y3 = c4(-y3)), (0, a.numberToBytesLE)(y3, 32);
    }
    toHex() {
      return (0, a.bytesToHex)(this.toRawBytes());
    }
    toString() {
      return this.toHex();
    }
    equals(t4) {
      I2(t4);
      const { ex: n7, ey: r3 } = this.ep, { ex: i5, ey: o4 } = t4.ep, s3 = e9.ed25519.CURVE.Fp.create, a2 = s3(n7 * o4) === s3(r3 * i5), c4 = s3(r3 * o4) === s3(n7 * i5);
      return a2 || c4;
    }
    add(e10) {
      return I2(e10), new K4(this.ep.add(e10.ep));
    }
    subtract(e10) {
      return I2(e10), new K4(this.ep.subtract(e10.ep));
    }
    multiply(e10) {
      return new K4(this.ep.multiply(e10));
    }
    multiplyUnsafe(e10) {
      return new K4(this.ep.multiplyUnsafe(e10));
    }
    double() {
      return new K4(this.ep.double());
    }
    negate() {
      return new K4(this.ep.negate());
    }
  }
  e9.RistrettoPoint = (K4.BASE || (K4.BASE = new K4(e9.ed25519.ExtendedPoint.BASE)), K4.ZERO || (K4.ZERO = new K4(e9.ed25519.ExtendedPoint.ZERO)), K4);
  e9.hashToRistretto255 = (e10, r3) => {
    const o4 = r3.DST, s3 = "string" == typeof o4 ? (0, n6.utf8ToBytes)(o4) : o4, a2 = (0, i4.expand_message_xmd)(e10, s3, 64, t3.sha512);
    return K4.hashToCurve(a2);
  }, e9.hash_to_ristretto255 = e9.hashToRistretto255;
}(Pe2);
var Jn = {};
var Qn = {};
Object.defineProperty(Qn, "__esModule", { value: true }), Qn.sha224 = Qn.sha256 = Qn.SHA256 = void 0;
var Xn = Ne;
var er = ze;
var tr = new Uint32Array([1116352408, 1899447441, 3049323471, 3921009573, 961987163, 1508970993, 2453635748, 2870763221, 3624381080, 310598401, 607225278, 1426881987, 1925078388, 2162078206, 2614888103, 3248222580, 3835390401, 4022224774, 264347078, 604807628, 770255983, 1249150122, 1555081692, 1996064986, 2554220882, 2821834349, 2952996808, 3210313671, 3336571891, 3584528711, 113926993, 338241895, 666307205, 773529912, 1294757372, 1396182291, 1695183700, 1986661051, 2177026350, 2456956037, 2730485921, 2820302411, 3259730800, 3345764771, 3516065817, 3600352804, 4094571909, 275423344, 430227734, 506948616, 659060556, 883997877, 958139571, 1322822218, 1537002063, 1747873779, 1955562222, 2024104815, 2227730452, 2361852424, 2428436474, 2756734187, 3204031479, 3329325298]);
var nr = new Uint32Array([1779033703, 3144134277, 1013904242, 2773480762, 1359893119, 2600822924, 528734635, 1541459225]);
var rr = new Uint32Array(64);
var ir = class extends Xn.HashMD {
  constructor() {
    super(64, 32, 8, false), this.A = 0 | nr[0], this.B = 0 | nr[1], this.C = 0 | nr[2], this.D = 0 | nr[3], this.E = 0 | nr[4], this.F = 0 | nr[5], this.G = 0 | nr[6], this.H = 0 | nr[7];
  }
  get() {
    const { A: e9, B: t3, C: n6, D: r2, E: i4, F: o3, G: s2, H: a } = this;
    return [e9, t3, n6, r2, i4, o3, s2, a];
  }
  set(e9, t3, n6, r2, i4, o3, s2, a) {
    this.A = 0 | e9, this.B = 0 | t3, this.C = 0 | n6, this.D = 0 | r2, this.E = 0 | i4, this.F = 0 | o3, this.G = 0 | s2, this.H = 0 | a;
  }
  process(e9, t3) {
    for (let n7 = 0; n7 < 16; n7++, t3 += 4) rr[n7] = e9.getUint32(t3, false);
    for (let e10 = 16; e10 < 64; e10++) {
      const t4 = rr[e10 - 15], n7 = rr[e10 - 2], r3 = (0, er.rotr)(t4, 7) ^ (0, er.rotr)(t4, 18) ^ t4 >>> 3, i5 = (0, er.rotr)(n7, 17) ^ (0, er.rotr)(n7, 19) ^ n7 >>> 10;
      rr[e10] = i5 + rr[e10 - 7] + r3 + rr[e10 - 16] | 0;
    }
    let { A: n6, B: r2, C: i4, D: o3, E: s2, F: a, G: c3, H: l5 } = this;
    for (let e10 = 0; e10 < 64; e10++) {
      const t4 = l5 + ((0, er.rotr)(s2, 6) ^ (0, er.rotr)(s2, 11) ^ (0, er.rotr)(s2, 25)) + (0, Xn.Chi)(s2, a, c3) + tr[e10] + rr[e10] | 0, d3 = ((0, er.rotr)(n6, 2) ^ (0, er.rotr)(n6, 13) ^ (0, er.rotr)(n6, 22)) + (0, Xn.Maj)(n6, r2, i4) | 0;
      l5 = c3, c3 = a, a = s2, s2 = o3 + t4 | 0, o3 = i4, i4 = r2, r2 = n6, n6 = t4 + d3 | 0;
    }
    n6 = n6 + this.A | 0, r2 = r2 + this.B | 0, i4 = i4 + this.C | 0, o3 = o3 + this.D | 0, s2 = s2 + this.E | 0, a = a + this.F | 0, c3 = c3 + this.G | 0, l5 = l5 + this.H | 0, this.set(n6, r2, i4, o3, s2, a, c3, l5);
  }
  roundClean() {
    rr.fill(0);
  }
  destroy() {
    this.set(0, 0, 0, 0, 0, 0, 0, 0), this.buffer.fill(0);
  }
};
Qn.SHA256 = ir;
var or = class extends ir {
  constructor() {
    super(), this.A = -1056596264, this.B = 914150663, this.C = 812702999, this.D = -150054599, this.E = -4191439, this.F = 1750603025, this.G = 1694076839, this.H = -1090891868, this.outputLen = 28;
  }
};
Qn.sha256 = (0, er.wrapConstructor)(() => new ir()), Qn.sha224 = (0, er.wrapConstructor)(() => new or());
var sr = {};
var ar = {};
!function(e9) {
  Object.defineProperty(e9, "__esModule", { value: true }), e9.hmac = e9.HMAC = void 0;
  const t3 = Le, n6 = ze;
  class r2 extends n6.Hash {
    constructor(e10, r3) {
      super(), this.finished = false, this.destroyed = false, (0, t3.hash)(e10);
      const i4 = (0, n6.toBytes)(r3);
      if (this.iHash = e10.create(), "function" != typeof this.iHash.update) throw new Error("Expected instance of class which extends utils.Hash");
      this.blockLen = this.iHash.blockLen, this.outputLen = this.iHash.outputLen;
      const o3 = this.blockLen, s2 = new Uint8Array(o3);
      s2.set(i4.length > o3 ? e10.create().update(i4).digest() : i4);
      for (let e11 = 0; e11 < s2.length; e11++) s2[e11] ^= 54;
      this.iHash.update(s2), this.oHash = e10.create();
      for (let e11 = 0; e11 < s2.length; e11++) s2[e11] ^= 106;
      this.oHash.update(s2), s2.fill(0);
    }
    update(e10) {
      return (0, t3.exists)(this), this.iHash.update(e10), this;
    }
    digestInto(e10) {
      (0, t3.exists)(this), (0, t3.bytes)(e10, this.outputLen), this.finished = true, this.iHash.digestInto(e10), this.oHash.update(e10), this.oHash.digestInto(e10), this.destroy();
    }
    digest() {
      const e10 = new Uint8Array(this.oHash.outputLen);
      return this.digestInto(e10), e10;
    }
    _cloneInto(e10) {
      e10 || (e10 = Object.create(Object.getPrototypeOf(this), {}));
      const { oHash: t4, iHash: n7, finished: r3, destroyed: i4, blockLen: o3, outputLen: s2 } = this;
      return e10.finished = r3, e10.destroyed = i4, e10.blockLen = o3, e10.outputLen = s2, e10.oHash = t4._cloneInto(e10.oHash), e10.iHash = n7._cloneInto(e10.iHash), e10;
    }
    destroy() {
      this.destroyed = true, this.oHash.destroy(), this.iHash.destroy();
    }
  }
  e9.HMAC = r2;
  e9.hmac = (e10, t4, n7) => new r2(e10, t4).update(n7).digest(), e9.hmac.create = (e10, t4) => new r2(e10, t4);
}(ar);
var cr = {};
!function(e9) {
  Object.defineProperty(e9, "__esModule", { value: true }), e9.DER = void 0, e9.weierstrassPoints = f4, e9.weierstrass = function(s3) {
    const a2 = function(e10) {
      const n7 = (0, t3.validateBasic)(e10);
      return r2.validateObject(n7, { hash: "hash", hmac: "function", randomBytes: "function" }, { bits2int: "function", bits2int_modN: "function", lowS: "boolean" }), Object.freeze({ lowS: true, ...n7 });
    }(s3), { Fp: d4, n: u3 } = a2, h4 = d4.BYTES + 1, p5 = 2 * d4.BYTES + 1;
    function g2(e10) {
      return n6.mod(e10, u3);
    }
    function m4(e10) {
      return n6.invert(e10, u3);
    }
    const { ProjectivePoint: y2, normPrivateKeyToScalar: v2, weierstrassEquation: b3, isWithinCurveOrder: w5 } = f4({ ...a2, toBytes(e10, t4, n7) {
      const o4 = t4.toAffine(), s4 = d4.toBytes(o4.x), a3 = r2.concatBytes;
      return (0, i4.abool)("isCompressed", n7), n7 ? a3(Uint8Array.from([t4.hasEvenY() ? 2 : 3]), s4) : a3(Uint8Array.from([4]), s4, d4.toBytes(o4.y));
    }, fromBytes(e10) {
      const t4 = e10.length, n7 = e10[0], i5 = e10.subarray(1);
      if (t4 !== h4 || 2 !== n7 && 3 !== n7) {
        if (t4 === p5 && 4 === n7) {
          return { x: d4.fromBytes(i5.subarray(0, d4.BYTES)), y: d4.fromBytes(i5.subarray(d4.BYTES, 2 * d4.BYTES)) };
        }
        throw new Error(`Point of length ${t4} was invalid. Expected ${h4} compressed bytes or ${p5} uncompressed bytes`);
      }
      {
        const e11 = r2.bytesToNumberBE(i5);
        if (!r2.inRange(e11, l5, d4.ORDER)) throw new Error("Point is not on curve");
        const t5 = b3(e11);
        let o4;
        try {
          o4 = d4.sqrt(t5);
        } catch (e12) {
          const t6 = e12 instanceof Error ? ": " + e12.message : "";
          throw new Error("Point is not on curve" + t6);
        }
        return 1 == (1 & n7) !== ((o4 & l5) === l5) && (o4 = d4.neg(o4)), { x: e11, y: o4 };
      }
    } }), E4 = (e10) => r2.bytesToHex(r2.numberToBytesBE(e10, a2.nByteLength));
    function S5(e10) {
      return e10 > u3 >> l5;
    }
    const _2 = (e10, t4, n7) => r2.bytesToNumberBE(e10.slice(t4, n7));
    class C4 {
      constructor(e10, t4, n7) {
        this.r = e10, this.s = t4, this.recovery = n7, this.assertValidity();
      }
      static fromCompact(e10) {
        const t4 = a2.nByteLength;
        return e10 = (0, i4.ensureBytes)("compactSignature", e10, 2 * t4), new C4(_2(e10, 0, t4), _2(e10, t4, 2 * t4));
      }
      static fromDER(t4) {
        const { r: n7, s: r3 } = e9.DER.toSig((0, i4.ensureBytes)("DER", t4));
        return new C4(n7, r3);
      }
      assertValidity() {
        r2.aInRange("r", this.r, l5, u3), r2.aInRange("s", this.s, l5, u3);
      }
      addRecoveryBit(e10) {
        return new C4(this.r, this.s, e10);
      }
      recoverPublicKey(e10) {
        const { r: t4, s: n7, recovery: r3 } = this, o4 = M4((0, i4.ensureBytes)("msgHash", e10));
        if (null == r3 || ![0, 1, 2, 3].includes(r3)) throw new Error("recovery id invalid");
        const s4 = 2 === r3 || 3 === r3 ? t4 + a2.n : t4;
        if (s4 >= d4.ORDER) throw new Error("recovery id 2 or 3 invalid");
        const c4 = 0 == (1 & r3) ? "02" : "03", l6 = y2.fromHex(c4 + E4(s4)), u4 = m4(s4), h5 = g2(-o4 * u4), f5 = g2(n7 * u4), p6 = y2.BASE.multiplyAndAddUnsafe(l6, h5, f5);
        if (!p6) throw new Error("point at infinify");
        return p6.assertValidity(), p6;
      }
      hasHighS() {
        return S5(this.s);
      }
      normalizeS() {
        return this.hasHighS() ? new C4(this.r, g2(-this.s), this.recovery) : this;
      }
      toDERRawBytes() {
        return r2.hexToBytes(this.toDERHex());
      }
      toDERHex() {
        return e9.DER.hexFromSig({ r: this.r, s: this.s });
      }
      toCompactRawBytes() {
        return r2.hexToBytes(this.toCompactHex());
      }
      toCompactHex() {
        return E4(this.r) + E4(this.s);
      }
    }
    const k3 = { isValidPrivateKey(e10) {
      try {
        return v2(e10), true;
      } catch (e11) {
        return false;
      }
    }, normPrivateKeyToScalar: v2, randomPrivateKey: () => {
      const e10 = n6.getMinHashLength(a2.n);
      return n6.mapHashToField(a2.randomBytes(e10), a2.n);
    }, precompute: (e10 = 8, t4 = y2.BASE) => (t4._setWindowSize(e10), t4.multiply(BigInt(3)), t4) };
    function A3(e10) {
      const t4 = r2.isBytes(e10), n7 = "string" == typeof e10, i5 = (t4 || n7) && e10.length;
      return t4 ? i5 === h4 || i5 === p5 : n7 ? i5 === 2 * h4 || i5 === 2 * p5 : e10 instanceof y2;
    }
    const x3 = a2.bits2int || function(e10) {
      const t4 = r2.bytesToNumberBE(e10), n7 = 8 * e10.length - a2.nBitLength;
      return n7 > 0 ? t4 >> BigInt(n7) : t4;
    }, M4 = a2.bits2int_modN || function(e10) {
      return g2(x3(e10));
    }, I2 = r2.bitMask(a2.nBitLength);
    function T3(e10) {
      return r2.aInRange(`num < 2^${a2.nBitLength}`, e10, c3, I2), r2.numberToBytesBE(e10, a2.nByteLength);
    }
    function R3(e10, t4, n7 = P5) {
      if (["recovered", "canonical"].some((e11) => e11 in n7)) throw new Error("sign() legacy options not supported");
      const { hash: s4, randomBytes: u4 } = a2;
      let { lowS: h5, prehash: f5, extraEntropy: p6 } = n7;
      null == h5 && (h5 = true), e10 = (0, i4.ensureBytes)("msgHash", e10), o3(n7), f5 && (e10 = (0, i4.ensureBytes)("prehashed msgHash", s4(e10)));
      const b4 = M4(e10), E5 = v2(t4), _3 = [T3(E5), T3(b4)];
      if (null != p6 && false !== p6) {
        const e11 = true === p6 ? u4(d4.BYTES) : p6;
        _3.push((0, i4.ensureBytes)("extraEntropy", e11));
      }
      const k4 = r2.concatBytes(..._3), A4 = b4;
      return { seed: k4, k2sig: function(e11) {
        const t5 = x3(e11);
        if (!w5(t5)) return;
        const n8 = m4(t5), r3 = y2.BASE.multiply(t5).toAffine(), i5 = g2(r3.x);
        if (i5 === c3) return;
        const o4 = g2(n8 * g2(A4 + i5 * E5));
        if (o4 === c3) return;
        let s5 = (r3.x === i5 ? 0 : 2) | Number(r3.y & l5), a3 = o4;
        return h5 && S5(o4) && (a3 = function(e12) {
          return S5(e12) ? g2(-e12) : e12;
        }(o4), s5 ^= 1), new C4(i5, a3, s5);
      } };
    }
    const P5 = { lowS: a2.lowS, prehash: false }, O4 = { lowS: a2.lowS, prehash: false };
    return y2.BASE._setWindowSize(8), { CURVE: a2, getPublicKey: function(e10, t4 = true) {
      return y2.fromPrivateKey(e10).toRawBytes(t4);
    }, getSharedSecret: function(e10, t4, n7 = true) {
      if (A3(e10)) throw new Error("first arg must be private key");
      if (!A3(t4)) throw new Error("second arg must be public key");
      const r3 = y2.fromHex(t4);
      return r3.multiply(v2(e10)).toRawBytes(n7);
    }, sign: function(e10, t4, n7 = P5) {
      const { seed: i5, k2sig: o4 } = R3(e10, t4, n7), s4 = a2, c4 = r2.createHmacDrbg(s4.hash.outputLen, s4.nByteLength, s4.hmac);
      return c4(i5, o4);
    }, verify: function(t4, n7, s4, c4 = O4) {
      var _a2;
      const l6 = t4;
      if (n7 = (0, i4.ensureBytes)("msgHash", n7), s4 = (0, i4.ensureBytes)("publicKey", s4), "strict" in c4) throw new Error("options.strict was renamed to lowS");
      o3(c4);
      const { lowS: d5, prehash: u4 } = c4;
      let h5, f5;
      try {
        if ("string" == typeof l6 || r2.isBytes(l6)) try {
          h5 = C4.fromDER(l6);
        } catch (t5) {
          if (!(t5 instanceof e9.DER.Err)) throw t5;
          h5 = C4.fromCompact(l6);
        }
        else {
          if ("object" != typeof l6 || "bigint" != typeof l6.r || "bigint" != typeof l6.s) throw new Error("PARSE");
          {
            const { r: e10, s: t5 } = l6;
            h5 = new C4(e10, t5);
          }
        }
        f5 = y2.fromHex(s4);
      } catch (e10) {
        if ("PARSE" === e10.message) throw new Error("signature must be Signature instance, Uint8Array or hex string");
        return false;
      }
      if (d5 && h5.hasHighS()) return false;
      u4 && (n7 = a2.hash(n7));
      const { r: p6, s: v6 } = h5, b4 = M4(n7), w6 = m4(v6), E5 = g2(b4 * w6), S6 = g2(p6 * w6), _3 = (_a2 = y2.BASE.multiplyAndAddUnsafe(f5, E5, S6)) == null ? void 0 : _a2.toAffine();
      if (!_3) return false;
      const k4 = g2(_3.x);
      return k4 === p6;
    }, ProjectivePoint: y2, Signature: C4, utils: k3 };
  }, e9.SWUFpSqrtRatio = p4, e9.mapToCurveSimpleSWU = function(e10, t4) {
    if (n6.validateField(e10), !e10.isValid(t4.A) || !e10.isValid(t4.B) || !e10.isValid(t4.Z)) throw new Error("mapToCurveSimpleSWU: invalid opts");
    const r3 = p4(e10, t4.Z);
    if (!e10.isOdd) throw new Error("Fp.isOdd is not implemented!");
    return (n7) => {
      let i5, o4, s3, a2, c4, l6, d4, u3;
      i5 = e10.sqr(n7), i5 = e10.mul(i5, t4.Z), o4 = e10.sqr(i5), o4 = e10.add(o4, i5), s3 = e10.add(o4, e10.ONE), s3 = e10.mul(s3, t4.B), a2 = e10.cmov(t4.Z, e10.neg(o4), !e10.eql(o4, e10.ZERO)), a2 = e10.mul(a2, t4.A), o4 = e10.sqr(s3), l6 = e10.sqr(a2), c4 = e10.mul(l6, t4.A), o4 = e10.add(o4, c4), o4 = e10.mul(o4, s3), l6 = e10.mul(l6, a2), c4 = e10.mul(l6, t4.B), o4 = e10.add(o4, c4), d4 = e10.mul(i5, s3);
      const { isValid: h4, value: f5 } = r3(o4, l6);
      u3 = e10.mul(i5, n7), u3 = e10.mul(u3, f5), d4 = e10.cmov(d4, s3, h4), u3 = e10.cmov(u3, f5, h4);
      const p5 = e10.isOdd(n7) === e10.isOdd(u3);
      return u3 = e10.cmov(e10.neg(u3), u3, p5), d4 = e10.div(d4, a2), { x: d4, y: u3 };
    };
  };
  const t3 = Pt, n6 = Ot, r2 = Nt, i4 = Nt;
  function o3(e10) {
    void 0 !== e10.lowS && (0, i4.abool)("lowS", e10.lowS), void 0 !== e10.prehash && (0, i4.abool)("prehash", e10.prehash);
  }
  const { bytesToNumberBE: s2, hexToBytes: a } = r2;
  e9.DER = { Err: class extends Error {
    constructor(e10 = "") {
      super(e10);
    }
  }, _tlv: { encode: (t4, n7) => {
    const { Err: i5 } = e9.DER;
    if (t4 < 0 || t4 > 256) throw new i5("tlv.encode: wrong tag");
    if (1 & n7.length) throw new i5("tlv.encode: unpadded data");
    const o4 = n7.length / 2, s3 = r2.numberToHexUnpadded(o4);
    if (s3.length / 2 & 128) throw new i5("tlv.encode: long form length too big");
    const a2 = o4 > 127 ? r2.numberToHexUnpadded(s3.length / 2 | 128) : "";
    return `${r2.numberToHexUnpadded(t4)}${a2}${s3}${n7}`;
  }, decode(t4, n7) {
    const { Err: r3 } = e9.DER;
    let i5 = 0;
    if (t4 < 0 || t4 > 256) throw new r3("tlv.encode: wrong tag");
    if (n7.length < 2 || n7[i5++] !== t4) throw new r3("tlv.decode: wrong tlv");
    const o4 = n7[i5++];
    let s3 = 0;
    if (!!(128 & o4)) {
      const e10 = 127 & o4;
      if (!e10) throw new r3("tlv.decode(long): indefinite length not supported");
      if (e10 > 4) throw new r3("tlv.decode(long): byte length is too big");
      const t5 = n7.subarray(i5, i5 + e10);
      if (t5.length !== e10) throw new r3("tlv.decode: length bytes not complete");
      if (0 === t5[0]) throw new r3("tlv.decode(long): zero leftmost byte");
      for (const e11 of t5) s3 = s3 << 8 | e11;
      if (i5 += e10, s3 < 128) throw new r3("tlv.decode(long): not minimal encoding");
    } else s3 = o4;
    const a2 = n7.subarray(i5, i5 + s3);
    if (a2.length !== s3) throw new r3("tlv.decode: wrong value length");
    return { v: a2, l: n7.subarray(i5 + s3) };
  } }, _int: { encode(t4) {
    const { Err: n7 } = e9.DER;
    if (t4 < c3) throw new n7("integer: negative integers are not allowed");
    let i5 = r2.numberToHexUnpadded(t4);
    if (8 & Number.parseInt(i5[0], 16) && (i5 = "00" + i5), 1 & i5.length) throw new n7("unexpected assertion");
    return i5;
  }, decode(t4) {
    const { Err: n7 } = e9.DER;
    if (128 & t4[0]) throw new n7("Invalid signature integer: negative");
    if (0 === t4[0] && !(128 & t4[1])) throw new n7("Invalid signature integer: unnecessary leading zero");
    return s2(t4);
  } }, toSig(t4) {
    const { Err: n7, _int: i5, _tlv: o4 } = e9.DER, s3 = "string" == typeof t4 ? a(t4) : t4;
    r2.abytes(s3);
    const { v: c4, l: l6 } = o4.decode(48, s3);
    if (l6.length) throw new n7("Invalid signature: left bytes after parsing");
    const { v: d4, l: u3 } = o4.decode(2, c4), { v: h4, l: f5 } = o4.decode(2, u3);
    if (f5.length) throw new n7("Invalid signature: left bytes after parsing");
    return { r: i5.decode(d4), s: i5.decode(h4) };
  }, hexFromSig(t4) {
    const { _tlv: n7, _int: r3 } = e9.DER, i5 = `${n7.encode(2, r3.encode(t4.r))}${n7.encode(2, r3.encode(t4.s))}`;
    return n7.encode(48, i5);
  } };
  const c3 = BigInt(0), l5 = BigInt(1), d3 = BigInt(2), u2 = BigInt(3), h3 = BigInt(4);
  function f4(e10) {
    const o4 = function(e11) {
      const n7 = (0, t3.validateBasic)(e11);
      r2.validateObject(n7, { a: "field", b: "field" }, { allowedPrivateKeyLengths: "array", wrapPrivateKey: "boolean", isTorsionFree: "function", clearCofactor: "function", allowInfinityPoint: "boolean", fromBytes: "function", toBytes: "function" });
      const { endo: i5, Fp: o5, a: s4 } = n7;
      if (i5) {
        if (!o5.eql(s4, o5.ZERO)) throw new Error("Endomorphism can only be defined for Koblitz curves that have a=0");
        if ("object" != typeof i5 || "bigint" != typeof i5.beta || "function" != typeof i5.splitScalar) throw new Error("Expected endomorphism with beta: bigint and splitScalar: function");
      }
      return Object.freeze({ ...n7 });
    }(e10), { Fp: s3 } = o4, a2 = n6.Field(o4.n, o4.nBitLength), d4 = o4.toBytes || ((e11, t4, n7) => {
      const i5 = t4.toAffine();
      return r2.concatBytes(Uint8Array.from([4]), s3.toBytes(i5.x), s3.toBytes(i5.y));
    }), h4 = o4.fromBytes || ((e11) => {
      const t4 = e11.subarray(1);
      return { x: s3.fromBytes(t4.subarray(0, s3.BYTES)), y: s3.fromBytes(t4.subarray(s3.BYTES, 2 * s3.BYTES)) };
    });
    function f5(e11) {
      const { a: t4, b: n7 } = o4, r3 = s3.sqr(e11), i5 = s3.mul(r3, e11);
      return s3.add(s3.add(i5, s3.mul(e11, t4)), n7);
    }
    if (!s3.eql(s3.sqr(o4.Gy), f5(o4.Gx))) throw new Error("bad generator point: equation left != right");
    function p5(e11) {
      const { allowedPrivateKeyLengths: t4, nByteLength: s4, wrapPrivateKey: a3, n: c4 } = o4;
      if (t4 && "bigint" != typeof e11) {
        if (r2.isBytes(e11) && (e11 = r2.bytesToHex(e11)), "string" != typeof e11 || !t4.includes(e11.length)) throw new Error("Invalid key");
        e11 = e11.padStart(2 * s4, "0");
      }
      let d5;
      try {
        d5 = "bigint" == typeof e11 ? e11 : r2.bytesToNumberBE((0, i4.ensureBytes)("private key", e11, s4));
      } catch (t5) {
        throw new Error(`private key must be ${s4} bytes, hex or bigint, not ${typeof e11}`);
      }
      return a3 && (d5 = n6.mod(d5, c4)), r2.aInRange("private key", d5, l5, c4), d5;
    }
    function g2(e11) {
      if (!(e11 instanceof v2)) throw new Error("ProjectivePoint expected");
    }
    const m4 = (0, i4.memoized)((e11, t4) => {
      const { px: n7, py: r3, pz: i5 } = e11;
      if (s3.eql(i5, s3.ONE)) return { x: n7, y: r3 };
      const o5 = e11.is0();
      null == t4 && (t4 = o5 ? s3.ONE : s3.inv(i5));
      const a3 = s3.mul(n7, t4), c4 = s3.mul(r3, t4), l6 = s3.mul(i5, t4);
      if (o5) return { x: s3.ZERO, y: s3.ZERO };
      if (!s3.eql(l6, s3.ONE)) throw new Error("invZ was invalid");
      return { x: a3, y: c4 };
    }), y2 = (0, i4.memoized)((e11) => {
      if (e11.is0()) {
        if (o4.allowInfinityPoint && !s3.is0(e11.py)) return;
        throw new Error("bad point: ZERO");
      }
      const { x: t4, y: n7 } = e11.toAffine();
      if (!s3.isValid(t4) || !s3.isValid(n7)) throw new Error("bad point: x or y not FE");
      const r3 = s3.sqr(n7), i5 = f5(t4);
      if (!s3.eql(r3, i5)) throw new Error("bad point: equation left != right");
      if (!e11.isTorsionFree()) throw new Error("bad point: not in prime-order subgroup");
      return true;
    });
    class v2 {
      constructor(e11, t4, n7) {
        if (this.px = e11, this.py = t4, this.pz = n7, null == e11 || !s3.isValid(e11)) throw new Error("x required");
        if (null == t4 || !s3.isValid(t4)) throw new Error("y required");
        if (null == n7 || !s3.isValid(n7)) throw new Error("z required");
        Object.freeze(this);
      }
      static fromAffine(e11) {
        const { x: t4, y: n7 } = e11 || {};
        if (!e11 || !s3.isValid(t4) || !s3.isValid(n7)) throw new Error("invalid affine point");
        if (e11 instanceof v2) throw new Error("projective point not allowed");
        const r3 = (e12) => s3.eql(e12, s3.ZERO);
        return r3(t4) && r3(n7) ? v2.ZERO : new v2(t4, n7, s3.ONE);
      }
      get x() {
        return this.toAffine().x;
      }
      get y() {
        return this.toAffine().y;
      }
      static normalizeZ(e11) {
        const t4 = s3.invertBatch(e11.map((e12) => e12.pz));
        return e11.map((e12, n7) => e12.toAffine(t4[n7])).map(v2.fromAffine);
      }
      static fromHex(e11) {
        const t4 = v2.fromAffine(h4((0, i4.ensureBytes)("pointHex", e11)));
        return t4.assertValidity(), t4;
      }
      static fromPrivateKey(e11) {
        return v2.BASE.multiply(p5(e11));
      }
      static msm(e11, n7) {
        return (0, t3.pippenger)(v2, a2, e11, n7);
      }
      _setWindowSize(e11) {
        w5.setWindowSize(this, e11);
      }
      assertValidity() {
        y2(this);
      }
      hasEvenY() {
        const { y: e11 } = this.toAffine();
        if (s3.isOdd) return !s3.isOdd(e11);
        throw new Error("Field doesn't support isOdd");
      }
      equals(e11) {
        g2(e11);
        const { px: t4, py: n7, pz: r3 } = this, { px: i5, py: o5, pz: a3 } = e11, c4 = s3.eql(s3.mul(t4, a3), s3.mul(i5, r3)), l6 = s3.eql(s3.mul(n7, a3), s3.mul(o5, r3));
        return c4 && l6;
      }
      negate() {
        return new v2(this.px, s3.neg(this.py), this.pz);
      }
      double() {
        const { a: e11, b: t4 } = o4, n7 = s3.mul(t4, u2), { px: r3, py: i5, pz: a3 } = this;
        let c4 = s3.ZERO, l6 = s3.ZERO, d5 = s3.ZERO, h5 = s3.mul(r3, r3), f6 = s3.mul(i5, i5), p6 = s3.mul(a3, a3), g3 = s3.mul(r3, i5);
        return g3 = s3.add(g3, g3), d5 = s3.mul(r3, a3), d5 = s3.add(d5, d5), c4 = s3.mul(e11, d5), l6 = s3.mul(n7, p6), l6 = s3.add(c4, l6), c4 = s3.sub(f6, l6), l6 = s3.add(f6, l6), l6 = s3.mul(c4, l6), c4 = s3.mul(g3, c4), d5 = s3.mul(n7, d5), p6 = s3.mul(e11, p6), g3 = s3.sub(h5, p6), g3 = s3.mul(e11, g3), g3 = s3.add(g3, d5), d5 = s3.add(h5, h5), h5 = s3.add(d5, h5), h5 = s3.add(h5, p6), h5 = s3.mul(h5, g3), l6 = s3.add(l6, h5), p6 = s3.mul(i5, a3), p6 = s3.add(p6, p6), h5 = s3.mul(p6, g3), c4 = s3.sub(c4, h5), d5 = s3.mul(p6, f6), d5 = s3.add(d5, d5), d5 = s3.add(d5, d5), new v2(c4, l6, d5);
      }
      add(e11) {
        g2(e11);
        const { px: t4, py: n7, pz: r3 } = this, { px: i5, py: a3, pz: c4 } = e11;
        let l6 = s3.ZERO, d5 = s3.ZERO, h5 = s3.ZERO;
        const f6 = o4.a, p6 = s3.mul(o4.b, u2);
        let m5 = s3.mul(t4, i5), y3 = s3.mul(n7, a3), b4 = s3.mul(r3, c4), w6 = s3.add(t4, n7), E4 = s3.add(i5, a3);
        w6 = s3.mul(w6, E4), E4 = s3.add(m5, y3), w6 = s3.sub(w6, E4), E4 = s3.add(t4, r3);
        let S5 = s3.add(i5, c4);
        return E4 = s3.mul(E4, S5), S5 = s3.add(m5, b4), E4 = s3.sub(E4, S5), S5 = s3.add(n7, r3), l6 = s3.add(a3, c4), S5 = s3.mul(S5, l6), l6 = s3.add(y3, b4), S5 = s3.sub(S5, l6), h5 = s3.mul(f6, E4), l6 = s3.mul(p6, b4), h5 = s3.add(l6, h5), l6 = s3.sub(y3, h5), h5 = s3.add(y3, h5), d5 = s3.mul(l6, h5), y3 = s3.add(m5, m5), y3 = s3.add(y3, m5), b4 = s3.mul(f6, b4), E4 = s3.mul(p6, E4), y3 = s3.add(y3, b4), b4 = s3.sub(m5, b4), b4 = s3.mul(f6, b4), E4 = s3.add(E4, b4), m5 = s3.mul(y3, E4), d5 = s3.add(d5, m5), m5 = s3.mul(S5, E4), l6 = s3.mul(w6, l6), l6 = s3.sub(l6, m5), m5 = s3.mul(w6, y3), h5 = s3.mul(S5, h5), h5 = s3.add(h5, m5), new v2(l6, d5, h5);
      }
      subtract(e11) {
        return this.add(e11.negate());
      }
      is0() {
        return this.equals(v2.ZERO);
      }
      wNAF(e11) {
        return w5.wNAFCached(this, e11, v2.normalizeZ);
      }
      multiplyUnsafe(e11) {
        r2.aInRange("scalar", e11, c3, o4.n);
        const t4 = v2.ZERO;
        if (e11 === c3) return t4;
        if (e11 === l5) return this;
        const { endo: n7 } = o4;
        if (!n7) return w5.unsafeLadder(this, e11);
        let { k1neg: i5, k1: a3, k2neg: d5, k2: u3 } = n7.splitScalar(e11), h5 = t4, f6 = t4, p6 = this;
        for (; a3 > c3 || u3 > c3; ) a3 & l5 && (h5 = h5.add(p6)), u3 & l5 && (f6 = f6.add(p6)), p6 = p6.double(), a3 >>= l5, u3 >>= l5;
        return i5 && (h5 = h5.negate()), d5 && (f6 = f6.negate()), f6 = new v2(s3.mul(f6.px, n7.beta), f6.py, f6.pz), h5.add(f6);
      }
      multiply(e11) {
        const { endo: t4, n: n7 } = o4;
        let i5, a3;
        if (r2.aInRange("scalar", e11, l5, n7), t4) {
          const { k1neg: n8, k1: r3, k2neg: o5, k2: c4 } = t4.splitScalar(e11);
          let { p: l6, f: d5 } = this.wNAF(r3), { p: u3, f: h5 } = this.wNAF(c4);
          l6 = w5.constTimeNegate(n8, l6), u3 = w5.constTimeNegate(o5, u3), u3 = new v2(s3.mul(u3.px, t4.beta), u3.py, u3.pz), i5 = l6.add(u3), a3 = d5.add(h5);
        } else {
          const { p: t5, f: n8 } = this.wNAF(e11);
          i5 = t5, a3 = n8;
        }
        return v2.normalizeZ([i5, a3])[0];
      }
      multiplyAndAddUnsafe(e11, t4, n7) {
        const r3 = v2.BASE, i5 = (e12, t5) => t5 !== c3 && t5 !== l5 && e12.equals(r3) ? e12.multiply(t5) : e12.multiplyUnsafe(t5), o5 = i5(this, t4).add(i5(e11, n7));
        return o5.is0() ? void 0 : o5;
      }
      toAffine(e11) {
        return m4(this, e11);
      }
      isTorsionFree() {
        const { h: e11, isTorsionFree: t4 } = o4;
        if (e11 === l5) return true;
        if (t4) return t4(v2, this);
        throw new Error("isTorsionFree() has not been declared for the elliptic curve");
      }
      clearCofactor() {
        const { h: e11, clearCofactor: t4 } = o4;
        return e11 === l5 ? this : t4 ? t4(v2, this) : this.multiplyUnsafe(o4.h);
      }
      toRawBytes(e11 = true) {
        return (0, i4.abool)("isCompressed", e11), this.assertValidity(), d4(v2, this, e11);
      }
      toHex(e11 = true) {
        return (0, i4.abool)("isCompressed", e11), r2.bytesToHex(this.toRawBytes(e11));
      }
    }
    v2.BASE = new v2(o4.Gx, o4.Gy, s3.ONE), v2.ZERO = new v2(s3.ZERO, s3.ONE, s3.ZERO);
    const b3 = o4.nBitLength, w5 = (0, t3.wNAF)(v2, o4.endo ? Math.ceil(b3 / 2) : b3);
    return { CURVE: o4, ProjectivePoint: v2, normPrivateKeyToScalar: p5, weierstrassEquation: f5, isWithinCurveOrder: function(e11) {
      return r2.inRange(e11, l5, o4.n);
    } };
  }
  function p4(e10, t4) {
    const n7 = e10.ORDER;
    let r3 = c3;
    for (let e11 = n7 - l5; e11 % d3 === c3; e11 /= d3) r3 += l5;
    const i5 = r3, o4 = d3 << i5 - l5 - l5, s3 = o4 * d3, a2 = (n7 - l5) / s3, f5 = (a2 - l5) / d3, p5 = s3 - l5, g2 = o4, m4 = e10.pow(t4, a2), y2 = e10.pow(t4, (a2 + l5) / d3);
    let v2 = (t5, n8) => {
      let r4 = m4, o5 = e10.pow(n8, p5), s4 = e10.sqr(o5);
      s4 = e10.mul(s4, n8);
      let a3 = e10.mul(t5, s4);
      a3 = e10.pow(a3, f5), a3 = e10.mul(a3, o5), o5 = e10.mul(a3, n8), s4 = e10.mul(a3, t5);
      let c4 = e10.mul(s4, o5);
      a3 = e10.pow(c4, g2);
      let u3 = e10.eql(a3, e10.ONE);
      o5 = e10.mul(s4, y2), a3 = e10.mul(c4, r4), s4 = e10.cmov(o5, s4, u3), c4 = e10.cmov(a3, c4, u3);
      for (let t6 = i5; t6 > l5; t6--) {
        let n9 = t6 - d3;
        n9 = d3 << n9 - l5;
        let i6 = e10.pow(c4, n9);
        const a4 = e10.eql(i6, e10.ONE);
        o5 = e10.mul(s4, r4), r4 = e10.mul(r4, r4), i6 = e10.mul(c4, r4), s4 = e10.cmov(o5, s4, a4), c4 = e10.cmov(i6, c4, a4);
      }
      return { isValid: u3, value: s4 };
    };
    if (e10.ORDER % h3 === u2) {
      const n8 = (e10.ORDER - u2) / h3, r4 = e10.sqrt(e10.neg(t4));
      v2 = (t5, i6) => {
        let o5 = e10.sqr(i6);
        const s4 = e10.mul(t5, i6);
        o5 = e10.mul(o5, s4);
        let a3 = e10.pow(o5, n8);
        a3 = e10.mul(a3, s4);
        const c4 = e10.mul(a3, r4), l6 = e10.mul(e10.sqr(a3), i6), d4 = e10.eql(l6, t5);
        return { isValid: d4, value: e10.cmov(c4, a3, d4) };
      };
    }
    return v2;
  }
}(cr), Object.defineProperty(sr, "__esModule", { value: true }), sr.getHash = hr, sr.createCurve = function(e9, t3) {
  const n6 = (t4) => (0, ur.weierstrass)({ ...e9, ...hr(t4) });
  return Object.freeze({ ...n6(t3), create: n6 });
};
var lr = ar;
var dr = ze;
var ur = cr;
function hr(e9) {
  return { hash: e9, hmac: (t3, ...n6) => (0, lr.hmac)(e9, t3, (0, dr.concatBytes)(...n6)), randomBytes: dr.randomBytes };
}
!function(e9) {
  Object.defineProperty(e9, "__esModule", { value: true }), e9.encodeToCurve = e9.hashToCurve = e9.schnorr = e9.secp256k1 = void 0;
  const t3 = Qn, n6 = ze, r2 = sr, i4 = Dn, o3 = Ot, s2 = Nt, a = cr, c3 = BigInt("0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffffc2f"), l5 = BigInt("0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141"), d3 = BigInt(1), u2 = BigInt(2), h3 = (e10, t4) => (e10 + t4 / u2) / t4;
  function f4(e10) {
    const t4 = c3, n7 = BigInt(3), r3 = BigInt(6), i5 = BigInt(11), s3 = BigInt(22), a2 = BigInt(23), l6 = BigInt(44), d4 = BigInt(88), h4 = e10 * e10 * e10 % t4, f5 = h4 * h4 * e10 % t4, g3 = (0, o3.pow2)(f5, n7, t4) * f5 % t4, m5 = (0, o3.pow2)(g3, n7, t4) * f5 % t4, y3 = (0, o3.pow2)(m5, u2, t4) * h4 % t4, v6 = (0, o3.pow2)(y3, i5, t4) * y3 % t4, b4 = (0, o3.pow2)(v6, s3, t4) * v6 % t4, w6 = (0, o3.pow2)(b4, l6, t4) * b4 % t4, E5 = (0, o3.pow2)(w6, d4, t4) * w6 % t4, S6 = (0, o3.pow2)(E5, l6, t4) * b4 % t4, _3 = (0, o3.pow2)(S6, n7, t4) * f5 % t4, C5 = (0, o3.pow2)(_3, a2, t4) * v6 % t4, k4 = (0, o3.pow2)(C5, r3, t4) * h4 % t4, A4 = (0, o3.pow2)(k4, u2, t4);
    if (!p4.eql(p4.sqr(A4), e10)) throw new Error("Cannot find square root");
    return A4;
  }
  const p4 = (0, o3.Field)(c3, void 0, void 0, { sqrt: f4 });
  e9.secp256k1 = (0, r2.createCurve)({ a: BigInt(0), b: BigInt(7), Fp: p4, n: l5, Gx: BigInt("55066263022277343669578718895168534326250603453777594175500187360389116729240"), Gy: BigInt("32670510020758816978083085130507043184471273380659243275938904335757337482424"), h: BigInt(1), lowS: true, endo: { beta: BigInt("0x7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee"), splitScalar: (e10) => {
    const t4 = l5, n7 = BigInt("0x3086d221a7d46bcde86c90e49284eb15"), r3 = -d3 * BigInt("0xe4437ed6010e88286f547fa90abfe4c3"), i5 = BigInt("0x114ca50f7a8e2f3f657c1108d9d44cfd8"), s3 = n7, a2 = BigInt("0x100000000000000000000000000000000"), c4 = h3(s3 * e10, t4), u3 = h3(-r3 * e10, t4);
    let f5 = (0, o3.mod)(e10 - c4 * n7 - u3 * i5, t4), p5 = (0, o3.mod)(-c4 * r3 - u3 * s3, t4);
    const g3 = f5 > a2, m5 = p5 > a2;
    if (g3 && (f5 = t4 - f5), m5 && (p5 = t4 - p5), f5 > a2 || p5 > a2) throw new Error("splitScalar: Endomorphism failed, k=" + e10);
    return { k1neg: g3, k1: f5, k2neg: m5, k2: p5 };
  } } }, t3.sha256);
  const g2 = BigInt(0), m4 = {};
  function y2(e10, ...n7) {
    let r3 = m4[e10];
    if (void 0 === r3) {
      const n8 = (0, t3.sha256)(Uint8Array.from(e10, (e11) => e11.charCodeAt(0)));
      r3 = (0, s2.concatBytes)(n8, n8), m4[e10] = r3;
    }
    return (0, t3.sha256)((0, s2.concatBytes)(r3, ...n7));
  }
  const v2 = (e10) => e10.toRawBytes(true).slice(1), b3 = (e10) => (0, s2.numberToBytesBE)(e10, 32), w5 = (e10) => (0, o3.mod)(e10, c3), E4 = (e10) => (0, o3.mod)(e10, l5), S5 = e9.secp256k1.ProjectivePoint, _2 = (e10, t4, n7) => S5.BASE.multiplyAndAddUnsafe(e10, t4, n7);
  function C4(t4) {
    let n7 = e9.secp256k1.utils.normPrivateKeyToScalar(t4), r3 = S5.fromPrivateKey(n7);
    return { scalar: r3.hasEvenY() ? n7 : E4(-n7), bytes: v2(r3) };
  }
  function k3(e10) {
    (0, s2.aInRange)("x", e10, d3, c3);
    const t4 = w5(e10 * e10);
    let n7 = f4(w5(t4 * e10 + BigInt(7)));
    n7 % u2 !== g2 && (n7 = w5(-n7));
    const r3 = new S5(e10, n7, d3);
    return r3.assertValidity(), r3;
  }
  const A3 = s2.bytesToNumberBE;
  function x3(...e10) {
    return E4(A3(y2("BIP0340/challenge", ...e10)));
  }
  function M4(e10) {
    return C4(e10).bytes;
  }
  function I2(e10, t4, r3 = (0, n6.randomBytes)(32)) {
    const i5 = (0, s2.ensureBytes)("message", e10), { bytes: o4, scalar: a2 } = C4(t4), c4 = (0, s2.ensureBytes)("auxRand", r3, 32), l6 = b3(a2 ^ A3(y2("BIP0340/aux", c4))), d4 = y2("BIP0340/nonce", l6, o4, i5), u3 = E4(A3(d4));
    if (u3 === g2) throw new Error("sign failed: k is zero");
    const { bytes: h4, scalar: f5 } = C4(u3), p5 = x3(h4, o4, i5), m5 = new Uint8Array(64);
    if (m5.set(h4, 0), m5.set(b3(E4(f5 + p5 * a2)), 32), !T3(m5, i5, o4)) throw new Error("sign: Invalid signature produced");
    return m5;
  }
  function T3(e10, t4, n7) {
    const r3 = (0, s2.ensureBytes)("signature", e10, 64), i5 = (0, s2.ensureBytes)("message", t4), o4 = (0, s2.ensureBytes)("publicKey", n7, 32);
    try {
      const e11 = k3(A3(o4)), t5 = A3(r3.subarray(0, 32));
      if (!(0, s2.inRange)(t5, d3, c3)) return false;
      const n8 = A3(r3.subarray(32, 64));
      if (!(0, s2.inRange)(n8, d3, l5)) return false;
      const a2 = x3(b3(t5), v2(e11), i5), u3 = _2(e11, n8, E4(-a2));
      return !(!u3 || !u3.hasEvenY() || u3.toAffine().x !== t5);
    } catch (e11) {
      return false;
    }
  }
  e9.schnorr = { getPublicKey: M4, sign: I2, verify: T3, utils: { randomPrivateKey: e9.secp256k1.utils.randomPrivateKey, lift_x: k3, pointToBytes: v2, numberToBytesBE: s2.numberToBytesBE, bytesToNumberBE: s2.bytesToNumberBE, taggedHash: y2, mod: o3.mod } };
  const R3 = (() => (0, i4.isogenyMap)(p4, [["0x8e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38daaaaa8c7", "0x7d3d4c80bc321d5b9f315cea7fd44c5d595d2fc0bf63b92dfff1044f17c6581", "0x534c328d23f234e6e2a413deca25caece4506144037c40314ecbd0b53d9dd262", "0x8e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38daaaaa88c"], ["0xd35771193d94918a9ca34ccbb7b640dd86cd409542f8487d9fe6b745781eb49b", "0xedadc6f64383dc1df7c4b2d51b54225406d36b641f5e41bbc52a56612a8c6d14", "0x0000000000000000000000000000000000000000000000000000000000000001"], ["0x4bda12f684bda12f684bda12f684bda12f684bda12f684bda12f684b8e38e23c", "0xc75e0c32d5cb7c0fa9d0a54b12a0a6d5647ab046d686da6fdffc90fc201d71a3", "0x29a6194691f91a73715209ef6512e576722830a201be2018a765e85a9ecee931", "0x2f684bda12f684bda12f684bda12f684bda12f684bda12f684bda12f38e38d84"], ["0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffff93b", "0x7a06534bb8bdb49fd5e9e6632722c2989467c1bfc8e8d978dfb425d2685c2573", "0x6484aa716545ca2cf3a70c3fa8fe337e0a3d21162f0d6299a7bf8192bfd2a76f", "0x0000000000000000000000000000000000000000000000000000000000000001"]].map((e10) => e10.map((e11) => BigInt(e11)))))(), P5 = (() => (0, a.mapToCurveSimpleSWU)(p4, { A: BigInt("0x3f8731abdd661adca08a5558f0f5d272e953d363cb6f0e5d405447c01a444533"), B: BigInt("1771"), Z: p4.create(BigInt("-11")) }))(), O4 = (() => (0, i4.createHasher)(e9.secp256k1.ProjectivePoint, (e10) => {
    const { x: t4, y: n7 } = P5(p4.create(e10[0]));
    return R3(t4, n7);
  }, { DST: "secp256k1_XMD:SHA-256_SSWU_RO_", encodeDST: "secp256k1_XMD:SHA-256_SSWU_NU_", p: p4.ORDER, m: 1, k: 128, expand: "xmd", hash: t3.sha256 }))();
  e9.hashToCurve = O4.hashToCurve, e9.encodeToCurve = O4.encodeToCurve;
}(Jn);
var fr = {};
!function(e9) {
  Object.defineProperty(e9, "__esModule", { value: true }), e9.decodeHex = e9.remove0x = void 0;
  var t3 = pe;
  e9.remove0x = function(e10) {
    return e10.startsWith("0x") || e10.startsWith("0X") ? e10.slice(2) : e10;
  };
  e9.decodeHex = function(n6) {
    return (0, t3.hexToBytes)((0, e9.remove0x)(n6));
  };
}(fr), function(e9) {
  Object.defineProperty(e9, "__esModule", { value: true }), e9.hexToPublicKey = e9.convertPublicKeyFormat = e9.getSharedPoint = e9.getPublicKey = e9.isValidPrivateKey = e9.getValidSecret = void 0;
  var t3 = Te, n6 = Pe2, r2 = Jn, i4 = Ce, o3 = ke, s2 = fr;
  e9.getValidSecret = function() {
    var n7;
    do {
      n7 = (0, t3.randomBytes)(o3.SECRET_KEY_LENGTH);
    } while (!(0, e9.isValidPrivateKey)(n7));
    return n7;
  };
  e9.isValidPrivateKey = function(e10) {
    return a((0, i4.ellipticCurve)(), function(t4) {
      return t4.utils.isValidPrivateKey(e10);
    }, function() {
      return true;
    }, function() {
      return true;
    });
  };
  e9.getPublicKey = function(e10) {
    return a((0, i4.ellipticCurve)(), function(t4) {
      return t4.getPublicKey(e10);
    }, function(t4) {
      return t4.getPublicKey(e10);
    }, function(t4) {
      return t4.getPublicKey(e10);
    });
  };
  e9.getSharedPoint = function(e10, t4, n7) {
    return a((0, i4.ellipticCurve)(), function(r3) {
      return r3.getSharedSecret(e10, t4, n7);
    }, function(n8) {
      return n8.getSharedSecret(e10, t4);
    }, function(n8) {
      return l5(n8, e10, t4);
    });
  };
  e9.convertPublicKeyFormat = function(e10, t4) {
    return a((0, i4.ellipticCurve)(), function(n7) {
      return n7.getSharedSecret(BigInt(1), e10, t4);
    }, function() {
      return e10;
    }, function() {
      return e10;
    });
  };
  function a(e10, t4, i5, o4) {
    if ("secp256k1" === e10) return t4(r2.secp256k1);
    if ("x25519" === e10) return i5(n6.x25519);
    if ("ed25519" === e10) return o4(n6.ed25519);
    throw new Error("Not implemented");
  }
  e9.hexToPublicKey = function(e10) {
    var t4 = (0, s2.decodeHex)(e10);
    return a((0, i4.ellipticCurve)(), function() {
      return c3(t4);
    }, function() {
      return t4;
    }, function() {
      return t4;
    });
  };
  var c3 = function(e10) {
    if (e10.length === o3.ETH_PUBLIC_KEY_SIZE) {
      var t4 = new Uint8Array(1 + e10.length);
      return t4.set([4]), t4.set(e10, 1), t4;
    }
    return e10;
  }, l5 = function(e10, t4, n7) {
    var r3 = e10.utils.getExtendedPublicKey(t4).scalar;
    return e10.ExtendedPoint.fromHex(n7).multiply(r3).toRawBytes();
  };
}(Ie);
var pr = {};
var gr = {};
Object.defineProperty(gr, "__esModule", { value: true }), gr.hkdf = void 0, gr.extract = br, gr.expand = Sr;
var mr = Le;
var yr = ze;
var vr = ar;
function br(e9, t3, n6) {
  return (0, mr.hash)(e9), void 0 === n6 && (n6 = new Uint8Array(e9.outputLen)), (0, vr.hmac)(e9, (0, yr.toBytes)(n6), (0, yr.toBytes)(t3));
}
var wr = new Uint8Array([0]);
var Er = new Uint8Array();
function Sr(e9, t3, n6, r2 = 32) {
  if ((0, mr.hash)(e9), (0, mr.number)(r2), r2 > 255 * e9.outputLen) throw new Error("Length should be <= 255*HashLen");
  const i4 = Math.ceil(r2 / e9.outputLen);
  void 0 === n6 && (n6 = Er);
  const o3 = new Uint8Array(i4 * e9.outputLen), s2 = vr.hmac.create(e9, t3), a = s2._cloneInto(), c3 = new Uint8Array(s2.outputLen);
  for (let t4 = 0; t4 < i4; t4++) wr[0] = t4 + 1, a.update(0 === t4 ? Er : c3).update(n6).update(wr).digestInto(c3), o3.set(c3, e9.outputLen * t4), s2._cloneInto(a);
  return s2.destroy(), a.destroy(), c3.fill(0), wr.fill(0), o3.slice(0, r2);
}
gr.hkdf = (e9, t3, n6, r2, i4) => Sr(e9, br(e9, t3, n6), r2, i4), function(e9) {
  Object.defineProperty(e9, "__esModule", { value: true }), e9.getSharedKey = e9.deriveKey = void 0;
  var t3 = pe, n6 = gr, r2 = Qn;
  e9.deriveKey = function(e10, t4, i4) {
    return (0, n6.hkdf)(r2.sha256, e10, t4, i4, 32);
  };
  e9.getSharedKey = function() {
    for (var n7 = [], r3 = 0; r3 < arguments.length; r3++) n7[r3] = arguments[r3];
    return (0, e9.deriveKey)(t3.concatBytes.apply(void 0, n7));
  };
}(pr);
var _r = {};
var Cr = {};
var kr = {};
var Ar = {};
Object.defineProperty(Ar, "__esModule", { value: true }), Ar.polyval = Ar.ghash = void 0, Ar._toGHASHKey = Or;
var xr = ge;
var Mr = pe;
var Ir = 16;
var Tr = new Uint8Array(16);
var Rr = (0, Mr.u32)(Tr);
var Pr = (e9) => (e9 >>> 0 & 255) << 24 | (e9 >>> 8 & 255) << 16 | (e9 >>> 16 & 255) << 8 | e9 >>> 24 & 255 | 0;
function Or(e9) {
  e9.reverse();
  const t3 = 1 & e9[15];
  let n6 = 0;
  for (let t4 = 0; t4 < e9.length; t4++) {
    const r2 = e9[t4];
    e9[t4] = r2 >>> 1 | n6, n6 = (1 & r2) << 7;
  }
  return e9[0] ^= 225 & -t3, e9;
}
var Nr = class {
  constructor(e9, t3) {
    this.blockLen = Ir, this.outputLen = Ir, this.s0 = 0, this.s1 = 0, this.s2 = 0, this.s3 = 0, this.finished = false, e9 = (0, Mr.toBytes)(e9), (0, xr.bytes)(e9, 16);
    const n6 = (0, Mr.createView)(e9);
    let r2 = n6.getUint32(0, false), i4 = n6.getUint32(4, false), o3 = n6.getUint32(8, false), s2 = n6.getUint32(12, false);
    const a = [];
    for (let e10 = 0; e10 < 128; e10++) a.push({ s0: Pr(r2), s1: Pr(i4), s2: Pr(o3), s3: Pr(s2) }), { s0: r2, s1: i4, s2: o3, s3: s2 } = { s3: (d3 = o3) << 31 | (u2 = s2) >>> 1, s2: (l5 = i4) << 31 | d3 >>> 1, s1: (c3 = r2) << 31 | l5 >>> 1, s0: c3 >>> 1 ^ 225 << 24 & -(1 & u2) };
    var c3, l5, d3, u2;
    const h3 = ((e10) => e10 > 65536 ? 8 : e10 > 1024 ? 4 : 2)(t3 || 1024);
    if (![1, 2, 4, 8].includes(h3)) throw new Error(`ghash: wrong window size=${h3}, should be 2, 4 or 8`);
    this.W = h3;
    const f4 = 128 / h3, p4 = this.windowSize = 2 ** h3, g2 = [];
    for (let e10 = 0; e10 < f4; e10++) for (let t4 = 0; t4 < p4; t4++) {
      let n7 = 0, r3 = 0, i5 = 0, o4 = 0;
      for (let s3 = 0; s3 < h3; s3++) {
        if (!(t4 >>> h3 - s3 - 1 & 1)) continue;
        const { s0: c4, s1: l6, s2: d4, s3: u3 } = a[h3 * e10 + s3];
        n7 ^= c4, r3 ^= l6, i5 ^= d4, o4 ^= u3;
      }
      g2.push({ s0: n7, s1: r3, s2: i5, s3: o4 });
    }
    this.t = g2;
  }
  _updateBlock(e9, t3, n6, r2) {
    e9 ^= this.s0, t3 ^= this.s1, n6 ^= this.s2, r2 ^= this.s3;
    const { W: i4, t: o3, windowSize: s2 } = this;
    let a = 0, c3 = 0, l5 = 0, d3 = 0;
    const u2 = (1 << i4) - 1;
    let h3 = 0;
    for (const f4 of [e9, t3, n6, r2]) for (let e10 = 0; e10 < 4; e10++) {
      const t4 = f4 >>> 8 * e10 & 255;
      for (let e11 = 8 / i4 - 1; e11 >= 0; e11--) {
        const n7 = t4 >>> i4 * e11 & u2, { s0: r3, s1: f5, s2: p4, s3: g2 } = o3[h3 * s2 + n7];
        a ^= r3, c3 ^= f5, l5 ^= p4, d3 ^= g2, h3 += 1;
      }
    }
    this.s0 = a, this.s1 = c3, this.s2 = l5, this.s3 = d3;
  }
  update(e9) {
    e9 = (0, Mr.toBytes)(e9), (0, xr.exists)(this);
    const t3 = (0, Mr.u32)(e9), n6 = Math.floor(e9.length / Ir), r2 = e9.length % Ir;
    for (let e10 = 0; e10 < n6; e10++) this._updateBlock(t3[4 * e10 + 0], t3[4 * e10 + 1], t3[4 * e10 + 2], t3[4 * e10 + 3]);
    return r2 && (Tr.set(e9.subarray(n6 * Ir)), this._updateBlock(Rr[0], Rr[1], Rr[2], Rr[3]), (0, Mr.clean)(Rr)), this;
  }
  destroy() {
    const { t: e9 } = this;
    for (const t3 of e9) t3.s0 = 0, t3.s1 = 0, t3.s2 = 0, t3.s3 = 0;
  }
  digestInto(e9) {
    (0, xr.exists)(this), (0, xr.output)(e9, this), this.finished = true;
    const { s0: t3, s1: n6, s2: r2, s3: i4 } = this, o3 = (0, Mr.u32)(e9);
    return o3[0] = t3, o3[1] = n6, o3[2] = r2, o3[3] = i4, e9;
  }
  digest() {
    const e9 = new Uint8Array(Ir);
    return this.digestInto(e9), this.destroy(), e9;
  }
};
var Lr = class extends Nr {
  constructor(e9, t3) {
    e9 = (0, Mr.toBytes)(e9);
    const n6 = Or((0, Mr.copyBytes)(e9));
    super(n6, t3), (0, Mr.clean)(n6);
  }
  update(e9) {
    e9 = (0, Mr.toBytes)(e9), (0, xr.exists)(this);
    const t3 = (0, Mr.u32)(e9), n6 = e9.length % Ir, r2 = Math.floor(e9.length / Ir);
    for (let e10 = 0; e10 < r2; e10++) this._updateBlock(Pr(t3[4 * e10 + 3]), Pr(t3[4 * e10 + 2]), Pr(t3[4 * e10 + 1]), Pr(t3[4 * e10 + 0]));
    return n6 && (Tr.set(e9.subarray(r2 * Ir)), this._updateBlock(Pr(Rr[3]), Pr(Rr[2]), Pr(Rr[1]), Pr(Rr[0])), (0, Mr.clean)(Rr)), this;
  }
  digestInto(e9) {
    (0, xr.exists)(this), (0, xr.output)(e9, this), this.finished = true;
    const { s0: t3, s1: n6, s2: r2, s3: i4 } = this, o3 = (0, Mr.u32)(e9);
    return o3[0] = t3, o3[1] = n6, o3[2] = r2, o3[3] = i4, e9.reverse();
  }
};
function Dr(e9) {
  const t3 = (t4, n7) => e9(n7, t4.length).update((0, Mr.toBytes)(t4)).digest(), n6 = e9(new Uint8Array(16), 0);
  return t3.outputLen = n6.outputLen, t3.blockLen = n6.blockLen, t3.create = (t4, n7) => e9(t4, n7), t3;
}
Ar.ghash = Dr((e9, t3) => new Nr(e9, t3)), Ar.polyval = Dr((e9, t3) => new Lr(e9, t3)), Object.defineProperty(kr, "__esModule", { value: true }), kr.unsafe = kr.aeskwp = kr.aeskw = kr.siv = kr.gcm = kr.cfb = kr.cbc = kr.ecb = kr.ctr = void 0, kr.expandKeyLE = ei, kr.expandKeyDecLE = ti;
var $r = ge;
var Br = Ar;
var Kr = pe;
var jr = 16;
var Ur = new Uint8Array(jr);
var Hr = 283;
function Fr(e9) {
  return e9 << 1 ^ Hr & -(e9 >> 7);
}
function zr(e9, t3) {
  let n6 = 0;
  for (; t3 > 0; t3 >>= 1) n6 ^= e9 & -(1 & t3), e9 = Fr(e9);
  return n6;
}
var qr = (() => {
  const e9 = new Uint8Array(256);
  for (let t4 = 0, n6 = 1; t4 < 256; t4++, n6 ^= Fr(n6)) e9[t4] = n6;
  const t3 = new Uint8Array(256);
  t3[0] = 99;
  for (let n6 = 0; n6 < 255; n6++) {
    let r2 = e9[255 - n6];
    r2 |= r2 << 8, t3[e9[n6]] = 255 & (r2 ^ r2 >> 4 ^ r2 >> 5 ^ r2 >> 6 ^ r2 >> 7 ^ 99);
  }
  return (0, Kr.clean)(e9), t3;
})();
var Wr = qr.map((e9, t3) => qr.indexOf(t3));
var Vr = (e9) => e9 << 24 | e9 >>> 8;
var Gr = (e9) => e9 << 8 | e9 >>> 24;
var Yr = (e9) => e9 << 24 & 4278190080 | e9 << 8 & 16711680 | e9 >>> 8 & 65280 | e9 >>> 24 & 255;
function Zr(e9, t3) {
  if (256 !== e9.length) throw new Error("Wrong sbox length");
  const n6 = new Uint32Array(256).map((n7, r3) => t3(e9[r3])), r2 = n6.map(Gr), i4 = r2.map(Gr), o3 = i4.map(Gr), s2 = new Uint32Array(65536), a = new Uint32Array(65536), c3 = new Uint16Array(65536);
  for (let t4 = 0; t4 < 256; t4++) for (let l5 = 0; l5 < 256; l5++) {
    const d3 = 256 * t4 + l5;
    s2[d3] = n6[t4] ^ r2[l5], a[d3] = i4[t4] ^ o3[l5], c3[d3] = e9[t4] << 8 | e9[l5];
  }
  return { sbox: e9, sbox2: c3, T0: n6, T1: r2, T2: i4, T3: o3, T01: s2, T23: a };
}
var Jr = Zr(qr, (e9) => zr(e9, 3) << 24 | e9 << 16 | e9 << 8 | zr(e9, 2));
var Qr = Zr(Wr, (e9) => zr(e9, 11) << 24 | zr(e9, 13) << 16 | zr(e9, 9) << 8 | zr(e9, 14));
var Xr = (() => {
  const e9 = new Uint8Array(16);
  for (let t3 = 0, n6 = 1; t3 < 16; t3++, n6 = Fr(n6)) e9[t3] = n6;
  return e9;
})();
function ei(e9) {
  (0, $r.bytes)(e9);
  const t3 = e9.length;
  if (![16, 24, 32].includes(t3)) throw new Error(`aes: wrong key size: should be 16, 24 or 32, got: ${t3}`);
  const { sbox2: n6 } = Jr, r2 = [];
  (0, Kr.isAligned32)(e9) || r2.push(e9 = (0, Kr.copyBytes)(e9));
  const i4 = (0, Kr.u32)(e9), o3 = i4.length, s2 = (e10) => ri(n6, e10, e10, e10, e10), a = new Uint32Array(t3 + 28);
  a.set(i4);
  for (let e10 = o3; e10 < a.length; e10++) {
    let t4 = a[e10 - 1];
    e10 % o3 == 0 ? t4 = s2(Vr(t4)) ^ Xr[e10 / o3 - 1] : o3 > 6 && e10 % o3 == 4 && (t4 = s2(t4)), a[e10] = a[e10 - o3] ^ t4;
  }
  return (0, Kr.clean)(...r2), a;
}
function ti(e9) {
  const t3 = ei(e9), n6 = t3.slice(), r2 = t3.length, { sbox2: i4 } = Jr, { T0: o3, T1: s2, T2: a, T3: c3 } = Qr;
  for (let e10 = 0; e10 < r2; e10 += 4) for (let i5 = 0; i5 < 4; i5++) n6[e10 + i5] = t3[r2 - e10 - 4 + i5];
  (0, Kr.clean)(t3);
  for (let e10 = 4; e10 < r2 - 4; e10++) {
    const t4 = n6[e10], r3 = ri(i4, t4, t4, t4, t4);
    n6[e10] = o3[255 & r3] ^ s2[r3 >>> 8 & 255] ^ a[r3 >>> 16 & 255] ^ c3[r3 >>> 24];
  }
  return n6;
}
function ni(e9, t3, n6, r2, i4, o3) {
  return e9[n6 << 8 & 65280 | r2 >>> 8 & 255] ^ t3[i4 >>> 8 & 65280 | o3 >>> 24 & 255];
}
function ri(e9, t3, n6, r2, i4) {
  return e9[255 & t3 | 65280 & n6] | e9[r2 >>> 16 & 255 | i4 >>> 16 & 65280] << 16;
}
function ii(e9, t3, n6, r2, i4) {
  const { sbox2: o3, T01: s2, T23: a } = Jr;
  let c3 = 0;
  t3 ^= e9[c3++], n6 ^= e9[c3++], r2 ^= e9[c3++], i4 ^= e9[c3++];
  const l5 = e9.length / 4 - 2;
  for (let o4 = 0; o4 < l5; o4++) {
    const o5 = e9[c3++] ^ ni(s2, a, t3, n6, r2, i4), l6 = e9[c3++] ^ ni(s2, a, n6, r2, i4, t3), d3 = e9[c3++] ^ ni(s2, a, r2, i4, t3, n6), u2 = e9[c3++] ^ ni(s2, a, i4, t3, n6, r2);
    t3 = o5, n6 = l6, r2 = d3, i4 = u2;
  }
  return { s0: e9[c3++] ^ ri(o3, t3, n6, r2, i4), s1: e9[c3++] ^ ri(o3, n6, r2, i4, t3), s2: e9[c3++] ^ ri(o3, r2, i4, t3, n6), s3: e9[c3++] ^ ri(o3, i4, t3, n6, r2) };
}
function oi(e9, t3, n6, r2, i4) {
  const { sbox2: o3, T01: s2, T23: a } = Qr;
  let c3 = 0;
  t3 ^= e9[c3++], n6 ^= e9[c3++], r2 ^= e9[c3++], i4 ^= e9[c3++];
  const l5 = e9.length / 4 - 2;
  for (let o4 = 0; o4 < l5; o4++) {
    const o5 = e9[c3++] ^ ni(s2, a, t3, i4, r2, n6), l6 = e9[c3++] ^ ni(s2, a, n6, t3, i4, r2), d3 = e9[c3++] ^ ni(s2, a, r2, n6, t3, i4), u2 = e9[c3++] ^ ni(s2, a, i4, r2, n6, t3);
    t3 = o5, n6 = l6, r2 = d3, i4 = u2;
  }
  return { s0: e9[c3++] ^ ri(o3, t3, i4, r2, n6), s1: e9[c3++] ^ ri(o3, n6, t3, i4, r2), s2: e9[c3++] ^ ri(o3, r2, n6, t3, i4), s3: e9[c3++] ^ ri(o3, i4, r2, n6, t3) };
}
function si(e9, t3) {
  if (void 0 === t3) return new Uint8Array(e9);
  if ((0, $r.bytes)(t3), t3.length < e9) throw new Error(`aes: wrong destination length, expected at least ${e9}, got: ${t3.length}`);
  if (!(0, Kr.isAligned32)(t3)) throw new Error("unaligned dst");
  return t3;
}
function ai(e9, t3, n6, r2) {
  (0, $r.bytes)(t3, jr), (0, $r.bytes)(n6);
  const i4 = n6.length;
  r2 = si(i4, r2);
  const o3 = t3, s2 = (0, Kr.u32)(o3);
  let { s0: a, s1: c3, s2: l5, s3: d3 } = ii(e9, s2[0], s2[1], s2[2], s2[3]);
  const u2 = (0, Kr.u32)(n6), h3 = (0, Kr.u32)(r2);
  for (let t4 = 0; t4 + 4 <= u2.length; t4 += 4) {
    h3[t4 + 0] = u2[t4 + 0] ^ a, h3[t4 + 1] = u2[t4 + 1] ^ c3, h3[t4 + 2] = u2[t4 + 2] ^ l5, h3[t4 + 3] = u2[t4 + 3] ^ d3;
    let n7 = 1;
    for (let e10 = o3.length - 1; e10 >= 0; e10--) n7 = n7 + (255 & o3[e10]) | 0, o3[e10] = 255 & n7, n7 >>>= 8;
    ({ s0: a, s1: c3, s2: l5, s3: d3 } = ii(e9, s2[0], s2[1], s2[2], s2[3]));
  }
  const f4 = jr * Math.floor(u2.length / 4);
  if (f4 < i4) {
    const e10 = new Uint32Array([a, c3, l5, d3]), t4 = (0, Kr.u8)(e10);
    for (let e11 = f4, o4 = 0; e11 < i4; e11++, o4++) r2[e11] = n6[e11] ^ t4[o4];
    (0, Kr.clean)(e10);
  }
  return r2;
}
function ci(e9, t3, n6, r2, i4) {
  (0, $r.bytes)(n6, jr), (0, $r.bytes)(r2), i4 = si(r2.length, i4);
  const o3 = n6, s2 = (0, Kr.u32)(o3), a = (0, Kr.createView)(o3), c3 = (0, Kr.u32)(r2), l5 = (0, Kr.u32)(i4), d3 = t3 ? 0 : 12, u2 = r2.length;
  let h3 = a.getUint32(d3, t3), { s0: f4, s1: p4, s2: g2, s3: m4 } = ii(e9, s2[0], s2[1], s2[2], s2[3]);
  for (let n7 = 0; n7 + 4 <= c3.length; n7 += 4) l5[n7 + 0] = c3[n7 + 0] ^ f4, l5[n7 + 1] = c3[n7 + 1] ^ p4, l5[n7 + 2] = c3[n7 + 2] ^ g2, l5[n7 + 3] = c3[n7 + 3] ^ m4, h3 = h3 + 1 >>> 0, a.setUint32(d3, h3, t3), { s0: f4, s1: p4, s2: g2, s3: m4 } = ii(e9, s2[0], s2[1], s2[2], s2[3]);
  const y2 = jr * Math.floor(c3.length / 4);
  if (y2 < u2) {
    const e10 = new Uint32Array([f4, p4, g2, m4]), t4 = (0, Kr.u8)(e10);
    for (let e11 = y2, n7 = 0; e11 < u2; e11++, n7++) i4[e11] = r2[e11] ^ t4[n7];
    (0, Kr.clean)(e10);
  }
  return i4;
}
function li(e9) {
  if ((0, $r.bytes)(e9), e9.length % jr != 0) throw new Error("aes/(cbc-ecb).decrypt ciphertext should consist of blocks with size 16");
}
function di(e9, t3, n6) {
  (0, $r.bytes)(e9);
  let r2 = e9.length;
  const i4 = r2 % jr;
  if (!t3 && 0 !== i4) throw new Error("aec/(cbc-ecb): unpadded plaintext with disabled padding");
  (0, Kr.isAligned32)(e9) || (e9 = (0, Kr.copyBytes)(e9));
  const o3 = (0, Kr.u32)(e9);
  if (t3) {
    let e10 = jr - i4;
    e10 || (e10 = jr), r2 += e10;
  }
  const s2 = si(r2, n6);
  return { b: o3, o: (0, Kr.u32)(s2), out: s2 };
}
function ui(e9, t3) {
  if (!t3) return e9;
  const n6 = e9.length;
  if (!n6) throw new Error("aes/pcks5: empty ciphertext not allowed");
  const r2 = e9[n6 - 1];
  if (r2 <= 0 || r2 > 16) throw new Error("aes/pcks5: wrong padding");
  const i4 = e9.subarray(0, -r2);
  for (let t4 = 0; t4 < r2; t4++) if (e9[n6 - t4 - 1] !== r2) throw new Error("aes/pcks5: wrong padding");
  return i4;
}
function hi(e9) {
  const t3 = new Uint8Array(16), n6 = (0, Kr.u32)(t3);
  t3.set(e9);
  const r2 = jr - e9.length;
  for (let e10 = jr - r2; e10 < jr; e10++) t3[e10] = r2;
  return n6;
}
function fi(e9, t3, n6, r2, i4) {
  const o3 = null == i4 ? 0 : i4.length, s2 = e9.create(n6, r2.length + o3);
  i4 && s2.update(i4), s2.update(r2);
  const a = new Uint8Array(16), c3 = (0, Kr.createView)(a);
  i4 && (0, Kr.setBigUint64)(c3, 0, BigInt(8 * o3), t3), (0, Kr.setBigUint64)(c3, 8, BigInt(8 * r2.length), t3), s2.update(a);
  const l5 = s2.digest();
  return (0, Kr.clean)(a), l5;
}
kr.ctr = (0, Kr.wrapCipher)({ blockSize: 16, nonceLength: 16 }, function(e9, t3) {
  function n6(n7, r2) {
    if ((0, $r.bytes)(n7), void 0 !== r2 && ((0, $r.bytes)(r2), !(0, Kr.isAligned32)(r2))) throw new Error("unaligned destination");
    const i4 = ei(e9), o3 = (0, Kr.copyBytes)(t3), s2 = [i4, o3];
    (0, Kr.isAligned32)(n7) || s2.push(n7 = (0, Kr.copyBytes)(n7));
    const a = ai(i4, o3, n7, r2);
    return (0, Kr.clean)(...s2), a;
  }
  return (0, $r.bytes)(e9), (0, $r.bytes)(t3, jr), { encrypt: (e10, t4) => n6(e10, t4), decrypt: (e10, t4) => n6(e10, t4) };
}), kr.ecb = (0, Kr.wrapCipher)({ blockSize: 16 }, function(e9, t3 = {}) {
  (0, $r.bytes)(e9);
  const n6 = !t3.disablePadding;
  return { encrypt(t4, r2) {
    const { b: i4, o: o3, out: s2 } = di(t4, n6, r2), a = ei(e9);
    let c3 = 0;
    for (; c3 + 4 <= i4.length; ) {
      const { s0: e10, s1: t5, s2: n7, s3: r3 } = ii(a, i4[c3 + 0], i4[c3 + 1], i4[c3 + 2], i4[c3 + 3]);
      o3[c3++] = e10, o3[c3++] = t5, o3[c3++] = n7, o3[c3++] = r3;
    }
    if (n6) {
      const e10 = hi(t4.subarray(4 * c3)), { s0: n7, s1: r3, s2: i5, s3 } = ii(a, e10[0], e10[1], e10[2], e10[3]);
      o3[c3++] = n7, o3[c3++] = r3, o3[c3++] = i5, o3[c3++] = s3;
    }
    return (0, Kr.clean)(a), s2;
  }, decrypt(t4, r2) {
    li(t4);
    const i4 = ti(e9), o3 = si(t4.length, r2), s2 = [i4];
    (0, Kr.isAligned32)(t4) || s2.push(t4 = (0, Kr.copyBytes)(t4));
    const a = (0, Kr.u32)(t4), c3 = (0, Kr.u32)(o3);
    for (let e10 = 0; e10 + 4 <= a.length; ) {
      const { s0: t5, s1: n7, s2: r3, s3: o4 } = oi(i4, a[e10 + 0], a[e10 + 1], a[e10 + 2], a[e10 + 3]);
      c3[e10++] = t5, c3[e10++] = n7, c3[e10++] = r3, c3[e10++] = o4;
    }
    return (0, Kr.clean)(...s2), ui(o3, n6);
  } };
}), kr.cbc = (0, Kr.wrapCipher)({ blockSize: 16, nonceLength: 16 }, function(e9, t3, n6 = {}) {
  (0, $r.bytes)(e9), (0, $r.bytes)(t3, 16);
  const r2 = !n6.disablePadding;
  return { encrypt(n7, i4) {
    const o3 = ei(e9), { b: s2, o: a, out: c3 } = di(n7, r2, i4);
    let l5 = t3;
    const d3 = [o3];
    (0, Kr.isAligned32)(l5) || d3.push(l5 = (0, Kr.copyBytes)(l5));
    const u2 = (0, Kr.u32)(l5);
    let h3 = u2[0], f4 = u2[1], p4 = u2[2], g2 = u2[3], m4 = 0;
    for (; m4 + 4 <= s2.length; ) h3 ^= s2[m4 + 0], f4 ^= s2[m4 + 1], p4 ^= s2[m4 + 2], g2 ^= s2[m4 + 3], { s0: h3, s1: f4, s2: p4, s3: g2 } = ii(o3, h3, f4, p4, g2), a[m4++] = h3, a[m4++] = f4, a[m4++] = p4, a[m4++] = g2;
    if (r2) {
      const e10 = hi(n7.subarray(4 * m4));
      h3 ^= e10[0], f4 ^= e10[1], p4 ^= e10[2], g2 ^= e10[3], { s0: h3, s1: f4, s2: p4, s3: g2 } = ii(o3, h3, f4, p4, g2), a[m4++] = h3, a[m4++] = f4, a[m4++] = p4, a[m4++] = g2;
    }
    return (0, Kr.clean)(...d3), c3;
  }, decrypt(n7, i4) {
    li(n7);
    const o3 = ti(e9);
    let s2 = t3;
    const a = [o3];
    (0, Kr.isAligned32)(s2) || a.push(s2 = (0, Kr.copyBytes)(s2));
    const c3 = (0, Kr.u32)(s2), l5 = si(n7.length, i4);
    (0, Kr.isAligned32)(n7) || a.push(n7 = (0, Kr.copyBytes)(n7));
    const d3 = (0, Kr.u32)(n7), u2 = (0, Kr.u32)(l5);
    let h3 = c3[0], f4 = c3[1], p4 = c3[2], g2 = c3[3];
    for (let e10 = 0; e10 + 4 <= d3.length; ) {
      const t4 = h3, n8 = f4, r3 = p4, i5 = g2;
      h3 = d3[e10 + 0], f4 = d3[e10 + 1], p4 = d3[e10 + 2], g2 = d3[e10 + 3];
      const { s0: s3, s1: a2, s2: c4, s3: l6 } = oi(o3, h3, f4, p4, g2);
      u2[e10++] = s3 ^ t4, u2[e10++] = a2 ^ n8, u2[e10++] = c4 ^ r3, u2[e10++] = l6 ^ i5;
    }
    return (0, Kr.clean)(...a), ui(l5, r2);
  } };
}), kr.cfb = (0, Kr.wrapCipher)({ blockSize: 16, nonceLength: 16 }, function(e9, t3) {
  function n6(n7, r2, i4) {
    (0, $r.bytes)(n7);
    const o3 = n7.length;
    i4 = si(o3, i4);
    const s2 = ei(e9);
    let a = t3;
    const c3 = [s2];
    (0, Kr.isAligned32)(a) || c3.push(a = (0, Kr.copyBytes)(a)), (0, Kr.isAligned32)(n7) || c3.push(n7 = (0, Kr.copyBytes)(n7));
    const l5 = (0, Kr.u32)(n7), d3 = (0, Kr.u32)(i4), u2 = r2 ? d3 : l5, h3 = (0, Kr.u32)(a);
    let f4 = h3[0], p4 = h3[1], g2 = h3[2], m4 = h3[3];
    for (let e10 = 0; e10 + 4 <= l5.length; ) {
      const { s0: t4, s1: n8, s2: r3, s3: i5 } = ii(s2, f4, p4, g2, m4);
      d3[e10 + 0] = l5[e10 + 0] ^ t4, d3[e10 + 1] = l5[e10 + 1] ^ n8, d3[e10 + 2] = l5[e10 + 2] ^ r3, d3[e10 + 3] = l5[e10 + 3] ^ i5, f4 = u2[e10++], p4 = u2[e10++], g2 = u2[e10++], m4 = u2[e10++];
    }
    const y2 = jr * Math.floor(l5.length / 4);
    if (y2 < o3) {
      ({ s0: f4, s1: p4, s2: g2, s3: m4 } = ii(s2, f4, p4, g2, m4));
      const e10 = (0, Kr.u8)(new Uint32Array([f4, p4, g2, m4]));
      for (let t4 = y2, r3 = 0; t4 < o3; t4++, r3++) i4[t4] = n7[t4] ^ e10[r3];
      (0, Kr.clean)(e10);
    }
    return (0, Kr.clean)(...c3), i4;
  }
  return (0, $r.bytes)(e9), (0, $r.bytes)(t3, 16), { encrypt: (e10, t4) => n6(e10, true, t4), decrypt: (e10, t4) => n6(e10, false, t4) };
}), kr.gcm = (0, Kr.wrapCipher)({ blockSize: 16, nonceLength: 12, tagLength: 16 }, function(e9, t3, n6) {
  if ((0, $r.bytes)(e9), (0, $r.bytes)(t3), void 0 !== n6 && (0, $r.bytes)(n6), t3.length < 8) throw new Error("aes/gcm: invalid nonce length");
  const r2 = 16;
  function i4(e10, t4, r3) {
    const i5 = fi(Br.ghash, false, e10, r3, n6);
    for (let e11 = 0; e11 < t4.length; e11++) i5[e11] ^= t4[e11];
    return i5;
  }
  function o3() {
    const n7 = ei(e9), r3 = Ur.slice(), i5 = Ur.slice();
    if (ci(n7, false, i5, i5, r3), 12 === t3.length) i5.set(t3);
    else {
      const e10 = Ur.slice(), n8 = (0, Kr.createView)(e10);
      (0, Kr.setBigUint64)(n8, 8, BigInt(8 * t3.length), false);
      const o4 = Br.ghash.create(r3).update(t3).update(e10);
      o4.digestInto(i5), o4.destroy();
    }
    return { xk: n7, authKey: r3, counter: i5, tagMask: ci(n7, false, i5, Ur) };
  }
  return { encrypt(e10) {
    (0, $r.bytes)(e10);
    const { xk: t4, authKey: n7, counter: s2, tagMask: a } = o3(), c3 = new Uint8Array(e10.length + r2), l5 = [t4, n7, s2, a];
    (0, Kr.isAligned32)(e10) || l5.push(e10 = (0, Kr.copyBytes)(e10)), ci(t4, false, s2, e10, c3);
    const d3 = i4(n7, a, c3.subarray(0, c3.length - r2));
    return l5.push(d3), c3.set(d3, e10.length), (0, Kr.clean)(...l5), c3;
  }, decrypt(e10) {
    if ((0, $r.bytes)(e10), e10.length < r2) throw new Error("aes/gcm: ciphertext less than tagLen (16)");
    const { xk: t4, authKey: n7, counter: s2, tagMask: a } = o3(), c3 = [t4, n7, a, s2];
    (0, Kr.isAligned32)(e10) || c3.push(e10 = (0, Kr.copyBytes)(e10));
    const l5 = e10.subarray(0, -16), d3 = e10.subarray(-16), u2 = i4(n7, a, l5);
    if (c3.push(u2), !(0, Kr.equalBytes)(u2, d3)) throw new Error("aes/gcm: invalid ghash tag");
    const h3 = ci(t4, false, s2, l5);
    return (0, Kr.clean)(...c3), h3;
  } };
});
var pi = (e9, t3, n6) => (r2) => {
  if (!Number.isSafeInteger(r2) || t3 > r2 || r2 > n6) throw new Error(`${e9}: invalid value=${r2}, must be [${t3}..${n6}]`);
};
function gi(e9) {
  return null != e9 && "object" == typeof e9 && (e9 instanceof Uint32Array || "Uint32Array" === e9.constructor.name);
}
function mi(e9, t3) {
  if ((0, $r.bytes)(t3, 16), !gi(e9)) throw new Error("_encryptBlock accepts result of expandKeyLE");
  const n6 = (0, Kr.u32)(t3);
  let { s0: r2, s1: i4, s2: o3, s3: s2 } = ii(e9, n6[0], n6[1], n6[2], n6[3]);
  return n6[0] = r2, n6[1] = i4, n6[2] = o3, n6[3] = s2, t3;
}
function yi(e9, t3) {
  if ((0, $r.bytes)(t3, 16), !gi(e9)) throw new Error("_decryptBlock accepts result of expandKeyLE");
  const n6 = (0, Kr.u32)(t3);
  let { s0: r2, s1: i4, s2: o3, s3: s2 } = oi(e9, n6[0], n6[1], n6[2], n6[3]);
  return n6[0] = r2, n6[1] = i4, n6[2] = o3, n6[3] = s2, t3;
}
kr.siv = (0, Kr.wrapCipher)({ blockSize: 16, nonceLength: 12, tagLength: 16 }, function(e9, t3, n6) {
  const r2 = pi("AAD", 0, 2 ** 36), i4 = pi("plaintext", 0, 2 ** 36), o3 = pi("nonce", 12, 12), s2 = pi("ciphertext", 16, 2 ** 36 + 16);
  function a() {
    const n7 = ei(e9), r3 = new Uint8Array(e9.length), i5 = new Uint8Array(16), o4 = [n7, r3];
    let s3 = t3;
    (0, Kr.isAligned32)(s3) || o4.push(s3 = (0, Kr.copyBytes)(s3));
    const a2 = (0, Kr.u32)(s3);
    let c4 = 0, l6 = a2[0], d3 = a2[1], u2 = a2[2], h3 = 0;
    for (const e10 of [i5, r3].map(Kr.u32)) {
      const t4 = (0, Kr.u32)(e10);
      for (let e11 = 0; e11 < t4.length; e11 += 2) {
        const { s0: r4, s1: i6 } = ii(n7, c4, l6, d3, u2);
        t4[e11 + 0] = r4, t4[e11 + 1] = i6, c4 = ++h3;
      }
    }
    const f4 = { authKey: i5, encKey: ei(r3) };
    return (0, Kr.clean)(...o4), f4;
  }
  function c3(e10, r3, i5) {
    const o4 = fi(Br.polyval, true, r3, i5, n6);
    for (let e11 = 0; e11 < 12; e11++) o4[e11] ^= t3[e11];
    o4[15] &= 127;
    const s3 = (0, Kr.u32)(o4);
    let a2 = s3[0], c4 = s3[1], l6 = s3[2], d3 = s3[3];
    return { s0: a2, s1: c4, s2: l6, s3: d3 } = ii(e10, a2, c4, l6, d3), s3[0] = a2, s3[1] = c4, s3[2] = l6, s3[3] = d3, o4;
  }
  function l5(e10, t4, n7) {
    let r3 = (0, Kr.copyBytes)(t4);
    r3[15] |= 128;
    const i5 = ci(e10, true, r3, n7);
    return (0, Kr.clean)(r3), i5;
  }
  return (0, $r.bytes)(e9, 16, 24, 32), (0, $r.bytes)(t3), o3(t3.length), void 0 !== n6 && ((0, $r.bytes)(n6), r2(n6.length)), { encrypt(e10) {
    (0, $r.bytes)(e10), i4(e10.length);
    const { encKey: t4, authKey: n7 } = a(), r3 = c3(t4, n7, e10), o4 = [t4, n7, r3];
    (0, Kr.isAligned32)(e10) || o4.push(e10 = (0, Kr.copyBytes)(e10));
    const s3 = new Uint8Array(e10.length + 16);
    return s3.set(r3, e10.length), s3.set(l5(t4, r3, e10)), (0, Kr.clean)(...o4), s3;
  }, decrypt(e10) {
    (0, $r.bytes)(e10), s2(e10.length);
    const t4 = e10.subarray(-16), { encKey: n7, authKey: r3 } = a(), i5 = [n7, r3];
    (0, Kr.isAligned32)(e10) || i5.push(e10 = (0, Kr.copyBytes)(e10));
    const o4 = l5(n7, t4, e10.subarray(0, -16)), d3 = c3(n7, r3, o4);
    if (i5.push(d3), !(0, Kr.equalBytes)(t4, d3)) throw (0, Kr.clean)(...i5), new Error("invalid polyval tag");
    return (0, Kr.clean)(...i5), o4;
  } };
});
var vi = { encrypt(e9, t3) {
  if (t3.length >= 2 ** 32) throw new Error("plaintext should be less than 4gb");
  const n6 = ei(e9);
  if (16 === t3.length) mi(n6, t3);
  else {
    const e10 = (0, Kr.u32)(t3);
    let r2 = e10[0], i4 = e10[1];
    for (let t4 = 0, o3 = 1; t4 < 6; t4++) for (let t5 = 2; t5 < e10.length; t5 += 2, o3++) {
      const { s0: s2, s1: a, s2: c3, s3: l5 } = ii(n6, r2, i4, e10[t5], e10[t5 + 1]);
      r2 = s2, i4 = a ^ Yr(o3), e10[t5] = c3, e10[t5 + 1] = l5;
    }
    e10[0] = r2, e10[1] = i4;
  }
  n6.fill(0);
}, decrypt(e9, t3) {
  if (t3.length - 8 >= 2 ** 32) throw new Error("ciphertext should be less than 4gb");
  const n6 = ti(e9), r2 = t3.length / 8 - 1;
  if (1 === r2) yi(n6, t3);
  else {
    const e10 = (0, Kr.u32)(t3);
    let i4 = e10[0], o3 = e10[1];
    for (let t4 = 0, s2 = 6 * r2; t4 < 6; t4++) for (let t5 = 2 * r2; t5 >= 1; t5 -= 2, s2--) {
      o3 ^= Yr(s2);
      const { s0: r3, s1: a, s2: c3, s3: l5 } = oi(n6, i4, o3, e10[t5], e10[t5 + 1]);
      i4 = r3, o3 = a, e10[t5] = c3, e10[t5 + 1] = l5;
    }
    e10[0] = i4, e10[1] = o3;
  }
  n6.fill(0);
} };
var bi = new Uint8Array(8).fill(166);
kr.aeskw = (0, Kr.wrapCipher)({ blockSize: 8 }, (e9) => ({ encrypt(t3) {
  if ((0, $r.bytes)(t3), !t3.length || t3.length % 8 != 0) throw new Error("invalid plaintext length");
  if (8 === t3.length) throw new Error("8-byte keys not allowed in AESKW, use AESKWP instead");
  const n6 = (0, Kr.concatBytes)(bi, t3);
  return vi.encrypt(e9, n6), n6;
}, decrypt(t3) {
  if ((0, $r.bytes)(t3), t3.length % 8 != 0 || t3.length < 24) throw new Error("invalid ciphertext length");
  const n6 = (0, Kr.copyBytes)(t3);
  if (vi.decrypt(e9, n6), !(0, Kr.equalBytes)(n6.subarray(0, 8), bi)) throw new Error("integrity check failed");
  return n6.subarray(0, 8).fill(0), n6.subarray(8);
} }));
var wi = 2790873510;
kr.aeskwp = (0, Kr.wrapCipher)({ blockSize: 8 }, (e9) => ({ encrypt(t3) {
  if ((0, $r.bytes)(t3), !t3.length) throw new Error("invalid plaintext length");
  const n6 = 8 * Math.ceil(t3.length / 8), r2 = new Uint8Array(8 + n6);
  r2.set(t3, 8);
  const i4 = (0, Kr.u32)(r2);
  return i4[0] = wi, i4[1] = Yr(t3.length), vi.encrypt(e9, r2), r2;
}, decrypt(t3) {
  if ((0, $r.bytes)(t3), t3.length < 16) throw new Error("invalid ciphertext length");
  const n6 = (0, Kr.copyBytes)(t3), r2 = (0, Kr.u32)(n6);
  vi.decrypt(e9, n6);
  const i4 = Yr(r2[1]) >>> 0, o3 = 8 * Math.ceil(i4 / 8);
  if (r2[0] !== wi || n6.length - 8 !== o3) throw new Error("integrity check failed");
  for (let e10 = i4; e10 < o3; e10++) if (0 !== n6[8 + e10]) throw new Error("integrity check failed");
  return n6.subarray(0, 8).fill(0), n6.subarray(8, 8 + i4);
} })), kr.unsafe = { expandKeyLE: ei, expandKeyDecLE: ti, encrypt: ii, decrypt: oi, encryptBlock: mi, decryptBlock: yi, ctrCounter: ai, ctr32: ci }, Object.defineProperty(Cr, "__esModule", { value: true }), Cr.aes256cbc = Cr.aes256gcm = void 0;
var Ei = kr;
Cr.aes256gcm = function(e9, t3, n6) {
  return (0, Ei.gcm)(e9, t3, n6);
};
Cr.aes256cbc = function(e9, t3, n6) {
  return (0, Ei.cbc)(e9, t3);
};
var Si = {};
var _i = {};
var Ci = {};
Object.defineProperty(Ci, "__esModule", { value: true }), Ci.sigma = void 0, Ci.rotl = function(e9, t3) {
  return e9 << t3 | e9 >>> 32 - t3;
}, Ci.createCipher = function(e9, t3) {
  const { allowShortKeys: n6, extendNonceFn: r2, counterLength: i4, counterRight: o3, rounds: s2 } = (0, Ai.checkOpts)({ allowShortKeys: false, counterLength: 8, counterRight: false, rounds: 20 }, t3);
  if ("function" != typeof e9) throw new Error("core must be a function");
  return (0, ki.number)(i4), (0, ki.number)(s2), (0, ki.bool)(o3), (0, ki.bool)(n6), (t4, a, c3, l5, d3 = 0) => {
    (0, ki.bytes)(t4), (0, ki.bytes)(a), (0, ki.bytes)(c3);
    const u2 = c3.length;
    if (void 0 === l5 && (l5 = new Uint8Array(u2)), (0, ki.bytes)(l5), (0, ki.number)(d3), d3 < 0 || d3 >= Li) throw new Error("arx: counter overflow");
    if (l5.length < u2) throw new Error(`arx: output (${l5.length}) is shorter than data (${u2})`);
    const h3 = [];
    let f4, p4, g2 = t4.length;
    if (32 === g2) h3.push(f4 = (0, Ai.copyBytes)(t4)), p4 = Ri;
    else {
      if (16 !== g2 || !n6) throw new Error(`arx: invalid 32-byte key, got length=${g2}`);
      f4 = new Uint8Array(32), f4.set(t4), f4.set(t4, 16), p4 = Ti, h3.push(f4);
    }
    Pi(a) || h3.push(a = (0, Ai.copyBytes)(a));
    const m4 = (0, Ai.u32)(f4);
    if (r2) {
      if (24 !== a.length) throw new Error("arx: extended nonce must be 24 bytes");
      r2(p4, m4, (0, Ai.u32)(a.subarray(0, 16)), m4), a = a.subarray(16);
    }
    const y2 = 16 - i4;
    if (y2 !== a.length) throw new Error(`arx: nonce must be ${y2} or 16 bytes`);
    if (12 !== y2) {
      const e10 = new Uint8Array(12);
      e10.set(a, o3 ? 0 : 12 - a.length), a = e10, h3.push(a);
    }
    const v2 = (0, Ai.u32)(a);
    return function(e10, t5, n7, r3, i5, o4, s3, a2) {
      const c4 = i5.length, l6 = new Uint8Array(Oi), d4 = (0, Ai.u32)(l6), u3 = Pi(i5) && Pi(o4), h4 = u3 ? (0, Ai.u32)(i5) : Di, f5 = u3 ? (0, Ai.u32)(o4) : Di;
      for (let p5 = 0; p5 < c4; s3++) {
        if (e10(t5, n7, r3, d4, s3, a2), s3 >= Li) throw new Error("arx: counter overflow");
        const g3 = Math.min(Oi, c4 - p5);
        if (u3 && g3 === Oi) {
          const e11 = p5 / 4;
          if (p5 % 4 != 0) throw new Error("arx: invalid block position");
          for (let t6, n8 = 0; n8 < Ni; n8++) t6 = e11 + n8, f5[t6] = h4[t6] ^ d4[n8];
          p5 += Oi;
        } else {
          for (let e11, t6 = 0; t6 < g3; t6++) e11 = p5 + t6, o4[e11] = i5[e11] ^ l6[t6];
          p5 += g3;
        }
      }
    }(e9, p4, m4, v2, c3, l5, d3, s2), (0, Ai.clean)(...h3), l5;
  };
};
var ki = ge;
var Ai = pe;
var xi = (e9) => Uint8Array.from(e9.split("").map((e10) => e10.charCodeAt(0)));
var Mi = xi("expand 16-byte k");
var Ii = xi("expand 32-byte k");
var Ti = (0, Ai.u32)(Mi);
var Ri = (0, Ai.u32)(Ii);
function Pi(e9) {
  return e9.byteOffset % 4 == 0;
}
Ci.sigma = Ri.slice();
var Oi = 64;
var Ni = 16;
var Li = 2 ** 32 - 1;
var Di = new Uint32Array();
var $i = {};
Object.defineProperty($i, "__esModule", { value: true }), $i.poly1305 = void 0, $i.wrapConstructorWithKey = Hi;
var Bi = ge;
var Ki = pe;
var ji = (e9, t3) => 255 & e9[t3++] | (255 & e9[t3++]) << 8;
var Ui = class {
  constructor(e9) {
    this.blockLen = 16, this.outputLen = 16, this.buffer = new Uint8Array(16), this.r = new Uint16Array(10), this.h = new Uint16Array(10), this.pad = new Uint16Array(8), this.pos = 0, this.finished = false, e9 = (0, Ki.toBytes)(e9), (0, Bi.bytes)(e9, 32);
    const t3 = ji(e9, 0), n6 = ji(e9, 2), r2 = ji(e9, 4), i4 = ji(e9, 6), o3 = ji(e9, 8), s2 = ji(e9, 10), a = ji(e9, 12), c3 = ji(e9, 14);
    this.r[0] = 8191 & t3, this.r[1] = 8191 & (t3 >>> 13 | n6 << 3), this.r[2] = 7939 & (n6 >>> 10 | r2 << 6), this.r[3] = 8191 & (r2 >>> 7 | i4 << 9), this.r[4] = 255 & (i4 >>> 4 | o3 << 12), this.r[5] = o3 >>> 1 & 8190, this.r[6] = 8191 & (o3 >>> 14 | s2 << 2), this.r[7] = 8065 & (s2 >>> 11 | a << 5), this.r[8] = 8191 & (a >>> 8 | c3 << 8), this.r[9] = c3 >>> 5 & 127;
    for (let t4 = 0; t4 < 8; t4++) this.pad[t4] = ji(e9, 16 + 2 * t4);
  }
  process(e9, t3, n6 = false) {
    const r2 = n6 ? 0 : 2048, { h: i4, r: o3 } = this, s2 = o3[0], a = o3[1], c3 = o3[2], l5 = o3[3], d3 = o3[4], u2 = o3[5], h3 = o3[6], f4 = o3[7], p4 = o3[8], g2 = o3[9], m4 = ji(e9, t3 + 0), y2 = ji(e9, t3 + 2), v2 = ji(e9, t3 + 4), b3 = ji(e9, t3 + 6), w5 = ji(e9, t3 + 8), E4 = ji(e9, t3 + 10), S5 = ji(e9, t3 + 12), _2 = ji(e9, t3 + 14);
    let C4 = i4[0] + (8191 & m4), k3 = i4[1] + (8191 & (m4 >>> 13 | y2 << 3)), A3 = i4[2] + (8191 & (y2 >>> 10 | v2 << 6)), x3 = i4[3] + (8191 & (v2 >>> 7 | b3 << 9)), M4 = i4[4] + (8191 & (b3 >>> 4 | w5 << 12)), I2 = i4[5] + (w5 >>> 1 & 8191), T3 = i4[6] + (8191 & (w5 >>> 14 | E4 << 2)), R3 = i4[7] + (8191 & (E4 >>> 11 | S5 << 5)), P5 = i4[8] + (8191 & (S5 >>> 8 | _2 << 8)), O4 = i4[9] + (_2 >>> 5 | r2), N3 = 0, L5 = N3 + C4 * s2 + k3 * (5 * g2) + A3 * (5 * p4) + x3 * (5 * f4) + M4 * (5 * h3);
    N3 = L5 >>> 13, L5 &= 8191, L5 += I2 * (5 * u2) + T3 * (5 * d3) + R3 * (5 * l5) + P5 * (5 * c3) + O4 * (5 * a), N3 += L5 >>> 13, L5 &= 8191;
    let D3 = N3 + C4 * a + k3 * s2 + A3 * (5 * g2) + x3 * (5 * p4) + M4 * (5 * f4);
    N3 = D3 >>> 13, D3 &= 8191, D3 += I2 * (5 * h3) + T3 * (5 * u2) + R3 * (5 * d3) + P5 * (5 * l5) + O4 * (5 * c3), N3 += D3 >>> 13, D3 &= 8191;
    let $2 = N3 + C4 * c3 + k3 * a + A3 * s2 + x3 * (5 * g2) + M4 * (5 * p4);
    N3 = $2 >>> 13, $2 &= 8191, $2 += I2 * (5 * f4) + T3 * (5 * h3) + R3 * (5 * u2) + P5 * (5 * d3) + O4 * (5 * l5), N3 += $2 >>> 13, $2 &= 8191;
    let B3 = N3 + C4 * l5 + k3 * c3 + A3 * a + x3 * s2 + M4 * (5 * g2);
    N3 = B3 >>> 13, B3 &= 8191, B3 += I2 * (5 * p4) + T3 * (5 * f4) + R3 * (5 * h3) + P5 * (5 * u2) + O4 * (5 * d3), N3 += B3 >>> 13, B3 &= 8191;
    let K4 = N3 + C4 * d3 + k3 * l5 + A3 * c3 + x3 * a + M4 * s2;
    N3 = K4 >>> 13, K4 &= 8191, K4 += I2 * (5 * g2) + T3 * (5 * p4) + R3 * (5 * f4) + P5 * (5 * h3) + O4 * (5 * u2), N3 += K4 >>> 13, K4 &= 8191;
    let j4 = N3 + C4 * u2 + k3 * d3 + A3 * l5 + x3 * c3 + M4 * a;
    N3 = j4 >>> 13, j4 &= 8191, j4 += I2 * s2 + T3 * (5 * g2) + R3 * (5 * p4) + P5 * (5 * f4) + O4 * (5 * h3), N3 += j4 >>> 13, j4 &= 8191;
    let U5 = N3 + C4 * h3 + k3 * u2 + A3 * d3 + x3 * l5 + M4 * c3;
    N3 = U5 >>> 13, U5 &= 8191, U5 += I2 * a + T3 * s2 + R3 * (5 * g2) + P5 * (5 * p4) + O4 * (5 * f4), N3 += U5 >>> 13, U5 &= 8191;
    let H3 = N3 + C4 * f4 + k3 * h3 + A3 * u2 + x3 * d3 + M4 * l5;
    N3 = H3 >>> 13, H3 &= 8191, H3 += I2 * c3 + T3 * a + R3 * s2 + P5 * (5 * g2) + O4 * (5 * p4), N3 += H3 >>> 13, H3 &= 8191;
    let F3 = N3 + C4 * p4 + k3 * f4 + A3 * h3 + x3 * u2 + M4 * d3;
    N3 = F3 >>> 13, F3 &= 8191, F3 += I2 * l5 + T3 * c3 + R3 * a + P5 * s2 + O4 * (5 * g2), N3 += F3 >>> 13, F3 &= 8191;
    let z3 = N3 + C4 * g2 + k3 * p4 + A3 * f4 + x3 * h3 + M4 * u2;
    N3 = z3 >>> 13, z3 &= 8191, z3 += I2 * d3 + T3 * l5 + R3 * c3 + P5 * a + O4 * s2, N3 += z3 >>> 13, z3 &= 8191, N3 = (N3 << 2) + N3 | 0, N3 = N3 + L5 | 0, L5 = 8191 & N3, N3 >>>= 13, D3 += N3, i4[0] = L5, i4[1] = D3, i4[2] = $2, i4[3] = B3, i4[4] = K4, i4[5] = j4, i4[6] = U5, i4[7] = H3, i4[8] = F3, i4[9] = z3;
  }
  finalize() {
    const { h: e9, pad: t3 } = this, n6 = new Uint16Array(10);
    let r2 = e9[1] >>> 13;
    e9[1] &= 8191;
    for (let t4 = 2; t4 < 10; t4++) e9[t4] += r2, r2 = e9[t4] >>> 13, e9[t4] &= 8191;
    e9[0] += 5 * r2, r2 = e9[0] >>> 13, e9[0] &= 8191, e9[1] += r2, r2 = e9[1] >>> 13, e9[1] &= 8191, e9[2] += r2, n6[0] = e9[0] + 5, r2 = n6[0] >>> 13, n6[0] &= 8191;
    for (let t4 = 1; t4 < 10; t4++) n6[t4] = e9[t4] + r2, r2 = n6[t4] >>> 13, n6[t4] &= 8191;
    n6[9] -= 8192;
    let i4 = (1 ^ r2) - 1;
    for (let e10 = 0; e10 < 10; e10++) n6[e10] &= i4;
    i4 = ~i4;
    for (let t4 = 0; t4 < 10; t4++) e9[t4] = e9[t4] & i4 | n6[t4];
    e9[0] = 65535 & (e9[0] | e9[1] << 13), e9[1] = 65535 & (e9[1] >>> 3 | e9[2] << 10), e9[2] = 65535 & (e9[2] >>> 6 | e9[3] << 7), e9[3] = 65535 & (e9[3] >>> 9 | e9[4] << 4), e9[4] = 65535 & (e9[4] >>> 12 | e9[5] << 1 | e9[6] << 14), e9[5] = 65535 & (e9[6] >>> 2 | e9[7] << 11), e9[6] = 65535 & (e9[7] >>> 5 | e9[8] << 8), e9[7] = 65535 & (e9[8] >>> 8 | e9[9] << 5);
    let o3 = e9[0] + t3[0];
    e9[0] = 65535 & o3;
    for (let n7 = 1; n7 < 8; n7++) o3 = (e9[n7] + t3[n7] | 0) + (o3 >>> 16) | 0, e9[n7] = 65535 & o3;
    (0, Ki.clean)(n6);
  }
  update(e9) {
    (0, Bi.exists)(this);
    const { buffer: t3, blockLen: n6 } = this, r2 = (e9 = (0, Ki.toBytes)(e9)).length;
    for (let i4 = 0; i4 < r2; ) {
      const o3 = Math.min(n6 - this.pos, r2 - i4);
      if (o3 !== n6) t3.set(e9.subarray(i4, i4 + o3), this.pos), this.pos += o3, i4 += o3, this.pos === n6 && (this.process(t3, 0, false), this.pos = 0);
      else for (; n6 <= r2 - i4; i4 += n6) this.process(e9, i4);
    }
    return this;
  }
  destroy() {
    (0, Ki.clean)(this.h, this.r, this.buffer, this.pad);
  }
  digestInto(e9) {
    (0, Bi.exists)(this), (0, Bi.output)(e9, this), this.finished = true;
    const { buffer: t3, h: n6 } = this;
    let { pos: r2 } = this;
    if (r2) {
      for (t3[r2++] = 1; r2 < 16; r2++) t3[r2] = 0;
      this.process(t3, 0, true);
    }
    this.finalize();
    let i4 = 0;
    for (let t4 = 0; t4 < 8; t4++) e9[i4++] = n6[t4] >>> 0, e9[i4++] = n6[t4] >>> 8;
    return e9;
  }
  digest() {
    const { buffer: e9, outputLen: t3 } = this;
    this.digestInto(e9);
    const n6 = e9.slice(0, t3);
    return this.destroy(), n6;
  }
};
function Hi(e9) {
  const t3 = (t4, n7) => e9(n7).update((0, Ki.toBytes)(t4)).digest(), n6 = e9(new Uint8Array(32));
  return t3.outputLen = n6.outputLen, t3.blockLen = n6.blockLen, t3.create = (t4) => e9(t4), t3;
}
$i.poly1305 = Hi((e9) => new Ui(e9)), function(e9) {
  Object.defineProperty(e9, "__esModule", { value: true }), e9.xchacha20poly1305 = e9.chacha20poly1305 = e9._poly1305_aead = e9.chacha12 = e9.chacha8 = e9.xchacha20 = e9.chacha20 = e9.chacha20orig = void 0, e9.hchacha = s2;
  const t3 = Ci, n6 = ge, r2 = $i, i4 = pe;
  function o3(e10, n7, r3, i5, o4, s3 = 20) {
    let a2 = e10[0], c4 = e10[1], l6 = e10[2], d4 = e10[3], u2 = n7[0], h3 = n7[1], f4 = n7[2], p4 = n7[3], g2 = n7[4], m4 = n7[5], y2 = n7[6], v2 = n7[7], b3 = o4, w5 = r3[0], E4 = r3[1], S5 = r3[2], _2 = a2, C4 = c4, k3 = l6, A3 = d4, x3 = u2, M4 = h3, I2 = f4, T3 = p4, R3 = g2, P5 = m4, O4 = y2, N3 = v2, L5 = b3, D3 = w5, $2 = E4, B3 = S5;
    for (let e11 = 0; e11 < s3; e11 += 2) _2 = _2 + x3 | 0, L5 = (0, t3.rotl)(L5 ^ _2, 16), R3 = R3 + L5 | 0, x3 = (0, t3.rotl)(x3 ^ R3, 12), _2 = _2 + x3 | 0, L5 = (0, t3.rotl)(L5 ^ _2, 8), R3 = R3 + L5 | 0, x3 = (0, t3.rotl)(x3 ^ R3, 7), C4 = C4 + M4 | 0, D3 = (0, t3.rotl)(D3 ^ C4, 16), P5 = P5 + D3 | 0, M4 = (0, t3.rotl)(M4 ^ P5, 12), C4 = C4 + M4 | 0, D3 = (0, t3.rotl)(D3 ^ C4, 8), P5 = P5 + D3 | 0, M4 = (0, t3.rotl)(M4 ^ P5, 7), k3 = k3 + I2 | 0, $2 = (0, t3.rotl)($2 ^ k3, 16), O4 = O4 + $2 | 0, I2 = (0, t3.rotl)(I2 ^ O4, 12), k3 = k3 + I2 | 0, $2 = (0, t3.rotl)($2 ^ k3, 8), O4 = O4 + $2 | 0, I2 = (0, t3.rotl)(I2 ^ O4, 7), A3 = A3 + T3 | 0, B3 = (0, t3.rotl)(B3 ^ A3, 16), N3 = N3 + B3 | 0, T3 = (0, t3.rotl)(T3 ^ N3, 12), A3 = A3 + T3 | 0, B3 = (0, t3.rotl)(B3 ^ A3, 8), N3 = N3 + B3 | 0, T3 = (0, t3.rotl)(T3 ^ N3, 7), _2 = _2 + M4 | 0, B3 = (0, t3.rotl)(B3 ^ _2, 16), O4 = O4 + B3 | 0, M4 = (0, t3.rotl)(M4 ^ O4, 12), _2 = _2 + M4 | 0, B3 = (0, t3.rotl)(B3 ^ _2, 8), O4 = O4 + B3 | 0, M4 = (0, t3.rotl)(M4 ^ O4, 7), C4 = C4 + I2 | 0, L5 = (0, t3.rotl)(L5 ^ C4, 16), N3 = N3 + L5 | 0, I2 = (0, t3.rotl)(I2 ^ N3, 12), C4 = C4 + I2 | 0, L5 = (0, t3.rotl)(L5 ^ C4, 8), N3 = N3 + L5 | 0, I2 = (0, t3.rotl)(I2 ^ N3, 7), k3 = k3 + T3 | 0, D3 = (0, t3.rotl)(D3 ^ k3, 16), R3 = R3 + D3 | 0, T3 = (0, t3.rotl)(T3 ^ R3, 12), k3 = k3 + T3 | 0, D3 = (0, t3.rotl)(D3 ^ k3, 8), R3 = R3 + D3 | 0, T3 = (0, t3.rotl)(T3 ^ R3, 7), A3 = A3 + x3 | 0, $2 = (0, t3.rotl)($2 ^ A3, 16), P5 = P5 + $2 | 0, x3 = (0, t3.rotl)(x3 ^ P5, 12), A3 = A3 + x3 | 0, $2 = (0, t3.rotl)($2 ^ A3, 8), P5 = P5 + $2 | 0, x3 = (0, t3.rotl)(x3 ^ P5, 7);
    let K4 = 0;
    i5[K4++] = a2 + _2 | 0, i5[K4++] = c4 + C4 | 0, i5[K4++] = l6 + k3 | 0, i5[K4++] = d4 + A3 | 0, i5[K4++] = u2 + x3 | 0, i5[K4++] = h3 + M4 | 0, i5[K4++] = f4 + I2 | 0, i5[K4++] = p4 + T3 | 0, i5[K4++] = g2 + R3 | 0, i5[K4++] = m4 + P5 | 0, i5[K4++] = y2 + O4 | 0, i5[K4++] = v2 + N3 | 0, i5[K4++] = b3 + L5 | 0, i5[K4++] = w5 + D3 | 0, i5[K4++] = E4 + $2 | 0, i5[K4++] = S5 + B3 | 0;
  }
  function s2(e10, n7, r3, i5) {
    let o4 = e10[0], s3 = e10[1], a2 = e10[2], c4 = e10[3], l6 = n7[0], d4 = n7[1], u2 = n7[2], h3 = n7[3], f4 = n7[4], p4 = n7[5], g2 = n7[6], m4 = n7[7], y2 = r3[0], v2 = r3[1], b3 = r3[2], w5 = r3[3];
    for (let e11 = 0; e11 < 20; e11 += 2) o4 = o4 + l6 | 0, y2 = (0, t3.rotl)(y2 ^ o4, 16), f4 = f4 + y2 | 0, l6 = (0, t3.rotl)(l6 ^ f4, 12), o4 = o4 + l6 | 0, y2 = (0, t3.rotl)(y2 ^ o4, 8), f4 = f4 + y2 | 0, l6 = (0, t3.rotl)(l6 ^ f4, 7), s3 = s3 + d4 | 0, v2 = (0, t3.rotl)(v2 ^ s3, 16), p4 = p4 + v2 | 0, d4 = (0, t3.rotl)(d4 ^ p4, 12), s3 = s3 + d4 | 0, v2 = (0, t3.rotl)(v2 ^ s3, 8), p4 = p4 + v2 | 0, d4 = (0, t3.rotl)(d4 ^ p4, 7), a2 = a2 + u2 | 0, b3 = (0, t3.rotl)(b3 ^ a2, 16), g2 = g2 + b3 | 0, u2 = (0, t3.rotl)(u2 ^ g2, 12), a2 = a2 + u2 | 0, b3 = (0, t3.rotl)(b3 ^ a2, 8), g2 = g2 + b3 | 0, u2 = (0, t3.rotl)(u2 ^ g2, 7), c4 = c4 + h3 | 0, w5 = (0, t3.rotl)(w5 ^ c4, 16), m4 = m4 + w5 | 0, h3 = (0, t3.rotl)(h3 ^ m4, 12), c4 = c4 + h3 | 0, w5 = (0, t3.rotl)(w5 ^ c4, 8), m4 = m4 + w5 | 0, h3 = (0, t3.rotl)(h3 ^ m4, 7), o4 = o4 + d4 | 0, w5 = (0, t3.rotl)(w5 ^ o4, 16), g2 = g2 + w5 | 0, d4 = (0, t3.rotl)(d4 ^ g2, 12), o4 = o4 + d4 | 0, w5 = (0, t3.rotl)(w5 ^ o4, 8), g2 = g2 + w5 | 0, d4 = (0, t3.rotl)(d4 ^ g2, 7), s3 = s3 + u2 | 0, y2 = (0, t3.rotl)(y2 ^ s3, 16), m4 = m4 + y2 | 0, u2 = (0, t3.rotl)(u2 ^ m4, 12), s3 = s3 + u2 | 0, y2 = (0, t3.rotl)(y2 ^ s3, 8), m4 = m4 + y2 | 0, u2 = (0, t3.rotl)(u2 ^ m4, 7), a2 = a2 + h3 | 0, v2 = (0, t3.rotl)(v2 ^ a2, 16), f4 = f4 + v2 | 0, h3 = (0, t3.rotl)(h3 ^ f4, 12), a2 = a2 + h3 | 0, v2 = (0, t3.rotl)(v2 ^ a2, 8), f4 = f4 + v2 | 0, h3 = (0, t3.rotl)(h3 ^ f4, 7), c4 = c4 + l6 | 0, b3 = (0, t3.rotl)(b3 ^ c4, 16), p4 = p4 + b3 | 0, l6 = (0, t3.rotl)(l6 ^ p4, 12), c4 = c4 + l6 | 0, b3 = (0, t3.rotl)(b3 ^ c4, 8), p4 = p4 + b3 | 0, l6 = (0, t3.rotl)(l6 ^ p4, 7);
    let E4 = 0;
    i5[E4++] = o4, i5[E4++] = s3, i5[E4++] = a2, i5[E4++] = c4, i5[E4++] = y2, i5[E4++] = v2, i5[E4++] = b3, i5[E4++] = w5;
  }
  e9.chacha20orig = (0, t3.createCipher)(o3, { counterRight: false, counterLength: 8, allowShortKeys: true }), e9.chacha20 = (0, t3.createCipher)(o3, { counterRight: false, counterLength: 4, allowShortKeys: false }), e9.xchacha20 = (0, t3.createCipher)(o3, { counterRight: false, counterLength: 8, extendNonceFn: s2, allowShortKeys: false }), e9.chacha8 = (0, t3.createCipher)(o3, { counterRight: false, counterLength: 4, rounds: 8 }), e9.chacha12 = (0, t3.createCipher)(o3, { counterRight: false, counterLength: 4, rounds: 12 });
  const a = new Uint8Array(16), c3 = (e10, t4) => {
    e10.update(t4);
    const n7 = t4.length % 16;
    n7 && e10.update(a.subarray(n7));
  }, l5 = new Uint8Array(32);
  function d3(e10, t4, n7, o4, s3) {
    const a2 = e10(t4, n7, l5), d4 = r2.poly1305.create(a2);
    s3 && c3(d4, s3), c3(d4, o4);
    const u2 = new Uint8Array(16), h3 = (0, i4.createView)(u2);
    (0, i4.setBigUint64)(h3, 0, BigInt(s3 ? s3.length : 0), true), (0, i4.setBigUint64)(h3, 8, BigInt(o4.length), true), d4.update(u2);
    const f4 = d4.digest();
    return (0, i4.clean)(a2, u2), f4;
  }
  e9._poly1305_aead = (e10) => (t4, r3, o4) => {
    const s3 = 16;
    return (0, n6.bytes)(t4, 32), (0, n6.bytes)(r3), { encrypt(a2, c4) {
      const l6 = a2.length, u2 = l6 + s3;
      c4 ? (0, n6.bytes)(c4, u2) : c4 = new Uint8Array(u2), e10(t4, r3, a2, c4, 1);
      const h3 = d3(e10, t4, r3, c4.subarray(0, -16), o4);
      return c4.set(h3, l6), (0, i4.clean)(h3), c4;
    }, decrypt(a2, c4) {
      const l6 = a2.length, u2 = l6 - s3;
      if (l6 < s3) throw new Error("encrypted data must be at least 16 bytes");
      c4 ? (0, n6.bytes)(c4, u2) : c4 = new Uint8Array(u2);
      const h3 = a2.subarray(0, -16), f4 = a2.subarray(-16), p4 = d3(e10, t4, r3, h3, o4);
      if (!(0, i4.equalBytes)(f4, p4)) throw new Error("invalid tag");
      return e10(t4, r3, h3, c4, 1), (0, i4.clean)(p4), c4;
    } };
  }, e9.chacha20poly1305 = (0, i4.wrapCipher)({ blockSize: 64, nonceLength: 12, tagLength: 16 }, (0, e9._poly1305_aead)(e9.chacha20)), e9.xchacha20poly1305 = (0, i4.wrapCipher)({ blockSize: 64, nonceLength: 24, tagLength: 16 }, (0, e9._poly1305_aead)(e9.xchacha20));
}(_i), Object.defineProperty(Si, "__esModule", { value: true }), Si.xchacha20 = void 0;
var Fi;
var zi;
var qi;
var Wi = _i;
Si.xchacha20 = function(e9, t3, n6) {
  return (0, Wi.xchacha20poly1305)(e9, t3, n6);
}, function(e9) {
  Object.defineProperty(e9, "__esModule", { value: true }), e9.aesDecrypt = e9.aesEncrypt = e9.symDecrypt = e9.symEncrypt = void 0;
  var t3 = pe, n6 = Te, r2 = Cr, i4 = Si, o3 = Ce, s2 = ke;
  e9.symEncrypt = function(e10, t4, n7) {
    return a(c3, e10, t4, n7);
  };
  function a(e10, t4, n7, a2) {
    var c4 = (0, o3.symmetricAlgorithm)();
    if ("aes-256-gcm" === c4) return e10(r2.aes256gcm, t4, n7, (0, o3.symmetricNonceLength)(), s2.AEAD_TAG_LENGTH, a2);
    if ("xchacha20" === c4) return e10(i4.xchacha20, t4, n7, s2.XCHACHA20_NONCE_LENGTH, s2.AEAD_TAG_LENGTH, a2);
    if ("aes-256-cbc" === c4) return e10(r2.aes256cbc, t4, n7, 16, 0);
    throw new Error("Not implemented");
  }
  function c3(e10, r3, i5, o4, s3, a2) {
    var c4 = (0, n6.randomBytes)(o4), l6 = e10(r3, c4, a2).encrypt(i5);
    if (0 === s3) return (0, t3.concatBytes)(c4, l6);
    var d3 = l6.length - s3, u2 = l6.subarray(0, d3), h3 = l6.subarray(d3);
    return (0, t3.concatBytes)(c4, h3, u2);
  }
  function l5(e10, n7, r3, i5, o4, s3) {
    var a2 = r3.subarray(0, i5), c4 = e10(n7, Uint8Array.from(a2), s3), l6 = r3.subarray(i5);
    if (0 === o4) return c4.decrypt(l6);
    var d3 = l6.subarray(0, o4), u2 = l6.subarray(o4);
    return c4.decrypt((0, t3.concatBytes)(u2, d3));
  }
  e9.symDecrypt = function(e10, t4, n7) {
    return a(l5, e10, t4, n7);
  }, e9.aesEncrypt = e9.symEncrypt, e9.aesDecrypt = e9.symDecrypt;
}(_r), Fi = Me, zi = de && de.__createBinding || (Object.create ? function(e9, t3, n6, r2) {
  void 0 === r2 && (r2 = n6);
  var i4 = Object.getOwnPropertyDescriptor(t3, n6);
  i4 && !("get" in i4 ? !t3.__esModule : i4.writable || i4.configurable) || (i4 = { enumerable: true, get: function() {
    return t3[n6];
  } }), Object.defineProperty(e9, r2, i4);
} : function(e9, t3, n6, r2) {
  void 0 === r2 && (r2 = n6), e9[r2] = t3[n6];
}), qi = de && de.__exportStar || function(e9, t3) {
  for (var n6 in e9) "default" === n6 || Object.prototype.hasOwnProperty.call(t3, n6) || zi(t3, e9, n6);
}, Object.defineProperty(Fi, "__esModule", { value: true }), qi(Ie, Fi), qi(pr, Fi), qi(fr, Fi), qi(_r, Fi);
var Vi = {};
Object.defineProperty(Vi, "__esModule", { value: true }), Vi.PublicKey = void 0;
var Gi = pe;
var Yi = Me;
var Zi = function() {
  function e9(e10) {
    this.data = (0, Yi.convertPublicKeyFormat)(e10, true);
  }
  return e9.fromHex = function(t3) {
    return new e9((0, Yi.hexToPublicKey)(t3));
  }, Object.defineProperty(e9.prototype, "uncompressed", { get: function() {
    return C3.from((0, Yi.convertPublicKeyFormat)(this.data, false));
  }, enumerable: false, configurable: true }), Object.defineProperty(e9.prototype, "compressed", { get: function() {
    return C3.from(this.data);
  }, enumerable: false, configurable: true }), e9.prototype.toHex = function(e10) {
    return void 0 === e10 && (e10 = true), (0, Gi.bytesToHex)(e10 ? this.data : this.uncompressed);
  }, e9.prototype.decapsulate = function(e10, t3) {
    void 0 === t3 && (t3 = false);
    var n6 = t3 ? this.data : this.uncompressed, r2 = e10.multiply(this, t3);
    return (0, Yi.getSharedKey)(n6, r2);
  }, e9.prototype.equals = function(e10) {
    return (0, Gi.equalBytes)(this.data, e10.data);
  }, e9;
}();
Vi.PublicKey = Zi, Object.defineProperty(xe, "__esModule", { value: true }), xe.PrivateKey = void 0;
var Ji = pe;
var Qi = Me;
var Xi = Vi;
var eo = function() {
  function e9(e10) {
    if (void 0 === e10) this.data = (0, Qi.getValidSecret)();
    else {
      if (!(0, Qi.isValidPrivateKey)(e10)) throw new Error("Invalid private key");
      this.data = e10;
    }
    this.publicKey = new Xi.PublicKey((0, Qi.getPublicKey)(this.data));
  }
  return e9.fromHex = function(t3) {
    return new e9((0, Qi.decodeHex)(t3));
  }, Object.defineProperty(e9.prototype, "secret", { get: function() {
    return C3.from(this.data);
  }, enumerable: false, configurable: true }), e9.prototype.toHex = function() {
    return (0, Ji.bytesToHex)(this.data);
  }, e9.prototype.encapsulate = function(e10, t3) {
    void 0 === t3 && (t3 = false);
    var n6 = t3 ? this.publicKey.compressed : this.publicKey.uncompressed, r2 = this.multiply(e10, t3);
    return (0, Qi.getSharedKey)(n6, r2);
  }, e9.prototype.multiply = function(e10, t3) {
    return void 0 === t3 && (t3 = false), (0, Qi.getSharedPoint)(this.data, e10.compressed, t3);
  }, e9.prototype.equals = function(e10) {
    return (0, Ji.equalBytes)(this.data, e10.data);
  }, e9;
}();
xe.PrivateKey = eo, function(e9) {
  Object.defineProperty(e9, "__esModule", { value: true }), e9.PublicKey = e9.PrivateKey = void 0;
  var t3 = xe;
  Object.defineProperty(e9, "PrivateKey", { enumerable: true, get: function() {
    return t3.PrivateKey;
  } });
  var n6 = Vi;
  Object.defineProperty(e9, "PublicKey", { enumerable: true, get: function() {
    return n6.PublicKey;
  } });
}(Ae), function(e9) {
  Object.defineProperty(e9, "__esModule", { value: true }), e9.utils = e9.PublicKey = e9.PrivateKey = e9.ECIES_CONFIG = void 0, e9.encrypt = function(e10, o4) {
    var s3 = new r2.PrivateKey(), a = e10 instanceof Uint8Array ? new r2.PublicKey(e10) : r2.PublicKey.fromHex(e10), c3 = s3.encapsulate(a, (0, n6.isHkdfKeyCompressed)()), l5 = (0, n6.isEphemeralKeyCompressed)() ? s3.publicKey.compressed : s3.publicKey.uncompressed, d3 = (0, i4.symEncrypt)(c3, o4);
    return C3.from((0, t3.concatBytes)(l5, d3));
  }, e9.decrypt = function(e10, t4) {
    var o4 = e10 instanceof Uint8Array ? new r2.PrivateKey(e10) : r2.PrivateKey.fromHex(e10), s3 = (0, n6.ephemeralKeySize)(), a = new r2.PublicKey(t4.subarray(0, s3)), c3 = t4.subarray(s3), l5 = a.decapsulate(o4, (0, n6.isHkdfKeyCompressed)());
    return C3.from((0, i4.symDecrypt)(l5, c3));
  };
  var t3 = pe, n6 = Ce, r2 = Ae, i4 = Me;
  var o3 = Ce;
  Object.defineProperty(e9, "ECIES_CONFIG", { enumerable: true, get: function() {
    return o3.ECIES_CONFIG;
  } });
  var s2 = Ae;
  Object.defineProperty(e9, "PrivateKey", { enumerable: true, get: function() {
    return s2.PrivateKey;
  } }), Object.defineProperty(e9, "PublicKey", { enumerable: true, get: function() {
    return s2.PublicKey;
  } }), e9.utils = { aesEncrypt: i4.aesEncrypt, aesDecrypt: i4.aesDecrypt, symEncrypt: i4.symEncrypt, symDecrypt: i4.symDecrypt, decodeHex: i4.decodeHex, getValidSecret: i4.getValidSecret, remove0x: i4.remove0x };
}(fe);
var to = (0, import_debug.default)("KeyExchange:Layer");
var no = (0, import_debug.default)("SocketService:Layer");
var ro = (0, import_debug.default)("Ecies:Layer");
var io = (0, import_debug.default)("RemoteCommunication:Layer");
to.color = "##95c44e", no.color = "#f638d7", ro.color = "#465b9c", io.color = "#47a2be";
var oo = { KeyExchange: to, SocketService: no, Ecies: ro, RemoteCommunication: io };
var so;
var ao = [];
var co = [];
var lo = (t3, n6) => c2(void 0, void 0, void 0, function* () {
  so = n6, co.push(t3), function(t4) {
    return c2(this, void 0, void 0, function* () {
      if (!so || !t4) return;
      !function() {
        const e9 = co;
        co = ao, ao = e9;
      }();
      const n7 = so.endsWith("/") ? `${so}evt` : `${so}/evt`, r2 = Object.assign({}, t4);
      if (delete r2.params, t4.params) for (const [e9, n8] of Object.entries(t4.params)) r2[e9] = n8;
      const i4 = JSON.stringify(r2);
      oo.RemoteCommunication(`[sendBufferedEvents] Sending ${ao.length} analytics events to ${n7}`);
      try {
        const t5 = yield (0, import_cross_fetch.default)(n7, { method: "POST", headers: { Accept: "application/json", "Content-Type": "application/json" }, body: i4 }), r3 = yield t5.text();
        oo.RemoteCommunication(`[sendBufferedEvents] Response: ${r3}`), ao.length = 0;
      } catch (n8) {
      }
    });
  }(t3).catch(() => {
  });
});
var uo = class {
  constructor(e9) {
    this.enabled = true, (null == e9 ? void 0 : e9.debug) && import_debug.default.enable("Ecies:Layer"), this.ecies = (null == e9 ? void 0 : e9.privateKey) ? fe.PrivateKey.fromHex(e9.privateKey) : new fe.PrivateKey(), oo.Ecies("[ECIES constructor()] initialized secret: ", this.ecies.toHex()), oo.Ecies("[ECIES constructor()] initialized public: ", this.ecies.publicKey.toHex()), oo.Ecies("[ECIES constructor()] init with", this);
  }
  generateECIES() {
    this.ecies = new fe.PrivateKey();
  }
  getPublicKey() {
    return this.ecies.publicKey.toHex();
  }
  encrypt(e9, t3) {
    let n6 = e9;
    if (this.enabled) try {
      oo.Ecies("[ECIES: encrypt()] using otherPublicKey", t3);
      const r2 = C3.from(e9), i4 = fe.encrypt(t3, r2);
      n6 = C3.from(i4).toString("base64");
    } catch (n7) {
      throw oo.Ecies("[ECIES: encrypt()] error encrypt:", n7), oo.Ecies("[ECIES: encrypt()] private: ", this.ecies.toHex()), oo.Ecies("[ECIES: encrypt()] data: ", e9), oo.Ecies("[ECIES: encrypt()] otherkey: ", t3), n7;
    }
    return n6;
  }
  decrypt(e9) {
    let t3 = e9;
    if (this.enabled) try {
      oo.Ecies("[ECIES: decrypt()] using privateKey", this.ecies.toHex());
      const n6 = C3.from(e9.toString(), "base64");
      t3 = fe.decrypt(this.ecies.toHex(), n6).toString();
    } catch (t4) {
      throw oo.Ecies("[ECIES: decrypt()] error decrypt", t4), oo.Ecies("[ECIES: decrypt()] private: ", this.ecies.toHex()), oo.Ecies("[ECIES: decrypt()] encryptedData: ", e9), t4;
    }
    return t3;
  }
  getKeyInfo() {
    return { private: this.ecies.toHex(), public: this.ecies.publicKey.toHex() };
  }
  toString() {
    oo.Ecies("[ECIES: toString()]", this.getKeyInfo());
  }
};
var ho = { name: "@metamask/sdk-communication-layer", version: "0.33.0", description: "", homepage: "https://github.com/MetaMask/metamask-sdk#readme", bugs: { url: "https://github.com/MetaMask/metamask-sdk/issues" }, repository: { type: "git", url: "https://github.com/MetaMask/metamask-sdk.git", directory: "packages/sdk-communication-layer" }, main: "dist/node/cjs/metamask-sdk-communication-layer.js", unpkg: "dist/browser/umd/metamask-sdk-communication-layer.js", module: "dist/node/es/metamask-sdk-communication-layer.js", browser: "dist/browser/es/metamask-sdk-communication-layer.js", "react-native": "dist/react-native/es/metamask-sdk-communication-layer.js", types: "dist/types/src/index.d.ts", files: ["/dist"], scripts: { "build:types": "tsc --project tsconfig.build.json --emitDeclarationOnly --outDir dist/types", "build:clean": "yarn clean && yarn build", build: "yarn build:types && rollup -c --bundleConfigAsCjs", "build:dev": "yarn build:types && NODE_ENV=dev rollup -c --bundleConfigAsCjs", dev: 'concurrently "tsc --watch" "rollup -c --bundleConfigAsCjs -w"', "build:post-tsc": "echo 'N/A'", "build:pre-tsc": "echo 'N/A'", size: "size-limit", clean: "rimraf ./dist", lint: "yarn lint:eslint && yarn lint:misc --check", "lint:changelog": "../../scripts/validate-changelog.sh @metamask/sdk-communication-layer", "lint:eslint": "eslint . --cache --ext js,ts", "lint:fix": "yarn lint:eslint --fix && yarn lint:misc --write", "lint:misc": "prettier '**/*.json' '**/*.md' '!CHANGELOG.md' --ignore-path ../../.gitignore", "publish:preview": "yarn npm publish --tag preview", prepack: "../../scripts/prepack.sh", reset: "yarn clean && rimraf ./node_modules/", test: 'jest --testPathIgnorePatterns "/e2e/"', "test:e2e": 'jest --testPathPattern "/e2e/"', "test:coverage": "jest --coverage", "test:ci": 'jest --coverage --passWithNoTests --setupFilesAfterEnv ./jest-preload.js --testPathIgnorePatterns "/e2e/"', "test:dev": "jest", watch: "rollup -c --bundleConfigAsCjs -w" }, dependencies: { "@metamask/sdk-analytics": "workspace:*", bufferutil: "^4.0.8", "date-fns": "^2.29.3", debug: "^4.3.4", "utf-8-validate": "^5.0.2", uuid: "^8.3.2" }, devDependencies: { "@jest/globals": "^29.3.1", "@lavamoat/allow-scripts": "^2.3.1", "@metamask/auto-changelog": "3.1.0", "@metamask/eslint-config": "^6.0.0", "@metamask/eslint-config-nodejs": "^6.0.0", "@metamask/eslint-config-typescript": "^6.0.0", "@rollup/plugin-commonjs": "^25.0.0", "@rollup/plugin-json": "^6.0.0", "@rollup/plugin-node-resolve": "^15.0.2", "@rollup/plugin-replace": "^6.0.1", "@rollup/plugin-terser": "^0.4.4", "@size-limit/preset-big-lib": "^11.0.2", "@types/jest": "^29.2.4", "@types/node": "^20.1.3", "@types/uuid": "^9.0.0", "@typescript-eslint/eslint-plugin": "^4.26.0", "@typescript-eslint/parser": "^4.26.0", concurrently: "^9.1.2", "cross-fetch": "^4.0.0", eciesjs: "^0.4.11", eslint: "^7.30.0", "eslint-config-prettier": "^8.3.0", "eslint-plugin-import": "^2.23.4", "eslint-plugin-jest": "^24.4.0", "eslint-plugin-jsdoc": "^36.1.0", "eslint-plugin-node": "^11.1.0", "eslint-plugin-prettier": "^3.4.0", eventemitter2: "^6.4.9", jest: "^29.3.1", prettier: "^2.3.0", rimraf: "^3.0.2", rollup: "^4.26.0", "rollup-plugin-jscc": "^2.0.0", "rollup-plugin-natives": "^0.7.5", "rollup-plugin-node-builtins": "^2.1.2", "rollup-plugin-node-globals": "^1.4.0", "rollup-plugin-peer-deps-external": "^2.2.4", "rollup-plugin-polyfill-node": "^0.13.0", "rollup-plugin-sizes": "^1.0.6", "rollup-plugin-typescript2": "^0.31.2", "rollup-plugin-visualizer": "^5.12.0", "size-limit": "^11.1.6", "socket.io-client": "^4.5.1", "stream-browserify": "^3.0.0", "ts-jest": "^29.0.3", "ts-node": "^10.9.1", typescript: "^5.6.3" }, peerDependencies: { "cross-fetch": "^4.0.0", eciesjs: "*", eventemitter2: "^6.4.9", "readable-stream": "^3.6.2", "socket.io-client": "^4.5.1" }, publishConfig: { access: "public", registry: "https://registry.npmjs.org/" }, lavamoat: { allowScripts: { "@lavamoat/preinstall-always-fail": false, canvas: true, "eciesjs>secp256k1": false, "socket.io-client>engine.io-client>ws>bufferutil": false, "socket.io-client>engine.io-client>ws>utf-8-validate": false, bufferutil: false, "utf-8-validate": false } } };
var fo = "https://metamask-sdk.api.cx.metamask.io/";
var po = ["websocket"];
var go = 6048e5;
var mo = 3e3;
var yo = { METAMASK_GETPROVIDERSTATE: "metamask_getProviderState", METAMASK_CONNECTSIGN: "metamask_connectSign", METAMASK_CONNECTWITH: "metamask_connectWith", METAMASK_OPEN: "metamask_open", METAMASK_BATCH: "metamask_batch", PERSONAL_SIGN: "personal_sign", WALLET_REQUESTPERMISSIONS: "wallet_requestPermissions", WALLET_REVOKEPERMISSIONS: "wallet_revokePermissions", WALLET_GETPERMISSIONS: "wallet_getPermissions", WALLET_WATCHASSET: "wallet_watchAsset", WALLET_SWITCHETHEREUMCHAIN: "wallet_switchEthereumChain", WALLET_ADDETHEREUMCHAIN: "wallet_addEthereumChain", ETH_REQUESTACCOUNTS: "eth_requestAccounts", ETH_ACCOUNTS: "eth_accounts", ETH_CHAINID: "eth_chainId", ETH_SENDTRANSACTION: "eth_sendTransaction", ETH_SIGNTYPEDDATA: "eth_signTypedData", ETH_SIGNTYPEDDATA_V3: "eth_signTypedData_v3", ETH_SIGNTYPEDDATA_V4: "eth_signTypedData_v4", ETH_SIGNTRANSACTION: "eth_signTransaction", ETH_SIGN: "eth_sign", PERSONAL_EC_RECOVER: "personal_ecRecover" };
var vo = [yo.METAMASK_CONNECTSIGN, yo.METAMASK_CONNECTWITH, yo.METAMASK_OPEN, yo.METAMASK_BATCH, yo.PERSONAL_SIGN, yo.WALLET_REQUESTPERMISSIONS, yo.WALLET_REVOKEPERMISSIONS, yo.WALLET_WATCHASSET, yo.ETH_SENDTRANSACTION, yo.ETH_SIGNTYPEDDATA, yo.ETH_SIGNTYPEDDATA_V3, yo.ETH_SIGNTYPEDDATA_V4, yo.ETH_SIGNTRANSACTION, yo.ETH_SIGN, yo.PERSONAL_EC_RECOVER];
function bo(e9) {
  return vo.includes(e9);
}
function wo(e9) {
  const { context: t3 } = e9;
  oo.RemoteCommunication(`[RemoteCommunication: clean()] context=${t3}`), e9.channelConfig = void 0, e9.ready = false, e9.originatorConnectStarted = false;
}
var Eo;
var So;
var _o;
var Co;
var ko;
var Ao;
var xo;
(xo = Eo || (Eo = {})).DISCONNECTED = "disconnected", xo.WAITING = "waiting", xo.TIMEOUT = "timeout", xo.LINKED = "linked", xo.PAUSED = "paused", xo.TERMINATED = "terminated", function(e9) {
  e9.KEY_INFO = "key_info", e9.SERVICE_STATUS = "service_status", e9.PROVIDER_UPDATE = "provider_update", e9.RPC_UPDATE = "rpc_update", e9.KEYS_EXCHANGED = "keys_exchanged", e9.JOIN_CHANNEL = "join_channel", e9.PUBLIC_KEY = "public_key", e9.CHANNEL_CREATED = "channel_created", e9.CLIENTS_CONNECTED = "clients_connected", e9.CLIENTS_DISCONNECTED = "clients_disconnected", e9.CLIENTS_WAITING = "clients_waiting", e9.CLIENTS_READY = "clients_ready", e9.REJECTED = "rejected", e9.WALLET_INIT = "wallet_init", e9.CHANNEL_PERSISTENCE = "channel_persistence", e9.CONFIG = "config", e9.MESSAGE_ACK = "ack", e9.SOCKET_DISCONNECTED = "socket_disconnected", e9.SOCKET_RECONNECT = "socket_reconnect", e9.OTP = "otp", e9.SDK_RPC_CALL = "sdk_rpc_call", e9.AUTHORIZED = "authorized", e9.CONNECTION_STATUS = "connection_status", e9.MESSAGE = "message", e9.TERMINATE = "terminate";
}(So || (So = {})), (_o || (_o = {})).KEY_EXCHANGE = "key_exchange", function(e9) {
  e9.KEY_HANDSHAKE_START = "key_handshake_start", e9.KEY_HANDSHAKE_CHECK = "key_handshake_check", e9.KEY_HANDSHAKE_SYN = "key_handshake_SYN", e9.KEY_HANDSHAKE_SYNACK = "key_handshake_SYNACK", e9.KEY_HANDSHAKE_ACK = "key_handshake_ACK", e9.KEY_HANDSHAKE_WALLET = "key_handshake_wallet", e9.KEY_HANDSHAKE_NONE = "none";
}(Co || (Co = {}));
var Mo = class extends import_eventemitter2.EventEmitter2 {
  constructor({ communicationLayer: e9, otherPublicKey: t3, context: n6, ecies: r2, logging: i4 }) {
    super(), this.keysExchanged = false, this.step = Co.KEY_HANDSHAKE_NONE, this.debug = false, this.context = n6, this.communicationLayer = e9, (null == r2 ? void 0 : r2.privateKey) && t3 && (oo.KeyExchange(`[KeyExchange: constructor()] otherPubKey=${t3} set keysExchanged to true!`, r2), this.keysExchanged = true), this.myECIES = new uo(Object.assign(Object.assign({}, r2), { debug: null == i4 ? void 0 : i4.eciesLayer })), this.communicationLayer.state.eciesInstance = this.myECIES, this.myPublicKey = this.myECIES.getPublicKey(), this.debug = true === (null == i4 ? void 0 : i4.keyExchangeLayer), t3 && this.setOtherPublicKey(t3), this.communicationLayer.on(_o.KEY_EXCHANGE, this.onKeyExchangeMessage.bind(this));
  }
  onKeyExchangeMessage(e9) {
    const { relayPersistence: t3 } = this.communicationLayer.remote.state;
    if (oo.KeyExchange(`[KeyExchange: onKeyExchangeMessage()] context=${this.context} keysExchanged=${this.keysExchanged} relayPersistence=${t3}`, e9), t3) return void oo.KeyExchange("[KeyExchange: onKeyExchangeMessage()] Ignoring key exchange message because relay persistence is activated");
    const { message: n6 } = e9;
    this.keysExchanged && oo.KeyExchange(`[KeyExchange: onKeyExchangeMessage()] context=${this.context} received handshake while already exchanged. step=${this.step} otherPubKey=${this.otherPublicKey}`), this.emit(So.KEY_INFO, n6.type), n6.type === Co.KEY_HANDSHAKE_SYN ? (this.checkStep([Co.KEY_HANDSHAKE_NONE, Co.KEY_HANDSHAKE_ACK]), oo.KeyExchange("[KeyExchange: onKeyExchangeMessage()] KEY_HANDSHAKE_SYN", n6), n6.pubkey && this.setOtherPublicKey(n6.pubkey), this.communicationLayer.sendMessage({ type: Co.KEY_HANDSHAKE_SYNACK, pubkey: this.myPublicKey }).catch((e10) => {
      oo.KeyExchange("[KeyExchange: onKeyExchangeMessage()] Error sending KEY_HANDSHAKE_SYNACK", e10);
    }), this.setStep(Co.KEY_HANDSHAKE_ACK)) : n6.type === Co.KEY_HANDSHAKE_SYNACK ? (this.checkStep([Co.KEY_HANDSHAKE_SYNACK, Co.KEY_HANDSHAKE_ACK, Co.KEY_HANDSHAKE_NONE]), oo.KeyExchange("[KeyExchange: onKeyExchangeMessage()] KEY_HANDSHAKE_SYNACK"), n6.pubkey && this.setOtherPublicKey(n6.pubkey), this.communicationLayer.sendMessage({ type: Co.KEY_HANDSHAKE_ACK }).catch((e10) => {
      oo.KeyExchange("[KeyExchange: onKeyExchangeMessage()] Error sending KEY_HANDSHAKE_ACK", e10);
    }), this.keysExchanged = true, this.setStep(Co.KEY_HANDSHAKE_ACK), this.emit(So.KEYS_EXCHANGED)) : n6.type === Co.KEY_HANDSHAKE_ACK && (oo.KeyExchange("[KeyExchange: onKeyExchangeMessage()] KEY_HANDSHAKE_ACK set keysExchanged to true!"), this.checkStep([Co.KEY_HANDSHAKE_ACK, Co.KEY_HANDSHAKE_NONE]), this.keysExchanged = true, this.setStep(Co.KEY_HANDSHAKE_ACK), this.emit(So.KEYS_EXCHANGED));
  }
  resetKeys(e9) {
    this.clean(), this.myECIES = new uo(e9);
  }
  clean() {
    oo.KeyExchange(`[KeyExchange: clean()] context=${this.context} reset handshake state`), this.setStep(Co.KEY_HANDSHAKE_NONE), this.emit(So.KEY_INFO, this.step), this.keysExchanged = false;
  }
  start({ isOriginator: e9, force: t3 }) {
    const { relayPersistence: n6, protocolVersion: r2 } = this.communicationLayer.remote.state, i4 = r2 >= 2;
    n6 ? oo.KeyExchange("[KeyExchange: start()] Ignoring key exchange message because relay persistence is activated") : (oo.KeyExchange(`[KeyExchange: start()] context=${this.context} protocolVersion=${r2} isOriginator=${e9} step=${this.step} force=${t3} relayPersistence=${n6} keysExchanged=${this.keysExchanged}`), e9 ? !(this.keysExchanged || this.step !== Co.KEY_HANDSHAKE_NONE && this.step !== Co.KEY_HANDSHAKE_SYNACK) || t3 ? (oo.KeyExchange(`[KeyExchange: start()] context=${this.context} -- start key exchange (force=${t3}) -- step=${this.step}`, this.step), this.clean(), this.setStep(Co.KEY_HANDSHAKE_SYNACK), this.communicationLayer.sendMessage({ type: Co.KEY_HANDSHAKE_SYN, pubkey: this.myPublicKey, v: 2 }).catch((e10) => {
      oo.KeyExchange("[KeyExchange: start()] Error sending KEY_HANDSHAKE_SYN", e10);
    })) : oo.KeyExchange(`[KeyExchange: start()] context=${this.context} -- key exchange already ${this.keysExchanged ? "done" : "in progress"} -- aborted.`, this.step) : this.keysExchanged && true !== t3 ? oo.KeyExchange("[KeyExchange: start()] don't send KEY_HANDSHAKE_START -- exchange already done.") : i4 ? this.communicationLayer.sendMessage({ type: Co.KEY_HANDSHAKE_SYNACK, pubkey: this.myPublicKey, v: 2 }).catch((e10) => {
      oo.KeyExchange("[KeyExchange: start()] Error sending KEY_HANDSHAKE_SYNACK", e10);
    }) : (this.communicationLayer.sendMessage({ type: Co.KEY_HANDSHAKE_START }).catch((e10) => {
      oo.KeyExchange("[KeyExchange: start()] Error sending KEY_HANDSHAKE_START", e10);
    }), this.clean()));
  }
  setStep(e9) {
    this.step = e9, this.emit(So.KEY_INFO, e9);
  }
  checkStep(e9) {
    e9.length > 0 && e9.indexOf(this.step.toString());
  }
  setRelayPersistence({ localKey: e9, otherKey: t3 }) {
    this.otherPublicKey = t3, this.myECIES = new uo({ privateKey: e9, debug: this.debug }), this.keysExchanged = true;
  }
  setKeysExchanged(e9) {
    this.keysExchanged = e9;
  }
  areKeysExchanged() {
    return this.keysExchanged;
  }
  getMyPublicKey() {
    return this.myPublicKey;
  }
  getOtherPublicKey() {
    return this.otherPublicKey;
  }
  setOtherPublicKey(e9) {
    oo.KeyExchange("[KeyExchange: setOtherPubKey()]", e9), this.otherPublicKey = e9;
  }
  encryptMessage(e9) {
    if (!this.otherPublicKey) throw new Error("encryptMessage: Keys not exchanged - missing otherPubKey");
    return this.myECIES.encrypt(e9, this.otherPublicKey);
  }
  decryptMessage(e9) {
    if (!this.otherPublicKey) throw new Error("decryptMessage: Keys not exchanged - missing otherPubKey");
    return this.myECIES.decrypt(e9);
  }
  getKeyInfo() {
    return { ecies: Object.assign(Object.assign({}, this.myECIES.getKeyInfo()), { otherPubKey: this.otherPublicKey }), step: this.step, keysExchanged: this.areKeysExchanged() };
  }
  toString() {
    const e9 = { keyInfo: this.getKeyInfo(), keysExchanged: this.keysExchanged, step: this.step };
    return JSON.stringify(e9);
  }
};
!function(e9) {
  e9.TERMINATE = "terminate", e9.ANSWER = "answer", e9.OFFER = "offer", e9.CANDIDATE = "candidate", e9.JSONRPC = "jsonrpc", e9.WALLET_INFO = "wallet_info", e9.WALLET_INIT = "wallet_init", e9.ORIGINATOR_INFO = "originator_info", e9.PAUSE = "pause", e9.OTP = "otp", e9.AUTHORIZED = "authorized", e9.PING = "ping", e9.READY = "ready";
}(ko || (ko = {})), function(e9) {
  e9.REQUEST = "sdk_connect_request_started", e9.REQUEST_MOBILE = "sdk_connect_request_started_mobile", e9.RECONNECT = "sdk_reconnect_request_started", e9.CONNECTED = "sdk_connection_established", e9.CONNECTED_MOBILE = "sdk_connection_established_mobile", e9.AUTHORIZED = "sdk_connection_authorized", e9.REJECTED = "sdk_connection_rejected", e9.TERMINATED = "sdk_connection_terminated", e9.DISCONNECTED = "sdk_disconnected", e9.SDK_USE_EXTENSION = "sdk_use_extension", e9.SDK_RPC_REQUEST = "sdk_rpc_request", e9.SDK_RPC_REQUEST_RECEIVED = "sdk_rpc_request_received", e9.SDK_RPC_REQUEST_DONE = "sdk_rpc_request_done", e9.SDK_EXTENSION_UTILIZED = "sdk_extension_utilized", e9.SDK_USE_INAPP_BROWSER = "sdk_use_inapp_browser";
}(Ao || (Ao = {}));
var Io = (e9, t3, n6) => c2(void 0, void 0, void 0, function* () {
  var r2, i4, o3, s2, a, c3;
  const { remote: l5, state: d3 } = e9, { channelId: u2, isOriginator: h3 } = d3;
  if ("error_terminated" === t3) return oo.SocketService(`handleJoinChannelResults: Channel ${u2} terminated`), void e9.emit(So.TERMINATE);
  if (!n6) return void oo.SocketService(`handleJoinChannelResults: No result for channel ${u2}`);
  const { persistence: f4, walletKey: p4, rejected: g2 } = n6;
  if (oo.SocketService(`handleJoinChannelResults: Channel ${u2} persistence=${f4} walletKey=${p4} rejected=${g2}`), g2) return oo.SocketService(`handleJoinChannelResults: Channel ${u2} rejected`), yield e9.remote.disconnect({ terminate: true }), e9.remote.emit(So.REJECTED, { channelId: u2 }), void e9.remote.emitServiceStatusEvent();
  if (p4 && !(null === (r2 = l5.state.channelConfig) || void 0 === r2 ? void 0 : r2.otherKey)) {
    e9.getKeyExchange().setOtherPublicKey(p4), null === (i4 = e9.state.keyExchange) || void 0 === i4 || i4.setKeysExchanged(true), l5.state.ready = true, l5.state.authorized = true, l5.emit(So.AUTHORIZED);
    const { communicationLayer: t4, storageManager: n7 } = l5.state, r3 = Object.assign(Object.assign({}, l5.state.channelConfig), { channelId: null !== (o3 = l5.state.channelId) && void 0 !== o3 ? o3 : "", validUntil: Date.now() + go, localKey: null == t4 ? void 0 : t4.getKeyInfo().ecies.private, otherKey: p4 });
    e9.sendMessage({ type: Co.KEY_HANDSHAKE_ACK }).catch((e10) => {
    }), null === (s2 = e9.state.socket) || void 0 === s2 || s2.emit(ko.PING, { id: u2, clientType: h3 ? "dapp" : "wallet", context: "on_channel_reconnect", message: "" }), yield null == n7 ? void 0 : n7.persistChannelConfig(r3), l5.emitServiceStatusEvent(), l5.setConnectionStatus(Eo.LINKED);
  }
  f4 && (e9.emit(So.CHANNEL_PERSISTENCE), null === (a = e9.state.keyExchange) || void 0 === a || a.setKeysExchanged(true), l5.state.ready = true, l5.state.authorized = true, l5.emit(So.AUTHORIZED), lo(Object.assign(Object.assign({ id: null != u2 ? u2 : "", event: h3 ? Ao.CONNECTED : Ao.CONNECTED_MOBILE }, e9.remote.state.originatorInfo), { sdkVersion: e9.remote.state.sdkVersion, commLayer: e9.state.communicationLayerPreference, commLayerVersion: ho.version, walletVersion: null === (c3 = e9.remote.state.walletInfo) || void 0 === c3 ? void 0 : c3.version }), d3.communicationServerUrl).catch((e10) => {
  }));
});
var To = (e9) => new Promise((t3) => {
  setTimeout(t3, e9);
});
var Ro = (e9, t3, ...n6) => c2(void 0, [e9, t3, ...n6], void 0, function* (e10, t4, n7 = 200) {
  let r2;
  const i4 = Date.now();
  let o3 = false;
  for (; !o3; ) {
    if (o3 = Date.now() - i4 > 3e5, r2 = t4[e10], void 0 !== r2.elapsedTime) return r2;
    yield To(n7);
  }
  throw new Error(`RPC ${e10} timed out`);
});
var Po = (e9) => c2(void 0, void 0, void 0, function* () {
  const { state: t3 } = e9, { socket: n6, channelId: r2, context: i4, isOriginator: o3, isReconnecting: s2 } = t3;
  if (s2) return oo.SocketService("[SocketService: reconnectSocket()] Reconnection already in progress, skipping", e9), false;
  if (!n6) return oo.SocketService("[SocketService: reconnectSocket()] socket is not defined", e9), false;
  if (!r2) return false;
  const { connected: a } = n6;
  t3.isReconnecting = true, t3.reconnectionAttempts = 0, oo.SocketService(`[SocketService: reconnectSocket()] connected=${a} trying to reconnect after socketio disconnection`, e9);
  try {
    for (; 3 > t3.reconnectionAttempts; ) {
      if (oo.SocketService(`[SocketService: reconnectSocket()] Attempt ${t3.reconnectionAttempts + 1} of 3`, e9), yield To(200), n6.connected) return oo.SocketService("Socket already connected --- ping to retrieve messages"), n6.emit(ko.PING, { id: r2, clientType: o3 ? "dapp" : "wallet", context: "on_channel_config", message: "" }), true;
      t3.resumed = true, n6.connect(), e9.emit(So.SOCKET_RECONNECT);
      try {
        if (yield new Promise((t4, s3) => {
          n6.emit(So.JOIN_CHANNEL, { channelId: r2, context: `${i4}connect_again`, clientType: o3 ? "dapp" : "wallet" }, (n7, r3) => c2(void 0, void 0, void 0, function* () {
            try {
              yield Io(e9, n7, r3), t4();
            } catch (e10) {
              s3(e10);
            }
          }));
        }), yield To(100), n6.connected) return oo.SocketService(`Reconnection successful on attempt ${t3.reconnectionAttempts + 1}`), true;
      } catch (e10) {
        oo.SocketService(`Error during reconnection attempt ${t3.reconnectionAttempts + 1}:`, e10);
      }
      t3.reconnectionAttempts += 1, 3 > t3.reconnectionAttempts && (yield To(200));
    }
    return oo.SocketService("Failed to reconnect after 3 attempts"), false;
  } finally {
    t3.isReconnecting = false, t3.reconnectionAttempts = 0;
  }
});
function Oo(e9, t3) {
  return c2(this, void 0, void 0, function* () {
    var n6;
    const r2 = null === (n6 = e9.state.keyExchange) || void 0 === n6 ? void 0 : n6.encryptMessage(JSON.stringify(t3)), i4 = { id: e9.state.channelId, context: e9.state.context, clientType: e9.state.isOriginator ? "dapp" : "wallet", message: r2, plaintext: e9.state.hasPlaintext ? JSON.stringify(t3) : void 0 };
    return oo.SocketService(`[SocketService: encryptAndSendMessage()] context=${e9.state.context}`, i4), t3.type === ko.TERMINATE && (e9.state.manualDisconnect = true), new Promise((t4, n7) => {
      var r3;
      null === (r3 = e9.state.socket) || void 0 === r3 || r3.emit(So.MESSAGE, i4, (e10, r4) => {
        var i5;
        e10 && (oo.SocketService(`[SocketService: encryptAndSendMessage()] error=${e10}`), n7(e10)), oo.SocketService("[encryptAndSendMessage] response", r4), t4(null !== (i5 = null == r4 ? void 0 : r4.success) && void 0 !== i5 && i5);
      });
    });
  });
}
var No;
!function(e9) {
  e9.RPC_CHECK = "rpcCheck", e9.SKIPPED_RPC = "skippedRpc";
}(No || (No = {}));
var Lo = ["eth_sendTransaction", "eth_signTypedData", "eth_signTransaction", "personal_sign", "wallet_requestPermissions", "wallet_switchEthereumChain", "eth_signTypedData_v3", "eth_signTypedData_v4", "metamask_connectSign", "metamask_connectWith", "metamask_batch"].map((e9) => e9.toLowerCase());
var Do = [{ event: So.CLIENTS_CONNECTED, handler: function(e9, t3) {
  return (n6) => c2(this, void 0, void 0, function* () {
    var n7, r2, i4, o3, s2, a, c3, l5, d3, u2, h3;
    const f4 = null !== (r2 = null === (n7 = e9.remote.state.channelConfig) || void 0 === n7 ? void 0 : n7.relayPersistence) && void 0 !== r2 && r2;
    if (oo.SocketService(`[SocketService: handleClientsConnected()] context=${e9.state.context} on 'clients_connected-${t3}' relayPersistence=${f4} resumed=${e9.state.resumed}  clientsPaused=${e9.state.clientsPaused} keysExchanged=${null === (i4 = e9.state.keyExchange) || void 0 === i4 ? void 0 : i4.areKeysExchanged()} isOriginator=${e9.state.isOriginator}`), e9.emit(So.CLIENTS_CONNECTED, { isOriginator: e9.state.isOriginator, keysExchanged: null === (o3 = e9.state.keyExchange) || void 0 === o3 ? void 0 : o3.areKeysExchanged(), context: e9.state.context }), e9.state.resumed) e9.state.isOriginator || (oo.SocketService(`[SocketService: handleClientsConnected()] context=${e9.state.context} 'clients_connected' / keysExchanged=${null === (s2 = e9.state.keyExchange) || void 0 === s2 ? void 0 : s2.areKeysExchanged()} -- backward compatibility`), null === (a = e9.state.keyExchange) || void 0 === a || a.start({ isOriginator: null !== (c3 = e9.state.isOriginator) && void 0 !== c3 && c3 })), e9.state.resumed = false;
    else if (e9.state.clientsPaused) oo.SocketService("[SocketService: handleClientsConnected()] 'clients_connected' skip sending originatorInfo on pause");
    else if (!e9.state.isOriginator) {
      const t4 = !f4;
      oo.SocketService(`[SocketService: handleClientsConnected()] context=${e9.state.context} on 'clients_connected' / keysExchanged=${null === (l5 = e9.state.keyExchange) || void 0 === l5 ? void 0 : l5.areKeysExchanged()} -- force=${t4} -- backward compatibility`), oo.SocketService(`[SocketService: handleClientsConnected()] context=${e9.state.context} on 'clients_connected' / keysExchanged=${null === (d3 = e9.state.keyExchange) || void 0 === d3 ? void 0 : d3.areKeysExchanged()} -- force=${t4} -- backward compatibility`), null === (u2 = e9.state.keyExchange) || void 0 === u2 || u2.start({ isOriginator: null !== (h3 = e9.state.isOriginator) && void 0 !== h3 && h3, force: t4 });
    }
    e9.state.clientsConnected = true, e9.state.clientsPaused = false;
  });
} }, { event: So.CHANNEL_CREATED, handler: function(e9, t3) {
  return (n6) => {
    oo.SocketService(`[SocketService: handleChannelCreated()] context=${e9.state.context} on 'channel_created-${t3}'`, n6), e9.emit(So.CHANNEL_CREATED, n6);
  };
} }, { event: So.CLIENTS_DISCONNECTED, handler: function(e9, t3) {
  return () => {
    var n6;
    e9.state.clientsConnected = false, oo.SocketService(`[SocketService: handlesClientsDisconnected()] context=${e9.state.context} on 'clients_disconnected-${t3}'`), e9.remote.state.relayPersistence ? oo.SocketService(`[SocketService: handlesClientsDisconnected()] context=${e9.state.context} on 'clients_disconnected-${t3}' - relayPersistence enabled, skipping key exchange cleanup.`) : (e9.state.isOriginator && !e9.state.clientsPaused && (null === (n6 = e9.state.keyExchange) || void 0 === n6 || n6.clean()), e9.emit(So.CLIENTS_DISCONNECTED, t3));
  };
} }, { event: So.CONFIG, handler: function(e9, t3) {
  return (n6) => c2(this, void 0, void 0, function* () {
    var r2, i4, o3;
    oo.SocketService(`[SocketService: handleChannelConfig()] update relayPersistence on 'config-${t3}'`, n6);
    const { persistence: s2, walletKey: a } = n6;
    e9.state.isOriginator && e9.remote.state.channelConfig ? (n6.walletKey && !e9.remote.state.channelConfig.otherKey && (oo.SocketService(`Setting wallet key ${a}`), e9.remote.state.channelConfig.otherKey = a, e9.getKeyExchange().setOtherPublicKey(n6.walletKey), null === (r2 = e9.state.keyExchange) || void 0 === r2 || r2.setKeysExchanged(true), yield e9.remote.sendMessage({ type: Co.KEY_HANDSHAKE_ACK }), yield e9.remote.sendMessage({ type: ko.PING }), yield null === (i4 = e9.remote.state.storageManager) || void 0 === i4 ? void 0 : i4.persistChannelConfig(e9.remote.state.channelConfig)), true !== s2 || e9.remote.state.channelConfig.relayPersistence || (oo.SocketService(`Setting relay persistence ${s2}`), e9.remote.state.channelConfig.relayPersistence = s2, e9.remote.state.relayPersistence = true, e9.remote.emit(So.CHANNEL_PERSISTENCE), e9.remote.state.authorized = true, e9.remote.state.ready = true, e9.remote.emit(So.AUTHORIZED), yield null === (o3 = e9.remote.state.storageManager) || void 0 === o3 ? void 0 : o3.persistChannelConfig(e9.remote.state.channelConfig))) : e9.state.isOriginator || n6.persistence && (e9.remote.state.relayPersistence = true, e9.remote.emit(So.CHANNEL_PERSISTENCE));
  });
} }, { event: So.MESSAGE, handler: function(e9, t3) {
  return (r2) => {
    var i4, o3, s2, a, c3, l5, d3, u2, h3, f4, p4, g2, m4, y2, v2, b3, w5, E4;
    const { ackId: S5, message: _2, error: C4 } = r2, k3 = null !== (i4 = e9.remote.state.relayPersistence) && void 0 !== i4 && i4;
    if (oo.SocketService(`[SocketService handleMessage()]  relayPersistence=${k3}  context=${e9.state.context} on 'message' ${t3} keysExchanged=${null === (o3 = e9.state.keyExchange) || void 0 === o3 ? void 0 : o3.areKeysExchanged()}`, r2), C4) throw oo.SocketService(`
      [SocketService handleMessage()] context=${e9.state.context}::on 'message' error=${C4}`), new Error(C4);
    const A3 = "string" == typeof _2;
    if (!A3 && (null == _2 ? void 0 : _2.type) === Co.KEY_HANDSHAKE_START) {
      if (k3) return;
      return oo.SocketService(`[SocketService handleMessage()] context=${e9.state.context}::on 'message' received HANDSHAKE_START isOriginator=${e9.state.isOriginator}`, _2), void (null === (s2 = e9.state.keyExchange) || void 0 === s2 || s2.start({ isOriginator: null !== (a = e9.state.isOriginator) && void 0 !== a && a, force: true }));
    }
    if (!A3 && (null === (c3 = null == _2 ? void 0 : _2.type) || void 0 === c3 ? void 0 : c3.startsWith("key_handshake"))) {
      if (k3) return;
      return oo.SocketService(`[SocketService handleMessage()] context=${e9.state.context}::on 'message' emit KEY_EXCHANGE`, _2), void e9.emit(_o.KEY_EXCHANGE, { message: _2, context: e9.state.context });
    }
    if (A3 && !(null === (l5 = e9.state.keyExchange) || void 0 === l5 ? void 0 : l5.areKeysExchanged())) {
      let t4 = false;
      try {
        oo.SocketService(`[SocketService handleMessage()] context=${e9.state.context}::on 'message' trying to decrypt message`), null === (d3 = e9.state.keyExchange) || void 0 === d3 || d3.decryptMessage(_2), t4 = true;
      } catch (t5) {
        oo.SocketService(`[SocketService handleMessage()] context=${e9.state.context}::on 'message' error`, t5);
      }
      if (!t4) return e9.state.isOriginator ? null === (h3 = e9.state.keyExchange) || void 0 === h3 || h3.start({ isOriginator: null !== (f4 = e9.state.isOriginator) && void 0 !== f4 && f4 }) : e9.sendMessage({ type: Co.KEY_HANDSHAKE_START }).catch((e10) => {
      }), void oo.SocketService(`Message ignored because invalid key exchange status. step=${null === (p4 = e9.state.keyExchange) || void 0 === p4 ? void 0 : p4.getKeyInfo().step}`, null === (g2 = e9.state.keyExchange) || void 0 === g2 ? void 0 : g2.getKeyInfo(), _2);
      oo.SocketService("Invalid key exchange status detected --- updating it."), null === (u2 = e9.state.keyExchange) || void 0 === u2 || u2.setKeysExchanged(true);
    } else if (!A3 && (null == _2 ? void 0 : _2.type)) return void e9.emit(So.MESSAGE, _2);
    if (!A3) return void e9.emit(So.MESSAGE, _2);
    const x3 = null === (m4 = e9.state.keyExchange) || void 0 === m4 ? void 0 : m4.decryptMessage(_2), M4 = JSON.parse(null != x3 ? x3 : "{}");
    if (S5 && (null == S5 ? void 0 : S5.length) > 0 && (oo.SocketService(`[SocketService handleMessage()] context=${e9.state.context}::on 'message' ackid=${S5} channelId=${t3}`), null === (y2 = e9.state.socket) || void 0 === y2 || y2.emit(So.MESSAGE_ACK, { ackId: S5, channelId: t3, clientType: e9.state.isOriginator ? "dapp" : "wallet" })), e9.state.clientsPaused = (null == M4 ? void 0 : M4.type) === ko.PAUSE, e9.state.isOriginator && M4.data) {
      const t4 = M4.data, r3 = e9.state.rpcMethodTracker[t4.id];
      if (r3) {
        const i5 = Date.now() - r3.timestamp;
        oo.SocketService(`[SocketService handleMessage()] context=${e9.state.context}::on 'message' received answer for id=${t4.id} method=${r3.method} responseTime=${i5}`, M4), e9.remote.state.analytics && Lo.includes(r3.method.toLowerCase()) && lo(Object.assign(Object.assign({ id: null !== (v2 = e9.remote.state.channelId) && void 0 !== v2 ? v2 : "", event: Ao.SDK_RPC_REQUEST_DONE, sdkVersion: e9.remote.state.sdkVersion, commLayerVersion: ho.version }, e9.remote.state.originatorInfo), { walletVersion: null === (b3 = e9.remote.state.walletInfo) || void 0 === b3 ? void 0 : b3.version, params: { method: r3.method, from: "mobile" } }), e9.remote.state.communicationServerUrl).catch((e10) => {
        }), bo(r3.method) && import_sdk_analytics.analytics.track(t4.error ? 4001 === t4.error.code ? "sdk_action_rejected" : "sdk_action_failed" : "sdk_action_succeeded", { action: r3.method });
        const o4 = Object.assign(Object.assign({}, r3), { result: t4.result, error: t4.error ? { code: null === (w5 = t4.error) || void 0 === w5 ? void 0 : w5.code, message: null === (E4 = t4.error) || void 0 === E4 ? void 0 : E4.message } : void 0, elapsedTime: i5 });
        e9.state.rpcMethodTracker[t4.id] = o4, e9.emit(So.RPC_UPDATE, o4);
      }
    }
    e9.emit(So.MESSAGE, { message: M4 });
  };
} }, { event: So.REJECTED, handler: function(e9, t3) {
  return (r2) => c2(this, void 0, void 0, function* () {
    var r3;
    e9.state.isOriginator && !e9.remote.state.ready ? (oo.SocketService(`[SocketService: handleChannelRejected()] context=${e9.state.context} channelId=${t3} isOriginator=${e9.state.isOriginator} ready=${e9.remote.state.ready}`, e9.remote.state.originatorInfo), lo(Object.assign(Object.assign({ id: t3, event: Ao.REJECTED }, e9.remote.state.originatorInfo), { sdkVersion: e9.remote.state.sdkVersion, commLayer: e9.state.communicationLayerPreference, commLayerVersion: ho.version, walletVersion: null === (r3 = e9.remote.state.walletInfo) || void 0 === r3 ? void 0 : r3.version }), e9.remote.state.communicationServerUrl).catch((e10) => {
    }), import_sdk_analytics.analytics.track("sdk_connection_rejected", { transport_type: "websocket" }), yield e9.remote.disconnect({ terminate: true }), e9.remote.emit(So.REJECTED, { channelId: t3 }), e9.remote.setConnectionStatus(Eo.DISCONNECTED)) : oo.SocketService(`[SocketService: handleChannelRejected()] SKIP -- channelId=${t3} isOriginator=${e9.state.isOriginator} ready=${e9.remote.state.ready}`);
  });
} }, { event: "clients_waiting_to_join", handler: function(e9, t3) {
  return (n6) => {
    oo.SocketService(`[SocketService: handleClientsWaitingToJoin()] context=${e9.state.context} on 'clients_waiting_to_join-${t3}'`, n6), e9.emit(So.CLIENTS_WAITING, n6);
  };
} }];
var $o = [{ event: So.KEY_INFO, handler: function(e9) {
  return (t3) => {
    oo.SocketService("[SocketService: handleKeyInfo()] on 'KEY_INFO'", t3), e9.emit(So.KEY_INFO, t3);
  };
} }, { event: So.KEYS_EXCHANGED, handler: function(e9) {
  return () => {
    var t3, n6, r2;
    oo.SocketService(`[SocketService: handleKeysExchanged()] on 'keys_exchanged' keyschanged=${null === (t3 = e9.state.keyExchange) || void 0 === t3 ? void 0 : t3.areKeysExchanged()}`);
    const { channelConfig: i4 } = e9.remote.state;
    if (i4) {
      const t4 = e9.getKeyExchange().getKeyInfo().ecies;
      i4.localKey = t4.private, i4.otherKey = t4.otherPubKey, e9.remote.state.channelConfig = i4, null === (n6 = e9.remote.state.storageManager) || void 0 === n6 || n6.persistChannelConfig(i4).catch((e10) => {
      });
    }
    e9.emit(So.KEYS_EXCHANGED, { keysExchanged: null === (r2 = e9.state.keyExchange) || void 0 === r2 ? void 0 : r2.areKeysExchanged(), isOriginator: e9.state.isOriginator });
    const o3 = { keyInfo: e9.getKeyInfo() };
    e9.emit(So.SERVICE_STATUS, o3);
  };
} }];
function Bo(e9, t3) {
  oo.SocketService(`[SocketService: setupChannelListener()] context=${e9.state.context} setting socket listeners for channel ${t3}...`);
  const { socket: n6 } = e9.state, { keyExchange: r2 } = e9.state;
  n6 && e9.state.isOriginator && (e9.state.debug && (null == n6 || n6.io.on("error", (t4) => {
    oo.SocketService(`[SocketService: setupChannelListener()] context=${e9.state.context} socket event=error`, t4);
  }), null == n6 || n6.io.on("reconnect", (t4) => {
    oo.SocketService(`[SocketService: setupChannelListener()] context=${e9.state.context} socket event=reconnect`, t4), Po(e9).catch((e10) => {
    });
  }), null == n6 || n6.io.on("reconnect_error", (t4) => {
    oo.SocketService(`[SocketService: setupChannelListener()] context=${e9.state.context} socket event=reconnect_error`, t4);
  }), null == n6 || n6.io.on("reconnect_failed", () => {
    oo.SocketService(`[SocketService: setupChannelListener()] context=${e9.state.context} socket event=reconnect_failed`);
  })), null == n6 || n6.on("disconnect", (t4) => (oo.SocketService(`[SocketService: setupChannelListener()] on 'disconnect' -- MetaMaskSDK socket disconnected '${t4}' begin recovery...`), (/* @__PURE__ */ function(e10) {
    return (t5) => {
      oo.SocketService(`[SocketService: handleDisconnect()] on 'disconnect' manualDisconnect=${e10.state.manualDisconnect}`, t5), e10.state.manualDisconnect || (e10.emit(So.SOCKET_DISCONNECTED), Po(e10).catch((e11) => {
      }));
    };
  }(e9))(t4)))), Do.forEach(({ event: r3, handler: i4 }) => {
    null == n6 || n6.on(`${r3}-${t3}`, i4(e9, t3));
  }), $o.forEach(({ event: t4, handler: n7 }) => {
    null == r2 || r2.on(t4, n7(e9));
  }), e9.state.setupChannelListeners = true;
}
var Ko = class extends import_eventemitter2.EventEmitter2 {
  constructor(e9) {
    super(), this.state = { clientsConnected: false, clientsPaused: false, manualDisconnect: false, lastRpcId: void 0, rpcMethodTracker: {}, hasPlaintext: false, communicationServerUrl: "", focusListenerAdded: false, removeFocusListener: void 0, isReconnecting: false, reconnectionAttempts: 0 }, this.options = e9;
    const { reconnect: n6, communicationLayerPreference: r2, communicationServerUrl: i4, context: o3, remote: s2, logging: a } = e9;
    this.state.resumed = n6, this.state.context = o3, this.state.isOriginator = s2.state.isOriginator, this.state.communicationLayerPreference = r2, this.state.debug = true === (null == a ? void 0 : a.serviceLayer), this.remote = s2, true === (null == a ? void 0 : a.serviceLayer) && import_debug.default.enable("SocketService:Layer"), this.state.communicationServerUrl = i4, this.state.hasPlaintext = this.state.communicationServerUrl !== fo && true === (null == a ? void 0 : a.plaintext), oo.SocketService(`[SocketService: constructor()] Socket IO url: ${this.state.communicationServerUrl}`), this.initSocket();
  }
  initSocket() {
    var e9;
    const { otherPublicKey: t3, ecies: n6, logging: r2 } = this.options, i4 = { autoConnect: false, transports: po, withCredentials: true }, o3 = this.state.communicationServerUrl;
    oo.SocketService(`[SocketService: initSocket()] Socket IO url: ${o3}`), this.state.socket = lookup2(o3, i4), function(e10) {
      if ("undefined" != typeof window && "undefined" != typeof document && (oo.SocketService(`[SocketService: setupSocketFocusListener()] hasFocus=${document.hasFocus()}`, e10), !e10.state.focusListenerAdded)) {
        const t4 = () => {
          oo.SocketService("Document has focus --- reconnecting socket"), Po(e10).catch((e11) => {
          });
        };
        window.addEventListener("focus", t4), e10.state.focusListenerAdded = true, e10.state.removeFocusListener = () => {
          window.removeEventListener("focus", t4), e10.state.focusListenerAdded = false;
        };
      }
    }(this);
    const s2 = { communicationLayer: this, otherPublicKey: t3, sendPublicKey: false, context: null !== (e9 = this.state.context) && void 0 !== e9 ? e9 : "", ecies: n6, logging: r2 };
    this.state.keyExchange = new Mo(s2);
  }
  resetKeys() {
    return oo.SocketService("[SocketService: resetKeys()] Resetting keys."), void (null === (e9 = this.state.keyExchange) || void 0 === e9 || e9.resetKeys());
    var e9;
  }
  createChannel() {
    return c2(this, void 0, void 0, function* () {
      return function(e9) {
        return c2(this, void 0, void 0, function* () {
          var t3, n6, r2;
          if (oo.SocketService(`[SocketService: createChannel()] context=${e9.state.context}`), e9.state.socket || e9.initSocket(), null === (t3 = e9.state.socket) || void 0 === t3 ? void 0 : t3.connected) throw new Error("socket already connected");
          null === (n6 = e9.state.socket) || void 0 === n6 || n6.connect(), e9.state.manualDisconnect = false, e9.state.isOriginator = true;
          const i4 = v4_default();
          e9.state.channelId = i4, Bo(e9, i4), yield new Promise((t4, n7) => {
            var r3;
            null === (r3 = e9.state.socket) || void 0 === r3 || r3.emit(So.JOIN_CHANNEL, { channelId: i4, context: `${e9.state.context}createChannel`, clientType: "dapp" }, (r4, i5) => c2(this, void 0, void 0, function* () {
              try {
                yield Io(e9, r4, i5), t4();
              } catch (e10) {
                n7(e10);
              }
            }));
          });
          const o3 = null === (r2 = e9.state.keyExchange) || void 0 === r2 ? void 0 : r2.getKeyInfo();
          return { channelId: i4, pubKey: (null == o3 ? void 0 : o3.ecies.public) || "", privKey: (null == o3 ? void 0 : o3.ecies.private) || "" };
        });
      }(this);
    });
  }
  connectToChannel({ channelId: e9, withKeyExchange: t3 = false, authorized: n6 }) {
    return function(e10) {
      return c2(this, arguments, void 0, function* ({ options: e11, instance: t4 }) {
        const { channelId: n7, authorized: r2, withKeyExchange: i4 } = e11, { state: o3, remote: s2 } = t4, { isOriginator: a = false, socket: l5, keyExchange: d3 } = o3, { channelConfig: u2 } = s2.state;
        if (null == l5 ? void 0 : l5.connected) throw new Error("socket already connected");
        if (a && (null == u2 ? void 0 : u2.relayPersistence)) {
          const { localKey: e12, otherKey: t5 } = u2;
          e12 && t5 && (null == d3 || d3.setRelayPersistence({ localKey: e12, otherKey: t5 }));
        }
        return Object.assign(o3, { manualDisconnect: false, withKeyExchange: i4, isOriginator: a, channelId: n7 }), null == l5 || l5.connect(), Bo(t4, n7), !a && r2 && (null == d3 || d3.setKeysExchanged(true), Object.assign(s2.state, { ready: true, authorized: true })), new Promise((e12) => {
          var i5;
          const s3 = null === (i5 = null == d3 ? void 0 : d3.getKeyInfo()) || void 0 === i5 ? void 0 : i5.ecies.public;
          null == l5 || l5.emit(So.JOIN_CHANNEL, { channelId: n7, context: `${o3.context}_connectToChannel`, clientType: a ? "dapp" : "wallet", publicKey: r2 && !a ? s3 : void 0 }, (n8, r3) => c2(this, void 0, void 0, function* () {
            yield Io(t4, n8, r3), e12();
          }));
        });
      });
    }({ options: { channelId: e9, withKeyExchange: t3, authorized: n6 }, instance: this });
  }
  getKeyInfo() {
    return this.state.keyExchange.getKeyInfo();
  }
  keyCheck() {
    var e9, t3;
    null === (t3 = (e9 = this).state.socket) || void 0 === t3 || t3.emit(So.MESSAGE, { id: e9.state.channelId, context: e9.state.context, message: { type: Co.KEY_HANDSHAKE_CHECK, pubkey: e9.getKeyInfo().ecies.otherPubKey } });
  }
  getKeyExchange() {
    return this.state.keyExchange;
  }
  sendMessage(e9) {
    return c2(this, void 0, void 0, function* () {
      return function(e10, t3) {
        return c2(this, void 0, void 0, function* () {
          var r2, i4, o3;
          if (!e10.state.channelId) throw oo.SocketService("handleSendMessage: no channelId - Create a channel first"), new Error("Create a channel first");
          if (oo.SocketService(`[SocketService: handleSendMessage()] context=${e10.state.context} areKeysExchanged=${null === (r2 = e10.state.keyExchange) || void 0 === r2 ? void 0 : r2.areKeysExchanged()}`, t3), null === (i4 = null == t3 ? void 0 : t3.type) || void 0 === i4 ? void 0 : i4.startsWith("key_handshake")) return function(e11, t4) {
            var n6;
            oo.SocketService(`[SocketService: handleKeyHandshake()] context=${e11.state.context}`, t4), null === (n6 = e11.state.socket) || void 0 === n6 || n6.emit(So.MESSAGE, { id: e11.state.channelId, context: e11.state.context, clientType: e11.state.isOriginator ? "dapp" : "wallet", message: t4 });
          }(e10, t3), true;
          !function(e11, t4) {
            var n6;
            if (!(null === (n6 = e11.state.keyExchange) || void 0 === n6 ? void 0 : n6.areKeysExchanged()) && !e11.remote.state.relayPersistence) throw oo.SocketService(`[SocketService: validateKeyExchange()] context=${e11.state.context} ERROR keys not exchanged`, t4), new Error("Keys not exchanged BBB");
          }(e10, t3), function(e11, t4) {
            var n6;
            const r3 = null !== (n6 = null == t4 ? void 0 : t4.method) && void 0 !== n6 ? n6 : "", i5 = null == t4 ? void 0 : t4.id;
            e11.state.isOriginator && i5 && (e11.state.rpcMethodTracker[i5] = { id: i5, timestamp: Date.now(), method: r3 }, e11.emit(So.RPC_UPDATE, e11.state.rpcMethodTracker[i5]));
          }(e10, t3);
          const s2 = yield Oo(e10, t3);
          return e10.remote.state.analytics && e10.remote.state.isOriginator && t3.method && Lo.includes(t3.method.toLowerCase()) && lo({ id: null !== (o3 = e10.remote.state.channelId) && void 0 !== o3 ? o3 : "", event: Ao.SDK_RPC_REQUEST, params: { method: t3.method, from: "mobile" } }, e10.remote.state.communicationServerUrl).catch((e11) => {
          }), e10.remote.state.isOriginator && t3.method && bo(t3.method) && import_sdk_analytics.analytics.track("sdk_action_requested", { action: t3.method }), function(e11, t4) {
            return c2(this, void 0, void 0, function* () {
              var n6;
              const r3 = null == t4 ? void 0 : t4.id, i5 = null !== (n6 = null == t4 ? void 0 : t4.method) && void 0 !== n6 ? n6 : "";
              if (e11.state.isOriginator && r3) try {
                const n7 = Ro(r3, e11.state.rpcMethodTracker, 200).then((e12) => ({ type: No.RPC_CHECK, result: e12 })), o4 = (() => c2(this, void 0, void 0, function* () {
                  const t5 = yield ((e12) => c2(void 0, [e12], void 0, function* ({ rpcId: e13, instance: t6 }) {
                    for (; t6.state.lastRpcId === e13 || void 0 === t6.state.lastRpcId; ) yield To(200);
                    return t6.state.lastRpcId;
                  }))({ instance: e11, rpcId: r3 }), n8 = yield Ro(t5, e11.state.rpcMethodTracker, 200);
                  return { type: No.SKIPPED_RPC, result: n8 };
                }))(), s3 = yield Promise.race([n7, o4]);
                if (s3.type === No.RPC_CHECK) {
                  const e12 = s3.result;
                  oo.SocketService(`[SocketService:handleRpcReplies()] id=${t4.id} ${i5} ( ${e12.elapsedTime} ms)`, e12.result);
                } else {
                  if (s3.type !== No.SKIPPED_RPC) throw new Error(`Error handling RPC replies for ${r3}`);
                  {
                    const t5 = Object.assign(Object.assign({}, e11.state.rpcMethodTracker[r3]), { error: new Error("SDK_CONNECTION_ISSUE") });
                    e11.emit(So.RPC_UPDATE, t5);
                    const n8 = { data: Object.assign(Object.assign({}, t5), { jsonrpc: "2.0" }), name: "metamask-provider" };
                    e11.emit(So.MESSAGE, { message: n8 });
                  }
                }
              } catch (e12) {
                throw e12;
              }
            });
          }(e10, t3).catch((e11) => {
          }), s2;
        });
      }(this, e9);
    });
  }
  ping() {
    return function(e9) {
      return c2(this, void 0, void 0, function* () {
        var t3, n6;
        oo.SocketService(`[SocketService: ping()] context=${e9.state.context} originator=${e9.state.isOriginator} keysExchanged=${null === (t3 = e9.state.keyExchange) || void 0 === t3 ? void 0 : t3.areKeysExchanged()}`), null === (n6 = e9.state.socket) || void 0 === n6 || n6.emit(ko.PING, { id: e9.state.channelId, context: "ping", clientType: e9.remote.state.isOriginator ? "dapp" : "wallet", message: "" });
      });
    }(this);
  }
  pause() {
    return function(e9) {
      return c2(this, void 0, void 0, function* () {
        var t3, n6;
        oo.SocketService(`[SocketService: pause()] context=${e9.state.context}`), e9.state.manualDisconnect = true, (null === (t3 = e9.state.keyExchange) || void 0 === t3 ? void 0 : t3.areKeysExchanged()) && (yield e9.sendMessage({ type: ko.PAUSE })), null === (n6 = e9.state.socket) || void 0 === n6 || n6.disconnect();
      });
    }(this);
  }
  isConnected() {
    var e9;
    return null === (e9 = this.state.socket) || void 0 === e9 ? void 0 : e9.connected;
  }
  resume() {
    return function(e9) {
      return c2(this, void 0, void 0, function* () {
        const { state: t3, remote: n6 } = e9, { socket: r2, channelId: i4, context: o3, keyExchange: s2, isOriginator: a } = t3, { isOriginator: l5 } = n6.state;
        if (oo.SocketService(`[SocketService: resume()] channelId=${i4} context=${o3} connected=${null == r2 ? void 0 : r2.connected} manualDisconnect=${t3.manualDisconnect} resumed=${t3.resumed} keysExchanged=${null == s2 ? void 0 : s2.areKeysExchanged()}`), !i4) throw oo.SocketService("[SocketService: resume()] channelId is not defined"), new Error("ChannelId is not defined");
        (null == r2 ? void 0 : r2.connected) ? (oo.SocketService("[SocketService: resume()] already connected."), r2.emit(ko.PING, { id: i4, clientType: l5 ? "dapp" : "wallet", context: "on_channel_config", message: "" }), n6.hasRelayPersistence() || (null == s2 ? void 0 : s2.areKeysExchanged()) || (a ? yield e9.sendMessage({ type: ko.READY }) : null == s2 || s2.start({ isOriginator: false }))) : (null == r2 || r2.connect(), oo.SocketService(`[SocketService: resume()] after connecting socket --> connected=${null == r2 ? void 0 : r2.connected}`), null == r2 || r2.emit(So.JOIN_CHANNEL, { channelId: i4, context: `${o3}_resume`, clientType: l5 ? "dapp" : "wallet" }, (t4, n7) => c2(this, void 0, void 0, function* () {
          try {
            yield Io(e9, t4, n7);
          } catch (e10) {
          }
        }))), t3.manualDisconnect = false, t3.resumed = true;
      });
    }(this);
  }
  getRPCMethodTracker() {
    return this.state.rpcMethodTracker;
  }
  disconnect(e9) {
    return function(e10, t3) {
      var n6, r2, i4, o3, s2;
      oo.SocketService(`[SocketService: disconnect()] context=${e10.state.context}`, t3), (null == t3 ? void 0 : t3.terminate) && (null === (r2 = (n6 = e10.state).removeFocusListener) || void 0 === r2 || r2.call(n6), e10.state.channelId = t3.channelId, null === (i4 = e10.state.socket) || void 0 === i4 || i4.removeAllListeners(), null === (o3 = e10.state.keyExchange) || void 0 === o3 || o3.clean(), e10.remote.state.ready = false, e10.state.socket = void 0, e10.state.rpcMethodTracker = {}), e10.state.manualDisconnect = true, null === (s2 = e10.state.socket) || void 0 === s2 || s2.disconnect();
    }(this, e9);
  }
};
var jo;
var Uo;
var Ho;
function Fo(e9) {
  return () => c2(this, void 0, void 0, function* () {
    var t3, n6, r2;
    const { state: i4 } = e9;
    if (i4.authorized) return;
    yield (() => c2(this, void 0, void 0, function* () {
      for (; !i4.walletInfo; ) yield To(500);
    }))();
    const o3 = "7.3".localeCompare((null === (t3 = i4.walletInfo) || void 0 === t3 ? void 0 : t3.version) || "");
    if (oo.RemoteCommunication(`[RemoteCommunication: handleAuthorizedEvent()] HACK 'authorized' version=${null === (n6 = i4.walletInfo) || void 0 === n6 ? void 0 : n6.version} compareValue=${o3}`), 1 !== o3) return;
    const s2 = i4.platformType === Uo.MobileWeb || i4.platformType === Uo.ReactNative || i4.platformType === Uo.MetaMaskMobileWebview;
    oo.RemoteCommunication(`[RemoteCommunication: handleAuthorizedEvent()] HACK 'authorized' platform=${i4.platformType} secure=${s2} channel=${i4.channelId} walletVersion=${null === (r2 = i4.walletInfo) || void 0 === r2 ? void 0 : r2.version}`), s2 && (i4.authorized = true, e9.emit(So.AUTHORIZED));
  });
}
function zo(e9) {
  return (t3) => {
    const { state: n6 } = e9;
    oo.RemoteCommunication(`[RemoteCommunication: handleChannelCreatedEvent()] context=${n6.context} on 'channel_created' channelId=${t3}`), e9.emit(So.CHANNEL_CREATED, t3);
  };
}
function qo(e9, t3) {
  return () => {
    var r2, i4, o3, s2;
    const { state: a } = e9;
    oo.RemoteCommunication(`[RemoteCommunication: handleClientsConnectedEvent()] on 'clients_connected' channel=${a.channelId} keysExchanged=${null === (i4 = null === (r2 = a.communicationLayer) || void 0 === r2 ? void 0 : r2.getKeyInfo()) || void 0 === i4 ? void 0 : i4.keysExchanged}`), a.analytics && lo(Object.assign(Object.assign({ id: null !== (o3 = a.channelId) && void 0 !== o3 ? o3 : "", event: a.reconnection ? Ao.RECONNECT : a.isOriginator ? Ao.REQUEST : Ao.REQUEST_MOBILE }, a.originatorInfo), { commLayer: t3, sdkVersion: a.sdkVersion, walletVersion: null === (s2 = a.walletInfo) || void 0 === s2 ? void 0 : s2.version, commLayerVersion: ho.version }), a.communicationServerUrl).catch((e10) => {
    }), a.isOriginator && !a.reconnection && import_sdk_analytics.analytics.track("sdk_connection_established", { transport_type: "websocket" }), a.clientsConnected = true, a.originatorInfoSent = false, e9.emit(So.CLIENTS_CONNECTED);
  };
}
function Wo(e9) {
  return (t3) => {
    const { state: n6 } = e9;
    oo.RemoteCommunication(`[RemoteCommunication: handleClientsDisconnectedEvent()] context=${n6.context} on 'clients_disconnected' channelId=${t3}`), n6.relayPersistence || (n6.clientsConnected = false, n6.ready = false, n6.authorized = false), e9.emit(So.CLIENTS_DISCONNECTED, n6.channelId), e9.setConnectionStatus(Eo.DISCONNECTED);
  };
}
function Vo(e9) {
  return (t3) => {
    var n6;
    const { state: r2 } = e9;
    if (oo.RemoteCommunication(`[RemoteCommunication: handleClientsWaitingEvent()] context=${r2.context} on 'clients_waiting' numberUsers=${t3} ready=${r2.ready} autoStarted=${r2.originatorConnectStarted}`), e9.setConnectionStatus(Eo.WAITING), e9.emit(So.CLIENTS_WAITING, t3), r2.originatorConnectStarted) {
      oo.RemoteCommunication(`[RemoteCommunication: handleClientsWaitingEvent()] on 'clients_waiting' watch autoStarted=${r2.originatorConnectStarted} timeout`, r2.autoConnectOptions);
      const t4 = (null === (n6 = r2.autoConnectOptions) || void 0 === n6 ? void 0 : n6.timeout) || 3e3, i4 = setTimeout(() => {
        oo.RemoteCommunication(`[RemoteCommunication: handleClientsWaitingEvent()] setTimeout(${t4}) terminate channelConfig`, r2.autoConnectOptions), r2.originatorConnectStarted = false, r2.ready || e9.setConnectionStatus(Eo.TIMEOUT), clearTimeout(i4);
      }, t4);
    }
  };
}
function Go(e9, t3) {
  return (n6) => {
    var r2, i4, o3, s2, a, c3, l5, d3;
    const { state: u2 } = e9;
    if (oo.RemoteCommunication(`[RemoteCommunication: handleKeysExchangedEvent()] context=${u2.context} on commLayer.'keys_exchanged' channel=${u2.channelId}`, n6), null === (i4 = null === (r2 = u2.communicationLayer) || void 0 === r2 ? void 0 : r2.getKeyInfo()) || void 0 === i4 ? void 0 : i4.keysExchanged) {
      const t4 = Object.assign(Object.assign({}, u2.channelConfig), { channelId: null !== (o3 = u2.channelId) && void 0 !== o3 ? o3 : "", validUntil: (null === (s2 = u2.channelConfig) || void 0 === s2 ? void 0 : s2.validUntil) || go, localKey: u2.communicationLayer.getKeyInfo().ecies.private, otherKey: u2.communicationLayer.getKeyInfo().ecies.otherPubKey });
      null === (a = u2.storageManager) || void 0 === a || a.persistChannelConfig(t4).catch((e10) => {
      }), e9.setConnectionStatus(Eo.LINKED);
    }
    !function(e10, t4) {
      var n7, r3, i5, o4, s3, a2, c4, l6;
      const { state: d4 } = e10;
      oo.RemoteCommunication(`[RemoteCommunication: setLastActiveDate()] channel=${d4.channelId}`, t4);
      const u3 = Object.assign(Object.assign({}, d4.channelConfig), { channelId: null !== (n7 = d4.channelId) && void 0 !== n7 ? n7 : "", validUntil: null !== (i5 = null === (r3 = d4.channelConfig) || void 0 === r3 ? void 0 : r3.validUntil) && void 0 !== i5 ? i5 : 0, relayPersistence: d4.relayPersistence, localKey: null === (s3 = null === (o4 = d4.communicationLayer) || void 0 === o4 ? void 0 : o4.state.keyExchange) || void 0 === s3 ? void 0 : s3.getKeyInfo().ecies.private, otherKey: null === (c4 = null === (a2 = d4.communicationLayer) || void 0 === a2 ? void 0 : a2.state.keyExchange) || void 0 === c4 ? void 0 : c4.getKeyInfo().ecies.otherPubKey, lastActive: t4.getTime() });
      null === (l6 = d4.storageManager) || void 0 === l6 || l6.persistChannelConfig(u3);
    }(e9, /* @__PURE__ */ new Date()), u2.analytics && u2.channelId && lo(Object.assign(Object.assign({ id: u2.channelId, event: n6.isOriginator ? Ao.CONNECTED : Ao.CONNECTED_MOBILE }, u2.originatorInfo), { sdkVersion: u2.sdkVersion, commLayer: t3, commLayerVersion: ho.version, walletVersion: null === (c3 = u2.walletInfo) || void 0 === c3 ? void 0 : c3.version }), u2.communicationServerUrl).catch((e10) => {
    }), u2.isOriginator = n6.isOriginator, n6.isOriginator || (null === (l5 = u2.communicationLayer) || void 0 === l5 || l5.sendMessage({ type: ko.READY }), u2.ready = true, u2.paused = false), n6.isOriginator && !u2.originatorInfoSent && (null === (d3 = u2.communicationLayer) || void 0 === d3 || d3.sendMessage({ type: ko.ORIGINATOR_INFO, originatorInfo: u2.originatorInfo, originator: u2.originatorInfo }), u2.originatorInfoSent = true);
  };
}
function Yo(e9) {
  return (t3) => {
    let n6 = t3;
    t3.message && (n6 = n6.message), function(e10, t4) {
      const { state: n7 } = t4;
      if (oo.RemoteCommunication(`[RemoteCommunication: onCommunicationLayerMessage()] context=${n7.context} on 'message' typeof=${typeof e10}`, e10), t4.state.ready = true, n7.isOriginator || e10.type !== ko.ORIGINATOR_INFO) if (n7.isOriginator && e10.type === ko.WALLET_INFO) !function(e11, t5) {
        const { state: n8 } = e11;
        n8.walletInfo = t5.walletInfo, n8.paused = false;
      }(t4, e10);
      else {
        if (n7.isOriginator && e10.type === ko.WALLET_INIT) (function(e11, t5) {
          return c2(this, void 0, void 0, function* () {
            var n8, r2, i4;
            const { state: o3 } = e11;
            if (o3.isOriginator) {
              const o4 = t5.data || {};
              if ("object" == typeof o4 && "accounts" in o4 && "chainId" in o4 && "walletKey" in o4) try {
                const { channelConfig: t6 } = e11.state;
                if (oo.RemoteCommunication("WALLET_INIT: channelConfig", JSON.stringify(t6, null, 2)), t6) {
                  const s2 = o4.accounts, a = o4.chainId, c3 = o4.walletKey;
                  let l5, d3 = false;
                  "deeplinkProtocol" in o4 && (d3 = Boolean(o4.deeplinkProtocol), e11.state.deeplinkProtocolAvailable = d3), "walletVersion" in o4 && (l5 = o4.walletVersion), yield null === (n8 = e11.state.storageManager) || void 0 === n8 ? void 0 : n8.persistChannelConfig(Object.assign(Object.assign({}, t6), { otherKey: c3, walletVersion: l5, deeplinkProtocolAvailable: d3, relayPersistence: true })), yield null === (r2 = e11.state.storageManager) || void 0 === r2 ? void 0 : r2.persistAccounts(s2), yield null === (i4 = e11.state.storageManager) || void 0 === i4 ? void 0 : i4.persistChainId(a);
                }
                e11.emit(So.WALLET_INIT, { accounts: o4.accounts, chainId: o4.chainId });
              } catch (n9) {
              }
            }
          });
        })(t4, e10).catch((e11) => {
          oo.RemoteCommunication(`[RemoteCommunication: onCommunicationLayerMessage()] error=${e11}`);
        });
        else if (e10.type === ko.TERMINATE) (function(e11) {
          return c2(this, void 0, void 0, function* () {
            const { state: t5 } = e11;
            t5.isOriginator && (yield es({ options: { terminate: true, sendMessage: false }, instance: e11 }), e11.emit(So.TERMINATE));
          });
        })(t4).catch((e11) => {
          oo.RemoteCommunication(`[RemoteCommunication: onCommunicationLayerMessage()] error=${e11}`);
        });
        else if (e10.type === ko.PAUSE) !function(e11) {
          const { state: t5 } = e11;
          t5.paused = true, e11.setConnectionStatus(Eo.PAUSED);
        }(t4);
        else if (e10.type === ko.READY && n7.isOriginator) !function(e11) {
          const { state: t5 } = e11;
          e11.setConnectionStatus(Eo.LINKED);
          const n8 = t5.paused;
          t5.paused = false, e11.emit(So.CLIENTS_READY, { isOriginator: t5.isOriginator, walletInfo: t5.walletInfo }), n8 && (t5.authorized = true, e11.emit(So.AUTHORIZED));
        }(t4);
        else {
          if (e10.type === ko.OTP && n7.isOriginator) return void function(e11, t5) {
            var n8;
            const { state: r2 } = e11;
            e11.emit(So.OTP, t5.otpAnswer), 1 === "6.6".localeCompare((null === (n8 = r2.walletInfo) || void 0 === n8 ? void 0 : n8.version) || "") && e11.emit(So.SDK_RPC_CALL, { method: yo.ETH_REQUESTACCOUNTS, params: [] });
          }(t4, e10);
          e10.type === ko.AUTHORIZED && n7.isOriginator && function(e11) {
            const { state: t5 } = e11;
            t5.authorized = true, e11.emit(So.AUTHORIZED);
          }(t4);
        }
        t4.emit(So.MESSAGE, e10);
      }
      else !function(e11, t5) {
        var n8;
        const { state: r2 } = e11;
        null === (n8 = r2.communicationLayer) || void 0 === n8 || n8.sendMessage({ type: ko.WALLET_INFO, walletInfo: r2.walletInfo }), r2.originatorInfo = t5.originatorInfo || t5.originator, e11.emit(So.CLIENTS_READY, { isOriginator: r2.isOriginator, originatorInfo: r2.originatorInfo }), r2.paused = false;
      }(t4, e10);
    }(n6, e9);
  };
}
function Zo(e9) {
  return () => {
    const { state: t3 } = e9;
    oo.RemoteCommunication("[RemoteCommunication: handleSocketReconnectEvent()] on 'socket_reconnect' -- reset key exchange status / set ready to false"), t3.ready = false, t3.authorized = false, wo(t3), e9.emitServiceStatusEvent({ context: "socket_reconnect" });
  };
}
function Jo(e9) {
  return () => {
    const { state: t3 } = e9;
    oo.RemoteCommunication("[RemoteCommunication: handleSocketDisconnectedEvent()] on 'socket_Disconnected' set ready to false"), t3.ready = false;
  };
}
function Qo(e9) {
  return () => c2(this, void 0, void 0, function* () {
    var t3, n6, r2, i4, o3, s2, a;
    const { state: c3 } = e9;
    oo.RemoteCommunication(`[RemoteCommunication: handleFullPersistenceEvent()] context=${c3.context}`), e9.state.ready = true, e9.state.clientsConnected = true, e9.state.authorized = true, e9.state.relayPersistence = true, null === (t3 = e9.state.communicationLayer) || void 0 === t3 || t3.getKeyExchange().setKeysExchanged(true), e9.emit(So.KEYS_EXCHANGED, { keysExchanged: true, isOriginator: true }), e9.emit(So.AUTHORIZED), e9.emit(So.CLIENTS_READY), e9.emit(So.CHANNEL_PERSISTENCE);
    try {
      c3.channelConfig = Object.assign(Object.assign({}, c3.channelConfig), { localKey: null === (n6 = c3.communicationLayer) || void 0 === n6 ? void 0 : n6.getKeyExchange().getKeyInfo().ecies.private, otherKey: null === (r2 = c3.communicationLayer) || void 0 === r2 ? void 0 : r2.getKeyExchange().getOtherPublicKey(), channelId: null !== (i4 = c3.channelId) && void 0 !== i4 ? i4 : "", validUntil: null !== (s2 = null === (o3 = c3.channelConfig) || void 0 === o3 ? void 0 : o3.validUntil) && void 0 !== s2 ? s2 : go, relayPersistence: true }), yield null === (a = c3.storageManager) || void 0 === a ? void 0 : a.persistChannelConfig(c3.channelConfig);
    } catch (t4) {
    }
  });
}
function Xo({ communicationLayerPreference: e9, otherPublicKey: t3, reconnect: n6, ecies: r2, communicationServerUrl: i4 = fo, instance: o3 }) {
  var s2, a, c3, l5, d3, u2, h3, f4, p4, g2, m4;
  const { state: y2 } = o3;
  if (oo.RemoteCommunication("[initCommunicationLayer()] ", JSON.stringify(y2, null, 2)), e9 !== jo.SOCKET) throw new Error("Invalid communication protocol");
  y2.communicationLayer = new Ko({ communicationLayerPreference: e9, otherPublicKey: t3, reconnect: n6, transports: y2.transports, communicationServerUrl: i4, context: y2.context, ecies: r2, logging: y2.logging, remote: o3 });
  let v2 = "undefined" != typeof document && document.URL || "", b3 = "undefined" != typeof document && document.title || "";
  (null === (s2 = y2.dappMetadata) || void 0 === s2 ? void 0 : s2.url) && (v2 = y2.dappMetadata.url), (null === (a = y2.dappMetadata) || void 0 === a ? void 0 : a.name) && (b3 = y2.dappMetadata.name);
  const w5 = null !== (u2 = null !== (l5 = null === (c3 = y2.dappMetadata) || void 0 === c3 ? void 0 : c3.name) && void 0 !== l5 ? l5 : null === (d3 = y2.dappMetadata) || void 0 === d3 ? void 0 : d3.url) && void 0 !== u2 ? u2 : "N/A", E4 = "undefined" != typeof window && void 0 !== window.location && null !== (h3 = window.location.hostname) && void 0 !== h3 ? h3 : w5, S5 = { url: v2, title: b3, source: null === (f4 = y2.dappMetadata) || void 0 === f4 ? void 0 : f4.source, dappId: E4, anonId: y2.anonId, icon: (null === (p4 = y2.dappMetadata) || void 0 === p4 ? void 0 : p4.iconUrl) || (null === (g2 = y2.dappMetadata) || void 0 === g2 ? void 0 : g2.base64Icon), platform: y2.platformType, apiVersion: ho.version, connector: null === (m4 = y2.dappMetadata) || void 0 === m4 ? void 0 : m4.connector };
  y2.originatorInfo = S5;
  const _2 = { [So.AUTHORIZED]: Fo(o3), [So.MESSAGE]: Yo(o3), [So.CHANNEL_PERSISTENCE]: Qo(o3), [So.CLIENTS_CONNECTED]: qo(o3, e9), [So.KEYS_EXCHANGED]: Go(o3, e9), [So.SOCKET_DISCONNECTED]: Jo(o3), [So.SOCKET_RECONNECT]: Zo(o3), [So.CLIENTS_DISCONNECTED]: Wo(o3), [So.KEY_INFO]: () => {
  }, [So.CHANNEL_CREATED]: zo(o3), [So.CLIENTS_WAITING]: Vo(o3), [So.RPC_UPDATE]: (e10) => {
    o3.emit(So.RPC_UPDATE, e10);
  } };
  for (const [t4, n7] of Object.entries(_2)) try {
    y2.communicationLayer.on(t4, n7);
  } catch (e10) {
  }
}
function es(e9) {
  return c2(this, arguments, void 0, function* ({ options: e10, instance: t3 }) {
    const { state: n6 } = t3;
    return oo.RemoteCommunication(`[RemoteCommunication: disconnect()] channel=${n6.channelId}`, e10), new Promise((r2, i4) => {
      var o3, a, c3, l5, d3, u2;
      (null == e10 ? void 0 : e10.terminate) ? (t3.state.ready && lo({ id: null !== (o3 = t3.state.channelId) && void 0 !== o3 ? o3 : "", event: Ao.TERMINATED }, t3.state.communicationServerUrl).catch((e11) => {
      }), n6.ready = false, n6.paused = false, null === (a = n6.storageManager) || void 0 === a || a.terminate(null !== (c3 = n6.channelId) && void 0 !== c3 ? c3 : ""), t3.state.terminated = true, e10.sendMessage ? (null === (l5 = n6.communicationLayer) || void 0 === l5 ? void 0 : l5.getKeyInfo().keysExchanged) && t3.state.communicationLayer && Oo(t3.state.communicationLayer, { type: ko.TERMINATE }).then(() => {
        r2(true);
      }).catch((e11) => {
        i4(e11);
      }) : r2(true), n6.authorized = false, n6.relayPersistence = false, n6.channelId = v4_default(), e10.channelId = n6.channelId, n6.channelConfig = void 0, n6.originatorConnectStarted = false, null === (d3 = n6.communicationLayer) || void 0 === d3 || d3.disconnect(e10), t3.setConnectionStatus(Eo.TERMINATED)) : (null === (u2 = n6.communicationLayer) || void 0 === u2 || u2.disconnect(e10), t3.setConnectionStatus(Eo.DISCONNECTED), r2(true));
    });
  });
}
(jo || (jo = {})).SOCKET = "socket", function(e9) {
  e9.NonBrowser = "nodejs", e9.MetaMaskMobileWebview = "in-app-browser", e9.DesktopWeb = "web-desktop", e9.MobileWeb = "web-mobile", e9.ReactNative = "react-native";
}(Uo || (Uo = {}));
var ts = class extends import_eventemitter2.EventEmitter2 {
  constructor(e9) {
    super(), this.state = { ready: false, anonId: "", authorized: false, isOriginator: false, terminated: false, protocolVersion: 1, paused: false, deeplinkProtocolAvailable: false, platformType: "metamask-mobile", analytics: false, reconnection: false, originatorInfoSent: false, communicationServerUrl: fo, context: "", persist: false, clientsConnected: false, sessionDuration: go, originatorConnectStarted: false, debug: false, _connectionStatus: Eo.DISCONNECTED }, this._options = e9;
    const { anonId: n6, platformType: r2, communicationLayerPreference: i4, otherPublicKey: o3, reconnect: s2, walletInfo: a, dappMetadata: c3, protocolVersion: l5, transports: d3, context: u2, relayPersistence: h3, ecies: f4, analytics: p4 = false, storage: g2, sdkVersion: m4, communicationServerUrl: y2 = fo, logging: v2, autoConnect: b3 = { timeout: mo } } = e9;
    this.state.anonId = n6, this.state.otherPublicKey = o3, this.state.dappMetadata = c3, this.state.walletInfo = a, this.state.transports = d3, this.state.platformType = r2, this.state.analytics = p4, this.state.protocolVersion = null != l5 ? l5 : 1, this.state.isOriginator = !o3, this.state.relayPersistence = h3, this.state.communicationServerUrl = y2, this.state.context = u2, this.state.terminated = false, this.state.sdkVersion = m4, this.setMaxListeners(50), this.setConnectionStatus(Eo.DISCONNECTED), (null == g2 ? void 0 : g2.duration) && (this.state.sessionDuration = go), this.state.storageOptions = g2, this.state.autoConnectOptions = b3, this.state.debug = true === (null == v2 ? void 0 : v2.remoteLayer), true === (null == v2 ? void 0 : v2.remoteLayer) && import_debug.default.enable("RemoteCommunication:Layer"), true === (null == v2 ? void 0 : v2.serviceLayer) && import_debug.default.enable("SocketService:Layer"), true === (null == v2 ? void 0 : v2.eciesLayer) && import_debug.default.enable("ECIES:Layer"), true === (null == v2 ? void 0 : v2.keyExchangeLayer) && import_debug.default.enable("KeyExchange:Layer"), this.state.logging = v2, (null == g2 ? void 0 : g2.storageManager) && (this.state.storageManager = g2.storageManager), oo.RemoteCommunication(`[RemoteCommunication: constructor()] protocolVersion=${l5} relayPersistence=${h3} isOriginator=${this.state.isOriginator} communicationLayerPreference=${i4} otherPublicKey=${o3} reconnect=${s2}`), this.state.isOriginator || Xo({ communicationLayerPreference: i4, otherPublicKey: o3, reconnect: s2, ecies: f4, communicationServerUrl: y2, instance: this }), this.emitServiceStatusEvent({ context: "constructor" });
  }
  initFromDappStorage() {
    return c2(this, void 0, void 0, function* () {
      var e9;
      if (this.state.storageManager) {
        const t3 = yield this.state.storageManager.getPersistedChannelConfig({});
        t3 && (this.state.channelConfig = t3, this.state.channelId = t3.channelId, this.state.deeplinkProtocolAvailable = null !== (e9 = t3.deeplinkProtocolAvailable) && void 0 !== e9 && e9, t3.relayPersistence && (this.state.authorized = true, this.state.ready = true, this.setConnectionStatus(Eo.LINKED), yield this.connectToChannel({ channelId: t3.channelId })));
      }
      Xo({ communicationLayerPreference: jo.SOCKET, otherPublicKey: this.state.otherPublicKey, reconnect: this._options.reconnect, ecies: this._options.ecies, communicationServerUrl: this.state.communicationServerUrl, instance: this });
    });
  }
  originatorSessionConnect() {
    return c2(this, void 0, void 0, function* () {
      return yield function(e9) {
        return c2(this, void 0, void 0, function* () {
          var t3;
          const { state: n6 } = e9;
          if (!n6.storageManager) return void oo.RemoteCommunication("[RemoteCommunication: originatorSessionConnect()] no storage manager defined - skip");
          const r2 = yield n6.storageManager.getPersistedChannelConfig({});
          if (oo.RemoteCommunication(`[RemoteCommunication: originatorSessionConnect()] autoStarted=${n6.originatorConnectStarted} channelConfig`, r2), null === (t3 = n6.communicationLayer) || void 0 === t3 ? void 0 : t3.isConnected()) return oo.RemoteCommunication("[RemoteCommunication: originatorSessionConnect()] socket already connected - skip"), r2;
          if (r2) {
            if (r2.validUntil > Date.now()) return n6.channelConfig = r2, n6.originatorConnectStarted = true, n6.channelId = null == r2 ? void 0 : r2.channelId, n6.reconnection = true, r2;
            oo.RemoteCommunication("[RemoteCommunication: autoConnect()] Session has expired");
          }
          n6.originatorConnectStarted = false;
        });
      }(this);
    });
  }
  generateChannelIdConnect() {
    return c2(this, void 0, void 0, function* () {
      return function(e9) {
        return c2(this, void 0, void 0, function* () {
          var t3, n6, r2, i4, o3, s2;
          if (!e9.communicationLayer) throw new Error("communication layer not initialized");
          if (e9.ready) throw new Error("Channel already connected");
          if (e9.channelId && (null === (t3 = e9.communicationLayer) || void 0 === t3 ? void 0 : t3.isConnected())) return e9.channelConfig = Object.assign(Object.assign({}, e9.channelConfig), { channelId: e9.channelId, validUntil: Date.now() + e9.sessionDuration }), null === (n6 = e9.storageManager) || void 0 === n6 || n6.persistChannelConfig(e9.channelConfig), { channelId: e9.channelId, privKey: null === (i4 = null === (r2 = e9.communicationLayer) || void 0 === r2 ? void 0 : r2.getKeyInfo()) || void 0 === i4 ? void 0 : i4.ecies.private, pubKey: null === (s2 = null === (o3 = e9.communicationLayer) || void 0 === o3 ? void 0 : o3.getKeyInfo()) || void 0 === s2 ? void 0 : s2.ecies.public };
          oo.RemoteCommunication("[RemoteCommunication: generateChannelId()]");
          const a = yield e9.communicationLayer.createChannel();
          oo.RemoteCommunication("[RemoteCommunication: generateChannelId()] channel created", a);
          const c3 = Object.assign(Object.assign({}, e9.channelConfig), { channelId: a.channelId, localKey: a.privKey, validUntil: Date.now() + e9.sessionDuration });
          return e9.channelId = a.channelId, e9.channelConfig = c3, { channelId: e9.channelId, pubKey: a.pubKey, privKey: a.privKey };
        });
      }(this.state);
    });
  }
  clean() {
    return wo(this.state);
  }
  connectToChannel({ channelId: e9, withKeyExchange: t3, authorized: n6 }) {
    return function(e10) {
      return c2(this, arguments, void 0, function* ({ channelId: e11, withKeyExchange: t4, authorized: n7, state: r2 }) {
        var i4, s2, a;
        if (!validate_default(e11)) throw oo.RemoteCommunication(`[RemoteCommunication: connectToChannel()] context=${r2.context} invalid channel channelId=${e11}`), new Error(`Invalid channel ${e11}`);
        if (oo.RemoteCommunication(`[RemoteCommunication: connectToChannel()] context=${r2.context} channelId=${e11} withKeyExchange=${t4}`), null === (i4 = r2.communicationLayer) || void 0 === i4 ? void 0 : i4.isConnected()) return void oo.RemoteCommunication(`[RemoteCommunication: connectToChannel()] context=${r2.context} already connected - interrupt connection.`);
        r2.channelId = e11, yield null === (s2 = r2.communicationLayer) || void 0 === s2 ? void 0 : s2.connectToChannel({ channelId: e11, authorized: n7, withKeyExchange: t4 });
        const c3 = Object.assign(Object.assign({}, r2.channelConfig), { channelId: e11, validUntil: Date.now() + r2.sessionDuration });
        r2.channelConfig = c3, null === (a = r2.storageManager) || void 0 === a || a.persistChannelConfig(c3);
      });
    }({ channelId: e9, authorized: n6, withKeyExchange: t3, state: this.state });
  }
  sendMessage(e9) {
    return c2(this, void 0, void 0, function* () {
      const t3 = this.state.isOriginator && e9.method && bo(e9.method);
      t3 && import_sdk_analytics.analytics.track("sdk_action_requested", { action: e9.method });
      try {
        return yield function(e10, t4) {
          return c2(this, void 0, void 0, function* () {
            var n6, r2;
            const { state: i4 } = e10;
            oo.RemoteCommunication(`[RemoteCommunication: sendMessage()] context=${i4.context} paused=${i4.paused} ready=${i4.ready} relayPersistence=${i4.relayPersistence} authorized=${i4.authorized} socket=${null === (n6 = i4.communicationLayer) || void 0 === n6 ? void 0 : n6.isConnected()} clientsConnected=${i4.clientsConnected} status=${i4._connectionStatus}`, t4), i4.relayPersistence || i4.ready && (null === (r2 = i4.communicationLayer) || void 0 === r2 ? void 0 : r2.isConnected()) && i4.clientsConnected || (oo.RemoteCommunication(`[RemoteCommunication: sendMessage()] context=${i4.context}  SKIP message waiting for MM mobile readiness.`), yield new Promise((t5) => {
              e10.once(So.CLIENTS_READY, t5);
            }), oo.RemoteCommunication(`[RemoteCommunication: sendMessage()] context=${i4.context}  AFTER SKIP / READY -- sending pending message`));
            try {
              const n7 = yield function(e11, t5) {
                return c2(this, void 0, void 0, function* () {
                  return new Promise((n8) => {
                    var r3;
                    const { state: i5 } = e11;
                    oo.RemoteCommunication(`[RemoteCommunication: handleAuthorization()] context=${i5.context} ready=${i5.ready} authorized=${i5.authorized} method=${t5.method}`), !i5.isOriginator || i5.authorized || i5.relayPersistence ? null === (r3 = i5.communicationLayer) || void 0 === r3 || r3.sendMessage(t5).then((e12) => {
                      n8(e12);
                    }).catch((e12) => {
                      n8(false);
                    }) : e11.once(So.AUTHORIZED, () => {
                      var e12;
                      oo.RemoteCommunication(`[RemoteCommunication: handleAuthorization()] context=${i5.context}  AFTER SKIP / AUTHORIZED -- sending pending message`), null === (e12 = i5.communicationLayer) || void 0 === e12 || e12.sendMessage(t5).then((e13) => {
                        n8(e13);
                      }).catch((e13) => {
                        n8(false);
                      });
                    });
                  });
                });
              }(e10, t4);
              return n7;
            } catch (e11) {
              throw e11;
            }
          });
        }(this, e9);
      } catch (r2) {
        throw t3 && import_sdk_analytics.analytics.track("sdk_action_failed", { action: e9.method }), r2;
      }
    });
  }
  testStorage() {
    return c2(this, void 0, void 0, function* () {
      return function(e9) {
        return c2(this, void 0, void 0, function* () {
          var t3;
          const n6 = yield null === (t3 = e9.storageManager) || void 0 === t3 ? void 0 : t3.getPersistedChannelConfig();
          oo.RemoteCommunication("[RemoteCommunication: testStorage()] res", n6);
        });
      }(this.state);
    });
  }
  hasDeeplinkProtocol() {
    return this.state.deeplinkProtocolAvailable;
  }
  getChannelConfig() {
    return this.state.channelConfig;
  }
  isReady() {
    return this.state.ready;
  }
  isConnected() {
    var e9;
    return null === (e9 = this.state.communicationLayer) || void 0 === e9 ? void 0 : e9.isConnected();
  }
  isAuthorized() {
    return this.state.authorized;
  }
  isPaused() {
    return this.state.paused;
  }
  getCommunicationLayer() {
    return this.state.communicationLayer;
  }
  ping() {
    return c2(this, void 0, void 0, function* () {
      var e9;
      oo.RemoteCommunication(`[RemoteCommunication: ping()] channel=${this.state.channelId}`), yield null === (e9 = this.state.communicationLayer) || void 0 === e9 ? void 0 : e9.ping();
    });
  }
  testLogger() {
    oo.RemoteCommunication(`testLogger() channel=${this.state.channelId}`), oo.SocketService(`testLogger() channel=${this.state.channelId}`), oo.Ecies(`testLogger() channel=${this.state.channelId}`), oo.KeyExchange(`testLogger() channel=${this.state.channelId}`);
  }
  keyCheck() {
    var e9;
    oo.RemoteCommunication(`[RemoteCommunication: keyCheck()] channel=${this.state.channelId}`), null === (e9 = this.state.communicationLayer) || void 0 === e9 || e9.keyCheck();
  }
  setConnectionStatus(e9) {
    this.state._connectionStatus !== e9 && (this.state._connectionStatus = e9, this.emit(So.CONNECTION_STATUS, e9), this.emitServiceStatusEvent({ context: "setConnectionStatus" }));
  }
  emitServiceStatusEvent(e9 = {}) {
    this.emit(So.SERVICE_STATUS, this.getServiceStatus());
  }
  getConnectionStatus() {
    return this.state._connectionStatus;
  }
  getServiceStatus() {
    return { originatorInfo: this.state.originatorInfo, keyInfo: this.getKeyInfo(), connectionStatus: this.state._connectionStatus, channelConfig: this.state.channelConfig, channelId: this.state.channelId };
  }
  getKeyInfo() {
    var e9;
    return null === (e9 = this.state.communicationLayer) || void 0 === e9 ? void 0 : e9.getKeyInfo();
  }
  resetKeys() {
    var e9;
    null === (e9 = this.state.communicationLayer) || void 0 === e9 || e9.resetKeys();
  }
  setOtherPublicKey(e9) {
    var t3;
    const n6 = null === (t3 = this.state.communicationLayer) || void 0 === t3 ? void 0 : t3.getKeyExchange();
    if (!n6) throw new Error("KeyExchange is not initialized.");
    n6.getOtherPublicKey() !== e9 && n6.setOtherPublicKey(e9);
  }
  pause() {
    return c2(this, void 0, void 0, function* () {
      var e9;
      oo.RemoteCommunication(`[RemoteCommunication: pause()] channel=${this.state.channelId}`), yield null === (e9 = this.state.communicationLayer) || void 0 === e9 ? void 0 : e9.pause(), this.setConnectionStatus(Eo.PAUSED);
    });
  }
  getVersion() {
    return ho.version;
  }
  hasRelayPersistence() {
    var e9;
    return null !== (e9 = this.state.relayPersistence) && void 0 !== e9 && e9;
  }
  resume() {
    return c2(this, void 0, void 0, function* () {
      return function(e9) {
        return c2(this, void 0, void 0, function* () {
          var t3;
          const { state: n6 } = e9;
          oo.RemoteCommunication(`[RemoteCommunication: resume()] channel=${n6.channelId}`), yield null === (t3 = n6.communicationLayer) || void 0 === t3 ? void 0 : t3.resume(), e9.setConnectionStatus(Eo.LINKED);
        });
      }(this);
    });
  }
  encrypt(e9) {
    var t3, n6, r2;
    const i4 = null === (t3 = this.state.communicationLayer) || void 0 === t3 ? void 0 : t3.getKeyExchange(), o3 = null == i4 ? void 0 : i4.getOtherPublicKey();
    if (!o3) throw new Error("KeyExchange not completed");
    return null === (r2 = null === (n6 = this.state.communicationLayer) || void 0 === n6 ? void 0 : n6.state.eciesInstance) || void 0 === r2 ? void 0 : r2.encrypt(e9, o3);
  }
  decrypt(e9) {
    var t3, n6, r2;
    if (!(null === (t3 = this.state.communicationLayer) || void 0 === t3 ? void 0 : t3.state.eciesInstance)) throw new Error("ECIES instance is not initialized");
    return null === (r2 = null === (n6 = this.state.communicationLayer) || void 0 === n6 ? void 0 : n6.state.eciesInstance) || void 0 === r2 ? void 0 : r2.decrypt(e9);
  }
  getChannelId() {
    return this.state.channelId;
  }
  getRPCMethodTracker() {
    var e9;
    return null === (e9 = this.state.communicationLayer) || void 0 === e9 ? void 0 : e9.getRPCMethodTracker();
  }
  reject({ channelId: e9 }) {
    return function(e10) {
      return c2(this, arguments, void 0, function* ({ channelId: e11, state: t3 }) {
        var n6, r2, i4;
        if (!validate_default(e11)) throw oo.RemoteCommunication(`[RemoteCommunication: connectToChannel()] context=${t3.context} invalid channel channelId=${e11}`), new Error(`Invalid channel ${e11}`);
        if (t3.isOriginator) return void oo.RemoteCommunication(`[RemoteCommunication: reject()] context=${t3.context} isOriginator=${t3.isOriginator} channelId=${e11}`);
        const { socket: s2 } = null !== (r2 = null === (n6 = t3.communicationLayer) || void 0 === n6 ? void 0 : n6.state) && void 0 !== r2 ? r2 : {};
        (null == s2 ? void 0 : s2.connected) || (oo.RemoteCommunication(`[RemoteCommunication: reject()] context=${t3.context} socket already connected`), null == s2 || s2.connect()), lo(Object.assign(Object.assign({ id: e11, event: Ao.REJECTED }, t3.originatorInfo), { sdkVersion: t3.sdkVersion, commLayerVersion: ho.version, walletVersion: null === (i4 = t3.walletInfo) || void 0 === i4 ? void 0 : i4.version }), t3.communicationServerUrl).catch((e12) => {
        }), yield new Promise((n7, r3) => {
          null == s2 || s2.emit(So.REJECTED, { channelId: e11 }, (e12, i5) => {
            oo.RemoteCommunication(`[RemoteCommunication: reject()] context=${t3.context} socket=${null == s2 ? void 0 : s2.id}`, { error: e12, response: i5 }), e12 ? r3(e12) : n7(i5);
          });
        });
      });
    }({ channelId: e9, state: this.state });
  }
  disconnect(e9) {
    return c2(this, void 0, void 0, function* () {
      return es({ options: e9, instance: this });
    });
  }
};
!function(e9) {
  e9.RENEW = "renew", e9.LINK = "link";
}(Ho || (Ho = {}));
var ns = "ERC721";
var rs = "ERC1155";
var is = { errors: { disconnected: () => "MetaMask: Disconnected from chain. Attempting to connect.", permanentlyDisconnected: () => "MetaMask: Disconnected from MetaMask background. Page reload required.", sendSiteMetadata: () => "MetaMask: Failed to send site metadata. This is an internal error, please report this bug.", unsupportedSync: (e9) => `MetaMask: The MetaMask Ethereum provider does not support synchronous methods like ${e9} without a callback parameter.`, invalidDuplexStream: () => "Must provide a Node.js-style duplex stream.", invalidNetworkParams: () => "MetaMask: Received invalid network parameters. Please report this bug.", invalidRequestArgs: () => "Expected a single, non-array, object argument.", invalidRequestMethod: () => "'args.method' must be a non-empty string.", invalidRequestParams: () => "'args.params' must be an object or array if provided.", invalidLoggerObject: () => "'args.logger' must be an object if provided.", invalidLoggerMethod: (e9) => `'args.logger' must include required method '${e9}'.` }, info: { connected: (e9) => `MetaMask: Connected to chain with ID "${e9}".` }, warnings: { chainIdDeprecation: "MetaMask: 'ethereum.chainId' is deprecated and may be removed in the future. Please use the 'eth_chainId' RPC method instead.\nFor more information, see: https://github.com/MetaMask/metamask-improvement-proposals/discussions/23", networkVersionDeprecation: "MetaMask: 'ethereum.networkVersion' is deprecated and may be removed in the future. Please use the 'net_version' RPC method instead.\nFor more information, see: https://github.com/MetaMask/metamask-improvement-proposals/discussions/23", selectedAddressDeprecation: "MetaMask: 'ethereum.selectedAddress' is deprecated and may be removed in the future. Please use the 'eth_accounts' RPC method instead.\nFor more information, see: https://github.com/MetaMask/metamask-improvement-proposals/discussions/23", enableDeprecation: "MetaMask: 'ethereum.enable()' is deprecated and may be removed in the future. Please use the 'eth_requestAccounts' RPC method instead.\nFor more information, see: https://eips.ethereum.org/EIPS/eip-1102", sendDeprecation: "MetaMask: 'ethereum.send(...)' is deprecated and may be removed in the future. Please use 'ethereum.sendAsync(...)' or 'ethereum.request(...)' instead.\nFor more information, see: https://eips.ethereum.org/EIPS/eip-1193", events: { close: "MetaMask: The event 'close' is deprecated and may be removed in the future. Please use 'disconnect' instead.\nFor more information, see: https://eips.ethereum.org/EIPS/eip-1193#disconnect", data: "MetaMask: The event 'data' is deprecated and will be removed in the future. Use 'message' instead.\nFor more information, see: https://eips.ethereum.org/EIPS/eip-1193#message", networkChanged: "MetaMask: The event 'networkChanged' is deprecated and may be removed in the future. Use 'chainChanged' instead.\nFor more information, see: https://eips.ethereum.org/EIPS/eip-1193#chainchanged", notification: "MetaMask: The event 'notification' is deprecated and may be removed in the future. Use 'message' instead.\nFor more information, see: https://eips.ethereum.org/EIPS/eip-1193#message" }, rpc: { ethDecryptDeprecation: "MetaMask: The RPC method 'eth_decrypt' is deprecated and may be removed in the future.\nFor more information, see: https://medium.com/metamask/metamask-api-method-deprecation-2b0564a84686", ethGetEncryptionPublicKeyDeprecation: "MetaMask: The RPC method 'eth_getEncryptionPublicKey' is deprecated and may be removed in the future.\nFor more information, see: https://medium.com/metamask/metamask-api-method-deprecation-2b0564a84686", walletWatchAssetNFTExperimental: "MetaMask: The RPC method 'wallet_watchAsset' is experimental for ERC721/ERC1155 assets and may change in the future.\nFor more information, see: https://github.com/MetaMask/metamask-improvement-proposals/blob/main/MIPs/mip-1.md and https://github.com/MetaMask/metamask-improvement-proposals/blob/main/PROCESS-GUIDE.md#proposal-lifecycle" }, experimentalMethods: "MetaMask: 'ethereum._metamask' exposes non-standard, experimental methods. They may be removed or changed without warning." } };
function os(e9) {
  const t3 = { ethDecryptDeprecation: false, ethGetEncryptionPublicKeyDeprecation: false, walletWatchAssetNFTExperimental: false };
  return (n6, r2, i4) => {
    var _a2;
    t3.ethDecryptDeprecation || "eth_decrypt" !== n6.method ? t3.ethGetEncryptionPublicKeyDeprecation || "eth_getEncryptionPublicKey" !== n6.method ? !t3.walletWatchAssetNFTExperimental && "wallet_watchAsset" === n6.method && [ns, rs].includes(((_a2 = n6.params) == null ? void 0 : _a2.type) || "") && (e9.warn(is.warnings.rpc.walletWatchAssetNFTExperimental), t3.walletWatchAssetNFTExperimental = true) : (e9.warn(is.warnings.rpc.ethGetEncryptionPublicKeyDeprecation), t3.ethGetEncryptionPublicKeyDeprecation = true) : (e9.warn(is.warnings.rpc.ethDecryptDeprecation), t3.ethDecryptDeprecation = true), i4();
  };
}
var ss = 4294967295;
var as = Math.floor(Math.random() * ss);
function cs() {
  return (e9, t3, n6, r2) => {
    const i4 = e9.id, o3 = as = (as + 1) % ss;
    e9.id = o3, t3.id = o3, n6((n7) => {
      e9.id = i4, t3.id = i4, n7();
    });
  };
}
var ls = (e9, t3, n6) => {
  if (!t3.has(e9)) throw TypeError("Cannot " + n6);
};
var ds = (e9, t3, n6) => (ls(e9, t3, "read from private field"), n6 ? n6.call(e9) : t3.get(e9));
var us = (e9, t3, n6) => {
  if (t3.has(e9)) throw TypeError("Cannot add the same private member more than once");
  t3 instanceof WeakSet ? t3.add(e9) : t3.set(e9, n6);
};
var hs = (e9, t3, n6, r2) => (ls(e9, t3, "write to private field"), t3.set(e9, n6), n6);
var fs = (e9, t3, n6) => (ls(e9, t3, "access private method"), n6);
var ps = { invalidInput: -32e3, resourceNotFound: -32001, resourceUnavailable: -32002, transactionRejected: -32003, methodNotSupported: -32004, limitExceeded: -32005, parse: -32700, invalidRequest: -32600, methodNotFound: -32601, invalidParams: -32602, internal: -32603 };
var gs = { "-32700": { standard: "JSON RPC 2.0", message: "Invalid JSON was received by the server. An error occurred on the server while parsing the JSON text." }, "-32600": { standard: "JSON RPC 2.0", message: "The JSON sent is not a valid Request object." }, "-32601": { standard: "JSON RPC 2.0", message: "The method does not exist / is not available." }, "-32602": { standard: "JSON RPC 2.0", message: "Invalid method parameter(s)." }, "-32603": { standard: "JSON RPC 2.0", message: "Internal JSON-RPC error." }, "-32000": { standard: "EIP-1474", message: "Invalid input." }, "-32001": { standard: "EIP-1474", message: "Resource not found." }, "-32002": { standard: "EIP-1474", message: "Resource unavailable." }, "-32003": { standard: "EIP-1474", message: "Transaction rejected." }, "-32004": { standard: "EIP-1474", message: "Method not supported." }, "-32005": { standard: "EIP-1474", message: "Request limit exceeded." }, 4001: { standard: "EIP-1193", message: "User rejected the request." }, 4100: { standard: "EIP-1193", message: "The requested account and/or method has not been authorized by the user." }, 4200: { standard: "EIP-1193", message: "The requested method is not supported by this Ethereum provider." }, 4900: { standard: "EIP-1193", message: "The provider is disconnected from all chains." }, 4901: { standard: "EIP-1193", message: "The provider is disconnected from the specified chain." } };
function ms(e9) {
  return Boolean(e9) && "object" == typeof e9 && !Array.isArray(e9);
}
var ys = (e9, t3) => Object.hasOwnProperty.call(e9, t3);
var vs = class extends TypeError {
  constructor(e9, t3) {
    let n6;
    const { message: r2, explanation: i4, ...o3 } = e9, { path: s2 } = e9, a = 0 === s2.length ? r2 : `At path: ${s2.join(".")} -- ${r2}`;
    super(i4 ?? a), null != i4 && (this.cause = a), Object.assign(this, o3), this.name = this.constructor.name, this.failures = () => n6 ?? (n6 = [e9, ...t3()]);
  }
};
function bs(e9) {
  return "object" == typeof e9 && null != e9;
}
function ws(e9) {
  return "symbol" == typeof e9 ? e9.toString() : "string" == typeof e9 ? JSON.stringify(e9) : `${e9}`;
}
function Es(e9, t3, n6, r2) {
  if (true === e9) return;
  false === e9 ? e9 = {} : "string" == typeof e9 && (e9 = { message: e9 });
  const { path: i4, branch: o3 } = t3, { type: s2 } = n6, { refinement: a, message: c3 = `Expected a value of type \`${s2}\`${a ? ` with refinement \`${a}\`` : ""}, but received: \`${ws(r2)}\`` } = e9;
  return { value: r2, type: s2, refinement: a, key: i4[i4.length - 1], path: i4, branch: o3, ...e9, message: c3 };
}
function* Ss(e9, t3, n6, r2) {
  (function(e10) {
    return bs(e10) && "function" == typeof e10[Symbol.iterator];
  })(e9) || (e9 = [e9]);
  for (const i4 of e9) {
    const e10 = Es(i4, t3, n6, r2);
    e10 && (yield e10);
  }
}
function* _s(e9, t3, n6 = {}) {
  const { path: r2 = [], branch: i4 = [e9], coerce: o3 = false, mask: s2 = false } = n6, a = { path: r2, branch: i4 };
  if (o3 && (e9 = t3.coercer(e9, a), s2 && "type" !== t3.type && bs(t3.schema) && bs(e9) && !Array.isArray(e9))) for (const n7 in e9) void 0 === t3.schema[n7] && delete e9[n7];
  let c3 = "valid";
  for (const r3 of t3.validator(e9, a)) r3.explanation = n6.message, c3 = "not_valid", yield [r3, void 0];
  for (let [l5, d3, u2] of t3.entries(e9, a)) {
    const t4 = _s(d3, u2, { path: void 0 === l5 ? r2 : [...r2, l5], branch: void 0 === l5 ? i4 : [...i4, d3], coerce: o3, mask: s2, message: n6.message });
    for (const n7 of t4) n7[0] ? (c3 = null != n7[0].refinement ? "not_refined" : "not_valid", yield [n7[0], void 0]) : o3 && (d3 = n7[1], void 0 === l5 ? e9 = d3 : e9 instanceof Map ? e9.set(l5, d3) : e9 instanceof Set ? e9.add(d3) : bs(e9) && (void 0 !== d3 || l5 in e9) && (e9[l5] = d3));
  }
  if ("not_valid" !== c3) for (const r3 of t3.refiner(e9, a)) r3.explanation = n6.message, c3 = "not_refined", yield [r3, void 0];
  "valid" === c3 && (yield [void 0, e9]);
}
var Cs = class {
  constructor(e9) {
    const { type: t3, schema: n6, validator: r2, refiner: i4, coercer: o3 = (e10) => e10, entries: s2 = function* () {
    } } = e9;
    this.type = t3, this.schema = n6, this.entries = s2, this.coercer = o3, this.validator = r2 ? (e10, t4) => Ss(r2(e10, t4), t4, this, e10) : () => [], this.refiner = i4 ? (e10, t4) => Ss(i4(e10, t4), t4, this, e10) : () => [];
  }
  assert(e9, t3) {
    return ks(e9, this, t3);
  }
  create(e9, t3) {
    return As(e9, this, t3);
  }
  is(e9) {
    return xs(e9, this);
  }
  mask(e9, t3) {
    return function(e10, t4, n6) {
      const r2 = Ms(e10, t4, { coerce: true, mask: true, message: n6 });
      if (r2[0]) throw r2[0];
      return r2[1];
    }(e9, this, t3);
  }
  validate(e9, t3 = {}) {
    return Ms(e9, this, t3);
  }
};
function ks(e9, t3, n6) {
  const r2 = Ms(e9, t3, { message: n6 });
  if (r2[0]) throw r2[0];
}
function As(e9, t3, n6) {
  const r2 = Ms(e9, t3, { coerce: true, message: n6 });
  if (r2[0]) throw r2[0];
  return r2[1];
}
function xs(e9, t3) {
  return !Ms(e9, t3)[0];
}
function Ms(e9, t3, n6 = {}) {
  const r2 = _s(e9, t3, n6), i4 = function(e10) {
    const { done: t4, value: n7 } = e10.next();
    return t4 ? void 0 : n7;
  }(r2);
  if (i4[0]) {
    const e10 = new vs(i4[0], function* () {
      for (const e11 of r2) e11[0] && (yield e11[0]);
    });
    return [e10, void 0];
  }
  return [void 0, i4[1]];
}
function Is(e9, t3) {
  return new Cs({ type: e9, schema: null, validator: t3 });
}
function Ts(e9) {
  let t3;
  return new Cs({ type: "lazy", schema: null, *entries(n6, r2) {
    t3 ?? (t3 = e9()), yield* t3.entries(n6, r2);
  }, validator: (n6, r2) => (t3 ?? (t3 = e9()), t3.validator(n6, r2)), coercer: (n6, r2) => (t3 ?? (t3 = e9()), t3.coercer(n6, r2)), refiner: (n6, r2) => (t3 ?? (t3 = e9()), t3.refiner(n6, r2)) });
}
function Rs(e9) {
  return new Cs({ type: "array", schema: e9, *entries(t3) {
    if (e9 && Array.isArray(t3)) for (const [n6, r2] of t3.entries()) yield [n6, r2, e9];
  }, coercer: (e10) => Array.isArray(e10) ? e10.slice() : e10, validator: (e10) => Array.isArray(e10) || `Expected an array value, but received: ${ws(e10)}` });
}
function Ps(e9) {
  const t3 = ws(e9), n6 = typeof e9;
  return new Cs({ type: "literal", schema: "string" === n6 || "number" === n6 || "boolean" === n6 ? e9 : null, validator: (n7) => n7 === e9 || `Expected the literal \`${t3}\`, but received: ${ws(n7)}` });
}
function Os() {
  return Is("number", (e9) => "number" == typeof e9 && !isNaN(e9) || `Expected a number, but received: ${ws(e9)}`);
}
function Ns(e9) {
  const t3 = e9 ? Object.keys(e9) : [], n6 = Is("never", () => false);
  return new Cs({ type: "object", schema: e9 || null, *entries(r2) {
    if (e9 && bs(r2)) {
      const i4 = new Set(Object.keys(r2));
      for (const n7 of t3) i4.delete(n7), yield [n7, r2[n7], e9[n7]];
      for (const e10 of i4) yield [e10, r2[e10], n6];
    }
  }, validator: (e10) => bs(e10) || `Expected an object, but received: ${ws(e10)}`, coercer: (e10) => bs(e10) ? { ...e10 } : e10 });
}
function Ls(e9) {
  return new Cs({ ...e9, validator: (t3, n6) => void 0 === t3 || e9.validator(t3, n6), refiner: (t3, n6) => void 0 === t3 || e9.refiner(t3, n6) });
}
function Ds(e9, t3) {
  return new Cs({ type: "record", schema: null, *entries(n6) {
    if (bs(n6)) for (const r2 in n6) {
      const i4 = n6[r2];
      yield [r2, r2, e9], yield [r2, i4, t3];
    }
  }, validator: (e10) => bs(e10) || `Expected an object, but received: ${ws(e10)}` });
}
function $s() {
  return Is("string", (e9) => "string" == typeof e9 || `Expected a string, but received: ${ws(e9)}`);
}
function Bs(e9) {
  const t3 = e9.map((e10) => e10.type).join(" | ");
  return new Cs({ type: "union", schema: null, coercer(t4) {
    for (const n6 of e9) {
      const [e10, r2] = n6.validate(t4, { coerce: true });
      if (!e10) return r2;
    }
    return t4;
  }, validator(n6, r2) {
    const i4 = [];
    for (const t4 of e9) {
      const [...e10] = _s(n6, t4, r2), [o3] = e10;
      if (!o3[0]) return [];
      for (const [t5] of e10) t5 && i4.push(t5);
    }
    return [`Expected the value to satisfy a union of \`${t3}\`, but received: ${ws(n6)}`, ...i4];
  } });
}
function Ks(e9) {
  return function(e10) {
    return function(e11) {
      return "object" == typeof e11 && null !== e11 && "message" in e11;
    }(e10) && "string" == typeof e10.message ? e10.message : null == e10 ? "" : String(e10);
  }(e9).replace(/\.$/u, "");
}
function js(e9, t3) {
  var _a2, _b;
  return n6 = e9, Boolean("string" == typeof ((_b = (_a2 = n6 == null ? void 0 : n6.prototype) == null ? void 0 : _a2.constructor) == null ? void 0 : _b.name)) ? new e9({ message: t3 }) : e9({ message: t3 });
  var n6;
}
var Us = class extends Error {
  constructor(e9) {
    super(e9.message), this.code = "ERR_ASSERTION";
  }
};
function Hs() {
  throw new Error("setTimeout has not been defined");
}
function Fs() {
  throw new Error("clearTimeout has not been defined");
}
var zs = Hs;
var qs = Fs;
function Ws(e9) {
  if (zs === setTimeout) return setTimeout(e9, 0);
  if ((zs === Hs || !zs) && setTimeout) return zs = setTimeout, setTimeout(e9, 0);
  try {
    return zs(e9, 0);
  } catch (t3) {
    try {
      return zs.call(null, e9, 0);
    } catch (t4) {
      return zs.call(this, e9, 0);
    }
  }
}
"function" == typeof l4.setTimeout && (zs = setTimeout), "function" == typeof l4.clearTimeout && (qs = clearTimeout);
var Vs;
var Gs = [];
var Ys = false;
var Zs = -1;
function Js() {
  Ys && Vs && (Ys = false, Vs.length ? Gs = Vs.concat(Gs) : Zs = -1, Gs.length && Qs());
}
function Qs() {
  if (!Ys) {
    var e9 = Ws(Js);
    Ys = true;
    for (var t3 = Gs.length; t3; ) {
      for (Vs = Gs, Gs = []; ++Zs < t3; ) Vs && Vs[Zs].run();
      Zs = -1, t3 = Gs.length;
    }
    Vs = null, Ys = false, function(e10) {
      if (qs === clearTimeout) return clearTimeout(e10);
      if ((qs === Fs || !qs) && clearTimeout) return qs = clearTimeout, clearTimeout(e10);
      try {
        return qs(e10);
      } catch (t4) {
        try {
          return qs.call(null, e10);
        } catch (t5) {
          return qs.call(this, e10);
        }
      }
    }(e9);
  }
}
function Xs(e9, t3) {
  this.fun = e9, this.array = t3;
}
Xs.prototype.run = function() {
  this.fun.apply(null, this.array);
};
function ea() {
}
var ta = ea;
var na = ea;
var ra = ea;
var ia = ea;
var oa = ea;
var sa = ea;
var aa = ea;
var ca = l4.performance || {};
var la = ca.now || ca.mozNow || ca.msNow || ca.oNow || ca.webkitNow || function() {
  return (/* @__PURE__ */ new Date()).getTime();
};
var da = /* @__PURE__ */ new Date();
var ua = { nextTick: function(e9) {
  var t3 = new Array(arguments.length - 1);
  if (arguments.length > 1) for (var n6 = 1; n6 < arguments.length; n6++) t3[n6 - 1] = arguments[n6];
  Gs.push(new Xs(e9, t3)), 1 !== Gs.length || Ys || Ws(Qs);
}, title: "browser", browser: true, env: {}, argv: [], version: "", versions: {}, on: ta, addListener: na, once: ra, off: ia, removeListener: oa, removeAllListeners: sa, emit: aa, binding: function(e9) {
  throw new Error("process.binding is not supported");
}, cwd: function() {
  return "/";
}, chdir: function(e9) {
  throw new Error("process.chdir is not supported");
}, umask: function() {
  return 0;
}, hrtime: function(e9) {
  var t3 = 1e-3 * la.call(ca), n6 = Math.floor(t3), r2 = Math.floor(t3 % 1 * 1e9);
  return e9 && (n6 -= e9[0], (r2 -= e9[1]) < 0 && (n6--, r2 += 1e9)), [n6, r2];
}, platform: "browser", release: {}, config: {}, uptime: function() {
  return (/* @__PURE__ */ new Date() - da) / 1e3;
} };
var ha = (e9) => Ns(e9);
function fa({ path: e9, branch: t3 }) {
  const n6 = e9[e9.length - 1];
  return ys(t3[t3.length - 2], n6);
}
function pa(e9) {
  return new Cs({ ...e9, type: `optional ${e9.type}`, validator: (t3, n6) => !fa(n6) || e9.validator(t3, n6), refiner: (t3, n6) => !fa(n6) || e9.refiner(t3, n6) });
}
var ga;
var ma;
var ya;
var va = Bs([Ps(null), Is("boolean", (e9) => "boolean" == typeof e9), Is("finite number", (e9) => xs(e9, Os()) && Number.isFinite(e9)), $s(), Rs(Ts(() => va)), Ds($s(), Ts(() => va))]);
var ba = (ga = va, ma = Is("any", () => true), ya = (e9) => (function(e10, t3, n6 = "Assertion failed", r2 = Us) {
  try {
    ks(e10, t3);
  } catch (e11) {
    throw js(r2, `${n6}: ${Ks(e11)}.`);
  }
}(e9, va), JSON.parse(JSON.stringify(e9, (e10, t3) => {
  if ("__proto__" !== e10 && "constructor" !== e10) return t3;
}))), new Cs({ ...ga, coercer: (e9, t3) => xs(e9, ma) ? ga.coercer(ya(e9, t3), t3) : ga.coercer(e9, t3) }));
function wa(e9) {
  try {
    return function(e10) {
      As(e10, ba);
    }(e9), true;
  } catch {
    return false;
  }
}
var Ea = Ps("2.0");
var Sa = function(e9) {
  return new Cs({ ...e9, validator: (t3, n6) => null === t3 || e9.validator(t3, n6), refiner: (t3, n6) => null === t3 || e9.refiner(t3, n6) });
}(Bs([Os(), $s()]));
var _a = ha({ code: Is("integer", (e9) => "number" == typeof e9 && !isNaN(e9) && Number.isInteger(e9) || `Expected an integer, but received: ${ws(e9)}`), message: $s(), data: pa(ba), stack: pa($s()) });
var Ca = Bs([Ds($s(), ba), Rs(ba)]);
var ka = ha({ id: Sa, jsonrpc: Ea, method: $s(), params: pa(Ca) });
var Aa = ha({ jsonrpc: Ea, method: $s(), params: pa(Ca) });
function xa(e9) {
  return xs(e9, ka);
}
function Ma(e9) {
  return xs(e9, _a);
}
Ns({ id: Sa, jsonrpc: Ea, result: Ls(Is("unknown", () => true)), error: Ls(_a) }), Bs([ha({ id: Sa, jsonrpc: Ea, result: ba }), ha({ id: Sa, jsonrpc: Ea, error: _a })]);
var Ia = ps.internal;
var Ta = "Unspecified error message. This is a bug, please report it.";
var Ra = { code: Ia, message: Oa(Ia) };
var Pa = "Unspecified server error.";
function Oa(e9, t3 = Ta) {
  if (function(e10) {
    return Number.isInteger(e10);
  }(e9)) {
    const t4 = e9.toString();
    if (ys(gs, t4)) return gs[t4].message;
    if (function(e10) {
      return e10 >= -32099 && e10 <= -32e3;
    }(e9)) return Pa;
  }
  return t3;
}
function Na(e9, { fallbackError: t3 = Ra, shouldIncludeStack: n6 = true } = {}) {
  if (!Ma(t3)) throw new Error("Must provide fallback error with integer number code and string message.");
  const r2 = function(e10, t4) {
    if (e10 && "object" == typeof e10 && "serialize" in e10 && "function" == typeof e10.serialize) return e10.serialize();
    if (Ma(e10)) return e10;
    const n7 = La(e10), r3 = { ...t4, data: { cause: n7 } };
    return r3;
  }(e9, t3);
  return n6 || delete r2.stack, r2;
}
function La(e9) {
  return Array.isArray(e9) ? e9.map((e10) => wa(e10) ? e10 : ms(e10) ? Da(e10) : null) : ms(e9) ? Da(e9) : wa(e9) ? e9 : null;
}
function Da(e9) {
  return Object.getOwnPropertyNames(e9).reduce((t3, n6) => {
    const r2 = e9[n6];
    return wa(r2) && (t3[n6] = r2), t3;
  }, {});
}
var $a = Fa;
Fa.default = Fa, Fa.stable = Va, Fa.stableStringify = Va;
var Ba = "[...]";
var Ka = "[Circular]";
var ja = [];
var Ua = [];
function Ha() {
  return { depthLimit: Number.MAX_SAFE_INTEGER, edgesLimit: Number.MAX_SAFE_INTEGER };
}
function Fa(e9, t3, n6, r2) {
  var i4;
  void 0 === r2 && (r2 = Ha()), qa(e9, "", 0, [], void 0, 0, r2);
  try {
    i4 = 0 === Ua.length ? JSON.stringify(e9, t3, n6) : JSON.stringify(e9, Ya(t3), n6);
  } catch (e10) {
    return JSON.stringify("[unable to serialize, circular reference is too complex to analyze]");
  } finally {
    for (; 0 !== ja.length; ) {
      var o3 = ja.pop();
      4 === o3.length ? Object.defineProperty(o3[0], o3[1], o3[3]) : o3[0][o3[1]] = o3[2];
    }
  }
  return i4;
}
function za(e9, t3, n6, r2) {
  var i4 = Object.getOwnPropertyDescriptor(r2, n6);
  void 0 !== i4.get ? i4.configurable ? (Object.defineProperty(r2, n6, { value: e9 }), ja.push([r2, n6, t3, i4])) : Ua.push([t3, n6, e9]) : (r2[n6] = e9, ja.push([r2, n6, t3]));
}
function qa(e9, t3, n6, r2, i4, o3, s2) {
  var a;
  if (o3 += 1, "object" == typeof e9 && null !== e9) {
    for (a = 0; a < r2.length; a++) if (r2[a] === e9) return void za(Ka, e9, t3, i4);
    if (void 0 !== s2.depthLimit && o3 > s2.depthLimit) return void za(Ba, e9, t3, i4);
    if (void 0 !== s2.edgesLimit && n6 + 1 > s2.edgesLimit) return void za(Ba, e9, t3, i4);
    if (r2.push(e9), Array.isArray(e9)) for (a = 0; a < e9.length; a++) qa(e9[a], a, a, r2, e9, o3, s2);
    else {
      var c3 = Object.keys(e9);
      for (a = 0; a < c3.length; a++) {
        var l5 = c3[a];
        qa(e9[l5], l5, a, r2, e9, o3, s2);
      }
    }
    r2.pop();
  }
}
function Wa(e9, t3) {
  return e9 < t3 ? -1 : e9 > t3 ? 1 : 0;
}
function Va(e9, t3, n6, r2) {
  void 0 === r2 && (r2 = Ha());
  var i4, o3 = Ga(e9, "", 0, [], void 0, 0, r2) || e9;
  try {
    i4 = 0 === Ua.length ? JSON.stringify(o3, t3, n6) : JSON.stringify(o3, Ya(t3), n6);
  } catch (e10) {
    return JSON.stringify("[unable to serialize, circular reference is too complex to analyze]");
  } finally {
    for (; 0 !== ja.length; ) {
      var s2 = ja.pop();
      4 === s2.length ? Object.defineProperty(s2[0], s2[1], s2[3]) : s2[0][s2[1]] = s2[2];
    }
  }
  return i4;
}
function Ga(e9, t3, n6, r2, i4, o3, s2) {
  var a;
  if (o3 += 1, "object" == typeof e9 && null !== e9) {
    for (a = 0; a < r2.length; a++) if (r2[a] === e9) return void za(Ka, e9, t3, i4);
    try {
      if ("function" == typeof e9.toJSON) return;
    } catch (e10) {
      return;
    }
    if (void 0 !== s2.depthLimit && o3 > s2.depthLimit) return void za(Ba, e9, t3, i4);
    if (void 0 !== s2.edgesLimit && n6 + 1 > s2.edgesLimit) return void za(Ba, e9, t3, i4);
    if (r2.push(e9), Array.isArray(e9)) for (a = 0; a < e9.length; a++) Ga(e9[a], a, a, r2, e9, o3, s2);
    else {
      var c3 = {}, l5 = Object.keys(e9).sort(Wa);
      for (a = 0; a < l5.length; a++) {
        var d3 = l5[a];
        Ga(e9[d3], d3, a, r2, e9, o3, s2), c3[d3] = e9[d3];
      }
      if (void 0 === i4) return c3;
      ja.push([i4, t3, e9]), i4[t3] = c3;
    }
    r2.pop();
  }
}
function Ya(e9) {
  return e9 = void 0 !== e9 ? e9 : function(e10, t3) {
    return t3;
  }, function(t3, n6) {
    if (Ua.length > 0) for (var r2 = 0; r2 < Ua.length; r2++) {
      var i4 = Ua[r2];
      if (i4[1] === t3 && i4[0] === n6) {
        n6 = i4[2], Ua.splice(r2, 1);
        break;
      }
    }
    return e9.call(this, t3, n6);
  };
}
var Za = ue($a);
var Ja = class extends Error {
  constructor(e9, t3, n6) {
    if (!Number.isInteger(e9)) throw new Error('"code" must be an integer.');
    if (!t3 || "string" != typeof t3) throw new Error('"message" must be a non-empty string.');
    super(t3), this.code = e9, void 0 !== n6 && (this.data = n6);
  }
  serialize() {
    const e9 = { code: this.code, message: this.message };
    return void 0 !== this.data && (e9.data = this.data, function(e10) {
      if ("object" != typeof e10 || null === e10) return false;
      try {
        let t3 = e10;
        for (; null !== Object.getPrototypeOf(t3); ) t3 = Object.getPrototypeOf(t3);
        return Object.getPrototypeOf(e10) === t3;
      } catch (e11) {
        return false;
      }
    }(this.data) && (e9.data.cause = La(this.data.cause))), this.stack && (e9.stack = this.stack), e9;
  }
  toString() {
    return Za(this.serialize(), Qa, 2);
  }
};
function Qa(e9, t3) {
  if ("[Circular]" !== t3) return t3;
}
var Xa = (e9) => ec(ps.invalidRequest, e9);
function ec(e9, t3) {
  const [n6, r2] = function(e10) {
    if (e10) {
      if ("string" == typeof e10) return [e10];
      if ("object" == typeof e10 && !Array.isArray(e10)) {
        const { message: t4, data: n7 } = e10;
        if (t4 && "string" != typeof t4) throw new Error("Must specify string message.");
        return [t4 ?? void 0, n7];
      }
    }
    return [];
  }(t3);
  return new Ja(e9, n6 ?? Oa(e9), r2);
}
var tc = {};
function nc() {
}
function rc() {
  rc.init.call(this);
}
function ic(e9) {
  return void 0 === e9._maxListeners ? rc.defaultMaxListeners : e9._maxListeners;
}
function oc(e9, t3, n6, r2) {
  var i4, o3, s2;
  if ("function" != typeof n6) throw new TypeError('"listener" argument must be a function');
  if ((o3 = e9._events) ? (o3.newListener && (e9.emit("newListener", t3, n6.listener ? n6.listener : n6), o3 = e9._events), s2 = o3[t3]) : (o3 = e9._events = new nc(), e9._eventsCount = 0), s2) {
    if ("function" == typeof s2 ? s2 = o3[t3] = r2 ? [n6, s2] : [s2, n6] : r2 ? s2.unshift(n6) : s2.push(n6), !s2.warned && (i4 = ic(e9)) && i4 > 0 && s2.length > i4) {
      s2.warned = true;
      var a = new Error("Possible EventEmitter memory leak detected. " + s2.length + " " + t3 + " listeners added. Use emitter.setMaxListeners() to increase limit");
      a.name = "MaxListenersExceededWarning", a.emitter = e9, a.type = t3, a.count = s2.length, function(e10) {
        "function" == typeof console.warn ? console.warn(e10) : console.log(e10);
      }(a);
    }
  } else s2 = o3[t3] = n6, ++e9._eventsCount;
  return e9;
}
function sc(e9, t3, n6) {
  var r2 = false;
  function i4() {
    e9.removeListener(t3, i4), r2 || (r2 = true, n6.apply(e9, arguments));
  }
  return i4.listener = n6, i4;
}
function ac(e9) {
  var t3 = this._events;
  if (t3) {
    var n6 = t3[e9];
    if ("function" == typeof n6) return 1;
    if (n6) return n6.length;
  }
  return 0;
}
function cc(e9, t3) {
  for (var n6 = new Array(t3); t3--; ) n6[t3] = e9[t3];
  return n6;
}
nc.prototype = /* @__PURE__ */ Object.create(null), rc.EventEmitter = rc, rc.usingDomains = false, rc.prototype.domain = void 0, rc.prototype._events = void 0, rc.prototype._maxListeners = void 0, rc.defaultMaxListeners = 10, rc.init = function() {
  this.domain = null, rc.usingDomains && (void 0).active, this._events && this._events !== Object.getPrototypeOf(this)._events || (this._events = new nc(), this._eventsCount = 0), this._maxListeners = this._maxListeners || void 0;
}, rc.prototype.setMaxListeners = function(e9) {
  if ("number" != typeof e9 || e9 < 0 || isNaN(e9)) throw new TypeError('"n" argument must be a positive number');
  return this._maxListeners = e9, this;
}, rc.prototype.getMaxListeners = function() {
  return ic(this);
}, rc.prototype.emit = function(e9) {
  var t3, n6, r2, i4, o3, s2, a, c3 = "error" === e9;
  if (s2 = this._events) c3 = c3 && null == s2.error;
  else if (!c3) return false;
  if (a = this.domain, c3) {
    if (t3 = arguments[1], !a) {
      if (t3 instanceof Error) throw t3;
      var l5 = new Error('Uncaught, unspecified "error" event. (' + t3 + ")");
      throw l5.context = t3, l5;
    }
    return t3 || (t3 = new Error('Uncaught, unspecified "error" event')), t3.domainEmitter = this, t3.domain = a, t3.domainThrown = false, a.emit("error", t3), false;
  }
  if (!(n6 = s2[e9])) return false;
  var d3 = "function" == typeof n6;
  switch (r2 = arguments.length) {
    case 1:
      !function(e10, t4, n7) {
        if (t4) e10.call(n7);
        else for (var r3 = e10.length, i5 = cc(e10, r3), o4 = 0; o4 < r3; ++o4) i5[o4].call(n7);
      }(n6, d3, this);
      break;
    case 2:
      !function(e10, t4, n7, r3) {
        if (t4) e10.call(n7, r3);
        else for (var i5 = e10.length, o4 = cc(e10, i5), s3 = 0; s3 < i5; ++s3) o4[s3].call(n7, r3);
      }(n6, d3, this, arguments[1]);
      break;
    case 3:
      !function(e10, t4, n7, r3, i5) {
        if (t4) e10.call(n7, r3, i5);
        else for (var o4 = e10.length, s3 = cc(e10, o4), a2 = 0; a2 < o4; ++a2) s3[a2].call(n7, r3, i5);
      }(n6, d3, this, arguments[1], arguments[2]);
      break;
    case 4:
      !function(e10, t4, n7, r3, i5, o4) {
        if (t4) e10.call(n7, r3, i5, o4);
        else for (var s3 = e10.length, a2 = cc(e10, s3), c4 = 0; c4 < s3; ++c4) a2[c4].call(n7, r3, i5, o4);
      }(n6, d3, this, arguments[1], arguments[2], arguments[3]);
      break;
    default:
      for (i4 = new Array(r2 - 1), o3 = 1; o3 < r2; o3++) i4[o3 - 1] = arguments[o3];
      !function(e10, t4, n7, r3) {
        if (t4) e10.apply(n7, r3);
        else for (var i5 = e10.length, o4 = cc(e10, i5), s3 = 0; s3 < i5; ++s3) o4[s3].apply(n7, r3);
      }(n6, d3, this, i4);
  }
  return true;
}, rc.prototype.addListener = function(e9, t3) {
  return oc(this, e9, t3, false);
}, rc.prototype.on = rc.prototype.addListener, rc.prototype.prependListener = function(e9, t3) {
  return oc(this, e9, t3, true);
}, rc.prototype.once = function(e9, t3) {
  if ("function" != typeof t3) throw new TypeError('"listener" argument must be a function');
  return this.on(e9, sc(this, e9, t3)), this;
}, rc.prototype.prependOnceListener = function(e9, t3) {
  if ("function" != typeof t3) throw new TypeError('"listener" argument must be a function');
  return this.prependListener(e9, sc(this, e9, t3)), this;
}, rc.prototype.removeListener = function(e9, t3) {
  var n6, r2, i4, o3, s2;
  if ("function" != typeof t3) throw new TypeError('"listener" argument must be a function');
  if (!(r2 = this._events)) return this;
  if (!(n6 = r2[e9])) return this;
  if (n6 === t3 || n6.listener && n6.listener === t3) 0 == --this._eventsCount ? this._events = new nc() : (delete r2[e9], r2.removeListener && this.emit("removeListener", e9, n6.listener || t3));
  else if ("function" != typeof n6) {
    for (i4 = -1, o3 = n6.length; o3-- > 0; ) if (n6[o3] === t3 || n6[o3].listener && n6[o3].listener === t3) {
      s2 = n6[o3].listener, i4 = o3;
      break;
    }
    if (i4 < 0) return this;
    if (1 === n6.length) {
      if (n6[0] = void 0, 0 == --this._eventsCount) return this._events = new nc(), this;
      delete r2[e9];
    } else !function(e10, t4) {
      for (var n7 = t4, r3 = n7 + 1, i5 = e10.length; r3 < i5; n7 += 1, r3 += 1) e10[n7] = e10[r3];
      e10.pop();
    }(n6, i4);
    r2.removeListener && this.emit("removeListener", e9, s2 || t3);
  }
  return this;
}, rc.prototype.off = function(e9, t3) {
  return this.removeListener(e9, t3);
}, rc.prototype.removeAllListeners = function(e9) {
  var t3, n6;
  if (!(n6 = this._events)) return this;
  if (!n6.removeListener) return 0 === arguments.length ? (this._events = new nc(), this._eventsCount = 0) : n6[e9] && (0 == --this._eventsCount ? this._events = new nc() : delete n6[e9]), this;
  if (0 === arguments.length) {
    for (var r2, i4 = Object.keys(n6), o3 = 0; o3 < i4.length; ++o3) "removeListener" !== (r2 = i4[o3]) && this.removeAllListeners(r2);
    return this.removeAllListeners("removeListener"), this._events = new nc(), this._eventsCount = 0, this;
  }
  if ("function" == typeof (t3 = n6[e9])) this.removeListener(e9, t3);
  else if (t3) do {
    this.removeListener(e9, t3[t3.length - 1]);
  } while (t3[0]);
  return this;
}, rc.prototype.listeners = function(e9) {
  var t3, n6, r2 = this._events;
  return n6 = r2 && (t3 = r2[e9]) ? "function" == typeof t3 ? [t3.listener || t3] : function(e10) {
    for (var t4 = new Array(e10.length), n7 = 0; n7 < t4.length; ++n7) t4[n7] = e10[n7].listener || e10[n7];
    return t4;
  }(t3) : [], n6;
}, rc.listenerCount = function(e9, t3) {
  return "function" == typeof e9.listenerCount ? e9.listenerCount(t3) : ac.call(e9, t3);
}, rc.prototype.listenerCount = ac, rc.prototype.eventNames = function() {
  return this._eventsCount > 0 ? Reflect.ownKeys(this._events) : [];
};
var lc = he(Object.freeze({ __proto__: null, EventEmitter: rc, default: rc }));
Object.defineProperty(tc, "__esModule", { value: true });
var dc = lc;
function uc(e9, t3, n6) {
  try {
    Reflect.apply(e9, t3, n6);
  } catch (e10) {
    setTimeout(() => {
      throw e10;
    });
  }
}
var hc = class extends dc.EventEmitter {
  emit(e9, ...t3) {
    let n6 = "error" === e9;
    const r2 = this._events;
    if (void 0 !== r2) n6 = n6 && void 0 === r2.error;
    else if (!n6) return false;
    if (n6) {
      let e10;
      if (t3.length > 0 && ([e10] = t3), e10 instanceof Error) throw e10;
      const n7 = new Error("Unhandled error." + (e10 ? ` (${e10.message})` : ""));
      throw n7.context = e10, n7;
    }
    const i4 = r2[e9];
    if (void 0 === i4) return false;
    if ("function" == typeof i4) uc(i4, this, t3);
    else {
      const e10 = i4.length, n7 = function(e11) {
        const t4 = e11.length, n8 = new Array(t4);
        for (let r3 = 0; r3 < t4; r3 += 1) n8[r3] = e11[r3];
        return n8;
      }(i4);
      for (let r3 = 0; r3 < e10; r3 += 1) uc(n7[r3], this, t3);
    }
    return true;
  }
};
var fc;
var pc;
var gc;
var mc;
var yc;
var vc;
var bc;
var wc;
var Ec;
var Sc;
var _c;
var Cc;
var kc;
var Ac;
var xc;
var Mc;
var Ic;
var Tc;
var Rc;
var Pc = tc.default = hc;
var Oc = class e4 extends Pc {
  constructor({ notificationHandler: e9 } = {}) {
    super(), us(this, mc), us(this, vc), us(this, wc), us(this, fc, false), us(this, pc, void 0), us(this, gc, void 0), hs(this, pc, []), hs(this, gc, e9);
  }
  destroy() {
    ds(this, pc).forEach((e9) => {
      "destroy" in e9 && "function" == typeof e9.destroy && e9.destroy();
    }), hs(this, pc, []), hs(this, fc, true);
  }
  push(e9) {
    fs(this, mc, yc).call(this), ds(this, pc).push(e9);
  }
  handle(e9, t3) {
    if (fs(this, mc, yc).call(this), t3 && "function" != typeof t3) throw new Error('"callback" must be a function if provided.');
    return Array.isArray(e9) ? t3 ? fs(this, vc, bc).call(this, e9, t3) : fs(this, vc, bc).call(this, e9) : t3 ? fs(this, wc, Ec).call(this, e9, t3) : this._promiseHandle(e9);
  }
  asMiddleware() {
    return fs(this, mc, yc).call(this), async (t3, n6, r2, i4) => {
      var o3, s2;
      try {
        const [a, c3, l5] = await fs(o3 = e4, Cc, kc).call(o3, t3, n6, ds(this, pc));
        return c3 ? (await fs(s2 = e4, Mc, Ic).call(s2, l5), i4(a)) : r2(async (t4) => {
          var n7;
          try {
            await fs(n7 = e4, Mc, Ic).call(n7, l5);
          } catch (e9) {
            return t4(e9);
          }
          return t4();
        });
      } catch (e9) {
        return i4(e9);
      }
    };
  }
  async _promiseHandle(e9) {
    return new Promise((t3, n6) => {
      fs(this, wc, Ec).call(this, e9, (e10, r2) => {
        e10 && void 0 === r2 ? n6(e10) : t3(r2);
      }).catch(n6);
    });
  }
};
fc = /* @__PURE__ */ new WeakMap(), pc = /* @__PURE__ */ new WeakMap(), gc = /* @__PURE__ */ new WeakMap(), mc = /* @__PURE__ */ new WeakSet(), yc = function() {
  if (ds(this, fc)) throw new Error("This engine is destroyed and can no longer be used.");
}, vc = /* @__PURE__ */ new WeakSet(), bc = async function(e9, t3) {
  try {
    if (0 === e9.length) {
      const e10 = [{ id: null, jsonrpc: "2.0", error: new Ja(ps.invalidRequest, "Request batch must contain plain objects. Received an empty array") }];
      return t3 ? t3(null, e10) : e10;
    }
    const n6 = (await Promise.all(e9.map(this._promiseHandle.bind(this)))).filter((e10) => void 0 !== e10);
    return t3 ? t3(null, n6) : n6;
  } catch (e10) {
    if (t3) return t3(e10);
    throw e10;
  }
}, wc = /* @__PURE__ */ new WeakSet(), Ec = async function(e9, t3) {
  var n6;
  if (!e9 || Array.isArray(e9) || "object" != typeof e9) {
    const n7 = new Ja(ps.invalidRequest, "Requests must be plain objects. Received: " + typeof e9, { request: e9 });
    return t3(n7, { id: null, jsonrpc: "2.0", error: n7 });
  }
  if ("string" != typeof e9.method) {
    const n7 = new Ja(ps.invalidRequest, "Must specify a string method. Received: " + typeof e9.method, { request: e9 });
    return ds(this, gc) && !xa(e9) ? t3(null) : t3(n7, { id: e9.id ?? null, jsonrpc: "2.0", error: n7 });
  }
  if (ds(this, gc) && xs(e9, Aa) && !xa(e9)) {
    try {
      await ds(this, gc).call(this, e9);
    } catch (e10) {
      return t3(e10);
    }
    return t3(null);
  }
  let r2 = null;
  const i4 = { ...e9 }, o3 = { id: i4.id, jsonrpc: i4.jsonrpc };
  try {
    await fs(n6 = Oc, Sc, _c).call(n6, i4, o3, ds(this, pc));
  } catch (e10) {
    r2 = e10;
  }
  return r2 && (delete o3.result, o3.error || (o3.error = Na(r2))), t3(r2, o3);
}, Sc = /* @__PURE__ */ new WeakSet(), _c = async function(e9, t3, n6) {
  var r2, i4, o3;
  const [s2, a, c3] = await fs(r2 = Oc, Cc, kc).call(r2, e9, t3, n6);
  if (fs(i4 = Oc, Tc, Rc).call(i4, e9, t3, a), await fs(o3 = Oc, Mc, Ic).call(o3, c3), s2) throw s2;
}, Cc = /* @__PURE__ */ new WeakSet(), kc = async function(e9, t3, n6) {
  var r2;
  const i4 = [];
  let o3 = null, s2 = false;
  for (const a of n6) if ([o3, s2] = await fs(r2 = Oc, Ac, xc).call(r2, e9, t3, a, i4), s2) break;
  return [o3, s2, i4.reverse()];
}, Ac = /* @__PURE__ */ new WeakSet(), xc = async function(e9, t3, n6, r2) {
  return new Promise((i4) => {
    const o3 = (e10) => {
      const n7 = e10 || t3.error;
      n7 && (t3.error = Na(n7)), i4([n7, true]);
    }, s2 = (n7) => {
      t3.error ? o3(t3.error) : (n7 && ("function" != typeof n7 && o3(new Ja(ps.internal, `JsonRpcEngine: "next" return handlers must be functions. Received "${typeof n7}" for request:
${Lc(e9)}`, { request: e9 })), r2.push(n7)), i4([null, false]));
    };
    try {
      n6(e9, t3, s2, o3);
    } catch (e10) {
      o3(e10);
    }
  });
}, Mc = /* @__PURE__ */ new WeakSet(), Ic = async function(e9) {
  for (const t3 of e9) await new Promise((e10, n6) => {
    t3((t4) => t4 ? n6(t4) : e10());
  });
}, Tc = /* @__PURE__ */ new WeakSet(), Rc = function(e9, t3, n6) {
  if (!ys(t3, "result") && !ys(t3, "error")) throw new Ja(ps.internal, `JsonRpcEngine: Response has no error or result for request:
${Lc(e9)}`, { request: e9 });
  if (!n6) throw new Ja(ps.internal, `JsonRpcEngine: Nothing ended request:
${Lc(e9)}`, { request: e9 });
}, us(Oc, Sc), us(Oc, Cc), us(Oc, Ac), us(Oc, Mc), us(Oc, Tc);
var Nc = Oc;
function Lc(e9) {
  return JSON.stringify(e9, null, 2);
}
var Dc = Object.freeze(["eth_subscription"]);
var $c = (e9 = console) => [cs(), Bc(e9), os(e9)];
function Bc(e9) {
  return (t3, n6, r2) => {
    "string" == typeof t3.method && t3.method || (n6.error = Xa({ message: "The request 'method' must be a non-empty string.", data: t3 })), r2((t4) => {
      const { error: r3 } = n6;
      return r3 ? (e9.error(`MetaMask - RPC Error: ${r3.message}`, r3), t4()) : t4();
    });
  };
}
var Kc = (e9, t3, n6 = true) => (r2, i4) => {
  r2 || i4.error ? t3(r2 || i4.error) : !n6 || Array.isArray(i4) ? e9(i4) : e9(i4.result);
};
var jc = (e9) => Boolean(e9) && "string" == typeof e9 && e9.startsWith("0x");
var Uc = () => {
};
async function Hc(e9, t3) {
  try {
    const t4 = await async function() {
      return { name: Fc(window), icon: await zc(window) };
    }();
    e9.handle({ jsonrpc: "2.0", id: 1, method: "metamask_sendDomainMetadata", params: t4 }, Uc);
  } catch (e10) {
    t3.error({ message: is.errors.sendSiteMetadata(), originalError: e10 });
  }
}
function Fc(e9) {
  const { document: t3 } = e9, n6 = t3.querySelector('head > meta[property="og:site_name"]');
  if (n6) return n6.content;
  const r2 = t3.querySelector('head > meta[name="title"]');
  return r2 ? r2.content : t3.title && t3.title.length > 0 ? t3.title : window.location.hostname;
}
async function zc(e9) {
  const { document: t3 } = e9, n6 = t3.querySelectorAll('head > link[rel~="icon"]');
  for (const e10 of Array.from(n6)) if (e10 && await qc(e10.href)) return e10.href;
  return null;
}
async function qc(e9) {
  return new Promise((t3, n6) => {
    try {
      const n7 = document.createElement("img");
      n7.onload = () => t3(true), n7.onerror = () => t3(false), n7.src = e9;
    } catch (e10) {
      n6(e10);
    }
  });
}
var Wc = (e9, t3, n6) => {
  if (!t3.has(e9)) throw TypeError("Cannot " + n6);
};
var Vc = (e9, t3, n6) => (Wc(e9, t3, "read from private field"), n6 ? n6.call(e9) : t3.get(e9));
var Gc = (e9, t3, n6) => {
  if (t3.has(e9)) throw TypeError("Cannot add the same private member more than once");
  t3 instanceof WeakSet ? t3.add(e9) : t3.set(e9, n6);
};
var Yc = (e9, t3, n6, r2) => (Wc(e9, t3, "write to private field"), t3.set(e9, n6), n6);
function Zc(e9, t3, n6) {
  try {
    Reflect.apply(e9, t3, n6);
  } catch (e10) {
    setTimeout(() => {
      throw e10;
    });
  }
}
var Jc = class extends rc {
  emit(e9, ...t3) {
    let n6 = "error" === e9;
    const r2 = this._events;
    if (void 0 !== r2) n6 = n6 && void 0 === r2.error;
    else if (!n6) return false;
    if (n6) {
      let e10;
      if (t3.length > 0 && ([e10] = t3), e10 instanceof Error) throw e10;
      const n7 = new Error("Unhandled error." + (e10 ? ` (${e10.message})` : ""));
      throw n7.context = e10, n7;
    }
    const i4 = r2[e9];
    if (void 0 === i4) return false;
    if ("function" == typeof i4) Zc(i4, this, t3);
    else {
      const e10 = i4.length, n7 = function(e11) {
        const t4 = e11.length, n8 = new Array(t4);
        for (let r3 = 0; r3 < t4; r3 += 1) n8[r3] = e11[r3];
        return n8;
      }(i4);
      for (let r3 = 0; r3 < e10; r3 += 1) Zc(n7[r3], this, t3);
    }
    return true;
  }
};
var Qc;
var Xc;
var el = function e5(t3, n6) {
  if (t3 === n6) return true;
  if (t3 && n6 && "object" == typeof t3 && "object" == typeof n6) {
    if (t3.constructor !== n6.constructor) return false;
    var r2, i4, o3;
    if (Array.isArray(t3)) {
      if ((r2 = t3.length) != n6.length) return false;
      for (i4 = r2; 0 != i4--; ) if (!e5(t3[i4], n6[i4])) return false;
      return true;
    }
    if (t3.constructor === RegExp) return t3.source === n6.source && t3.flags === n6.flags;
    if (t3.valueOf !== Object.prototype.valueOf) return t3.valueOf() === n6.valueOf();
    if (t3.toString !== Object.prototype.toString) return t3.toString() === n6.toString();
    if ((r2 = (o3 = Object.keys(t3)).length) !== Object.keys(n6).length) return false;
    for (i4 = r2; 0 != i4--; ) if (!Object.prototype.hasOwnProperty.call(n6, o3[i4])) return false;
    for (i4 = r2; 0 != i4--; ) {
      var s2 = o3[i4];
      if (!e5(t3[s2], n6[s2])) return false;
    }
    return true;
  }
  return t3 != t3 && n6 != n6;
};
var tl = ue(el);
var nl = class e6 extends Jc {
  constructor({ logger: t3 = console, maxEventListeners: n6 = 100, rpcMiddleware: r2 = [] } = {}) {
    super(), Gc(this, Qc, void 0), Gc(this, Xc, void 0), this._log = t3, this.setMaxListeners(n6), this._state = { ...e6._defaultState }, Yc(this, Xc, null), Yc(this, Qc, null), this._handleAccountsChanged = this._handleAccountsChanged.bind(this), this._handleConnect = this._handleConnect.bind(this), this._handleChainChanged = this._handleChainChanged.bind(this), this._handleDisconnect = this._handleDisconnect.bind(this), this._handleUnlockStateChanged = this._handleUnlockStateChanged.bind(this), this._rpcRequest = this._rpcRequest.bind(this), this.request = this.request.bind(this);
    const i4 = new Nc();
    r2.forEach((e9) => i4.push(e9)), this._rpcEngine = i4;
  }
  get chainId() {
    return Vc(this, Qc);
  }
  get selectedAddress() {
    return Vc(this, Xc);
  }
  isConnected() {
    return this._state.isConnected;
  }
  async request(e9) {
    if (!e9 || "object" != typeof e9 || Array.isArray(e9)) throw Xa({ message: is.errors.invalidRequestArgs(), data: e9 });
    const { method: t3, params: n6 } = e9;
    if ("string" != typeof t3 || 0 === t3.length) throw Xa({ message: is.errors.invalidRequestMethod(), data: e9 });
    if (void 0 !== n6 && !Array.isArray(n6) && ("object" != typeof n6 || null === n6)) throw Xa({ message: is.errors.invalidRequestParams(), data: e9 });
    const r2 = null == n6 ? { method: t3 } : { method: t3, params: n6 };
    return new Promise((e10, t4) => {
      this._rpcRequest(r2, Kc(e10, t4));
    });
  }
  _initializeState(e9) {
    if (this._state.initialized) throw new Error("Provider already initialized.");
    if (e9) {
      const { accounts: t3, chainId: n6, isUnlocked: r2, networkVersion: i4 } = e9;
      this._handleConnect(n6), this._handleChainChanged({ chainId: n6, networkVersion: i4 }), this._handleUnlockStateChanged({ accounts: t3, isUnlocked: r2 }), this._handleAccountsChanged(t3);
    }
    this._state.initialized = true, this.emit("_initialized");
  }
  _rpcRequest(e9, t3) {
    let n6 = t3;
    return Array.isArray(e9) || (e9.jsonrpc || (e9.jsonrpc = "2.0"), "eth_accounts" !== e9.method && "eth_requestAccounts" !== e9.method || (n6 = (n7, r2) => {
      this._handleAccountsChanged(r2.result ?? [], "eth_accounts" === e9.method), t3(n7, r2);
    })), this._rpcEngine.handle(e9, n6);
  }
  _handleConnect(e9) {
    this._state.isConnected || (this._state.isConnected = true, this.emit("connect", { chainId: e9 }), this._log.debug(is.info.connected(e9)));
  }
  _handleDisconnect(e9, t3) {
    if (this._state.isConnected || !this._state.isPermanentlyDisconnected && !e9) {
      let n6;
      this._state.isConnected = false, e9 ? (n6 = new Ja(1013, t3 ?? is.errors.disconnected()), this._log.debug(n6)) : (n6 = new Ja(1011, t3 ?? is.errors.permanentlyDisconnected()), this._log.error(n6), Yc(this, Qc, null), this._state.accounts = null, Yc(this, Xc, null), this._state.isUnlocked = false, this._state.isPermanentlyDisconnected = true), this.emit("disconnect", n6);
    }
  }
  _handleChainChanged({ chainId: e9 } = {}) {
    jc(e9) ? (this._handleConnect(e9), e9 !== Vc(this, Qc) && (Yc(this, Qc, e9), this._state.initialized && this.emit("chainChanged", Vc(this, Qc)))) : this._log.error(is.errors.invalidNetworkParams(), { chainId: e9 });
  }
  _handleAccountsChanged(e9, t3 = false) {
    let n6 = e9;
    Array.isArray(e9) || (this._log.error("MetaMask: Received invalid accounts parameter. Please report this bug.", e9), n6 = []);
    for (const t4 of e9) if ("string" != typeof t4) {
      this._log.error("MetaMask: Received non-string account. Please report this bug.", e9), n6 = [];
      break;
    }
    if (!tl(this._state.accounts, n6) && (t3 && null !== this._state.accounts && this._log.error("MetaMask: 'eth_accounts' unexpectedly updated accounts. Please report this bug.", n6), this._state.accounts = n6, Vc(this, Xc) !== n6[0] && Yc(this, Xc, n6[0] || null), this._state.initialized)) {
      const e10 = [...n6];
      this.emit("accountsChanged", e10);
    }
  }
  _handleUnlockStateChanged({ accounts: e9, isUnlocked: t3 } = {}) {
    "boolean" == typeof t3 ? t3 !== this._state.isUnlocked && (this._state.isUnlocked = t3, this._handleAccountsChanged(e9 ?? [])) : this._log.error("MetaMask: Received invalid isUnlocked parameter. Please report this bug.");
  }
};
Qc = /* @__PURE__ */ new WeakMap(), Xc = /* @__PURE__ */ new WeakMap(), nl._defaultState = { accounts: null, isConnected: false, isUnlocked: false, initialized: false, isPermanentlyDisconnected: false };
var rl;
var il;
var ol = nl;
var sl = { exports: {} };
function al() {
  return il ? rl : (il = 1, rl = lc.EventEmitter);
}
var cl;
var ll = he(le);
cl = "function" == typeof Object.create ? function(e9, t3) {
  e9.super_ = t3, e9.prototype = Object.create(t3.prototype, { constructor: { value: e9, enumerable: false, writable: true, configurable: true } });
} : function(e9, t3) {
  e9.super_ = t3;
  var n6 = function() {
  };
  n6.prototype = t3.prototype, e9.prototype = new n6(), e9.prototype.constructor = e9;
};
var dl = Object.getOwnPropertyDescriptors || function(e9) {
  for (var t3 = Object.keys(e9), n6 = {}, r2 = 0; r2 < t3.length; r2++) n6[t3[r2]] = Object.getOwnPropertyDescriptor(e9, t3[r2]);
  return n6;
};
var ul = /%[sdj%]/g;
function hl(e9) {
  if (!Ml(e9)) {
    for (var t3 = [], n6 = 0; n6 < arguments.length; n6++) t3.push(yl(arguments[n6]));
    return t3.join(" ");
  }
  n6 = 1;
  for (var r2 = arguments, i4 = r2.length, o3 = String(e9).replace(ul, function(e10) {
    if ("%%" === e10) return "%";
    if (n6 >= i4) return e10;
    switch (e10) {
      case "%s":
        return String(r2[n6++]);
      case "%d":
        return Number(r2[n6++]);
      case "%j":
        try {
          return JSON.stringify(r2[n6++]);
        } catch (e11) {
          return "[Circular]";
        }
      default:
        return e10;
    }
  }), s2 = r2[n6]; n6 < i4; s2 = r2[++n6]) kl(s2) || !Pl(s2) ? o3 += " " + s2 : o3 += " " + yl(s2);
  return o3;
}
function fl(e9, t3) {
  if (Tl(l4.process)) return function() {
    return fl(e9, t3).apply(this, arguments);
  };
  if (true === ua.noDeprecation) return e9;
  var n6 = false;
  return function() {
    if (!n6) {
      if (ua.throwDeprecation) throw new Error(t3);
      ua.traceDeprecation ? console.trace(t3) : console.error(t3), n6 = true;
    }
    return e9.apply(this, arguments);
  };
}
var pl;
var gl = {};
function ml(e9) {
  if (Tl(pl) && (pl = ua.env.NODE_DEBUG || ""), e9 = e9.toUpperCase(), !gl[e9]) if (new RegExp("\\b" + e9 + "\\b", "i").test(pl)) {
    gl[e9] = function() {
      var t3 = hl.apply(null, arguments);
      console.error("%s %d: %s", e9, 0, t3);
    };
  } else gl[e9] = function() {
  };
  return gl[e9];
}
function yl(e9, t3) {
  var n6 = { seen: [], stylize: bl2 };
  return arguments.length >= 3 && (n6.depth = arguments[2]), arguments.length >= 4 && (n6.colors = arguments[3]), Cl(t3) ? n6.showHidden = t3 : t3 && Hl(n6, t3), Tl(n6.showHidden) && (n6.showHidden = false), Tl(n6.depth) && (n6.depth = 2), Tl(n6.colors) && (n6.colors = false), Tl(n6.customInspect) && (n6.customInspect = true), n6.colors && (n6.stylize = vl), wl2(n6, e9, n6.depth);
}
function vl(e9, t3) {
  var n6 = yl.styles[t3];
  return n6 ? "\x1B[" + yl.colors[n6][0] + "m" + e9 + "\x1B[" + yl.colors[n6][1] + "m" : e9;
}
function bl2(e9, t3) {
  return e9;
}
function wl2(e9, t3, n6) {
  if (e9.customInspect && t3 && Ll(t3.inspect) && t3.inspect !== yl && (!t3.constructor || t3.constructor.prototype !== t3)) {
    var r2 = t3.inspect(n6, e9);
    return Ml(r2) || (r2 = wl2(e9, r2, n6)), r2;
  }
  var i4 = function(e10, t4) {
    if (Tl(t4)) return e10.stylize("undefined", "undefined");
    if (Ml(t4)) {
      var n7 = "'" + JSON.stringify(t4).replace(/^"|"$/g, "").replace(/'/g, "\\'").replace(/\\"/g, '"') + "'";
      return e10.stylize(n7, "string");
    }
    if (xl(t4)) return e10.stylize("" + t4, "number");
    if (Cl(t4)) return e10.stylize("" + t4, "boolean");
    if (kl(t4)) return e10.stylize("null", "null");
  }(e9, t3);
  if (i4) return i4;
  var o3 = Object.keys(t3), s2 = function(e10) {
    var t4 = {};
    return e10.forEach(function(e11, n7) {
      t4[e11] = true;
    }), t4;
  }(o3);
  if (e9.showHidden && (o3 = Object.getOwnPropertyNames(t3)), Nl(t3) && (o3.indexOf("message") >= 0 || o3.indexOf("description") >= 0)) return El(t3);
  if (0 === o3.length) {
    if (Ll(t3)) {
      var a = t3.name ? ": " + t3.name : "";
      return e9.stylize("[Function" + a + "]", "special");
    }
    if (Rl(t3)) return e9.stylize(RegExp.prototype.toString.call(t3), "regexp");
    if (Ol(t3)) return e9.stylize(Date.prototype.toString.call(t3), "date");
    if (Nl(t3)) return El(t3);
  }
  var c3, l5 = "", d3 = false, u2 = ["{", "}"];
  (_l(t3) && (d3 = true, u2 = ["[", "]"]), Ll(t3)) && (l5 = " [Function" + (t3.name ? ": " + t3.name : "") + "]");
  return Rl(t3) && (l5 = " " + RegExp.prototype.toString.call(t3)), Ol(t3) && (l5 = " " + Date.prototype.toUTCString.call(t3)), Nl(t3) && (l5 = " " + El(t3)), 0 !== o3.length || d3 && 0 != t3.length ? n6 < 0 ? Rl(t3) ? e9.stylize(RegExp.prototype.toString.call(t3), "regexp") : e9.stylize("[Object]", "special") : (e9.seen.push(t3), c3 = d3 ? function(e10, t4, n7, r3, i5) {
    for (var o4 = [], s3 = 0, a2 = t4.length; s3 < a2; ++s3) Fl(t4, String(s3)) ? o4.push(Sl(e10, t4, n7, r3, String(s3), true)) : o4.push("");
    return i5.forEach(function(i6) {
      i6.match(/^\d+$/) || o4.push(Sl(e10, t4, n7, r3, i6, true));
    }), o4;
  }(e9, t3, n6, s2, o3) : o3.map(function(r3) {
    return Sl(e9, t3, n6, s2, r3, d3);
  }), e9.seen.pop(), function(e10, t4, n7) {
    var r3 = e10.reduce(function(e11, t5) {
      return t5.indexOf("\n"), e11 + t5.replace(/\u001b\[\d\d?m/g, "").length + 1;
    }, 0);
    if (r3 > 60) return n7[0] + ("" === t4 ? "" : t4 + "\n ") + " " + e10.join(",\n  ") + " " + n7[1];
    return n7[0] + t4 + " " + e10.join(", ") + " " + n7[1];
  }(c3, l5, u2)) : u2[0] + l5 + u2[1];
}
function El(e9) {
  return "[" + Error.prototype.toString.call(e9) + "]";
}
function Sl(e9, t3, n6, r2, i4, o3) {
  var s2, a, c3;
  if ((c3 = Object.getOwnPropertyDescriptor(t3, i4) || { value: t3[i4] }).get ? a = c3.set ? e9.stylize("[Getter/Setter]", "special") : e9.stylize("[Getter]", "special") : c3.set && (a = e9.stylize("[Setter]", "special")), Fl(r2, i4) || (s2 = "[" + i4 + "]"), a || (e9.seen.indexOf(c3.value) < 0 ? (a = kl(n6) ? wl2(e9, c3.value, null) : wl2(e9, c3.value, n6 - 1)).indexOf("\n") > -1 && (a = o3 ? a.split("\n").map(function(e10) {
    return "  " + e10;
  }).join("\n").substr(2) : "\n" + a.split("\n").map(function(e10) {
    return "   " + e10;
  }).join("\n")) : a = e9.stylize("[Circular]", "special")), Tl(s2)) {
    if (o3 && i4.match(/^\d+$/)) return a;
    (s2 = JSON.stringify("" + i4)).match(/^"([a-zA-Z_][a-zA-Z_0-9]*)"$/) ? (s2 = s2.substr(1, s2.length - 2), s2 = e9.stylize(s2, "name")) : (s2 = s2.replace(/'/g, "\\'").replace(/\\"/g, '"').replace(/(^"|"$)/g, "'"), s2 = e9.stylize(s2, "string"));
  }
  return s2 + ": " + a;
}
function _l(e9) {
  return Array.isArray(e9);
}
function Cl(e9) {
  return "boolean" == typeof e9;
}
function kl(e9) {
  return null === e9;
}
function Al(e9) {
  return null == e9;
}
function xl(e9) {
  return "number" == typeof e9;
}
function Ml(e9) {
  return "string" == typeof e9;
}
function Il(e9) {
  return "symbol" == typeof e9;
}
function Tl(e9) {
  return void 0 === e9;
}
function Rl(e9) {
  return Pl(e9) && "[object RegExp]" === Bl(e9);
}
function Pl(e9) {
  return "object" == typeof e9 && null !== e9;
}
function Ol(e9) {
  return Pl(e9) && "[object Date]" === Bl(e9);
}
function Nl(e9) {
  return Pl(e9) && ("[object Error]" === Bl(e9) || e9 instanceof Error);
}
function Ll(e9) {
  return "function" == typeof e9;
}
function Dl(e9) {
  return null === e9 || "boolean" == typeof e9 || "number" == typeof e9 || "string" == typeof e9 || "symbol" == typeof e9 || void 0 === e9;
}
function $l(e9) {
  return C3.isBuffer(e9);
}
function Bl(e9) {
  return Object.prototype.toString.call(e9);
}
function Kl(e9) {
  return e9 < 10 ? "0" + e9.toString(10) : e9.toString(10);
}
yl.colors = { bold: [1, 22], italic: [3, 23], underline: [4, 24], inverse: [7, 27], white: [37, 39], grey: [90, 39], black: [30, 39], blue: [34, 39], cyan: [36, 39], green: [32, 39], magenta: [35, 39], red: [31, 39], yellow: [33, 39] }, yl.styles = { special: "cyan", number: "yellow", boolean: "yellow", undefined: "grey", null: "bold", string: "green", date: "magenta", regexp: "red" };
var jl = ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"];
function Ul() {
  var e9, t3;
  console.log("%s - %s", (e9 = /* @__PURE__ */ new Date(), t3 = [Kl(e9.getHours()), Kl(e9.getMinutes()), Kl(e9.getSeconds())].join(":"), [e9.getDate(), jl[e9.getMonth()], t3].join(" ")), hl.apply(null, arguments));
}
function Hl(e9, t3) {
  if (!t3 || !Pl(t3)) return e9;
  for (var n6 = Object.keys(t3), r2 = n6.length; r2--; ) e9[n6[r2]] = t3[n6[r2]];
  return e9;
}
function Fl(e9, t3) {
  return Object.prototype.hasOwnProperty.call(e9, t3);
}
var zl = "undefined" != typeof Symbol ? Symbol("util.promisify.custom") : void 0;
function ql(e9) {
  if ("function" != typeof e9) throw new TypeError('The "original" argument must be of type Function');
  if (zl && e9[zl]) {
    var t3;
    if ("function" != typeof (t3 = e9[zl])) throw new TypeError('The "util.promisify.custom" argument must be of type Function');
    return Object.defineProperty(t3, zl, { value: t3, enumerable: false, writable: false, configurable: true }), t3;
  }
  function t3() {
    for (var t4, n6, r2 = new Promise(function(e10, r3) {
      t4 = e10, n6 = r3;
    }), i4 = [], o3 = 0; o3 < arguments.length; o3++) i4.push(arguments[o3]);
    i4.push(function(e10, r3) {
      e10 ? n6(e10) : t4(r3);
    });
    try {
      e9.apply(this, i4);
    } catch (e10) {
      n6(e10);
    }
    return r2;
  }
  return Object.setPrototypeOf(t3, Object.getPrototypeOf(e9)), zl && Object.defineProperty(t3, zl, { value: t3, enumerable: false, writable: false, configurable: true }), Object.defineProperties(t3, dl(e9));
}
function Wl(e9, t3) {
  if (!e9) {
    var n6 = new Error("Promise was rejected with a falsy value");
    n6.reason = e9, e9 = n6;
  }
  return t3(e9);
}
function Vl(e9) {
  if ("function" != typeof e9) throw new TypeError('The "original" argument must be of type Function');
  function t3() {
    for (var t4 = [], n6 = 0; n6 < arguments.length; n6++) t4.push(arguments[n6]);
    var r2 = t4.pop();
    if ("function" != typeof r2) throw new TypeError("The last argument must be of type Function");
    var i4 = this, o3 = function() {
      return r2.apply(i4, arguments);
    };
    e9.apply(this, t4).then(function(e10) {
      ua.nextTick(o3.bind(null, null, e10));
    }, function(e10) {
      ua.nextTick(Wl.bind(null, e10, o3));
    });
  }
  return Object.setPrototypeOf(t3, Object.getPrototypeOf(e9)), Object.defineProperties(t3, dl(e9)), t3;
}
ql.custom = zl;
var Gl;
var Yl;
var Zl;
var Jl;
var Ql = { inherits: cl, _extend: Hl, log: Ul, isBuffer: $l, isPrimitive: Dl, isFunction: Ll, isError: Nl, isDate: Ol, isObject: Pl, isRegExp: Rl, isUndefined: Tl, isSymbol: Il, isString: Ml, isNumber: xl, isNullOrUndefined: Al, isNull: kl, isBoolean: Cl, isArray: _l, inspect: yl, deprecate: fl, format: hl, debuglog: ml, promisify: ql, callbackify: Vl };
var Xl = he(Object.freeze({ __proto__: null, _extend: Hl, callbackify: Vl, debuglog: ml, default: Ql, deprecate: fl, format: hl, inherits: cl, inspect: yl, isArray: _l, isBoolean: Cl, isBuffer: $l, isDate: Ol, isError: Nl, isFunction: Ll, isNull: kl, isNullOrUndefined: Al, isNumber: xl, isObject: Pl, isPrimitive: Dl, isRegExp: Rl, isString: Ml, isSymbol: Il, isUndefined: Tl, log: Ul, promisify: ql }));
function ed() {
  if (Yl) return Gl;
  function e9(e10, t4) {
    var n7 = Object.keys(e10);
    if (Object.getOwnPropertySymbols) {
      var r3 = Object.getOwnPropertySymbols(e10);
      t4 && (r3 = r3.filter(function(t5) {
        return Object.getOwnPropertyDescriptor(e10, t5).enumerable;
      })), n7.push.apply(n7, r3);
    }
    return n7;
  }
  function t3(t4) {
    for (var r3 = 1; r3 < arguments.length; r3++) {
      var i5 = null != arguments[r3] ? arguments[r3] : {};
      r3 % 2 ? e9(Object(i5), true).forEach(function(e10) {
        n6(t4, e10, i5[e10]);
      }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(t4, Object.getOwnPropertyDescriptors(i5)) : e9(Object(i5)).forEach(function(e10) {
        Object.defineProperty(t4, e10, Object.getOwnPropertyDescriptor(i5, e10));
      });
    }
    return t4;
  }
  function n6(e10, t4, n7) {
    return (t4 = i4(t4)) in e10 ? Object.defineProperty(e10, t4, { value: n7, enumerable: true, configurable: true, writable: true }) : e10[t4] = n7, e10;
  }
  function r2(e10, t4, n7) {
    return t4 && function(e11, t5) {
      for (var n8 = 0; n8 < t5.length; n8++) {
        var r3 = t5[n8];
        r3.enumerable = r3.enumerable || false, r3.configurable = true, "value" in r3 && (r3.writable = true), Object.defineProperty(e11, i4(r3.key), r3);
      }
    }(e10.prototype, t4), Object.defineProperty(e10, "prototype", { writable: false }), e10;
  }
  function i4(e10) {
    var t4 = function(e11, t5) {
      if ("object" != typeof e11 || null === e11) return e11;
      var n7 = e11[Symbol.toPrimitive];
      if (void 0 !== n7) {
        var r3 = n7.call(e11, t5 || "default");
        if ("object" != typeof r3) return r3;
        throw new TypeError("@@toPrimitive must return a primitive value.");
      }
      return ("string" === t5 ? String : Number)(e11);
    }(e10, "string");
    return "symbol" == typeof t4 ? t4 : String(t4);
  }
  Yl = 1;
  var o3 = ll.Buffer, s2 = Xl.inspect, a = s2 && s2.custom || "inspect";
  return Gl = function() {
    function e10() {
      !function(e11, t4) {
        if (!(e11 instanceof t4)) throw new TypeError("Cannot call a class as a function");
      }(this, e10), this.head = null, this.tail = null, this.length = 0;
    }
    return r2(e10, [{ key: "push", value: function(e11) {
      var t4 = { data: e11, next: null };
      this.length > 0 ? this.tail.next = t4 : this.head = t4, this.tail = t4, ++this.length;
    } }, { key: "unshift", value: function(e11) {
      var t4 = { data: e11, next: this.head };
      0 === this.length && (this.tail = t4), this.head = t4, ++this.length;
    } }, { key: "shift", value: function() {
      if (0 !== this.length) {
        var e11 = this.head.data;
        return 1 === this.length ? this.head = this.tail = null : this.head = this.head.next, --this.length, e11;
      }
    } }, { key: "clear", value: function() {
      this.head = this.tail = null, this.length = 0;
    } }, { key: "join", value: function(e11) {
      if (0 === this.length) return "";
      for (var t4 = this.head, n7 = "" + t4.data; t4 = t4.next; ) n7 += e11 + t4.data;
      return n7;
    } }, { key: "concat", value: function(e11) {
      if (0 === this.length) return o3.alloc(0);
      for (var t4, n7, r3, i5 = o3.allocUnsafe(e11 >>> 0), s3 = this.head, a2 = 0; s3; ) t4 = s3.data, n7 = i5, r3 = a2, o3.prototype.copy.call(t4, n7, r3), a2 += s3.data.length, s3 = s3.next;
      return i5;
    } }, { key: "consume", value: function(e11, t4) {
      var n7;
      return e11 < this.head.data.length ? (n7 = this.head.data.slice(0, e11), this.head.data = this.head.data.slice(e11)) : n7 = e11 === this.head.data.length ? this.shift() : t4 ? this._getString(e11) : this._getBuffer(e11), n7;
    } }, { key: "first", value: function() {
      return this.head.data;
    } }, { key: "_getString", value: function(e11) {
      var t4 = this.head, n7 = 1, r3 = t4.data;
      for (e11 -= r3.length; t4 = t4.next; ) {
        var i5 = t4.data, o4 = e11 > i5.length ? i5.length : e11;
        if (o4 === i5.length ? r3 += i5 : r3 += i5.slice(0, e11), 0 === (e11 -= o4)) {
          o4 === i5.length ? (++n7, t4.next ? this.head = t4.next : this.head = this.tail = null) : (this.head = t4, t4.data = i5.slice(o4));
          break;
        }
        ++n7;
      }
      return this.length -= n7, r3;
    } }, { key: "_getBuffer", value: function(e11) {
      var t4 = o3.allocUnsafe(e11), n7 = this.head, r3 = 1;
      for (n7.data.copy(t4), e11 -= n7.data.length; n7 = n7.next; ) {
        var i5 = n7.data, s3 = e11 > i5.length ? i5.length : e11;
        if (i5.copy(t4, t4.length - e11, 0, s3), 0 === (e11 -= s3)) {
          s3 === i5.length ? (++r3, n7.next ? this.head = n7.next : this.head = this.tail = null) : (this.head = n7, n7.data = i5.slice(s3));
          break;
        }
        ++r3;
      }
      return this.length -= r3, t4;
    } }, { key: a, value: function(e11, n7) {
      return s2(this, t3(t3({}, n7), {}, { depth: 0, customInspect: false }));
    } }]), e10;
  }(), Gl;
}
function td() {
  if (Jl) return Zl;
  function e9(e10, r2) {
    n6(e10, r2), t3(e10);
  }
  function t3(e10) {
    e10._writableState && !e10._writableState.emitClose || e10._readableState && !e10._readableState.emitClose || e10.emit("close");
  }
  function n6(e10, t4) {
    e10.emit("error", t4);
  }
  return Jl = 1, Zl = { destroy: function(r2, i4) {
    var o3 = this, s2 = this._readableState && this._readableState.destroyed, a = this._writableState && this._writableState.destroyed;
    return s2 || a ? (i4 ? i4(r2) : r2 && (this._writableState ? this._writableState.errorEmitted || (this._writableState.errorEmitted = true, ua.nextTick(n6, this, r2)) : ua.nextTick(n6, this, r2)), this) : (this._readableState && (this._readableState.destroyed = true), this._writableState && (this._writableState.destroyed = true), this._destroy(r2 || null, function(n7) {
      !i4 && n7 ? o3._writableState ? o3._writableState.errorEmitted ? ua.nextTick(t3, o3) : (o3._writableState.errorEmitted = true, ua.nextTick(e9, o3, n7)) : ua.nextTick(e9, o3, n7) : i4 ? (ua.nextTick(t3, o3), i4(n7)) : ua.nextTick(t3, o3);
    }), this);
  }, undestroy: function() {
    this._readableState && (this._readableState.destroyed = false, this._readableState.reading = false, this._readableState.ended = false, this._readableState.endEmitted = false), this._writableState && (this._writableState.destroyed = false, this._writableState.ended = false, this._writableState.ending = false, this._writableState.finalCalled = false, this._writableState.prefinished = false, this._writableState.finished = false, this._writableState.errorEmitted = false);
  }, errorOrDestroy: function(e10, t4) {
    var n7 = e10._readableState, r2 = e10._writableState;
    n7 && n7.autoDestroy || r2 && r2.autoDestroy ? e10.destroy(t4) : e10.emit("error", t4);
  } }, Zl;
}
var nd = {};
var rd;
var id;
var od = {};
function sd(e9, t3, n6) {
  n6 || (n6 = Error);
  var r2 = function(e10) {
    var n7, r3;
    function i4(n8, r4, i5) {
      return e10.call(this, function(e11, n9, r5) {
        return "string" == typeof t3 ? t3 : t3(e11, n9, r5);
      }(n8, r4, i5)) || this;
    }
    return r3 = e10, (n7 = i4).prototype = Object.create(r3.prototype), n7.prototype.constructor = n7, n7.__proto__ = r3, i4;
  }(n6);
  r2.prototype.name = n6.name, r2.prototype.code = e9, od[e9] = r2;
}
function ad(e9, t3) {
  if (Array.isArray(e9)) {
    var n6 = e9.length;
    return e9 = e9.map(function(e10) {
      return String(e10);
    }), n6 > 2 ? "one of ".concat(t3, " ").concat(e9.slice(0, n6 - 1).join(", "), ", or ") + e9[n6 - 1] : 2 === n6 ? "one of ".concat(t3, " ").concat(e9[0], " or ").concat(e9[1]) : "of ".concat(t3, " ").concat(e9[0]);
  }
  return "of ".concat(t3, " ").concat(String(e9));
}
function cd() {
  if (id) return rd;
  id = 1;
  var e9 = nd.codes.ERR_INVALID_OPT_VALUE;
  return rd = { getHighWaterMark: function(t3, n6, r2, i4) {
    var o3 = function(e10, t4, n7) {
      return null != e10.highWaterMark ? e10.highWaterMark : t4 ? e10[n7] : null;
    }(n6, i4, r2);
    if (null != o3) {
      if (!isFinite(o3) || Math.floor(o3) !== o3 || o3 < 0) throw new e9(i4 ? r2 : "highWaterMark", o3);
      return Math.floor(o3);
    }
    return t3.objectMode ? 16 : 16384;
  } };
}
sd("ERR_INVALID_OPT_VALUE", function(e9, t3) {
  return 'The value "' + t3 + '" is invalid for option "' + e9 + '"';
}, TypeError), sd("ERR_INVALID_ARG_TYPE", function(e9, t3, n6) {
  var r2, i4, o3;
  if ("string" == typeof t3 && (i4 = "not ", t3.substr(0, i4.length) === i4) ? (r2 = "must not be", t3 = t3.replace(/^not /, "")) : r2 = "must be", function(e10, t4, n7) {
    return (void 0 === n7 || n7 > e10.length) && (n7 = e10.length), e10.substring(n7 - t4.length, n7) === t4;
  }(e9, " argument")) o3 = "The ".concat(e9, " ").concat(r2, " ").concat(ad(t3, "type"));
  else {
    var s2 = function(e10, t4, n7) {
      return "number" != typeof n7 && (n7 = 0), !(n7 + t4.length > e10.length) && -1 !== e10.indexOf(t4, n7);
    }(e9, ".") ? "property" : "argument";
    o3 = 'The "'.concat(e9, '" ').concat(s2, " ").concat(r2, " ").concat(ad(t3, "type"));
  }
  return o3 += ". Received type ".concat(typeof n6);
}, TypeError), sd("ERR_STREAM_PUSH_AFTER_EOF", "stream.push() after EOF"), sd("ERR_METHOD_NOT_IMPLEMENTED", function(e9) {
  return "The " + e9 + " method is not implemented";
}), sd("ERR_STREAM_PREMATURE_CLOSE", "Premature close"), sd("ERR_STREAM_DESTROYED", function(e9) {
  return "Cannot call " + e9 + " after a stream was destroyed";
}), sd("ERR_MULTIPLE_CALLBACK", "Callback called multiple times"), sd("ERR_STREAM_CANNOT_PIPE", "Cannot pipe, not readable"), sd("ERR_STREAM_WRITE_AFTER_END", "write after end"), sd("ERR_STREAM_NULL_VALUES", "May not write null values to stream", TypeError), sd("ERR_UNKNOWN_ENCODING", function(e9) {
  return "Unknown encoding: " + e9;
}, TypeError), sd("ERR_STREAM_UNSHIFT_AFTER_END_EVENT", "stream.unshift() after end event"), nd.codes = od;
var ld;
var dd;
var ud;
var hd;
var fd;
var pd;
var gd = "function" == typeof Object.create ? function(e9, t3) {
  e9.super_ = t3, e9.prototype = Object.create(t3.prototype, { constructor: { value: e9, enumerable: false, writable: true, configurable: true } });
} : function(e9, t3) {
  e9.super_ = t3;
  var n6 = function() {
  };
  n6.prototype = t3.prototype, e9.prototype = new n6(), e9.prototype.constructor = e9;
};
var md = he(Object.freeze({ __proto__: null, default: gd }));
function yd() {
  if (dd) return ld;
  function e9(e10) {
    try {
      if (!de.localStorage) return false;
    } catch (e11) {
      return false;
    }
    var t3 = de.localStorage[e10];
    return null != t3 && "true" === String(t3).toLowerCase();
  }
  return dd = 1, ld = function(t3, n6) {
    if (e9("noDeprecation")) return t3;
    var r2 = false;
    return function() {
      if (!r2) {
        if (e9("throwDeprecation")) throw new Error(n6);
        e9("traceDeprecation") ? console.trace(n6) : console.warn(n6), r2 = true;
      }
      return t3.apply(this, arguments);
    };
  }, ld;
}
function vd() {
  if (hd) return ud;
  function e9(e10) {
    var t4 = this;
    this.next = null, this.entry = null, this.finish = function() {
      !function(e11, t5, n7) {
        var r3 = e11.entry;
        e11.entry = null;
        for (; r3; ) {
          var i5 = r3.callback;
          t5.pendingcb--, i5(n7), r3 = r3.next;
        }
        t5.corkedRequestsFree.next = e11;
      }(t4, e10);
    };
  }
  var t3;
  hd = 1, ud = E4, E4.WritableState = w5;
  var n6 = { deprecate: yd() }, r2 = al(), i4 = ll.Buffer, o3 = (void 0 !== de ? de : "undefined" != typeof window ? window : "undefined" != typeof self ? self : {}).Uint8Array || function() {
  };
  var s2, a = td(), c3 = cd().getHighWaterMark, l5 = nd.codes, d3 = l5.ERR_INVALID_ARG_TYPE, u2 = l5.ERR_METHOD_NOT_IMPLEMENTED, h3 = l5.ERR_MULTIPLE_CALLBACK, f4 = l5.ERR_STREAM_CANNOT_PIPE, p4 = l5.ERR_STREAM_DESTROYED, g2 = l5.ERR_STREAM_NULL_VALUES, m4 = l5.ERR_STREAM_WRITE_AFTER_END, y2 = l5.ERR_UNKNOWN_ENCODING, v2 = a.errorOrDestroy;
  function b3() {
  }
  function w5(n7, r3, i5) {
    t3 = t3 || bd(), n7 = n7 || {}, "boolean" != typeof i5 && (i5 = r3 instanceof t3), this.objectMode = !!n7.objectMode, i5 && (this.objectMode = this.objectMode || !!n7.writableObjectMode), this.highWaterMark = c3(this, n7, "writableHighWaterMark", i5), this.finalCalled = false, this.needDrain = false, this.ending = false, this.ended = false, this.finished = false, this.destroyed = false;
    var o4 = false === n7.decodeStrings;
    this.decodeStrings = !o4, this.defaultEncoding = n7.defaultEncoding || "utf8", this.length = 0, this.writing = false, this.corked = 0, this.sync = true, this.bufferProcessing = false, this.onwrite = function(e10) {
      !function(e11, t4) {
        var n8 = e11._writableState, r4 = n8.sync, i6 = n8.writecb;
        if ("function" != typeof i6) throw new h3();
        if (function(e12) {
          e12.writing = false, e12.writecb = null, e12.length -= e12.writelen, e12.writelen = 0;
        }(n8), t4) !function(e12, t5, n9, r5, i7) {
          --t5.pendingcb, n9 ? (ua.nextTick(i7, r5), ua.nextTick(x3, e12, t5), e12._writableState.errorEmitted = true, v2(e12, r5)) : (i7(r5), e12._writableState.errorEmitted = true, v2(e12, r5), x3(e12, t5));
        }(e11, n8, r4, t4, i6);
        else {
          var o5 = k3(n8) || e11.destroyed;
          o5 || n8.corked || n8.bufferProcessing || !n8.bufferedRequest || C4(e11, n8), r4 ? ua.nextTick(_2, e11, n8, o5, i6) : _2(e11, n8, o5, i6);
        }
      }(r3, e10);
    }, this.writecb = null, this.writelen = 0, this.bufferedRequest = null, this.lastBufferedRequest = null, this.pendingcb = 0, this.prefinished = false, this.errorEmitted = false, this.emitClose = false !== n7.emitClose, this.autoDestroy = !!n7.autoDestroy, this.bufferedRequestCount = 0, this.corkedRequestsFree = new e9(this);
  }
  function E4(e10) {
    var n7 = this instanceof (t3 = t3 || bd());
    if (!n7 && !s2.call(E4, this)) return new E4(e10);
    this._writableState = new w5(e10, this, n7), this.writable = true, e10 && ("function" == typeof e10.write && (this._write = e10.write), "function" == typeof e10.writev && (this._writev = e10.writev), "function" == typeof e10.destroy && (this._destroy = e10.destroy), "function" == typeof e10.final && (this._final = e10.final)), r2.call(this);
  }
  function S5(e10, t4, n7, r3, i5, o4, s3) {
    t4.writelen = r3, t4.writecb = s3, t4.writing = true, t4.sync = true, t4.destroyed ? t4.onwrite(new p4("write")) : n7 ? e10._writev(i5, t4.onwrite) : e10._write(i5, o4, t4.onwrite), t4.sync = false;
  }
  function _2(e10, t4, n7, r3) {
    n7 || function(e11, t5) {
      0 === t5.length && t5.needDrain && (t5.needDrain = false, e11.emit("drain"));
    }(e10, t4), t4.pendingcb--, r3(), x3(e10, t4);
  }
  function C4(t4, n7) {
    n7.bufferProcessing = true;
    var r3 = n7.bufferedRequest;
    if (t4._writev && r3 && r3.next) {
      var i5 = n7.bufferedRequestCount, o4 = new Array(i5), s3 = n7.corkedRequestsFree;
      s3.entry = r3;
      for (var a2 = 0, c4 = true; r3; ) o4[a2] = r3, r3.isBuf || (c4 = false), r3 = r3.next, a2 += 1;
      o4.allBuffers = c4, S5(t4, n7, true, n7.length, o4, "", s3.finish), n7.pendingcb++, n7.lastBufferedRequest = null, s3.next ? (n7.corkedRequestsFree = s3.next, s3.next = null) : n7.corkedRequestsFree = new e9(n7), n7.bufferedRequestCount = 0;
    } else {
      for (; r3; ) {
        var l6 = r3.chunk, d4 = r3.encoding, u3 = r3.callback;
        if (S5(t4, n7, false, n7.objectMode ? 1 : l6.length, l6, d4, u3), r3 = r3.next, n7.bufferedRequestCount--, n7.writing) break;
      }
      null === r3 && (n7.lastBufferedRequest = null);
    }
    n7.bufferedRequest = r3, n7.bufferProcessing = false;
  }
  function k3(e10) {
    return e10.ending && 0 === e10.length && null === e10.bufferedRequest && !e10.finished && !e10.writing;
  }
  function A3(e10, t4) {
    e10._final(function(n7) {
      t4.pendingcb--, n7 && v2(e10, n7), t4.prefinished = true, e10.emit("prefinish"), x3(e10, t4);
    });
  }
  function x3(e10, t4) {
    var n7 = k3(t4);
    if (n7 && (function(e11, t5) {
      t5.prefinished || t5.finalCalled || ("function" != typeof e11._final || t5.destroyed ? (t5.prefinished = true, e11.emit("prefinish")) : (t5.pendingcb++, t5.finalCalled = true, ua.nextTick(A3, e11, t5)));
    }(e10, t4), 0 === t4.pendingcb && (t4.finished = true, e10.emit("finish"), t4.autoDestroy))) {
      var r3 = e10._readableState;
      (!r3 || r3.autoDestroy && r3.endEmitted) && e10.destroy();
    }
    return n7;
  }
  return md(E4, r2), w5.prototype.getBuffer = function() {
    for (var e10 = this.bufferedRequest, t4 = []; e10; ) t4.push(e10), e10 = e10.next;
    return t4;
  }, function() {
    try {
      Object.defineProperty(w5.prototype, "buffer", { get: n6.deprecate(function() {
        return this.getBuffer();
      }, "_writableState.buffer is deprecated. Use _writableState.getBuffer instead.", "DEP0003") });
    } catch (e10) {
    }
  }(), "function" == typeof Symbol && Symbol.hasInstance && "function" == typeof Function.prototype[Symbol.hasInstance] ? (s2 = Function.prototype[Symbol.hasInstance], Object.defineProperty(E4, Symbol.hasInstance, { value: function(e10) {
    return !!s2.call(this, e10) || this === E4 && (e10 && e10._writableState instanceof w5);
  } })) : s2 = function(e10) {
    return e10 instanceof this;
  }, E4.prototype.pipe = function() {
    v2(this, new f4());
  }, E4.prototype.write = function(e10, t4, n7) {
    var r3, s3 = this._writableState, a2 = false, c4 = !s3.objectMode && (r3 = e10, i4.isBuffer(r3) || r3 instanceof o3);
    return c4 && !i4.isBuffer(e10) && (e10 = function(e11) {
      return i4.from(e11);
    }(e10)), "function" == typeof t4 && (n7 = t4, t4 = null), c4 ? t4 = "buffer" : t4 || (t4 = s3.defaultEncoding), "function" != typeof n7 && (n7 = b3), s3.ending ? function(e11, t5) {
      var n8 = new m4();
      v2(e11, n8), ua.nextTick(t5, n8);
    }(this, n7) : (c4 || function(e11, t5, n8, r4) {
      var i5;
      return null === n8 ? i5 = new g2() : "string" == typeof n8 || t5.objectMode || (i5 = new d3("chunk", ["string", "Buffer"], n8)), !i5 || (v2(e11, i5), ua.nextTick(r4, i5), false);
    }(this, s3, e10, n7)) && (s3.pendingcb++, a2 = function(e11, t5, n8, r4, o4, s4) {
      if (!n8) {
        var a3 = function(e12, t6, n9) {
          e12.objectMode || false === e12.decodeStrings || "string" != typeof t6 || (t6 = i4.from(t6, n9));
          return t6;
        }(t5, r4, o4);
        r4 !== a3 && (n8 = true, o4 = "buffer", r4 = a3);
      }
      var c5 = t5.objectMode ? 1 : r4.length;
      t5.length += c5;
      var l6 = t5.length < t5.highWaterMark;
      l6 || (t5.needDrain = true);
      if (t5.writing || t5.corked) {
        var d4 = t5.lastBufferedRequest;
        t5.lastBufferedRequest = { chunk: r4, encoding: o4, isBuf: n8, callback: s4, next: null }, d4 ? d4.next = t5.lastBufferedRequest : t5.bufferedRequest = t5.lastBufferedRequest, t5.bufferedRequestCount += 1;
      } else S5(e11, t5, false, c5, r4, o4, s4);
      return l6;
    }(this, s3, c4, e10, t4, n7)), a2;
  }, E4.prototype.cork = function() {
    this._writableState.corked++;
  }, E4.prototype.uncork = function() {
    var e10 = this._writableState;
    e10.corked && (e10.corked--, e10.writing || e10.corked || e10.bufferProcessing || !e10.bufferedRequest || C4(this, e10));
  }, E4.prototype.setDefaultEncoding = function(e10) {
    if ("string" == typeof e10 && (e10 = e10.toLowerCase()), !(["hex", "utf8", "utf-8", "ascii", "binary", "base64", "ucs2", "ucs-2", "utf16le", "utf-16le", "raw"].indexOf((e10 + "").toLowerCase()) > -1)) throw new y2(e10);
    return this._writableState.defaultEncoding = e10, this;
  }, Object.defineProperty(E4.prototype, "writableBuffer", { enumerable: false, get: function() {
    return this._writableState && this._writableState.getBuffer();
  } }), Object.defineProperty(E4.prototype, "writableHighWaterMark", { enumerable: false, get: function() {
    return this._writableState.highWaterMark;
  } }), E4.prototype._write = function(e10, t4, n7) {
    n7(new u2("_write()"));
  }, E4.prototype._writev = null, E4.prototype.end = function(e10, t4, n7) {
    var r3 = this._writableState;
    return "function" == typeof e10 ? (n7 = e10, e10 = null, t4 = null) : "function" == typeof t4 && (n7 = t4, t4 = null), null != e10 && this.write(e10, t4), r3.corked && (r3.corked = 1, this.uncork()), r3.ending || function(e11, t5, n8) {
      t5.ending = true, x3(e11, t5), n8 && (t5.finished ? ua.nextTick(n8) : e11.once("finish", n8));
      t5.ended = true, e11.writable = false;
    }(this, r3, n7), this;
  }, Object.defineProperty(E4.prototype, "writableLength", { enumerable: false, get: function() {
    return this._writableState.length;
  } }), Object.defineProperty(E4.prototype, "destroyed", { enumerable: false, get: function() {
    return void 0 !== this._writableState && this._writableState.destroyed;
  }, set: function(e10) {
    this._writableState && (this._writableState.destroyed = e10);
  } }), E4.prototype.destroy = a.destroy, E4.prototype._undestroy = a.undestroy, E4.prototype._destroy = function(e10, t4) {
    t4(e10);
  }, ud;
}
function bd() {
  if (pd) return fd;
  pd = 1;
  var e9 = Object.keys || function(e10) {
    var t4 = [];
    for (var n7 in e10) t4.push(n7);
    return t4;
  };
  fd = s2;
  var t3 = Dd(), n6 = vd();
  md(s2, t3);
  for (var r2 = e9(n6.prototype), i4 = 0; i4 < r2.length; i4++) {
    var o3 = r2[i4];
    s2.prototype[o3] || (s2.prototype[o3] = n6.prototype[o3]);
  }
  function s2(e10) {
    if (!(this instanceof s2)) return new s2(e10);
    t3.call(this, e10), n6.call(this, e10), this.allowHalfOpen = true, e10 && (false === e10.readable && (this.readable = false), false === e10.writable && (this.writable = false), false === e10.allowHalfOpen && (this.allowHalfOpen = false, this.once("end", a)));
  }
  function a() {
    this._writableState.ended || ua.nextTick(c3, this);
  }
  function c3(e10) {
    e10.end();
  }
  return Object.defineProperty(s2.prototype, "writableHighWaterMark", { enumerable: false, get: function() {
    return this._writableState.highWaterMark;
  } }), Object.defineProperty(s2.prototype, "writableBuffer", { enumerable: false, get: function() {
    return this._writableState && this._writableState.getBuffer();
  } }), Object.defineProperty(s2.prototype, "writableLength", { enumerable: false, get: function() {
    return this._writableState.length;
  } }), Object.defineProperty(s2.prototype, "destroyed", { enumerable: false, get: function() {
    return void 0 !== this._readableState && void 0 !== this._writableState && (this._readableState.destroyed && this._writableState.destroyed);
  }, set: function(e10) {
    void 0 !== this._readableState && void 0 !== this._writableState && (this._readableState.destroyed = e10, this._writableState.destroyed = e10);
  } }), fd;
}
var wd = C3.isEncoding || function(e9) {
  switch (e9 && e9.toLowerCase()) {
    case "hex":
    case "utf8":
    case "utf-8":
    case "ascii":
    case "binary":
    case "base64":
    case "ucs2":
    case "ucs-2":
    case "utf16le":
    case "utf-16le":
    case "raw":
      return true;
    default:
      return false;
  }
};
function Ed(e9) {
  switch (this.encoding = (e9 || "utf8").toLowerCase().replace(/[-_]/, ""), function(e10) {
    if (e10 && !wd(e10)) throw new Error("Unknown encoding: " + e10);
  }(e9), this.encoding) {
    case "utf8":
      this.surrogateSize = 3;
      break;
    case "ucs2":
    case "utf16le":
      this.surrogateSize = 2, this.detectIncompleteChar = _d;
      break;
    case "base64":
      this.surrogateSize = 3, this.detectIncompleteChar = Cd;
      break;
    default:
      return void (this.write = Sd);
  }
  this.charBuffer = new C3(6), this.charReceived = 0, this.charLength = 0;
}
function Sd(e9) {
  return e9.toString(this.encoding);
}
function _d(e9) {
  this.charReceived = e9.length % 2, this.charLength = this.charReceived ? 2 : 0;
}
function Cd(e9) {
  this.charReceived = e9.length % 3, this.charLength = this.charReceived ? 3 : 0;
}
Ed.prototype.write = function(e9) {
  for (var t3 = ""; this.charLength; ) {
    var n6 = e9.length >= this.charLength - this.charReceived ? this.charLength - this.charReceived : e9.length;
    if (e9.copy(this.charBuffer, this.charReceived, 0, n6), this.charReceived += n6, this.charReceived < this.charLength) return "";
    if (e9 = e9.slice(n6, e9.length), !((i4 = (t3 = this.charBuffer.slice(0, this.charLength).toString(this.encoding)).charCodeAt(t3.length - 1)) >= 55296 && i4 <= 56319)) {
      if (this.charReceived = this.charLength = 0, 0 === e9.length) return t3;
      break;
    }
    this.charLength += this.surrogateSize, t3 = "";
  }
  this.detectIncompleteChar(e9);
  var r2 = e9.length;
  this.charLength && (e9.copy(this.charBuffer, 0, e9.length - this.charReceived, r2), r2 -= this.charReceived);
  var i4;
  r2 = (t3 += e9.toString(this.encoding, 0, r2)).length - 1;
  if ((i4 = t3.charCodeAt(r2)) >= 55296 && i4 <= 56319) {
    var o3 = this.surrogateSize;
    return this.charLength += o3, this.charReceived += o3, this.charBuffer.copy(this.charBuffer, o3, 0, o3), e9.copy(this.charBuffer, 0, 0, o3), t3.substring(0, r2);
  }
  return t3;
}, Ed.prototype.detectIncompleteChar = function(e9) {
  for (var t3 = e9.length >= 3 ? 3 : e9.length; t3 > 0; t3--) {
    var n6 = e9[e9.length - t3];
    if (1 == t3 && n6 >> 5 == 6) {
      this.charLength = 2;
      break;
    }
    if (t3 <= 2 && n6 >> 4 == 14) {
      this.charLength = 3;
      break;
    }
    if (t3 <= 3 && n6 >> 3 == 30) {
      this.charLength = 4;
      break;
    }
  }
  this.charReceived = t3;
}, Ed.prototype.end = function(e9) {
  var t3 = "";
  if (e9 && e9.length && (t3 = this.write(e9)), this.charReceived) {
    var n6 = this.charReceived, r2 = this.charBuffer, i4 = this.encoding;
    t3 += r2.slice(0, n6).toString(i4);
  }
  return t3;
};
var kd = he(Object.freeze({ __proto__: null, StringDecoder: Ed }));
var Ad = nd.codes.ERR_STREAM_PREMATURE_CLOSE;
function xd() {
}
var Md;
var Id;
var Td;
var Rd;
var Pd;
var Od;
var Nd = function e7(t3, n6, r2) {
  if ("function" == typeof n6) return e7(t3, null, n6);
  n6 || (n6 = {}), r2 = /* @__PURE__ */ function(e9) {
    var t4 = false;
    return function() {
      if (!t4) {
        t4 = true;
        for (var n7 = arguments.length, r3 = new Array(n7), i5 = 0; i5 < n7; i5++) r3[i5] = arguments[i5];
        e9.apply(this, r3);
      }
    };
  }(r2 || xd);
  var i4 = n6.readable || false !== n6.readable && t3.readable, o3 = n6.writable || false !== n6.writable && t3.writable, s2 = function() {
    t3.writable || c3();
  }, a = t3._writableState && t3._writableState.finished, c3 = function() {
    o3 = false, a = true, i4 || r2.call(t3);
  }, l5 = t3._readableState && t3._readableState.endEmitted, d3 = function() {
    i4 = false, l5 = true, o3 || r2.call(t3);
  }, u2 = function(e9) {
    r2.call(t3, e9);
  }, h3 = function() {
    var e9;
    return i4 && !l5 ? (t3._readableState && t3._readableState.ended || (e9 = new Ad()), r2.call(t3, e9)) : o3 && !a ? (t3._writableState && t3._writableState.ended || (e9 = new Ad()), r2.call(t3, e9)) : void 0;
  }, f4 = function() {
    t3.req.on("finish", c3);
  };
  return !function(e9) {
    return e9.setHeader && "function" == typeof e9.abort;
  }(t3) ? o3 && !t3._writableState && (t3.on("end", s2), t3.on("close", s2)) : (t3.on("complete", c3), t3.on("abort", h3), t3.req ? f4() : t3.on("request", f4)), t3.on("end", d3), t3.on("finish", c3), false !== n6.error && t3.on("error", u2), t3.on("close", h3), function() {
    t3.removeListener("complete", c3), t3.removeListener("abort", h3), t3.removeListener("request", f4), t3.req && t3.req.removeListener("finish", c3), t3.removeListener("end", s2), t3.removeListener("close", s2), t3.removeListener("finish", c3), t3.removeListener("end", d3), t3.removeListener("error", u2), t3.removeListener("close", h3);
  };
};
function Ld() {
  if (Id) return Md;
  var e9;
  function t3(e10, t4, n7) {
    return (t4 = function(e11) {
      var t5 = function(e12, t6) {
        if ("object" != typeof e12 || null === e12) return e12;
        var n8 = e12[Symbol.toPrimitive];
        if (void 0 !== n8) {
          var r3 = n8.call(e12, t6 || "default");
          if ("object" != typeof r3) return r3;
          throw new TypeError("@@toPrimitive must return a primitive value.");
        }
        return ("string" === t6 ? String : Number)(e12);
      }(e11, "string");
      return "symbol" == typeof t5 ? t5 : String(t5);
    }(t4)) in e10 ? Object.defineProperty(e10, t4, { value: n7, enumerable: true, configurable: true, writable: true }) : e10[t4] = n7, e10;
  }
  Id = 1;
  var n6 = Nd, r2 = Symbol("lastResolve"), i4 = Symbol("lastReject"), o3 = Symbol("error"), s2 = Symbol("ended"), a = Symbol("lastPromise"), c3 = Symbol("handlePromise"), l5 = Symbol("stream");
  function d3(e10, t4) {
    return { value: e10, done: t4 };
  }
  function u2(e10) {
    var t4 = e10[r2];
    if (null !== t4) {
      var n7 = e10[l5].read();
      null !== n7 && (e10[a] = null, e10[r2] = null, e10[i4] = null, t4(d3(n7, false)));
    }
  }
  function h3(e10) {
    ua.nextTick(u2, e10);
  }
  var f4 = Object.getPrototypeOf(function() {
  }), p4 = Object.setPrototypeOf((t3(e9 = { get stream() {
    return this[l5];
  }, next: function() {
    var e10 = this, t4 = this[o3];
    if (null !== t4) return Promise.reject(t4);
    if (this[s2]) return Promise.resolve(d3(void 0, true));
    if (this[l5].destroyed) return new Promise(function(t5, n8) {
      ua.nextTick(function() {
        e10[o3] ? n8(e10[o3]) : t5(d3(void 0, true));
      });
    });
    var n7, r3 = this[a];
    if (r3) n7 = new Promise(/* @__PURE__ */ function(e11, t5) {
      return function(n8, r4) {
        e11.then(function() {
          t5[s2] ? n8(d3(void 0, true)) : t5[c3](n8, r4);
        }, r4);
      };
    }(r3, this));
    else {
      var i5 = this[l5].read();
      if (null !== i5) return Promise.resolve(d3(i5, false));
      n7 = new Promise(this[c3]);
    }
    return this[a] = n7, n7;
  } }, Symbol.asyncIterator, function() {
    return this;
  }), t3(e9, "return", function() {
    var e10 = this;
    return new Promise(function(t4, n7) {
      e10[l5].destroy(null, function(e11) {
        e11 ? n7(e11) : t4(d3(void 0, true));
      });
    });
  }), e9), f4);
  return Md = function(e10) {
    var u3, f5 = Object.create(p4, (t3(u3 = {}, l5, { value: e10, writable: true }), t3(u3, r2, { value: null, writable: true }), t3(u3, i4, { value: null, writable: true }), t3(u3, o3, { value: null, writable: true }), t3(u3, s2, { value: e10._readableState.endEmitted, writable: true }), t3(u3, c3, { value: function(e11, t4) {
      var n7 = f5[l5].read();
      n7 ? (f5[a] = null, f5[r2] = null, f5[i4] = null, e11(d3(n7, false))) : (f5[r2] = e11, f5[i4] = t4);
    }, writable: true }), u3));
    return f5[a] = null, n6(e10, function(e11) {
      if (e11 && "ERR_STREAM_PREMATURE_CLOSE" !== e11.code) {
        var t4 = f5[i4];
        return null !== t4 && (f5[a] = null, f5[r2] = null, f5[i4] = null, t4(e11)), void (f5[o3] = e11);
      }
      var n7 = f5[r2];
      null !== n7 && (f5[a] = null, f5[r2] = null, f5[i4] = null, n7(d3(void 0, true))), f5[s2] = true;
    }), e10.on("readable", h3.bind(null, f5)), f5;
  }, Md;
}
function Dd() {
  if (Od) return Pd;
  var e9;
  Od = 1, Pd = E4, E4.ReadableState = w5, lc.EventEmitter;
  var t3 = function(e10, t4) {
    return e10.listeners(t4).length;
  }, n6 = al(), r2 = ll.Buffer, i4 = (void 0 !== de ? de : "undefined" != typeof window ? window : "undefined" != typeof self ? self : {}).Uint8Array || function() {
  };
  var o3, s2 = Xl;
  o3 = s2 && s2.debuglog ? s2.debuglog("stream") : function() {
  };
  var a, c3, l5, d3 = ed(), u2 = td(), h3 = cd().getHighWaterMark, f4 = nd.codes, p4 = f4.ERR_INVALID_ARG_TYPE, g2 = f4.ERR_STREAM_PUSH_AFTER_EOF, m4 = f4.ERR_METHOD_NOT_IMPLEMENTED, y2 = f4.ERR_STREAM_UNSHIFT_AFTER_END_EVENT;
  md(E4, n6);
  var v2 = u2.errorOrDestroy, b3 = ["error", "close", "destroy", "pause", "resume"];
  function w5(t4, n7, r3) {
    e9 = e9 || bd(), t4 = t4 || {}, "boolean" != typeof r3 && (r3 = n7 instanceof e9), this.objectMode = !!t4.objectMode, r3 && (this.objectMode = this.objectMode || !!t4.readableObjectMode), this.highWaterMark = h3(this, t4, "readableHighWaterMark", r3), this.buffer = new d3(), this.length = 0, this.pipes = null, this.pipesCount = 0, this.flowing = null, this.ended = false, this.endEmitted = false, this.reading = false, this.sync = true, this.needReadable = false, this.emittedReadable = false, this.readableListening = false, this.resumeScheduled = false, this.paused = true, this.emitClose = false !== t4.emitClose, this.autoDestroy = !!t4.autoDestroy, this.destroyed = false, this.defaultEncoding = t4.defaultEncoding || "utf8", this.awaitDrain = 0, this.readingMore = false, this.decoder = null, this.encoding = null, t4.encoding && (a || (a = kd.StringDecoder), this.decoder = new a(t4.encoding), this.encoding = t4.encoding);
  }
  function E4(t4) {
    if (e9 = e9 || bd(), !(this instanceof E4)) return new E4(t4);
    var r3 = this instanceof e9;
    this._readableState = new w5(t4, this, r3), this.readable = true, t4 && ("function" == typeof t4.read && (this._read = t4.read), "function" == typeof t4.destroy && (this._destroy = t4.destroy)), n6.call(this);
  }
  function S5(e10, t4, n7, s3, a2) {
    o3("readableAddChunk", t4);
    var c4, l6 = e10._readableState;
    if (null === t4) l6.reading = false, function(e11, t5) {
      if (o3("onEofChunk"), t5.ended) return;
      if (t5.decoder) {
        var n8 = t5.decoder.end();
        n8 && n8.length && (t5.buffer.push(n8), t5.length += t5.objectMode ? 1 : n8.length);
      }
      t5.ended = true, t5.sync ? A3(e11) : (t5.needReadable = false, t5.emittedReadable || (t5.emittedReadable = true, x3(e11)));
    }(e10, l6);
    else if (a2 || (c4 = function(e11, t5) {
      var n8;
      o4 = t5, r2.isBuffer(o4) || o4 instanceof i4 || "string" == typeof t5 || void 0 === t5 || e11.objectMode || (n8 = new p4("chunk", ["string", "Buffer", "Uint8Array"], t5));
      var o4;
      return n8;
    }(l6, t4)), c4) v2(e10, c4);
    else if (l6.objectMode || t4 && t4.length > 0) if ("string" == typeof t4 || l6.objectMode || Object.getPrototypeOf(t4) === r2.prototype || (t4 = function(e11) {
      return r2.from(e11);
    }(t4)), s3) l6.endEmitted ? v2(e10, new y2()) : _2(e10, l6, t4, true);
    else if (l6.ended) v2(e10, new g2());
    else {
      if (l6.destroyed) return false;
      l6.reading = false, l6.decoder && !n7 ? (t4 = l6.decoder.write(t4), l6.objectMode || 0 !== t4.length ? _2(e10, l6, t4, false) : M4(e10, l6)) : _2(e10, l6, t4, false);
    }
    else s3 || (l6.reading = false, M4(e10, l6));
    return !l6.ended && (l6.length < l6.highWaterMark || 0 === l6.length);
  }
  function _2(e10, t4, n7, r3) {
    t4.flowing && 0 === t4.length && !t4.sync ? (t4.awaitDrain = 0, e10.emit("data", n7)) : (t4.length += t4.objectMode ? 1 : n7.length, r3 ? t4.buffer.unshift(n7) : t4.buffer.push(n7), t4.needReadable && A3(e10)), M4(e10, t4);
  }
  Object.defineProperty(E4.prototype, "destroyed", { enumerable: false, get: function() {
    return void 0 !== this._readableState && this._readableState.destroyed;
  }, set: function(e10) {
    this._readableState && (this._readableState.destroyed = e10);
  } }), E4.prototype.destroy = u2.destroy, E4.prototype._undestroy = u2.undestroy, E4.prototype._destroy = function(e10, t4) {
    t4(e10);
  }, E4.prototype.push = function(e10, t4) {
    var n7, i5 = this._readableState;
    return i5.objectMode ? n7 = true : "string" == typeof e10 && ((t4 = t4 || i5.defaultEncoding) !== i5.encoding && (e10 = r2.from(e10, t4), t4 = ""), n7 = true), S5(this, e10, t4, false, n7);
  }, E4.prototype.unshift = function(e10) {
    return S5(this, e10, null, true, false);
  }, E4.prototype.isPaused = function() {
    return false === this._readableState.flowing;
  }, E4.prototype.setEncoding = function(e10) {
    a || (a = kd.StringDecoder);
    var t4 = new a(e10);
    this._readableState.decoder = t4, this._readableState.encoding = this._readableState.decoder.encoding;
    for (var n7 = this._readableState.buffer.head, r3 = ""; null !== n7; ) r3 += t4.write(n7.data), n7 = n7.next;
    return this._readableState.buffer.clear(), "" !== r3 && this._readableState.buffer.push(r3), this._readableState.length = r3.length, this;
  };
  var C4 = 1073741824;
  function k3(e10, t4) {
    return e10 <= 0 || 0 === t4.length && t4.ended ? 0 : t4.objectMode ? 1 : e10 != e10 ? t4.flowing && t4.length ? t4.buffer.head.data.length : t4.length : (e10 > t4.highWaterMark && (t4.highWaterMark = function(e11) {
      return e11 >= C4 ? e11 = C4 : (e11--, e11 |= e11 >>> 1, e11 |= e11 >>> 2, e11 |= e11 >>> 4, e11 |= e11 >>> 8, e11 |= e11 >>> 16, e11++), e11;
    }(e10)), e10 <= t4.length ? e10 : t4.ended ? t4.length : (t4.needReadable = true, 0));
  }
  function A3(e10) {
    var t4 = e10._readableState;
    o3("emitReadable", t4.needReadable, t4.emittedReadable), t4.needReadable = false, t4.emittedReadable || (o3("emitReadable", t4.flowing), t4.emittedReadable = true, ua.nextTick(x3, e10));
  }
  function x3(e10) {
    var t4 = e10._readableState;
    o3("emitReadable_", t4.destroyed, t4.length, t4.ended), t4.destroyed || !t4.length && !t4.ended || (e10.emit("readable"), t4.emittedReadable = false), t4.needReadable = !t4.flowing && !t4.ended && t4.length <= t4.highWaterMark, O4(e10);
  }
  function M4(e10, t4) {
    t4.readingMore || (t4.readingMore = true, ua.nextTick(I2, e10, t4));
  }
  function I2(e10, t4) {
    for (; !t4.reading && !t4.ended && (t4.length < t4.highWaterMark || t4.flowing && 0 === t4.length); ) {
      var n7 = t4.length;
      if (o3("maybeReadMore read 0"), e10.read(0), n7 === t4.length) break;
    }
    t4.readingMore = false;
  }
  function T3(e10) {
    var t4 = e10._readableState;
    t4.readableListening = e10.listenerCount("readable") > 0, t4.resumeScheduled && !t4.paused ? t4.flowing = true : e10.listenerCount("data") > 0 && e10.resume();
  }
  function R3(e10) {
    o3("readable nexttick read 0"), e10.read(0);
  }
  function P5(e10, t4) {
    o3("resume", t4.reading), t4.reading || e10.read(0), t4.resumeScheduled = false, e10.emit("resume"), O4(e10), t4.flowing && !t4.reading && e10.read(0);
  }
  function O4(e10) {
    var t4 = e10._readableState;
    for (o3("flow", t4.flowing); t4.flowing && null !== e10.read(); ) ;
  }
  function N3(e10, t4) {
    return 0 === t4.length ? null : (t4.objectMode ? n7 = t4.buffer.shift() : !e10 || e10 >= t4.length ? (n7 = t4.decoder ? t4.buffer.join("") : 1 === t4.buffer.length ? t4.buffer.first() : t4.buffer.concat(t4.length), t4.buffer.clear()) : n7 = t4.buffer.consume(e10, t4.decoder), n7);
    var n7;
  }
  function L5(e10) {
    var t4 = e10._readableState;
    o3("endReadable", t4.endEmitted), t4.endEmitted || (t4.ended = true, ua.nextTick(D3, t4, e10));
  }
  function D3(e10, t4) {
    if (o3("endReadableNT", e10.endEmitted, e10.length), !e10.endEmitted && 0 === e10.length && (e10.endEmitted = true, t4.readable = false, t4.emit("end"), e10.autoDestroy)) {
      var n7 = t4._writableState;
      (!n7 || n7.autoDestroy && n7.finished) && t4.destroy();
    }
  }
  function $2(e10, t4) {
    for (var n7 = 0, r3 = e10.length; n7 < r3; n7++) if (e10[n7] === t4) return n7;
    return -1;
  }
  return E4.prototype.read = function(e10) {
    o3("read", e10), e10 = parseInt(e10, 10);
    var t4 = this._readableState, n7 = e10;
    if (0 !== e10 && (t4.emittedReadable = false), 0 === e10 && t4.needReadable && ((0 !== t4.highWaterMark ? t4.length >= t4.highWaterMark : t4.length > 0) || t4.ended)) return o3("read: emitReadable", t4.length, t4.ended), 0 === t4.length && t4.ended ? L5(this) : A3(this), null;
    if (0 === (e10 = k3(e10, t4)) && t4.ended) return 0 === t4.length && L5(this), null;
    var r3, i5 = t4.needReadable;
    return o3("need readable", i5), (0 === t4.length || t4.length - e10 < t4.highWaterMark) && o3("length less than watermark", i5 = true), t4.ended || t4.reading ? o3("reading or ended", i5 = false) : i5 && (o3("do read"), t4.reading = true, t4.sync = true, 0 === t4.length && (t4.needReadable = true), this._read(t4.highWaterMark), t4.sync = false, t4.reading || (e10 = k3(n7, t4))), null === (r3 = e10 > 0 ? N3(e10, t4) : null) ? (t4.needReadable = t4.length <= t4.highWaterMark, e10 = 0) : (t4.length -= e10, t4.awaitDrain = 0), 0 === t4.length && (t4.ended || (t4.needReadable = true), n7 !== e10 && t4.ended && L5(this)), null !== r3 && this.emit("data", r3), r3;
  }, E4.prototype._read = function(e10) {
    v2(this, new m4("_read()"));
  }, E4.prototype.pipe = function(e10, n7) {
    var r3 = this, i5 = this._readableState;
    switch (i5.pipesCount) {
      case 0:
        i5.pipes = e10;
        break;
      case 1:
        i5.pipes = [i5.pipes, e10];
        break;
      default:
        i5.pipes.push(e10);
    }
    i5.pipesCount += 1, o3("pipe count=%d opts=%j", i5.pipesCount, n7);
    var s3 = (!n7 || false !== n7.end) && e10 !== ua.stdout && e10 !== ua.stderr ? c4 : g3;
    function a2(t4, n8) {
      o3("onunpipe"), t4 === r3 && n8 && false === n8.hasUnpiped && (n8.hasUnpiped = true, o3("cleanup"), e10.removeListener("close", f5), e10.removeListener("finish", p5), e10.removeListener("drain", l6), e10.removeListener("error", h4), e10.removeListener("unpipe", a2), r3.removeListener("end", c4), r3.removeListener("end", g3), r3.removeListener("data", u3), d4 = true, !i5.awaitDrain || e10._writableState && !e10._writableState.needDrain || l6());
    }
    function c4() {
      o3("onend"), e10.end();
    }
    i5.endEmitted ? ua.nextTick(s3) : r3.once("end", s3), e10.on("unpipe", a2);
    var l6 = /* @__PURE__ */ function(e11) {
      return function() {
        var n8 = e11._readableState;
        o3("pipeOnDrain", n8.awaitDrain), n8.awaitDrain && n8.awaitDrain--, 0 === n8.awaitDrain && t3(e11, "data") && (n8.flowing = true, O4(e11));
      };
    }(r3);
    e10.on("drain", l6);
    var d4 = false;
    function u3(t4) {
      o3("ondata");
      var n8 = e10.write(t4);
      o3("dest.write", n8), false === n8 && ((1 === i5.pipesCount && i5.pipes === e10 || i5.pipesCount > 1 && -1 !== $2(i5.pipes, e10)) && !d4 && (o3("false write response, pause", i5.awaitDrain), i5.awaitDrain++), r3.pause());
    }
    function h4(n8) {
      o3("onerror", n8), g3(), e10.removeListener("error", h4), 0 === t3(e10, "error") && v2(e10, n8);
    }
    function f5() {
      e10.removeListener("finish", p5), g3();
    }
    function p5() {
      o3("onfinish"), e10.removeListener("close", f5), g3();
    }
    function g3() {
      o3("unpipe"), r3.unpipe(e10);
    }
    return r3.on("data", u3), function(e11, t4, n8) {
      if ("function" == typeof e11.prependListener) return e11.prependListener(t4, n8);
      e11._events && e11._events[t4] ? Array.isArray(e11._events[t4]) ? e11._events[t4].unshift(n8) : e11._events[t4] = [n8, e11._events[t4]] : e11.on(t4, n8);
    }(e10, "error", h4), e10.once("close", f5), e10.once("finish", p5), e10.emit("pipe", r3), i5.flowing || (o3("pipe resume"), r3.resume()), e10;
  }, E4.prototype.unpipe = function(e10) {
    var t4 = this._readableState, n7 = { hasUnpiped: false };
    if (0 === t4.pipesCount) return this;
    if (1 === t4.pipesCount) return e10 && e10 !== t4.pipes || (e10 || (e10 = t4.pipes), t4.pipes = null, t4.pipesCount = 0, t4.flowing = false, e10 && e10.emit("unpipe", this, n7)), this;
    if (!e10) {
      var r3 = t4.pipes, i5 = t4.pipesCount;
      t4.pipes = null, t4.pipesCount = 0, t4.flowing = false;
      for (var o4 = 0; o4 < i5; o4++) r3[o4].emit("unpipe", this, { hasUnpiped: false });
      return this;
    }
    var s3 = $2(t4.pipes, e10);
    return -1 === s3 || (t4.pipes.splice(s3, 1), t4.pipesCount -= 1, 1 === t4.pipesCount && (t4.pipes = t4.pipes[0]), e10.emit("unpipe", this, n7)), this;
  }, E4.prototype.on = function(e10, t4) {
    var r3 = n6.prototype.on.call(this, e10, t4), i5 = this._readableState;
    return "data" === e10 ? (i5.readableListening = this.listenerCount("readable") > 0, false !== i5.flowing && this.resume()) : "readable" === e10 && (i5.endEmitted || i5.readableListening || (i5.readableListening = i5.needReadable = true, i5.flowing = false, i5.emittedReadable = false, o3("on readable", i5.length, i5.reading), i5.length ? A3(this) : i5.reading || ua.nextTick(R3, this))), r3;
  }, E4.prototype.addListener = E4.prototype.on, E4.prototype.removeListener = function(e10, t4) {
    var r3 = n6.prototype.removeListener.call(this, e10, t4);
    return "readable" === e10 && ua.nextTick(T3, this), r3;
  }, E4.prototype.removeAllListeners = function(e10) {
    var t4 = n6.prototype.removeAllListeners.apply(this, arguments);
    return "readable" !== e10 && void 0 !== e10 || ua.nextTick(T3, this), t4;
  }, E4.prototype.resume = function() {
    var e10 = this._readableState;
    return e10.flowing || (o3("resume"), e10.flowing = !e10.readableListening, function(e11, t4) {
      t4.resumeScheduled || (t4.resumeScheduled = true, ua.nextTick(P5, e11, t4));
    }(this, e10)), e10.paused = false, this;
  }, E4.prototype.pause = function() {
    return o3("call pause flowing=%j", this._readableState.flowing), false !== this._readableState.flowing && (o3("pause"), this._readableState.flowing = false, this.emit("pause")), this._readableState.paused = true, this;
  }, E4.prototype.wrap = function(e10) {
    var t4 = this, n7 = this._readableState, r3 = false;
    for (var i5 in e10.on("end", function() {
      if (o3("wrapped end"), n7.decoder && !n7.ended) {
        var e11 = n7.decoder.end();
        e11 && e11.length && t4.push(e11);
      }
      t4.push(null);
    }), e10.on("data", function(i6) {
      (o3("wrapped data"), n7.decoder && (i6 = n7.decoder.write(i6)), n7.objectMode && null == i6) || (n7.objectMode || i6 && i6.length) && (t4.push(i6) || (r3 = true, e10.pause()));
    }), e10) void 0 === this[i5] && "function" == typeof e10[i5] && (this[i5] = /* @__PURE__ */ function(t5) {
      return function() {
        return e10[t5].apply(e10, arguments);
      };
    }(i5));
    for (var s3 = 0; s3 < b3.length; s3++) e10.on(b3[s3], this.emit.bind(this, b3[s3]));
    return this._read = function(t5) {
      o3("wrapped _read", t5), r3 && (r3 = false, e10.resume());
    }, this;
  }, "function" == typeof Symbol && (E4.prototype[Symbol.asyncIterator] = function() {
    return void 0 === c3 && (c3 = Ld()), c3(this);
  }), Object.defineProperty(E4.prototype, "readableHighWaterMark", { enumerable: false, get: function() {
    return this._readableState.highWaterMark;
  } }), Object.defineProperty(E4.prototype, "readableBuffer", { enumerable: false, get: function() {
    return this._readableState && this._readableState.buffer;
  } }), Object.defineProperty(E4.prototype, "readableFlowing", { enumerable: false, get: function() {
    return this._readableState.flowing;
  }, set: function(e10) {
    this._readableState && (this._readableState.flowing = e10);
  } }), E4._fromList = N3, Object.defineProperty(E4.prototype, "readableLength", { enumerable: false, get: function() {
    return this._readableState.length;
  } }), "function" == typeof Symbol && (E4.from = function(e10, t4) {
    return void 0 === l5 && (l5 = Rd ? Td : (Rd = 1, Td = function() {
      throw new Error("Readable.from is not available in the browser");
    })), l5(E4, e10, t4);
  }), Pd;
}
var $d = qd;
var Bd = nd.codes;
var Kd = Bd.ERR_METHOD_NOT_IMPLEMENTED;
var jd = Bd.ERR_MULTIPLE_CALLBACK;
var Ud = Bd.ERR_TRANSFORM_ALREADY_TRANSFORMING;
var Hd = Bd.ERR_TRANSFORM_WITH_LENGTH_0;
var Fd = bd();
function zd(e9, t3) {
  var n6 = this._transformState;
  n6.transforming = false;
  var r2 = n6.writecb;
  if (null === r2) return this.emit("error", new jd());
  n6.writechunk = null, n6.writecb = null, null != t3 && this.push(t3), r2(e9);
  var i4 = this._readableState;
  i4.reading = false, (i4.needReadable || i4.length < i4.highWaterMark) && this._read(i4.highWaterMark);
}
function qd(e9) {
  if (!(this instanceof qd)) return new qd(e9);
  Fd.call(this, e9), this._transformState = { afterTransform: zd.bind(this), needTransform: false, transforming: false, writecb: null, writechunk: null, writeencoding: null }, this._readableState.needReadable = true, this._readableState.sync = false, e9 && ("function" == typeof e9.transform && (this._transform = e9.transform), "function" == typeof e9.flush && (this._flush = e9.flush)), this.on("prefinish", Wd);
}
function Wd() {
  var e9 = this;
  "function" != typeof this._flush || this._readableState.destroyed ? Vd(this, null, null) : this._flush(function(t3, n6) {
    Vd(e9, t3, n6);
  });
}
function Vd(e9, t3, n6) {
  if (t3) return e9.emit("error", t3);
  if (null != n6 && e9.push(n6), e9._writableState.length) throw new Hd();
  if (e9._transformState.transforming) throw new Ud();
  return e9.push(null);
}
md(qd, Fd), qd.prototype.push = function(e9, t3) {
  return this._transformState.needTransform = false, Fd.prototype.push.call(this, e9, t3);
}, qd.prototype._transform = function(e9, t3, n6) {
  n6(new Kd("_transform()"));
}, qd.prototype._write = function(e9, t3, n6) {
  var r2 = this._transformState;
  if (r2.writecb = n6, r2.writechunk = e9, r2.writeencoding = t3, !r2.transforming) {
    var i4 = this._readableState;
    (r2.needTransform || i4.needReadable || i4.length < i4.highWaterMark) && this._read(i4.highWaterMark);
  }
}, qd.prototype._read = function(e9) {
  var t3 = this._transformState;
  null === t3.writechunk || t3.transforming ? t3.needTransform = true : (t3.transforming = true, this._transform(t3.writechunk, t3.writeencoding, t3.afterTransform));
}, qd.prototype._destroy = function(e9, t3) {
  Fd.prototype._destroy.call(this, e9, function(e10) {
    t3(e10);
  });
};
var Gd;
var Yd = Jd;
var Zd = $d;
function Jd(e9) {
  if (!(this instanceof Jd)) return new Jd(e9);
  Zd.call(this, e9);
}
md(Jd, Zd), Jd.prototype._transform = function(e9, t3, n6) {
  n6(null, e9);
};
var Qd = nd.codes;
var Xd = Qd.ERR_MISSING_ARGS;
var eu = Qd.ERR_STREAM_DESTROYED;
function tu(e9) {
  if (e9) throw e9;
}
function nu(e9) {
  e9();
}
function ru(e9, t3) {
  return e9.pipe(t3);
}
var iu = function() {
  for (var e9 = arguments.length, t3 = new Array(e9), n6 = 0; n6 < e9; n6++) t3[n6] = arguments[n6];
  var r2, i4 = function(e10) {
    return e10.length ? "function" != typeof e10[e10.length - 1] ? tu : e10.pop() : tu;
  }(t3);
  if (Array.isArray(t3[0]) && (t3 = t3[0]), t3.length < 2) throw new Xd("streams");
  var o3 = t3.map(function(e10, n7) {
    var s2 = n7 < t3.length - 1;
    return function(e11, t4, n8, r3) {
      r3 = /* @__PURE__ */ function(e12) {
        var t5 = false;
        return function() {
          t5 || (t5 = true, e12.apply(void 0, arguments));
        };
      }(r3);
      var i5 = false;
      e11.on("close", function() {
        i5 = true;
      }), void 0 === Gd && (Gd = Nd), Gd(e11, { readable: t4, writable: n8 }, function(e12) {
        if (e12) return r3(e12);
        i5 = true, r3();
      });
      var o4 = false;
      return function(t5) {
        if (!i5 && !o4) return o4 = true, function(e12) {
          return e12.setHeader && "function" == typeof e12.abort;
        }(e11) ? e11.abort() : "function" == typeof e11.destroy ? e11.destroy() : void r3(t5 || new eu("pipe"));
      };
    }(e10, s2, n7 > 0, function(e11) {
      r2 || (r2 = e11), e11 && o3.forEach(nu), s2 || (o3.forEach(nu), i4(r2));
    });
  });
  return t3.reduce(ru);
};
!function(e9, t3) {
  (t3 = sl.exports = Dd()).Stream = t3, t3.Readable = t3, t3.Writable = vd(), t3.Duplex = bd(), t3.Transform = $d, t3.PassThrough = Yd, t3.finished = Nd, t3.pipeline = iu;
}(0, sl.exports);
var ou = sl.exports;
function su(e9 = {}) {
  const t3 = {}, n6 = new ou.Duplex({ objectMode: true, read: () => {
  }, write: function(n7, o3, s2) {
    let a = null;
    try {
      !n7.id ? function(n8) {
        (e9 == null ? void 0 : e9.retryOnMessage) && n8.method === e9.retryOnMessage && Object.values(t3).forEach(({ req: e10, retryCount: n9 = 0 }) => {
          if (!e10.id) return;
          if (n9 >= 3) throw new Error(`StreamMiddleware - Retry limit exceeded for request id "${e10.id}"`);
          const r3 = t3[e10.id];
          r3 && (r3.retryCount = n9 + 1), i4(e10);
        });
        r2.emit("notification", n8);
      }(n7) : function(e10) {
        const { id: n8 } = e10;
        if (null === n8) return;
        const r3 = t3[n8];
        if (!r3) return void console.warn(`StreamMiddleware - Unknown response id "${n8}"`);
        delete t3[n8], Object.assign(r3.res, e10), setTimeout(r3.end);
      }(n7);
    } catch (e10) {
      a = e10;
    }
    s2(a);
  } }), r2 = new Pc();
  return { events: r2, middleware: (e10, n7, r3, o3) => {
    t3[e10.id] = { req: e10, res: n7, next: r3, end: o3 }, i4(e10);
  }, stream: n6 };
  function i4(e10) {
    n6.push(e10);
  }
}
var au = {};
var cu = { exports: {} };
var lu = function e8(t3, n6) {
  if (t3 && n6) return e8(t3)(n6);
  if ("function" != typeof t3) throw new TypeError("need wrapper function");
  return Object.keys(t3).forEach(function(e9) {
    r2[e9] = t3[e9];
  }), r2;
  function r2() {
    for (var e9 = new Array(arguments.length), n7 = 0; n7 < e9.length; n7++) e9[n7] = arguments[n7];
    var r3 = t3.apply(this, e9), i4 = e9[e9.length - 1];
    return "function" == typeof r3 && r3 !== i4 && Object.keys(i4).forEach(function(e10) {
      r3[e10] = i4[e10];
    }), r3;
  }
};
var du = lu;
function uu(e9) {
  var t3 = function() {
    return t3.called ? t3.value : (t3.called = true, t3.value = e9.apply(this, arguments));
  };
  return t3.called = false, t3;
}
function hu(e9) {
  var t3 = function() {
    if (t3.called) throw new Error(t3.onceError);
    return t3.called = true, t3.value = e9.apply(this, arguments);
  }, n6 = e9.name || "Function wrapped with `once`";
  return t3.onceError = n6 + " shouldn't be called more than once", t3.called = false, t3;
}
cu.exports = du(uu), cu.exports.strict = du(hu), uu.proto = uu(function() {
  Object.defineProperty(Function.prototype, "once", { value: function() {
    return uu(this);
  }, configurable: true }), Object.defineProperty(Function.prototype, "onceStrict", { value: function() {
    return hu(this);
  }, configurable: true });
});
var fu = cu.exports;
var pu = {};
Object.defineProperty(pu, "__esModule", { value: true }), pu.Substream = void 0;
var gu = ou;
var mu = class extends gu.Duplex {
  constructor({ parent: e9, name: t3 }) {
    super({ objectMode: true }), this._parent = e9, this._name = t3;
  }
  _read() {
  }
  _write(e9, t3, n6) {
    this._parent.push({ name: this._name, data: e9 }), n6();
  }
};
pu.Substream = mu;
var yu = de && de.__importDefault || function(e9) {
  return e9 && e9.__esModule ? e9 : { default: e9 };
};
Object.defineProperty(au, "__esModule", { value: true }), au.ObjectMultiplex = void 0;
var vu = ou;
var bu = yu(fu);
var wu = pu;
var Eu = Symbol("IGNORE_SUBSTREAM");
var Su = class extends vu.Duplex {
  constructor(e9 = {}) {
    super(Object.assign(Object.assign({}, e9), { objectMode: true })), this._substreams = {};
  }
  createStream(e9) {
    if (this.destroyed) throw new Error(`ObjectMultiplex - parent stream for name "${e9}" already destroyed`);
    if (this._readableState.ended || this._writableState.ended) throw new Error(`ObjectMultiplex - parent stream for name "${e9}" already ended`);
    if (!e9) throw new Error("ObjectMultiplex - name must not be empty");
    if (this._substreams[e9]) throw new Error(`ObjectMultiplex - Substream for name "${e9}" already exists`);
    const t3 = new wu.Substream({ parent: this, name: e9 });
    return this._substreams[e9] = t3, function(e10, t4) {
      const n6 = (0, bu.default)(t4);
      (0, vu.finished)(e10, { readable: false }, n6), (0, vu.finished)(e10, { writable: false }, n6);
    }(this, (e10) => t3.destroy(e10 || void 0)), t3;
  }
  ignoreStream(e9) {
    if (!e9) throw new Error("ObjectMultiplex - name must not be empty");
    if (this._substreams[e9]) throw new Error(`ObjectMultiplex - Substream for name "${e9}" already exists`);
    this._substreams[e9] = Eu;
  }
  _read() {
  }
  _write(e9, t3, n6) {
    const { name: r2, data: i4 } = e9;
    if (!r2) return console.warn(`ObjectMultiplex - malformed chunk without name "${e9}"`), n6();
    const o3 = this._substreams[r2];
    return o3 ? (o3 !== Eu && o3.push(i4), n6()) : (console.warn(`ObjectMultiplex - orphaned data for stream "${r2}"`), n6());
  }
};
au.ObjectMultiplex = Su;
var _u = ue(au.ObjectMultiplex);
var Cu = (e9) => null !== e9 && "object" == typeof e9 && "function" == typeof e9.pipe;
Cu.writable = (e9) => Cu(e9) && false !== e9.writable && "function" == typeof e9._write && "object" == typeof e9._writableState, Cu.readable = (e9) => Cu(e9) && false !== e9.readable && "function" == typeof e9._read && "object" == typeof e9._readableState, Cu.duplex = (e9) => Cu.writable(e9) && Cu.readable(e9), Cu.transform = (e9) => Cu.duplex(e9) && "function" == typeof e9._transform;
var ku;
var Au = Cu;
var xu = class extends ol {
  constructor(e9, { jsonRpcStreamName: t3, logger: n6 = console, maxEventListeners: r2 = 100, rpcMiddleware: i4 = [] }) {
    if (super({ logger: n6, maxEventListeners: r2, rpcMiddleware: i4 }), !Au.duplex(e9)) throw new Error(is.errors.invalidDuplexStream());
    this._handleStreamDisconnect = this._handleStreamDisconnect.bind(this);
    const o3 = new _u();
    ou.pipeline(e9, o3, e9, this._handleStreamDisconnect.bind(this, "MetaMask")), this._jsonRpcConnection = su({ retryOnMessage: "METAMASK_EXTENSION_CONNECT_CAN_RETRY" }), ou.pipeline(this._jsonRpcConnection.stream, o3.createStream(t3), this._jsonRpcConnection.stream, this._handleStreamDisconnect.bind(this, "MetaMask RpcProvider")), this._rpcEngine.push(this._jsonRpcConnection.middleware), this._jsonRpcConnection.events.on("notification", (t4) => {
      const { method: n7, params: r3 } = t4;
      "metamask_accountsChanged" === n7 ? this._handleAccountsChanged(r3) : "metamask_unlockStateChanged" === n7 ? this._handleUnlockStateChanged(r3) : "metamask_chainChanged" === n7 ? this._handleChainChanged(r3) : Dc.includes(n7) ? this.emit("message", { type: n7, data: r3 }) : "METAMASK_STREAM_FAILURE" === n7 && e9.destroy(new Error(is.errors.permanentlyDisconnected()));
    });
  }
  async _initializeStateAsync() {
    let e9;
    try {
      e9 = await this.request({ method: "metamask_getProviderState" });
    } catch (e10) {
      this._log.error("MetaMask: Failed to get initial state. Please report this bug.", e10);
    }
    this._initializeState(e9);
  }
  _handleStreamDisconnect(e9, t3) {
    let n6 = `MetaMask: Lost connection to "${e9}".`;
    (t3 == null ? void 0 : t3.stack) && (n6 += `
${t3.stack}`), this._log.warn(n6), this.listenerCount("error") > 0 && this.emit("error", n6), this._handleDisconnect(false, t3 ? t3.message : void 0);
  }
  _handleChainChanged({ chainId: e9, networkVersion: t3 } = {}) {
    jc(e9) && ((e10) => Boolean(e10) && "string" == typeof e10)(t3) ? "loading" === t3 ? this._handleDisconnect(true) : super._handleChainChanged({ chainId: e9 }) : this._log.error(is.errors.invalidNetworkParams(), { chainId: e9, networkVersion: t3 });
  }
};
var Mu = class extends xu {
  constructor(e9, { jsonRpcStreamName: t3 = "metamask-provider", logger: n6 = console, maxEventListeners: r2 = 100, shouldSendMetadata: i4 } = {}) {
    if (super(e9, { jsonRpcStreamName: t3, logger: n6, maxEventListeners: r2, rpcMiddleware: $c(n6) }), this._sentWarnings = { chainId: false, networkVersion: false, selectedAddress: false, enable: false, experimentalMethods: false, send: false, events: { close: false, data: false, networkChanged: false, notification: false } }, Gc(this, ku, void 0), this._initializeStateAsync(), Yc(this, ku, null), this.isMetaMask = true, this._sendSync = this._sendSync.bind(this), this.enable = this.enable.bind(this), this.send = this.send.bind(this), this.sendAsync = this.sendAsync.bind(this), this._warnOfDeprecation = this._warnOfDeprecation.bind(this), this._metamask = this._getExperimentalApi(), this._jsonRpcConnection.events.on("notification", (e10) => {
      const { method: t4 } = e10;
      Dc.includes(t4) && (this.emit("data", e10), this.emit("notification", e10.params.result));
    }), i4) if ("complete" === document.readyState) Hc(this._rpcEngine, this._log);
    else {
      const e10 = () => {
        Hc(this._rpcEngine, this._log), window.removeEventListener("DOMContentLoaded", e10);
      };
      window.addEventListener("DOMContentLoaded", e10);
    }
  }
  get chainId() {
    return this._sentWarnings.chainId || (this._log.warn(is.warnings.chainIdDeprecation), this._sentWarnings.chainId = true), super.chainId;
  }
  get networkVersion() {
    return this._sentWarnings.networkVersion || (this._log.warn(is.warnings.networkVersionDeprecation), this._sentWarnings.networkVersion = true), Vc(this, ku);
  }
  get selectedAddress() {
    return this._sentWarnings.selectedAddress || (this._log.warn(is.warnings.selectedAddressDeprecation), this._sentWarnings.selectedAddress = true), super.selectedAddress;
  }
  sendAsync(e9, t3) {
    this._rpcRequest(e9, t3);
  }
  addListener(e9, t3) {
    return this._warnOfDeprecation(e9), super.addListener(e9, t3);
  }
  on(e9, t3) {
    return this._warnOfDeprecation(e9), super.on(e9, t3);
  }
  once(e9, t3) {
    return this._warnOfDeprecation(e9), super.once(e9, t3);
  }
  prependListener(e9, t3) {
    return this._warnOfDeprecation(e9), super.prependListener(e9, t3);
  }
  prependOnceListener(e9, t3) {
    return this._warnOfDeprecation(e9), super.prependOnceListener(e9, t3);
  }
  _handleDisconnect(e9, t3) {
    super._handleDisconnect(e9, t3), Vc(this, ku) && !e9 && Yc(this, ku, null);
  }
  _warnOfDeprecation(e9) {
    var _a2;
    false === ((_a2 = this._sentWarnings) == null ? void 0 : _a2.events[e9]) && (this._log.warn(is.warnings.events[e9]), this._sentWarnings.events[e9] = true);
  }
  async enable() {
    return this._sentWarnings.enable || (this._log.warn(is.warnings.enableDeprecation), this._sentWarnings.enable = true), new Promise((e9, t3) => {
      try {
        this._rpcRequest({ method: "eth_requestAccounts", params: [] }, Kc(e9, t3));
      } catch (e10) {
        t3(e10);
      }
    });
  }
  send(e9, t3) {
    return this._sentWarnings.send || (this._log.warn(is.warnings.sendDeprecation), this._sentWarnings.send = true), "string" != typeof e9 || t3 && !Array.isArray(t3) ? e9 && "object" == typeof e9 && "function" == typeof t3 ? this._rpcRequest(e9, t3) : this._sendSync(e9) : new Promise((n6, r2) => {
      try {
        this._rpcRequest({ method: e9, params: t3 }, Kc(n6, r2, false));
      } catch (e10) {
        r2(e10);
      }
    });
  }
  _sendSync(e9) {
    let t3;
    switch (e9.method) {
      case "eth_accounts":
        t3 = this.selectedAddress ? [this.selectedAddress] : [];
        break;
      case "eth_coinbase":
        t3 = this.selectedAddress ?? null;
        break;
      case "eth_uninstallFilter":
        this._rpcRequest(e9, Uc), t3 = true;
        break;
      case "net_version":
        t3 = Vc(this, ku) ?? null;
        break;
      default:
        throw new Error(is.errors.unsupportedSync(e9.method));
    }
    return { id: e9.id, jsonrpc: e9.jsonrpc, result: t3 };
  }
  _getExperimentalApi() {
    return new Proxy({ isUnlocked: async () => (this._state.initialized || await new Promise((e9) => {
      this.on("_initialized", () => e9());
    }), this._state.isUnlocked), requestBatch: async (e9) => {
      if (!Array.isArray(e9)) throw Xa({ message: "Batch requests must be made with an array of request objects.", data: e9 });
      return new Promise((t3, n6) => {
        this._rpcRequest(e9, Kc(t3, n6));
      });
    } }, { get: (e9, t3, ...n6) => (this._sentWarnings.experimentalMethods || (this._log.warn(is.warnings.experimentalMethods), this._sentWarnings.experimentalMethods = true), Reflect.get(e9, t3, ...n6)) });
  }
  _handleChainChanged({ chainId: e9, networkVersion: t3 } = {}) {
    super._handleChainChanged({ chainId: e9, networkVersion: t3 }), this._state.isConnected && t3 !== Vc(this, ku) && (Yc(this, ku, t3), this._state.initialized && this.emit("networkChanged", Vc(this, ku)));
  }
};
ku = /* @__PURE__ */ new WeakMap();
var Iu = (0, import_debug.default)("MM_SDK");
var Tu;
Iu.color = "#FFAC1C";
var Ru = {};
var Pu = {};
Object.defineProperty(Pu, "__esModule", { value: true }), Pu.EthereumProviderError = Pu.EthereumRpcError = void 0;
var Ou = $a;
var Nu = class extends Error {
  constructor(e9, t3, n6) {
    if (!Number.isInteger(e9)) throw new Error('"code" must be an integer.');
    if (!t3 || "string" != typeof t3) throw new Error('"message" must be a nonempty string.');
    super(t3), this.code = e9, void 0 !== n6 && (this.data = n6);
  }
  serialize() {
    const e9 = { code: this.code, message: this.message };
    return void 0 !== this.data && (e9.data = this.data), this.stack && (e9.stack = this.stack), e9;
  }
  toString() {
    return Ou.default(this.serialize(), Lu, 2);
  }
};
Pu.EthereumRpcError = Nu;
function Lu(e9, t3) {
  if ("[Circular]" !== t3) return t3;
}
Pu.EthereumProviderError = class extends Nu {
  constructor(e9, t3, n6) {
    if (!function(e10) {
      return Number.isInteger(e10) && e10 >= 1e3 && e10 <= 4999;
    }(e9)) throw new Error('"code" must be an integer such that: 1000 <= code <= 4999');
    super(e9, t3, n6);
  }
};
var Du = {};
var $u = {};
Object.defineProperty($u, "__esModule", { value: true }), $u.errorValues = $u.errorCodes = void 0, $u.errorCodes = { rpc: { invalidInput: -32e3, resourceNotFound: -32001, resourceUnavailable: -32002, transactionRejected: -32003, methodNotSupported: -32004, limitExceeded: -32005, parse: -32700, invalidRequest: -32600, methodNotFound: -32601, invalidParams: -32602, internal: -32603 }, provider: { userRejectedRequest: 4001, unauthorized: 4100, unsupportedMethod: 4200, disconnected: 4900, chainDisconnected: 4901 } }, $u.errorValues = { "-32700": { standard: "JSON RPC 2.0", message: "Invalid JSON was received by the server. An error occurred on the server while parsing the JSON text." }, "-32600": { standard: "JSON RPC 2.0", message: "The JSON sent is not a valid Request object." }, "-32601": { standard: "JSON RPC 2.0", message: "The method does not exist / is not available." }, "-32602": { standard: "JSON RPC 2.0", message: "Invalid method parameter(s)." }, "-32603": { standard: "JSON RPC 2.0", message: "Internal JSON-RPC error." }, "-32000": { standard: "EIP-1474", message: "Invalid input." }, "-32001": { standard: "EIP-1474", message: "Resource not found." }, "-32002": { standard: "EIP-1474", message: "Resource unavailable." }, "-32003": { standard: "EIP-1474", message: "Transaction rejected." }, "-32004": { standard: "EIP-1474", message: "Method not supported." }, "-32005": { standard: "EIP-1474", message: "Request limit exceeded." }, 4001: { standard: "EIP-1193", message: "User rejected the request." }, 4100: { standard: "EIP-1193", message: "The requested account and/or method has not been authorized by the user." }, 4200: { standard: "EIP-1193", message: "The requested method is not supported by this Ethereum provider." }, 4900: { standard: "EIP-1193", message: "The provider is disconnected from all chains." }, 4901: { standard: "EIP-1193", message: "The provider is disconnected from the specified chain." } }, function(e9) {
  Object.defineProperty(e9, "__esModule", { value: true }), e9.serializeError = e9.isValidCode = e9.getMessageFromCode = e9.JSON_RPC_SERVER_ERROR_MESSAGE = void 0;
  const t3 = $u, n6 = Pu, r2 = t3.errorCodes.rpc.internal, i4 = "Unspecified error message. This is a bug, please report it.", o3 = { code: r2, message: s2(r2) };
  function s2(n7, r3 = i4) {
    if (Number.isInteger(n7)) {
      const r4 = n7.toString();
      if (d3(t3.errorValues, r4)) return t3.errorValues[r4].message;
      if (c3(n7)) return e9.JSON_RPC_SERVER_ERROR_MESSAGE;
    }
    return r3;
  }
  function a(e10) {
    if (!Number.isInteger(e10)) return false;
    const n7 = e10.toString();
    return !!t3.errorValues[n7] || !!c3(e10);
  }
  function c3(e10) {
    return e10 >= -32099 && e10 <= -32e3;
  }
  function l5(e10) {
    return e10 && "object" == typeof e10 && !Array.isArray(e10) ? Object.assign({}, e10) : e10;
  }
  function d3(e10, t4) {
    return Object.prototype.hasOwnProperty.call(e10, t4);
  }
  e9.JSON_RPC_SERVER_ERROR_MESSAGE = "Unspecified server error.", e9.getMessageFromCode = s2, e9.isValidCode = a, e9.serializeError = function(e10, { fallbackError: t4 = o3, shouldIncludeStack: r3 = false } = {}) {
    var i5, c4;
    if (!t4 || !Number.isInteger(t4.code) || "string" != typeof t4.message) throw new Error("Must provide fallback error with integer number code and string message.");
    if (e10 instanceof n6.EthereumRpcError) return e10.serialize();
    const u2 = {};
    if (e10 && "object" == typeof e10 && !Array.isArray(e10) && d3(e10, "code") && a(e10.code)) {
      const t5 = e10;
      u2.code = t5.code, t5.message && "string" == typeof t5.message ? (u2.message = t5.message, d3(t5, "data") && (u2.data = t5.data)) : (u2.message = s2(u2.code), u2.data = { originalError: l5(e10) });
    } else {
      u2.code = t4.code;
      const n7 = null === (i5 = e10) || void 0 === i5 ? void 0 : i5.message;
      u2.message = n7 && "string" == typeof n7 ? n7 : t4.message, u2.data = { originalError: l5(e10) };
    }
    const h3 = null === (c4 = e10) || void 0 === c4 ? void 0 : c4.stack;
    return r3 && e10 && h3 && "string" == typeof h3 && (u2.stack = h3), u2;
  };
}(Du);
var Bu = {};
Object.defineProperty(Bu, "__esModule", { value: true }), Bu.ethErrors = void 0;
var Ku = Pu;
var ju = Du;
var Uu = $u;
function Hu(e9, t3) {
  const [n6, r2] = zu(t3);
  return new Ku.EthereumRpcError(e9, n6 || ju.getMessageFromCode(e9), r2);
}
function Fu(e9, t3) {
  const [n6, r2] = zu(t3);
  return new Ku.EthereumProviderError(e9, n6 || ju.getMessageFromCode(e9), r2);
}
function zu(e9) {
  if (e9) {
    if ("string" == typeof e9) return [e9];
    if ("object" == typeof e9 && !Array.isArray(e9)) {
      const { message: t3, data: n6 } = e9;
      if (t3 && "string" != typeof t3) throw new Error("Must specify string message.");
      return [t3 || void 0, n6];
    }
  }
  return [];
}
Bu.ethErrors = { rpc: { parse: (e9) => Hu(Uu.errorCodes.rpc.parse, e9), invalidRequest: (e9) => Hu(Uu.errorCodes.rpc.invalidRequest, e9), invalidParams: (e9) => Hu(Uu.errorCodes.rpc.invalidParams, e9), methodNotFound: (e9) => Hu(Uu.errorCodes.rpc.methodNotFound, e9), internal: (e9) => Hu(Uu.errorCodes.rpc.internal, e9), server: (e9) => {
  if (!e9 || "object" != typeof e9 || Array.isArray(e9)) throw new Error("Ethereum RPC Server errors must provide single object argument.");
  const { code: t3 } = e9;
  if (!Number.isInteger(t3) || t3 > -32005 || t3 < -32099) throw new Error('"code" must be an integer such that: -32099 <= code <= -32005');
  return Hu(t3, e9);
}, invalidInput: (e9) => Hu(Uu.errorCodes.rpc.invalidInput, e9), resourceNotFound: (e9) => Hu(Uu.errorCodes.rpc.resourceNotFound, e9), resourceUnavailable: (e9) => Hu(Uu.errorCodes.rpc.resourceUnavailable, e9), transactionRejected: (e9) => Hu(Uu.errorCodes.rpc.transactionRejected, e9), methodNotSupported: (e9) => Hu(Uu.errorCodes.rpc.methodNotSupported, e9), limitExceeded: (e9) => Hu(Uu.errorCodes.rpc.limitExceeded, e9) }, provider: { userRejectedRequest: (e9) => Fu(Uu.errorCodes.provider.userRejectedRequest, e9), unauthorized: (e9) => Fu(Uu.errorCodes.provider.unauthorized, e9), unsupportedMethod: (e9) => Fu(Uu.errorCodes.provider.unsupportedMethod, e9), disconnected: (e9) => Fu(Uu.errorCodes.provider.disconnected, e9), chainDisconnected: (e9) => Fu(Uu.errorCodes.provider.chainDisconnected, e9), custom: (e9) => {
  if (!e9 || "object" != typeof e9 || Array.isArray(e9)) throw new Error("Ethereum Provider custom errors must provide single object argument.");
  const { code: t3, message: n6, data: r2 } = e9;
  if (!n6 || "string" != typeof n6) throw new Error('"message" must be a nonempty string');
  return new Ku.EthereumProviderError(t3, n6, r2);
} } }, function(e9) {
  Object.defineProperty(e9, "__esModule", { value: true }), e9.getMessageFromCode = e9.serializeError = e9.EthereumProviderError = e9.EthereumRpcError = e9.ethErrors = e9.errorCodes = void 0;
  const t3 = Pu;
  Object.defineProperty(e9, "EthereumRpcError", { enumerable: true, get: function() {
    return t3.EthereumRpcError;
  } }), Object.defineProperty(e9, "EthereumProviderError", { enumerable: true, get: function() {
    return t3.EthereumProviderError;
  } });
  const n6 = Du;
  Object.defineProperty(e9, "serializeError", { enumerable: true, get: function() {
    return n6.serializeError;
  } }), Object.defineProperty(e9, "getMessageFromCode", { enumerable: true, get: function() {
    return n6.getMessageFromCode;
  } });
  const r2 = Bu;
  Object.defineProperty(e9, "ethErrors", { enumerable: true, get: function() {
    return r2.ethErrors;
  } });
  const i4 = $u;
  Object.defineProperty(e9, "errorCodes", { enumerable: true, get: function() {
    return i4.errorCodes;
  } });
}(Ru);
var qu = { exports: {} };
qu.exports = function(e9) {
  var t3 = {};
  function n6(r2) {
    if (t3[r2]) return t3[r2].exports;
    var i4 = t3[r2] = { i: r2, l: false, exports: {} };
    return e9[r2].call(i4.exports, i4, i4.exports, n6), i4.l = true, i4.exports;
  }
  return n6.m = e9, n6.c = t3, n6.d = function(e10, t4, r2) {
    n6.o(e10, t4) || Object.defineProperty(e10, t4, { enumerable: true, get: r2 });
  }, n6.r = function(e10) {
    "undefined" != typeof Symbol && Symbol.toStringTag && Object.defineProperty(e10, Symbol.toStringTag, { value: "Module" }), Object.defineProperty(e10, "__esModule", { value: true });
  }, n6.t = function(e10, t4) {
    if (1 & t4 && (e10 = n6(e10)), 8 & t4) return e10;
    if (4 & t4 && "object" == typeof e10 && e10 && e10.__esModule) return e10;
    var r2 = /* @__PURE__ */ Object.create(null);
    if (n6.r(r2), Object.defineProperty(r2, "default", { enumerable: true, value: e10 }), 2 & t4 && "string" != typeof e10) for (var i4 in e10) n6.d(r2, i4, (function(t5) {
      return e10[t5];
    }).bind(null, i4));
    return r2;
  }, n6.n = function(e10) {
    var t4 = e10 && e10.__esModule ? function() {
      return e10.default;
    } : function() {
      return e10;
    };
    return n6.d(t4, "a", t4), t4;
  }, n6.o = function(e10, t4) {
    return Object.prototype.hasOwnProperty.call(e10, t4);
  }, n6.p = "", n6(n6.s = 90);
}({ 17: function(e9, t3, n6) {
  t3.__esModule = true, t3.default = void 0;
  var r2 = n6(18), i4 = function() {
    function e10() {
    }
    return e10.getFirstMatch = function(e11, t4) {
      var n7 = t4.match(e11);
      return n7 && n7.length > 0 && n7[1] || "";
    }, e10.getSecondMatch = function(e11, t4) {
      var n7 = t4.match(e11);
      return n7 && n7.length > 1 && n7[2] || "";
    }, e10.matchAndReturnConst = function(e11, t4, n7) {
      if (e11.test(t4)) return n7;
    }, e10.getWindowsVersionName = function(e11) {
      switch (e11) {
        case "NT":
          return "NT";
        case "XP":
        case "NT 5.1":
          return "XP";
        case "NT 5.0":
          return "2000";
        case "NT 5.2":
          return "2003";
        case "NT 6.0":
          return "Vista";
        case "NT 6.1":
          return "7";
        case "NT 6.2":
          return "8";
        case "NT 6.3":
          return "8.1";
        case "NT 10.0":
          return "10";
        default:
          return;
      }
    }, e10.getMacOSVersionName = function(e11) {
      var t4 = e11.split(".").splice(0, 2).map(function(e12) {
        return parseInt(e12, 10) || 0;
      });
      if (t4.push(0), 10 === t4[0]) switch (t4[1]) {
        case 5:
          return "Leopard";
        case 6:
          return "Snow Leopard";
        case 7:
          return "Lion";
        case 8:
          return "Mountain Lion";
        case 9:
          return "Mavericks";
        case 10:
          return "Yosemite";
        case 11:
          return "El Capitan";
        case 12:
          return "Sierra";
        case 13:
          return "High Sierra";
        case 14:
          return "Mojave";
        case 15:
          return "Catalina";
        default:
          return;
      }
    }, e10.getAndroidVersionName = function(e11) {
      var t4 = e11.split(".").splice(0, 2).map(function(e12) {
        return parseInt(e12, 10) || 0;
      });
      if (t4.push(0), !(1 === t4[0] && t4[1] < 5)) return 1 === t4[0] && t4[1] < 6 ? "Cupcake" : 1 === t4[0] && t4[1] >= 6 ? "Donut" : 2 === t4[0] && t4[1] < 2 ? "Eclair" : 2 === t4[0] && 2 === t4[1] ? "Froyo" : 2 === t4[0] && t4[1] > 2 ? "Gingerbread" : 3 === t4[0] ? "Honeycomb" : 4 === t4[0] && t4[1] < 1 ? "Ice Cream Sandwich" : 4 === t4[0] && t4[1] < 4 ? "Jelly Bean" : 4 === t4[0] && t4[1] >= 4 ? "KitKat" : 5 === t4[0] ? "Lollipop" : 6 === t4[0] ? "Marshmallow" : 7 === t4[0] ? "Nougat" : 8 === t4[0] ? "Oreo" : 9 === t4[0] ? "Pie" : void 0;
    }, e10.getVersionPrecision = function(e11) {
      return e11.split(".").length;
    }, e10.compareVersions = function(t4, n7, r3) {
      void 0 === r3 && (r3 = false);
      var i5 = e10.getVersionPrecision(t4), o3 = e10.getVersionPrecision(n7), s2 = Math.max(i5, o3), a = 0, c3 = e10.map([t4, n7], function(t5) {
        var n8 = s2 - e10.getVersionPrecision(t5), r4 = t5 + new Array(n8 + 1).join(".0");
        return e10.map(r4.split("."), function(e11) {
          return new Array(20 - e11.length).join("0") + e11;
        }).reverse();
      });
      for (r3 && (a = s2 - Math.min(i5, o3)), s2 -= 1; s2 >= a; ) {
        if (c3[0][s2] > c3[1][s2]) return 1;
        if (c3[0][s2] === c3[1][s2]) {
          if (s2 === a) return 0;
          s2 -= 1;
        } else if (c3[0][s2] < c3[1][s2]) return -1;
      }
    }, e10.map = function(e11, t4) {
      var n7, r3 = [];
      if (Array.prototype.map) return Array.prototype.map.call(e11, t4);
      for (n7 = 0; n7 < e11.length; n7 += 1) r3.push(t4(e11[n7]));
      return r3;
    }, e10.find = function(e11, t4) {
      var n7, r3;
      if (Array.prototype.find) return Array.prototype.find.call(e11, t4);
      for (n7 = 0, r3 = e11.length; n7 < r3; n7 += 1) {
        var i5 = e11[n7];
        if (t4(i5, n7)) return i5;
      }
    }, e10.assign = function(e11) {
      for (var t4, n7, r3 = e11, i5 = arguments.length, o3 = new Array(i5 > 1 ? i5 - 1 : 0), s2 = 1; s2 < i5; s2++) o3[s2 - 1] = arguments[s2];
      if (Object.assign) return Object.assign.apply(Object, [e11].concat(o3));
      var a = function() {
        var e12 = o3[t4];
        "object" == typeof e12 && null !== e12 && Object.keys(e12).forEach(function(t5) {
          r3[t5] = e12[t5];
        });
      };
      for (t4 = 0, n7 = o3.length; t4 < n7; t4 += 1) a();
      return e11;
    }, e10.getBrowserAlias = function(e11) {
      return r2.BROWSER_ALIASES_MAP[e11];
    }, e10.getBrowserTypeByAlias = function(e11) {
      return r2.BROWSER_MAP[e11] || "";
    }, e10;
  }();
  t3.default = i4, e9.exports = t3.default;
}, 18: function(e9, t3, n6) {
  t3.__esModule = true, t3.ENGINE_MAP = t3.OS_MAP = t3.PLATFORMS_MAP = t3.BROWSER_MAP = t3.BROWSER_ALIASES_MAP = void 0, t3.BROWSER_ALIASES_MAP = { "Amazon Silk": "amazon_silk", "Android Browser": "android", Bada: "bada", BlackBerry: "blackberry", Chrome: "chrome", Chromium: "chromium", Electron: "electron", Epiphany: "epiphany", Firefox: "firefox", Focus: "focus", Generic: "generic", "Google Search": "google_search", Googlebot: "googlebot", "Internet Explorer": "ie", "K-Meleon": "k_meleon", Maxthon: "maxthon", "Microsoft Edge": "edge", "MZ Browser": "mz", "NAVER Whale Browser": "naver", Opera: "opera", "Opera Coast": "opera_coast", PhantomJS: "phantomjs", Puffin: "puffin", QupZilla: "qupzilla", QQ: "qq", QQLite: "qqlite", Safari: "safari", Sailfish: "sailfish", "Samsung Internet for Android": "samsung_internet", SeaMonkey: "seamonkey", Sleipnir: "sleipnir", Swing: "swing", Tizen: "tizen", "UC Browser": "uc", Vivaldi: "vivaldi", "WebOS Browser": "webos", WeChat: "wechat", "Yandex Browser": "yandex", Roku: "roku" }, t3.BROWSER_MAP = { amazon_silk: "Amazon Silk", android: "Android Browser", bada: "Bada", blackberry: "BlackBerry", chrome: "Chrome", chromium: "Chromium", electron: "Electron", epiphany: "Epiphany", firefox: "Firefox", focus: "Focus", generic: "Generic", googlebot: "Googlebot", google_search: "Google Search", ie: "Internet Explorer", k_meleon: "K-Meleon", maxthon: "Maxthon", edge: "Microsoft Edge", mz: "MZ Browser", naver: "NAVER Whale Browser", opera: "Opera", opera_coast: "Opera Coast", phantomjs: "PhantomJS", puffin: "Puffin", qupzilla: "QupZilla", qq: "QQ Browser", qqlite: "QQ Browser Lite", safari: "Safari", sailfish: "Sailfish", samsung_internet: "Samsung Internet for Android", seamonkey: "SeaMonkey", sleipnir: "Sleipnir", swing: "Swing", tizen: "Tizen", uc: "UC Browser", vivaldi: "Vivaldi", webos: "WebOS Browser", wechat: "WeChat", yandex: "Yandex Browser" }, t3.PLATFORMS_MAP = { tablet: "tablet", mobile: "mobile", desktop: "desktop", tv: "tv" }, t3.OS_MAP = { WindowsPhone: "Windows Phone", Windows: "Windows", MacOS: "macOS", iOS: "iOS", Android: "Android", WebOS: "WebOS", BlackBerry: "BlackBerry", Bada: "Bada", Tizen: "Tizen", Linux: "Linux", ChromeOS: "Chrome OS", PlayStation4: "PlayStation 4", Roku: "Roku" }, t3.ENGINE_MAP = { EdgeHTML: "EdgeHTML", Blink: "Blink", Trident: "Trident", Presto: "Presto", Gecko: "Gecko", WebKit: "WebKit" };
}, 90: function(e9, t3, n6) {
  t3.__esModule = true, t3.default = void 0;
  var r2, i4 = (r2 = n6(91)) && r2.__esModule ? r2 : { default: r2 }, o3 = n6(18);
  function s2(e10, t4) {
    for (var n7 = 0; n7 < t4.length; n7++) {
      var r3 = t4[n7];
      r3.enumerable = r3.enumerable || false, r3.configurable = true, "value" in r3 && (r3.writable = true), Object.defineProperty(e10, r3.key, r3);
    }
  }
  var a = function() {
    function e10() {
    }
    var t4, n7, r3;
    return e10.getParser = function(e11, t5) {
      if (void 0 === t5 && (t5 = false), "string" != typeof e11) throw new Error("UserAgent should be a string");
      return new i4.default(e11, t5);
    }, e10.parse = function(e11) {
      return new i4.default(e11).getResult();
    }, t4 = e10, r3 = [{ key: "BROWSER_MAP", get: function() {
      return o3.BROWSER_MAP;
    } }, { key: "ENGINE_MAP", get: function() {
      return o3.ENGINE_MAP;
    } }, { key: "OS_MAP", get: function() {
      return o3.OS_MAP;
    } }, { key: "PLATFORMS_MAP", get: function() {
      return o3.PLATFORMS_MAP;
    } }], (n7 = null) && s2(t4.prototype, n7), r3 && s2(t4, r3), e10;
  }();
  t3.default = a, e9.exports = t3.default;
}, 91: function(e9, t3, n6) {
  t3.__esModule = true, t3.default = void 0;
  var r2 = c3(n6(92)), i4 = c3(n6(93)), o3 = c3(n6(94)), s2 = c3(n6(95)), a = c3(n6(17));
  function c3(e10) {
    return e10 && e10.__esModule ? e10 : { default: e10 };
  }
  var l5 = function() {
    function e10(e11, t5) {
      if (void 0 === t5 && (t5 = false), null == e11 || "" === e11) throw new Error("UserAgent parameter can't be empty");
      this._ua = e11, this.parsedResult = {}, true !== t5 && this.parse();
    }
    var t4 = e10.prototype;
    return t4.getUA = function() {
      return this._ua;
    }, t4.test = function(e11) {
      return e11.test(this._ua);
    }, t4.parseBrowser = function() {
      var e11 = this;
      this.parsedResult.browser = {};
      var t5 = a.default.find(r2.default, function(t6) {
        if ("function" == typeof t6.test) return t6.test(e11);
        if (t6.test instanceof Array) return t6.test.some(function(t7) {
          return e11.test(t7);
        });
        throw new Error("Browser's test function is not valid");
      });
      return t5 && (this.parsedResult.browser = t5.describe(this.getUA())), this.parsedResult.browser;
    }, t4.getBrowser = function() {
      return this.parsedResult.browser ? this.parsedResult.browser : this.parseBrowser();
    }, t4.getBrowserName = function(e11) {
      return e11 ? String(this.getBrowser().name).toLowerCase() || "" : this.getBrowser().name || "";
    }, t4.getBrowserVersion = function() {
      return this.getBrowser().version;
    }, t4.getOS = function() {
      return this.parsedResult.os ? this.parsedResult.os : this.parseOS();
    }, t4.parseOS = function() {
      var e11 = this;
      this.parsedResult.os = {};
      var t5 = a.default.find(i4.default, function(t6) {
        if ("function" == typeof t6.test) return t6.test(e11);
        if (t6.test instanceof Array) return t6.test.some(function(t7) {
          return e11.test(t7);
        });
        throw new Error("Browser's test function is not valid");
      });
      return t5 && (this.parsedResult.os = t5.describe(this.getUA())), this.parsedResult.os;
    }, t4.getOSName = function(e11) {
      var t5 = this.getOS().name;
      return e11 ? String(t5).toLowerCase() || "" : t5 || "";
    }, t4.getOSVersion = function() {
      return this.getOS().version;
    }, t4.getPlatform = function() {
      return this.parsedResult.platform ? this.parsedResult.platform : this.parsePlatform();
    }, t4.getPlatformType = function(e11) {
      void 0 === e11 && (e11 = false);
      var t5 = this.getPlatform().type;
      return e11 ? String(t5).toLowerCase() || "" : t5 || "";
    }, t4.parsePlatform = function() {
      var e11 = this;
      this.parsedResult.platform = {};
      var t5 = a.default.find(o3.default, function(t6) {
        if ("function" == typeof t6.test) return t6.test(e11);
        if (t6.test instanceof Array) return t6.test.some(function(t7) {
          return e11.test(t7);
        });
        throw new Error("Browser's test function is not valid");
      });
      return t5 && (this.parsedResult.platform = t5.describe(this.getUA())), this.parsedResult.platform;
    }, t4.getEngine = function() {
      return this.parsedResult.engine ? this.parsedResult.engine : this.parseEngine();
    }, t4.getEngineName = function(e11) {
      return e11 ? String(this.getEngine().name).toLowerCase() || "" : this.getEngine().name || "";
    }, t4.parseEngine = function() {
      var e11 = this;
      this.parsedResult.engine = {};
      var t5 = a.default.find(s2.default, function(t6) {
        if ("function" == typeof t6.test) return t6.test(e11);
        if (t6.test instanceof Array) return t6.test.some(function(t7) {
          return e11.test(t7);
        });
        throw new Error("Browser's test function is not valid");
      });
      return t5 && (this.parsedResult.engine = t5.describe(this.getUA())), this.parsedResult.engine;
    }, t4.parse = function() {
      return this.parseBrowser(), this.parseOS(), this.parsePlatform(), this.parseEngine(), this;
    }, t4.getResult = function() {
      return a.default.assign({}, this.parsedResult);
    }, t4.satisfies = function(e11) {
      var t5 = this, n7 = {}, r3 = 0, i5 = {}, o4 = 0;
      if (Object.keys(e11).forEach(function(t6) {
        var s4 = e11[t6];
        "string" == typeof s4 ? (i5[t6] = s4, o4 += 1) : "object" == typeof s4 && (n7[t6] = s4, r3 += 1);
      }), r3 > 0) {
        var s3 = Object.keys(n7), c4 = a.default.find(s3, function(e12) {
          return t5.isOS(e12);
        });
        if (c4) {
          var l6 = this.satisfies(n7[c4]);
          if (void 0 !== l6) return l6;
        }
        var d3 = a.default.find(s3, function(e12) {
          return t5.isPlatform(e12);
        });
        if (d3) {
          var u2 = this.satisfies(n7[d3]);
          if (void 0 !== u2) return u2;
        }
      }
      if (o4 > 0) {
        var h3 = Object.keys(i5), f4 = a.default.find(h3, function(e12) {
          return t5.isBrowser(e12, true);
        });
        if (void 0 !== f4) return this.compareVersion(i5[f4]);
      }
    }, t4.isBrowser = function(e11, t5) {
      void 0 === t5 && (t5 = false);
      var n7 = this.getBrowserName().toLowerCase(), r3 = e11.toLowerCase(), i5 = a.default.getBrowserTypeByAlias(r3);
      return t5 && i5 && (r3 = i5.toLowerCase()), r3 === n7;
    }, t4.compareVersion = function(e11) {
      var t5 = [0], n7 = e11, r3 = false, i5 = this.getBrowserVersion();
      if ("string" == typeof i5) return ">" === e11[0] || "<" === e11[0] ? (n7 = e11.substr(1), "=" === e11[1] ? (r3 = true, n7 = e11.substr(2)) : t5 = [], ">" === e11[0] ? t5.push(1) : t5.push(-1)) : "=" === e11[0] ? n7 = e11.substr(1) : "~" === e11[0] && (r3 = true, n7 = e11.substr(1)), t5.indexOf(a.default.compareVersions(i5, n7, r3)) > -1;
    }, t4.isOS = function(e11) {
      return this.getOSName(true) === String(e11).toLowerCase();
    }, t4.isPlatform = function(e11) {
      return this.getPlatformType(true) === String(e11).toLowerCase();
    }, t4.isEngine = function(e11) {
      return this.getEngineName(true) === String(e11).toLowerCase();
    }, t4.is = function(e11, t5) {
      return void 0 === t5 && (t5 = false), this.isBrowser(e11, t5) || this.isOS(e11) || this.isPlatform(e11);
    }, t4.some = function(e11) {
      var t5 = this;
      return void 0 === e11 && (e11 = []), e11.some(function(e12) {
        return t5.is(e12);
      });
    }, e10;
  }();
  t3.default = l5, e9.exports = t3.default;
}, 92: function(e9, t3, n6) {
  t3.__esModule = true, t3.default = void 0;
  var r2, i4 = (r2 = n6(17)) && r2.__esModule ? r2 : { default: r2 }, o3 = /version\/(\d+(\.?_?\d+)+)/i, s2 = [{ test: [/googlebot/i], describe: function(e10) {
    var t4 = { name: "Googlebot" }, n7 = i4.default.getFirstMatch(/googlebot\/(\d+(\.\d+))/i, e10) || i4.default.getFirstMatch(o3, e10);
    return n7 && (t4.version = n7), t4;
  } }, { test: [/opera/i], describe: function(e10) {
    var t4 = { name: "Opera" }, n7 = i4.default.getFirstMatch(o3, e10) || i4.default.getFirstMatch(/(?:opera)[\s/](\d+(\.?_?\d+)+)/i, e10);
    return n7 && (t4.version = n7), t4;
  } }, { test: [/opr\/|opios/i], describe: function(e10) {
    var t4 = { name: "Opera" }, n7 = i4.default.getFirstMatch(/(?:opr|opios)[\s/](\S+)/i, e10) || i4.default.getFirstMatch(o3, e10);
    return n7 && (t4.version = n7), t4;
  } }, { test: [/SamsungBrowser/i], describe: function(e10) {
    var t4 = { name: "Samsung Internet for Android" }, n7 = i4.default.getFirstMatch(o3, e10) || i4.default.getFirstMatch(/(?:SamsungBrowser)[\s/](\d+(\.?_?\d+)+)/i, e10);
    return n7 && (t4.version = n7), t4;
  } }, { test: [/Whale/i], describe: function(e10) {
    var t4 = { name: "NAVER Whale Browser" }, n7 = i4.default.getFirstMatch(o3, e10) || i4.default.getFirstMatch(/(?:whale)[\s/](\d+(?:\.\d+)+)/i, e10);
    return n7 && (t4.version = n7), t4;
  } }, { test: [/MZBrowser/i], describe: function(e10) {
    var t4 = { name: "MZ Browser" }, n7 = i4.default.getFirstMatch(/(?:MZBrowser)[\s/](\d+(?:\.\d+)+)/i, e10) || i4.default.getFirstMatch(o3, e10);
    return n7 && (t4.version = n7), t4;
  } }, { test: [/focus/i], describe: function(e10) {
    var t4 = { name: "Focus" }, n7 = i4.default.getFirstMatch(/(?:focus)[\s/](\d+(?:\.\d+)+)/i, e10) || i4.default.getFirstMatch(o3, e10);
    return n7 && (t4.version = n7), t4;
  } }, { test: [/swing/i], describe: function(e10) {
    var t4 = { name: "Swing" }, n7 = i4.default.getFirstMatch(/(?:swing)[\s/](\d+(?:\.\d+)+)/i, e10) || i4.default.getFirstMatch(o3, e10);
    return n7 && (t4.version = n7), t4;
  } }, { test: [/coast/i], describe: function(e10) {
    var t4 = { name: "Opera Coast" }, n7 = i4.default.getFirstMatch(o3, e10) || i4.default.getFirstMatch(/(?:coast)[\s/](\d+(\.?_?\d+)+)/i, e10);
    return n7 && (t4.version = n7), t4;
  } }, { test: [/opt\/\d+(?:.?_?\d+)+/i], describe: function(e10) {
    var t4 = { name: "Opera Touch" }, n7 = i4.default.getFirstMatch(/(?:opt)[\s/](\d+(\.?_?\d+)+)/i, e10) || i4.default.getFirstMatch(o3, e10);
    return n7 && (t4.version = n7), t4;
  } }, { test: [/yabrowser/i], describe: function(e10) {
    var t4 = { name: "Yandex Browser" }, n7 = i4.default.getFirstMatch(/(?:yabrowser)[\s/](\d+(\.?_?\d+)+)/i, e10) || i4.default.getFirstMatch(o3, e10);
    return n7 && (t4.version = n7), t4;
  } }, { test: [/ucbrowser/i], describe: function(e10) {
    var t4 = { name: "UC Browser" }, n7 = i4.default.getFirstMatch(o3, e10) || i4.default.getFirstMatch(/(?:ucbrowser)[\s/](\d+(\.?_?\d+)+)/i, e10);
    return n7 && (t4.version = n7), t4;
  } }, { test: [/Maxthon|mxios/i], describe: function(e10) {
    var t4 = { name: "Maxthon" }, n7 = i4.default.getFirstMatch(o3, e10) || i4.default.getFirstMatch(/(?:Maxthon|mxios)[\s/](\d+(\.?_?\d+)+)/i, e10);
    return n7 && (t4.version = n7), t4;
  } }, { test: [/epiphany/i], describe: function(e10) {
    var t4 = { name: "Epiphany" }, n7 = i4.default.getFirstMatch(o3, e10) || i4.default.getFirstMatch(/(?:epiphany)[\s/](\d+(\.?_?\d+)+)/i, e10);
    return n7 && (t4.version = n7), t4;
  } }, { test: [/puffin/i], describe: function(e10) {
    var t4 = { name: "Puffin" }, n7 = i4.default.getFirstMatch(o3, e10) || i4.default.getFirstMatch(/(?:puffin)[\s/](\d+(\.?_?\d+)+)/i, e10);
    return n7 && (t4.version = n7), t4;
  } }, { test: [/sleipnir/i], describe: function(e10) {
    var t4 = { name: "Sleipnir" }, n7 = i4.default.getFirstMatch(o3, e10) || i4.default.getFirstMatch(/(?:sleipnir)[\s/](\d+(\.?_?\d+)+)/i, e10);
    return n7 && (t4.version = n7), t4;
  } }, { test: [/k-meleon/i], describe: function(e10) {
    var t4 = { name: "K-Meleon" }, n7 = i4.default.getFirstMatch(o3, e10) || i4.default.getFirstMatch(/(?:k-meleon)[\s/](\d+(\.?_?\d+)+)/i, e10);
    return n7 && (t4.version = n7), t4;
  } }, { test: [/micromessenger/i], describe: function(e10) {
    var t4 = { name: "WeChat" }, n7 = i4.default.getFirstMatch(/(?:micromessenger)[\s/](\d+(\.?_?\d+)+)/i, e10) || i4.default.getFirstMatch(o3, e10);
    return n7 && (t4.version = n7), t4;
  } }, { test: [/qqbrowser/i], describe: function(e10) {
    var t4 = { name: /qqbrowserlite/i.test(e10) ? "QQ Browser Lite" : "QQ Browser" }, n7 = i4.default.getFirstMatch(/(?:qqbrowserlite|qqbrowser)[/](\d+(\.?_?\d+)+)/i, e10) || i4.default.getFirstMatch(o3, e10);
    return n7 && (t4.version = n7), t4;
  } }, { test: [/msie|trident/i], describe: function(e10) {
    var t4 = { name: "Internet Explorer" }, n7 = i4.default.getFirstMatch(/(?:msie |rv:)(\d+(\.?_?\d+)+)/i, e10);
    return n7 && (t4.version = n7), t4;
  } }, { test: [/\sedg\//i], describe: function(e10) {
    var t4 = { name: "Microsoft Edge" }, n7 = i4.default.getFirstMatch(/\sedg\/(\d+(\.?_?\d+)+)/i, e10);
    return n7 && (t4.version = n7), t4;
  } }, { test: [/edg([ea]|ios)/i], describe: function(e10) {
    var t4 = { name: "Microsoft Edge" }, n7 = i4.default.getSecondMatch(/edg([ea]|ios)\/(\d+(\.?_?\d+)+)/i, e10);
    return n7 && (t4.version = n7), t4;
  } }, { test: [/vivaldi/i], describe: function(e10) {
    var t4 = { name: "Vivaldi" }, n7 = i4.default.getFirstMatch(/vivaldi\/(\d+(\.?_?\d+)+)/i, e10);
    return n7 && (t4.version = n7), t4;
  } }, { test: [/seamonkey/i], describe: function(e10) {
    var t4 = { name: "SeaMonkey" }, n7 = i4.default.getFirstMatch(/seamonkey\/(\d+(\.?_?\d+)+)/i, e10);
    return n7 && (t4.version = n7), t4;
  } }, { test: [/sailfish/i], describe: function(e10) {
    var t4 = { name: "Sailfish" }, n7 = i4.default.getFirstMatch(/sailfish\s?browser\/(\d+(\.\d+)?)/i, e10);
    return n7 && (t4.version = n7), t4;
  } }, { test: [/silk/i], describe: function(e10) {
    var t4 = { name: "Amazon Silk" }, n7 = i4.default.getFirstMatch(/silk\/(\d+(\.?_?\d+)+)/i, e10);
    return n7 && (t4.version = n7), t4;
  } }, { test: [/phantom/i], describe: function(e10) {
    var t4 = { name: "PhantomJS" }, n7 = i4.default.getFirstMatch(/phantomjs\/(\d+(\.?_?\d+)+)/i, e10);
    return n7 && (t4.version = n7), t4;
  } }, { test: [/slimerjs/i], describe: function(e10) {
    var t4 = { name: "SlimerJS" }, n7 = i4.default.getFirstMatch(/slimerjs\/(\d+(\.?_?\d+)+)/i, e10);
    return n7 && (t4.version = n7), t4;
  } }, { test: [/blackberry|\bbb\d+/i, /rim\stablet/i], describe: function(e10) {
    var t4 = { name: "BlackBerry" }, n7 = i4.default.getFirstMatch(o3, e10) || i4.default.getFirstMatch(/blackberry[\d]+\/(\d+(\.?_?\d+)+)/i, e10);
    return n7 && (t4.version = n7), t4;
  } }, { test: [/(web|hpw)[o0]s/i], describe: function(e10) {
    var t4 = { name: "WebOS Browser" }, n7 = i4.default.getFirstMatch(o3, e10) || i4.default.getFirstMatch(/w(?:eb)?[o0]sbrowser\/(\d+(\.?_?\d+)+)/i, e10);
    return n7 && (t4.version = n7), t4;
  } }, { test: [/bada/i], describe: function(e10) {
    var t4 = { name: "Bada" }, n7 = i4.default.getFirstMatch(/dolfin\/(\d+(\.?_?\d+)+)/i, e10);
    return n7 && (t4.version = n7), t4;
  } }, { test: [/tizen/i], describe: function(e10) {
    var t4 = { name: "Tizen" }, n7 = i4.default.getFirstMatch(/(?:tizen\s?)?browser\/(\d+(\.?_?\d+)+)/i, e10) || i4.default.getFirstMatch(o3, e10);
    return n7 && (t4.version = n7), t4;
  } }, { test: [/qupzilla/i], describe: function(e10) {
    var t4 = { name: "QupZilla" }, n7 = i4.default.getFirstMatch(/(?:qupzilla)[\s/](\d+(\.?_?\d+)+)/i, e10) || i4.default.getFirstMatch(o3, e10);
    return n7 && (t4.version = n7), t4;
  } }, { test: [/firefox|iceweasel|fxios/i], describe: function(e10) {
    var t4 = { name: "Firefox" }, n7 = i4.default.getFirstMatch(/(?:firefox|iceweasel|fxios)[\s/](\d+(\.?_?\d+)+)/i, e10);
    return n7 && (t4.version = n7), t4;
  } }, { test: [/electron/i], describe: function(e10) {
    var t4 = { name: "Electron" }, n7 = i4.default.getFirstMatch(/(?:electron)\/(\d+(\.?_?\d+)+)/i, e10);
    return n7 && (t4.version = n7), t4;
  } }, { test: [/MiuiBrowser/i], describe: function(e10) {
    var t4 = { name: "Miui" }, n7 = i4.default.getFirstMatch(/(?:MiuiBrowser)[\s/](\d+(\.?_?\d+)+)/i, e10);
    return n7 && (t4.version = n7), t4;
  } }, { test: [/chromium/i], describe: function(e10) {
    var t4 = { name: "Chromium" }, n7 = i4.default.getFirstMatch(/(?:chromium)[\s/](\d+(\.?_?\d+)+)/i, e10) || i4.default.getFirstMatch(o3, e10);
    return n7 && (t4.version = n7), t4;
  } }, { test: [/chrome|crios|crmo/i], describe: function(e10) {
    var t4 = { name: "Chrome" }, n7 = i4.default.getFirstMatch(/(?:chrome|crios|crmo)\/(\d+(\.?_?\d+)+)/i, e10);
    return n7 && (t4.version = n7), t4;
  } }, { test: [/GSA/i], describe: function(e10) {
    var t4 = { name: "Google Search" }, n7 = i4.default.getFirstMatch(/(?:GSA)\/(\d+(\.?_?\d+)+)/i, e10);
    return n7 && (t4.version = n7), t4;
  } }, { test: function(e10) {
    var t4 = !e10.test(/like android/i), n7 = e10.test(/android/i);
    return t4 && n7;
  }, describe: function(e10) {
    var t4 = { name: "Android Browser" }, n7 = i4.default.getFirstMatch(o3, e10);
    return n7 && (t4.version = n7), t4;
  } }, { test: [/playstation 4/i], describe: function(e10) {
    var t4 = { name: "PlayStation 4" }, n7 = i4.default.getFirstMatch(o3, e10);
    return n7 && (t4.version = n7), t4;
  } }, { test: [/safari|applewebkit/i], describe: function(e10) {
    var t4 = { name: "Safari" }, n7 = i4.default.getFirstMatch(o3, e10);
    return n7 && (t4.version = n7), t4;
  } }, { test: [/.*/i], describe: function(e10) {
    var t4 = -1 !== e10.search("\\(") ? /^(.*)\/(.*)[ \t]\((.*)/ : /^(.*)\/(.*) /;
    return { name: i4.default.getFirstMatch(t4, e10), version: i4.default.getSecondMatch(t4, e10) };
  } }];
  t3.default = s2, e9.exports = t3.default;
}, 93: function(e9, t3, n6) {
  t3.__esModule = true, t3.default = void 0;
  var r2, i4 = (r2 = n6(17)) && r2.__esModule ? r2 : { default: r2 }, o3 = n6(18), s2 = [{ test: [/Roku\/DVP/], describe: function(e10) {
    var t4 = i4.default.getFirstMatch(/Roku\/DVP-(\d+\.\d+)/i, e10);
    return { name: o3.OS_MAP.Roku, version: t4 };
  } }, { test: [/windows phone/i], describe: function(e10) {
    var t4 = i4.default.getFirstMatch(/windows phone (?:os)?\s?(\d+(\.\d+)*)/i, e10);
    return { name: o3.OS_MAP.WindowsPhone, version: t4 };
  } }, { test: [/windows /i], describe: function(e10) {
    var t4 = i4.default.getFirstMatch(/Windows ((NT|XP)( \d\d?.\d)?)/i, e10), n7 = i4.default.getWindowsVersionName(t4);
    return { name: o3.OS_MAP.Windows, version: t4, versionName: n7 };
  } }, { test: [/Macintosh(.*?) FxiOS(.*?)\//], describe: function(e10) {
    var t4 = { name: o3.OS_MAP.iOS }, n7 = i4.default.getSecondMatch(/(Version\/)(\d[\d.]+)/, e10);
    return n7 && (t4.version = n7), t4;
  } }, { test: [/macintosh/i], describe: function(e10) {
    var t4 = i4.default.getFirstMatch(/mac os x (\d+(\.?_?\d+)+)/i, e10).replace(/[_\s]/g, "."), n7 = i4.default.getMacOSVersionName(t4), r3 = { name: o3.OS_MAP.MacOS, version: t4 };
    return n7 && (r3.versionName = n7), r3;
  } }, { test: [/(ipod|iphone|ipad)/i], describe: function(e10) {
    var t4 = i4.default.getFirstMatch(/os (\d+([_\s]\d+)*) like mac os x/i, e10).replace(/[_\s]/g, ".");
    return { name: o3.OS_MAP.iOS, version: t4 };
  } }, { test: function(e10) {
    var t4 = !e10.test(/like android/i), n7 = e10.test(/android/i);
    return t4 && n7;
  }, describe: function(e10) {
    var t4 = i4.default.getFirstMatch(/android[\s/-](\d+(\.\d+)*)/i, e10), n7 = i4.default.getAndroidVersionName(t4), r3 = { name: o3.OS_MAP.Android, version: t4 };
    return n7 && (r3.versionName = n7), r3;
  } }, { test: [/(web|hpw)[o0]s/i], describe: function(e10) {
    var t4 = i4.default.getFirstMatch(/(?:web|hpw)[o0]s\/(\d+(\.\d+)*)/i, e10), n7 = { name: o3.OS_MAP.WebOS };
    return t4 && t4.length && (n7.version = t4), n7;
  } }, { test: [/blackberry|\bbb\d+/i, /rim\stablet/i], describe: function(e10) {
    var t4 = i4.default.getFirstMatch(/rim\stablet\sos\s(\d+(\.\d+)*)/i, e10) || i4.default.getFirstMatch(/blackberry\d+\/(\d+([_\s]\d+)*)/i, e10) || i4.default.getFirstMatch(/\bbb(\d+)/i, e10);
    return { name: o3.OS_MAP.BlackBerry, version: t4 };
  } }, { test: [/bada/i], describe: function(e10) {
    var t4 = i4.default.getFirstMatch(/bada\/(\d+(\.\d+)*)/i, e10);
    return { name: o3.OS_MAP.Bada, version: t4 };
  } }, { test: [/tizen/i], describe: function(e10) {
    var t4 = i4.default.getFirstMatch(/tizen[/\s](\d+(\.\d+)*)/i, e10);
    return { name: o3.OS_MAP.Tizen, version: t4 };
  } }, { test: [/linux/i], describe: function() {
    return { name: o3.OS_MAP.Linux };
  } }, { test: [/CrOS/], describe: function() {
    return { name: o3.OS_MAP.ChromeOS };
  } }, { test: [/PlayStation 4/], describe: function(e10) {
    var t4 = i4.default.getFirstMatch(/PlayStation 4[/\s](\d+(\.\d+)*)/i, e10);
    return { name: o3.OS_MAP.PlayStation4, version: t4 };
  } }];
  t3.default = s2, e9.exports = t3.default;
}, 94: function(e9, t3, n6) {
  t3.__esModule = true, t3.default = void 0;
  var r2, i4 = (r2 = n6(17)) && r2.__esModule ? r2 : { default: r2 }, o3 = n6(18), s2 = [{ test: [/googlebot/i], describe: function() {
    return { type: "bot", vendor: "Google" };
  } }, { test: [/huawei/i], describe: function(e10) {
    var t4 = i4.default.getFirstMatch(/(can-l01)/i, e10) && "Nova", n7 = { type: o3.PLATFORMS_MAP.mobile, vendor: "Huawei" };
    return t4 && (n7.model = t4), n7;
  } }, { test: [/nexus\s*(?:7|8|9|10).*/i], describe: function() {
    return { type: o3.PLATFORMS_MAP.tablet, vendor: "Nexus" };
  } }, { test: [/ipad/i], describe: function() {
    return { type: o3.PLATFORMS_MAP.tablet, vendor: "Apple", model: "iPad" };
  } }, { test: [/Macintosh(.*?) FxiOS(.*?)\//], describe: function() {
    return { type: o3.PLATFORMS_MAP.tablet, vendor: "Apple", model: "iPad" };
  } }, { test: [/kftt build/i], describe: function() {
    return { type: o3.PLATFORMS_MAP.tablet, vendor: "Amazon", model: "Kindle Fire HD 7" };
  } }, { test: [/silk/i], describe: function() {
    return { type: o3.PLATFORMS_MAP.tablet, vendor: "Amazon" };
  } }, { test: [/tablet(?! pc)/i], describe: function() {
    return { type: o3.PLATFORMS_MAP.tablet };
  } }, { test: function(e10) {
    var t4 = e10.test(/ipod|iphone/i), n7 = e10.test(/like (ipod|iphone)/i);
    return t4 && !n7;
  }, describe: function(e10) {
    var t4 = i4.default.getFirstMatch(/(ipod|iphone)/i, e10);
    return { type: o3.PLATFORMS_MAP.mobile, vendor: "Apple", model: t4 };
  } }, { test: [/nexus\s*[0-6].*/i, /galaxy nexus/i], describe: function() {
    return { type: o3.PLATFORMS_MAP.mobile, vendor: "Nexus" };
  } }, { test: [/[^-]mobi/i], describe: function() {
    return { type: o3.PLATFORMS_MAP.mobile };
  } }, { test: function(e10) {
    return "blackberry" === e10.getBrowserName(true);
  }, describe: function() {
    return { type: o3.PLATFORMS_MAP.mobile, vendor: "BlackBerry" };
  } }, { test: function(e10) {
    return "bada" === e10.getBrowserName(true);
  }, describe: function() {
    return { type: o3.PLATFORMS_MAP.mobile };
  } }, { test: function(e10) {
    return "windows phone" === e10.getBrowserName();
  }, describe: function() {
    return { type: o3.PLATFORMS_MAP.mobile, vendor: "Microsoft" };
  } }, { test: function(e10) {
    var t4 = Number(String(e10.getOSVersion()).split(".")[0]);
    return "android" === e10.getOSName(true) && t4 >= 3;
  }, describe: function() {
    return { type: o3.PLATFORMS_MAP.tablet };
  } }, { test: function(e10) {
    return "android" === e10.getOSName(true);
  }, describe: function() {
    return { type: o3.PLATFORMS_MAP.mobile };
  } }, { test: function(e10) {
    return "macos" === e10.getOSName(true);
  }, describe: function() {
    return { type: o3.PLATFORMS_MAP.desktop, vendor: "Apple" };
  } }, { test: function(e10) {
    return "windows" === e10.getOSName(true);
  }, describe: function() {
    return { type: o3.PLATFORMS_MAP.desktop };
  } }, { test: function(e10) {
    return "linux" === e10.getOSName(true);
  }, describe: function() {
    return { type: o3.PLATFORMS_MAP.desktop };
  } }, { test: function(e10) {
    return "playstation 4" === e10.getOSName(true);
  }, describe: function() {
    return { type: o3.PLATFORMS_MAP.tv };
  } }, { test: function(e10) {
    return "roku" === e10.getOSName(true);
  }, describe: function() {
    return { type: o3.PLATFORMS_MAP.tv };
  } }];
  t3.default = s2, e9.exports = t3.default;
}, 95: function(e9, t3, n6) {
  t3.__esModule = true, t3.default = void 0;
  var r2, i4 = (r2 = n6(17)) && r2.__esModule ? r2 : { default: r2 }, o3 = n6(18), s2 = [{ test: function(e10) {
    return "microsoft edge" === e10.getBrowserName(true);
  }, describe: function(e10) {
    if (/\sedg\//i.test(e10)) return { name: o3.ENGINE_MAP.Blink };
    var t4 = i4.default.getFirstMatch(/edge\/(\d+(\.?_?\d+)+)/i, e10);
    return { name: o3.ENGINE_MAP.EdgeHTML, version: t4 };
  } }, { test: [/trident/i], describe: function(e10) {
    var t4 = { name: o3.ENGINE_MAP.Trident }, n7 = i4.default.getFirstMatch(/trident\/(\d+(\.?_?\d+)+)/i, e10);
    return n7 && (t4.version = n7), t4;
  } }, { test: function(e10) {
    return e10.test(/presto/i);
  }, describe: function(e10) {
    var t4 = { name: o3.ENGINE_MAP.Presto }, n7 = i4.default.getFirstMatch(/presto\/(\d+(\.?_?\d+)+)/i, e10);
    return n7 && (t4.version = n7), t4;
  } }, { test: function(e10) {
    var t4 = e10.test(/gecko/i), n7 = e10.test(/like gecko/i);
    return t4 && !n7;
  }, describe: function(e10) {
    var t4 = { name: o3.ENGINE_MAP.Gecko }, n7 = i4.default.getFirstMatch(/gecko\/(\d+(\.?_?\d+)+)/i, e10);
    return n7 && (t4.version = n7), t4;
  } }, { test: [/(apple)?webkit\/537\.36/i], describe: function() {
    return { name: o3.ENGINE_MAP.Blink };
  } }, { test: [/(apple)?webkit/i], describe: function(e10) {
    var t4 = { name: o3.ENGINE_MAP.WebKit }, n7 = i4.default.getFirstMatch(/webkit\/(\d+(\.?_?\d+)+)/i, e10);
    return n7 && (t4.version = n7), t4;
  } }];
  t3.default = s2, e9.exports = t3.default;
} });
var Wu = ue(qu.exports);
var Vu = { Initialized: "initialized", DisplayURI: "display_uri", ProviderUpdate: "provider_update", ConnectWithResponse: "connectWithResponse", ConnectionStatus: "connection_status", ServiceStatus: "service_status" };
var Gu = class _Gu {
  constructor({ shouldSetOnWindow: e9, connectionStream: t3, shouldSendMetadata: n6 = false, shouldShimWeb3: r2, sdkInstance: i4 }) {
    const o3 = new Ju({ connectionStream: t3, shouldSendMetadata: n6, shouldSetOnWindow: e9, shouldShimWeb3: r2, autoRequestAccounts: false }), s2 = new Proxy(o3, { deleteProperty: () => true });
    if (this.provider = s2, this.sdkInstance = i4, e9 && "undefined" != typeof window) try {
      a = o3, window.ethereum = a, window.dispatchEvent(new Event("ethereum#initialized"));
    } catch (e10) {
      Iu("[Ethereum] Unable to set global provider - window.ethereum may be read-only", e10);
    }
    var a;
    if (r2 && "undefined" != typeof window) try {
      !function(e10, t4 = console) {
        let n7 = false, r3 = false;
        if (!window.web3) {
          const i5 = "__isMetaMaskShim__";
          let o4 = { currentProvider: e10 };
          Object.defineProperty(o4, i5, { value: true, enumerable: true, configurable: false, writable: false }), o4 = new Proxy(o4, { get: (o5, s3, ...a2) => ("currentProvider" !== s3 || n7 ? "currentProvider" === s3 || s3 === i5 || r3 || (r3 = true, t4.error("MetaMask no longer injects web3. For details, see: https://docs.metamask.io/guide/provider-migration.html#replacing-window-web3"), e10.request({ method: "metamask_logWeb3ShimUsage" }).catch((e11) => {
            t4.debug("MetaMask: Failed to log web3 shim usage.", e11);
          })) : (n7 = true, t4.warn("You are accessing the MetaMask window.web3.currentProvider shim. This property is deprecated; use window.ethereum instead. For details, see: https://docs.metamask.io/guide/provider-migration.html#replacing-window-web3")), Reflect.get(o5, s3, ...a2)), set: (...e11) => (t4.warn("You are accessing the MetaMask window.web3 shim. This object is deprecated; use window.ethereum instead. For details, see: https://docs.metamask.io/guide/provider-migration.html#replacing-window-web3"), Reflect.set(...e11)) }), Object.defineProperty(window, "web3", { value: o4, enumerable: false, configurable: true, writable: true });
        }
      }(this.provider);
    } catch (e10) {
      Iu("[Ethereum] Unable to shim web3 - window.web3 may be read-only", e10);
    }
    this.provider.on("display_uri", (e10) => {
      this.sdkInstance.emit(Vu.DisplayURI, e10);
    }), this.provider.on("_initialized", () => {
      const e10 = { chainId: this.provider.getChainId(), isConnected: this.provider.isConnected(), isMetaMask: this.provider.isMetaMask, selectedAddress: this.provider.getSelectedAddress(), networkVersion: this.provider.getNetworkVersion() };
      this.sdkInstance.emit(Vu.Initialized, e10), Iu("[Ethereum: constructor()] provider initialized", e10);
    });
  }
  static init(e9) {
    var t3;
    return Iu("[Ethereum: init()] Initializing Ethereum service"), this.instance = new _Gu(e9), null === (t3 = this.instance) || void 0 === t3 ? void 0 : t3.provider;
  }
  static destroy() {
  }
  static getInstance() {
    var e9;
    if (!(null === (e9 = this.instance) || void 0 === e9 ? void 0 : e9.provider)) throw new Error("Ethereum instance not intiialized - call Ethereum.factory first.");
    return this.instance;
  }
  static getProvider() {
    var e9;
    if (!(null === (e9 = this.instance) || void 0 === e9 ? void 0 : e9.provider)) throw new Error("Ethereum instance not intiialized - call Ethereum.factory first.");
    return this.instance.provider;
  }
};
var Yu = class _Yu {
  constructor({ useDeepLink: e9, preferredOpenLink: t3, debug: n6 = false }) {
    this.state = { platformType: void 0, useDeeplink: false, preferredOpenLink: void 0, debug: false }, this.state.platformType = this.getPlatformType(), this.state.useDeeplink = e9, this.state.preferredOpenLink = t3, this.state.debug = n6;
  }
  openDeeplink(e9, t3, n6) {
    return function(e10, t4, n7, r2) {
      const { state: i4 } = e10;
      Iu(`[PlatfformManager: openDeeplink()] universalLink --> ${t4}`), Iu(`[PlatfformManager: openDeeplink()] deepLink --> ${n7}`);
      try {
        if (i4.preferredOpenLink) return void i4.preferredOpenLink(i4.useDeeplink ? n7 : t4, r2);
        if (Iu(`[PlatfformManager: openDeeplink()] open link now useDeepLink=${i4.useDeeplink} link=${i4.useDeeplink ? n7 : t4}`), i4.useDeeplink) "undefined" != typeof window && (window.location.href = n7);
        else if ("undefined" != typeof document) {
          const e11 = document.createElement("a");
          e11.href = t4, e11.target = "_self", e11.rel = "noreferrer noopener", e11.click();
        }
      } catch (e11) {
        console.log("[PlatfformManager: openDeeplink()] can't open link", e11);
      }
    }(this, e9, t3, n6);
  }
  isReactNative() {
    var e9;
    return this.isNotBrowser() && "undefined" != typeof window && (null === window || void 0 === window ? void 0 : window.navigator) && "ReactNative" === (null === (e9 = window.navigator) || void 0 === e9 ? void 0 : e9.product);
  }
  isMetaMaskInstalled() {
    return function() {
      const e9 = Gu.getProvider() || (null === window || void 0 === window ? void 0 : window.ethereum);
      return Iu(`[PlatfformManager: isMetaMaskInstalled()] isMetaMask=${null == e9 ? void 0 : e9.isMetaMask} isConnected=${null == e9 ? void 0 : e9.isConnected()}`), (null == e9 ? void 0 : e9.isMetaMask) && (null == e9 ? void 0 : e9.isConnected());
    }();
  }
  isDesktopWeb() {
    return this.isBrowser() && !this.isMobileWeb();
  }
  isMobile() {
    var e9, t3;
    const n6 = Wu.parse(window.navigator.userAgent);
    return "mobile" === (null === (e9 = null == n6 ? void 0 : n6.platform) || void 0 === e9 ? void 0 : e9.type) || "tablet" === (null === (t3 = null == n6 ? void 0 : n6.platform) || void 0 === t3 ? void 0 : t3.type);
  }
  isSecure() {
    return this.isReactNative() || this.isMobileWeb();
  }
  isMetaMaskMobileWebView() {
    return "undefined" != typeof window && (Boolean(window.ReactNativeWebView) && Boolean(navigator.userAgent.endsWith("MetaMaskMobile")));
  }
  isMobileWeb() {
    return this.state.platformType === Uo.MobileWeb;
  }
  static isNotBrowser() {
    var e9;
    return "undefined" == typeof window || !(null === window || void 0 === window ? void 0 : window.navigator) || void 0 !== l4 && "ReactNative" === (null === (e9 = null == l4 ? void 0 : l4.navigator) || void 0 === e9 ? void 0 : e9.product) || "ReactNative" === (null === navigator || void 0 === navigator ? void 0 : navigator.product);
  }
  isNotBrowser() {
    return _Yu.isNotBrowser();
  }
  static isBrowser() {
    return !this.isNotBrowser();
  }
  isBrowser() {
    return _Yu.isBrowser();
  }
  isNodeJS() {
    return this.isNotBrowser() && !this.isReactNative();
  }
  isUseDeepLink() {
    return this.state.useDeeplink;
  }
  getPlatformType() {
    return function(e9) {
      const { state: t3 } = e9;
      return t3.platformType ? t3.platformType : e9.isReactNative() ? Uo.ReactNative : e9.isNotBrowser() ? Uo.NonBrowser : e9.isMetaMaskMobileWebView() ? Uo.MetaMaskMobileWebview : e9.isMobile() ? Uo.MobileWeb : Uo.DesktopWeb;
    }(this);
  }
};
var Zu = (e9) => c2(void 0, void 0, void 0, function* () {
  if (Yu.isBrowser()) {
    const { StorageManagerWeb: t4 } = yield Promise.resolve().then(function() {
      return cf;
    });
    return new t4(e9);
  }
  const t3 = { persistChannelConfig: () => c2(void 0, void 0, void 0, function* () {
  }), getPersistedChannelConfig: () => c2(void 0, void 0, void 0, function* () {
  }), persistAccounts: () => c2(void 0, void 0, void 0, function* () {
  }), getCachedAccounts: () => c2(void 0, void 0, void 0, function* () {
    return [];
  }), persistChainId: () => c2(void 0, void 0, void 0, function* () {
  }), getCachedChainId: () => c2(void 0, void 0, void 0, function* () {
  }), terminate: () => c2(void 0, void 0, void 0, function* () {
  }) };
  return Promise.resolve(t3);
});
var Ju = class extends Mu {
  constructor({ connectionStream: e9, shouldSendMetadata: t3, autoRequestAccounts: n6 = false }) {
    super(e9, { logger: console, maxEventListeners: 100, shouldSendMetadata: t3 }), this.state = { accounts: null, autoRequestAccounts: false, providerStateRequested: false, chainId: "", networkVersion: "" }, Iu(`[SDKProvider: constructor()] autoRequestAccounts=${n6}`), this.state.autoRequestAccounts = n6;
  }
  forceInitializeState() {
    return c2(this, void 0, void 0, function* () {
      return Iu(`[SDKProvider: forceInitializeState()] autoRequestAccounts=${this.state.autoRequestAccounts}`), this._initializeStateAsync();
    });
  }
  _setConnected() {
    Iu("[SDKProvider: _setConnected()] Setting connected state"), this._state.isConnected = true;
  }
  getState() {
    return this._state;
  }
  getSDKProviderState() {
    return this.state;
  }
  getSelectedAddress() {
    var e9;
    const { accounts: t3 } = this._state;
    return t3 && 0 !== t3.length ? (null === (e9 = t3[0]) || void 0 === e9 ? void 0 : e9.toLowerCase()) || "" : (Iu("[SDKProvider: getSelectedAddress] No accounts found"), null);
  }
  getChainId() {
    return this.state.chainId;
  }
  getNetworkVersion() {
    return this.state.networkVersion;
  }
  setSDKProviderState(e9) {
    this.state = Object.assign(Object.assign({}, this.state), e9);
  }
  handleAccountsChanged(e9, t3) {
    return this._handleAccountsChanged(e9, t3);
  }
  handleDisconnect({ terminate: e9 = false }) {
    !function({ terminate: e10 = false, instance: t3 }) {
      const { state: n6 } = t3;
      Iu(`[SDKProvider: handleDisconnect()] cleaning up provider state terminate=${e10}`, t3), e10 && (t3._state.accounts = null, t3._state.isUnlocked = false, t3._state.isPermanentlyDisconnected = true, t3._state.initialized = false), t3._handleAccountsChanged([]), t3._state.isConnected = false, t3.emit("disconnect", Ru.ethErrors.provider.disconnected()), n6.providerStateRequested = false;
    }({ terminate: e9, instance: this });
  }
  _initializeStateAsync() {
    return c2(this, void 0, void 0, function* () {
      return function(e9) {
        var t3, n6;
        return c2(this, void 0, void 0, function* () {
          void 0 === e9.state && (e9.state = { accounts: null, autoRequestAccounts: false, providerStateRequested: false, chainId: "" });
          const { state: r2 } = e9;
          let i4;
          if (r2.providerStateRequested) Iu("[SDKProvider: initializeStateAsync()] initialization already in progress");
          else {
            let o3;
            r2.providerStateRequested = true;
            let s2 = null, a = false, c3 = false;
            const l5 = yield Zu({ enabled: true });
            if (l5) {
              const e10 = yield l5.getPersistedChannelConfig({});
              a = null !== (t3 = null == e10 ? void 0 : e10.relayPersistence) && void 0 !== t3 && t3, o3 = yield l5.getCachedChainId();
              const n7 = yield l5.getCachedAccounts();
              n7.length > 0 && (s2 = n7[0]);
            }
            if (Iu(`[SDKProvider: initializeStateAsync()] relayPersistence=${a}`, { relayPersistence: a, cachedChainId: o3, cachedSelectedAddress: s2 }), a) if (o3 && s2) i4 = { accounts: [s2], chainId: o3, isUnlocked: false }, c3 = true;
            else try {
              i4 = yield e9.request({ method: "metamask_getProviderState" });
            } catch (t4) {
              return e9._log.error("MetaMask: Failed to get initial state. Please report this bug.", t4), void (r2.providerStateRequested = false);
            }
            if (0 === (null === (n6 = null == i4 ? void 0 : i4.accounts) || void 0 === n6 ? void 0 : n6.length)) if (e9.getSelectedAddress()) i4.accounts = [e9.getSelectedAddress()];
            else {
              Iu("[SDKProvider: initializeStateAsync()] Fetch accounts remotely.");
              const t4 = yield e9.request({ method: "eth_requestAccounts", params: [] });
              i4.accounts = t4;
            }
            e9._initializeState(i4), r2.providerStateRequested = false, c3 && (e9._state.isConnected = true, e9.emit("connect", { chainId: null == i4 ? void 0 : i4.chainId }));
          }
        });
      }(this);
    });
  }
  _initializeState(e9) {
    return Iu("[SDKProvider: _initializeState()]", e9), function(e10, t3, n6) {
      return Iu("[SDKProvider: initializeState()] set state._initialized to false"), e10._state.initialized = false, t3(n6);
    }(this, super._initializeState.bind(this), e9);
  }
  _handleChainChanged({ chainId: e9, networkVersion: t3 } = {}) {
    this.state.chainId = e9, this.state.networkVersion = t3, function({ instance: e10, chainId: t4, networkVersion: r2, superHandleChainChanged: i4 }) {
      Iu(`[SDKProvider: handleChainChanged()] chainId=${t4} networkVersion=${r2}`);
      let o3 = r2;
      r2 || (Iu("[SDKProvider: handleChainChanged()] forced network version to prevent provider error"), o3 = "1"), t4 !== Tu && (import_sdk_analytics.analytics.track("sdk_used_chain", { caip_chain_id: `eip155:${parseInt(null != t4 ? t4 : "0x1", 16)}` }), Tu = t4), e10._state.isConnected = true, e10.emit("connect", { chainId: t4 }), i4({ chainId: t4, networkVersion: o3 });
    }({ instance: this, chainId: e9, networkVersion: t3, superHandleChainChanged: super._handleChainChanged.bind(this) });
  }
};
var Qu;
var Xu = { name: "@metamask/sdk", version: "0.33.0", description: "", homepage: "https://github.com/MetaMask/metamask-sdk#readme", bugs: { url: "https://github.com/MetaMask/metamask-sdk/issues" }, repository: { type: "git", url: "https://github.com/MetaMask/metamask-sdk", directory: "packages/sdk" }, main: "dist/node/cjs/metamask-sdk.js", module: "dist/browser/es/metamask-sdk.js", browser: "dist/browser/es/metamask-sdk.js", unpkg: "dist/browser/umd/metamask-sdk.js", "react-native": "dist/react-native/es/metamask-sdk.js", types: "dist/types/src/index.d.ts", sideEffects: false, files: ["/dist"], scripts: { "build:types": "tsc --project tsconfig.build.json --emitDeclarationOnly --outDir dist/types", build: "yarn build:types && rollup -c --bundleConfigAsCjs", "build:clean": "yarn clean && yarn build", "build:post-tsc": "echo 'N/A'", "build:pre-tsc": "echo 'N/A'", typecheck: "tsc --noEmit", clean: "rimraf ./dist", size: "node bundle-size && size-limit", lint: "yarn lint:eslint && yarn lint:misc --check", "lint:changelog": "../../scripts/validate-changelog.sh @metamask/sdk", "lint:eslint": "eslint . --cache --ext js,ts", "lint:fix": "yarn lint:eslint --fix && yarn lint:misc --write", "lint:misc": "prettier '**/*.json' '**/*.md' '!CHANGELOG.md' --ignore-path ../../.gitignore", prepack: "../../scripts/prepack.sh", "publish:preview": "yarn npm publish --tag preview", reset: "yarn clean && rimraf ./node_modules/", test: 'jest --testPathIgnorePatterns "/e2e/"', "test:coverage": 'jest --coverage --testPathIgnorePatterns "/e2e/"', "test:e2e": 'jest --testPathPattern "/e2e/"', "test:ci": 'jest --coverage --passWithNoTests --setupFilesAfterEnv ./jest-preload.js --testPathIgnorePatterns "/e2e/"', "test:dev": 'jest -c ./jest.config.ts --detectOpenHandles  --testPathIgnorePatterns "/e2e/"', watch: "rollup -c -w", dev: 'concurrently "tsc --watch" "rollup -c -w --bundleConfigAsCjs"', "build:dev": "yarn build:types && NODE_ENV=dev rollup -c --bundleConfigAsCjs" }, dependencies: { "@babel/runtime": "^7.26.0", "@metamask/onboarding": "^1.0.1", "@metamask/providers": "16.1.0", "@metamask/sdk-analytics": "workspace:*", "@metamask/sdk-communication-layer": "workspace:*", "@metamask/sdk-install-modal-web": "workspace:*", "@paulmillr/qr": "^0.2.1", bowser: "^2.9.0", "cross-fetch": "^4.0.0", debug: "^4.3.4", eciesjs: "^0.4.11", "eth-rpc-errors": "^4.0.3", eventemitter2: "^6.4.9", "obj-multiplex": "^1.0.0", pump: "^3.0.0", "readable-stream": "^3.6.2", "socket.io-client": "^4.5.1", tslib: "^2.6.0", util: "^0.12.4", uuid: "^8.3.2" }, devDependencies: { "@jest/globals": "^29.3.1", "@lavamoat/allow-scripts": "^2.3.1", "@metamask/auto-changelog": "3.1.0", "@metamask/eslint-config": "^6.0.0", "@metamask/eslint-config-nodejs": "^6.0.0", "@metamask/eslint-config-typescript": "^6.0.0", "@react-native-async-storage/async-storage": "^1.19.6", "@rollup/plugin-alias": "^5.1.1", "@rollup/plugin-commonjs": "^25.0.7", "@rollup/plugin-json": "^6.0.0", "@rollup/plugin-node-resolve": "^15.0.2", "@rollup/plugin-replace": "^6.0.1", "@rollup/plugin-terser": "^0.4.1", "@size-limit/preset-big-lib": "^11.0.2", "@types/dom-screen-wake-lock": "^1.0.2", "@types/node": "^20.1.3", "@types/pump": "^1.1.1", "@types/qrcode-terminal": "^0.12.0", "@types/uuid": "^10.0.0", "@typescript-eslint/eslint-plugin": "^4.26.0", "@typescript-eslint/parser": "^4.26.0", "browserify-zlib": "^0.2.0", buffer: "^6.0.3", concurrently: "^9.1.2", "crypto-browserify": "^3.12.0", eslint: "^7.30.0", "eslint-config-prettier": "^8.3.0", "eslint-plugin-import": "^2.23.4", "eslint-plugin-jest": "^24.4.0", "eslint-plugin-jsdoc": "^36.1.0", "eslint-plugin-node": "^11.1.0", "eslint-plugin-prettier": "^3.4.0", "https-browserify": "^1.0.0", jest: "^29.3.1", "jest-environment-jsdom": "^29.3.1", prettier: "^2.3.0", process: "^0.11.10", rimraf: "^4.4.0", rollup: "^4.26.0", "rollup-plugin-analyzer": "^4.0.0", "rollup-plugin-jscc": "^2.0.0", "rollup-plugin-natives": "^0.7.5", "rollup-plugin-node-builtins": "^2.1.2", "rollup-plugin-polyfill-node": "^0.13.0", "rollup-plugin-sizes": "^1.0.6", "rollup-plugin-typescript2": "^0.31.2", "rollup-plugin-visualizer": "^5.12.0", "size-limit": "^11.0.2", "stream-browserify": "^3.0.0", "stream-http": "^3.2.0", "ts-jest": "^29.0.3", "ts-node": "^10.9.1", typescript: "^4.3.2", url: "^0.11.0", webpack: "^5.0.0" }, publishConfig: { access: "public", registry: "https://registry.npmjs.org/" }, lavamoat: { allowScripts: { "eciesjs>secp256k1": false, "socket.io-client>engine.io-client>ws>bufferutil": false, "socket.io-client>engine.io-client>ws>utf-8-validate": false, "@metamask/sdk-communication-layer>bufferutil": false, "@metamask/sdk-communication-layer>eciesjs>secp256k1": false, "@metamask/sdk-communication-layer>utf-8-validate": false } } };
!function(e9) {
  e9.INPAGE = "metamask-inpage", e9.CONTENT_SCRIPT = "metamask-contentscript", e9.PROVIDER = "metamask-provider";
}(Qu || (Qu = {}));
var eh = "direct";
var th = "https://metamask.app.link/connect";
var nh = "metamask://connect";
var rh = { NAME: "MetaMask", RDNS: ["io.metamask", "io.metamask.flask"] };
var ih = /(?:^[a-f0-9]{8}-[a-f0-9]{4}-4[a-f0-9]{3}-[a-f0-9]{4}-[a-f0-9]{12}$)|(?:^0{8}-0{4}-0{4}-0{4}-0{12}$)/u;
var oh = { METAMASK_GETPROVIDERSTATE: "metamask_getProviderState", METAMASK_CONNECTSIGN: "metamask_connectSign", METAMASK_CONNECTWITH: "metamask_connectWith", METAMASK_OPEN: "metamask_open", METAMASK_BATCH: "metamask_batch", PERSONAL_SIGN: "personal_sign", WALLET_REQUESTPERMISSIONS: "wallet_requestPermissions", WALLET_REVOKEPERMISSIONS: "wallet_revokePermissions", WALLET_GETPERMISSIONS: "wallet_getPermissions", WALLET_WATCHASSET: "wallet_watchAsset", WALLET_ADDETHEREUMCHAIN: "wallet_addEthereumChain", WALLET_SWITCHETHETHEREUMCHAIN: "wallet_switchEthereumChain", ETH_REQUESTACCOUNTS: "eth_requestAccounts", ETH_ACCOUNTS: "eth_accounts", ETH_CHAINID: "eth_chainId", ETH_SENDTRANSACTION: "eth_sendTransaction", ETH_SIGNTYPEDDATA: "eth_signTypedData", ETH_SIGNTYPEDDATA_V3: "eth_signTypedData_v3", ETH_SIGNTYPEDDATA_V4: "eth_signTypedData_v4", ETH_SIGNTRANSACTION: "eth_signTransaction", ETH_SIGN: "eth_sign", PERSONAL_EC_RECOVER: "personal_ecRecover" };
var sh = { [oh.ETH_REQUESTACCOUNTS]: true, [oh.ETH_SENDTRANSACTION]: true, [oh.ETH_SIGNTRANSACTION]: true, [oh.ETH_SIGN]: true, [oh.PERSONAL_SIGN]: true, [oh.ETH_ACCOUNTS]: false, [oh.ETH_CHAINID]: false, [oh.PERSONAL_SIGN]: true, [oh.ETH_SIGNTYPEDDATA]: true, [oh.ETH_SIGNTYPEDDATA_V3]: true, [oh.ETH_SIGNTYPEDDATA_V4]: true, [oh.WALLET_REQUESTPERMISSIONS]: true, [oh.WALLET_GETPERMISSIONS]: true, [oh.WALLET_WATCHASSET]: true, [oh.WALLET_ADDETHEREUMCHAIN]: true, [oh.WALLET_SWITCHETHETHEREUMCHAIN]: true, [oh.METAMASK_CONNECTSIGN]: true, [oh.METAMASK_CONNECTWITH]: true, [oh.PERSONAL_EC_RECOVER]: true, [oh.METAMASK_BATCH]: true, [oh.METAMASK_OPEN]: true };
var ah = Object.keys(sh).filter((e9) => true === sh[e9]).map((e9) => e9.toLowerCase());
var ch = ["eth_signTypedData", "eth_signTypedData_v3", "eth_signTypedData_v4", "eth_sign"].map((e9) => e9.toLowerCase());
var lh = ".sdk-comm";
var dh = "providerType";
var uh = ".MMSDK_cached_address";
var hh = ".MMSDK_cached_chainId";
var fh = { CHAIN_CHANGED: "chainChanged", ACCOUNTS_CHANGED: "accountsChanged", DISCONNECT: "disconnect", CONNECT: "connect", CONNECTED: "connected" };
var ph = 1e6;
var gh;
!function(e9) {
  e9.TERMINATE = "terminate", e9.EXTENSION = "extension", e9.INITIALIZED = "initialized";
}(gh || (gh = {}));
var mh = "undefined" != typeof window && window.localStorage;
function yh({ instance: e9, msg: t3 }) {
  return c2(this, void 0, void 0, function* () {
    if (e9._initialized || (Iu("[MetaMaskSDK: connectAndSign()] provider not ready -- wait for init()"), yield e9.init()), Iu(`[MetaMaskSDK: connectAndSign()] activeProvider=${e9.activeProvider}`), !e9.activeProvider) throw new Error("SDK state invalid -- undefined provider");
    const n6 = /^0x([0-9A-Fa-f]{2})*$/u.test(t3) ? t3 : function(e10) {
      let t4;
      if (void 0 !== C3) t4 = C3.from(e10, "utf8").toString("hex");
      else if ("undefined" != typeof TextEncoder) {
        const n7 = new TextEncoder().encode(e10);
        t4 = Array.from(n7).map((e11) => e11.toString(16).padStart(2, "0")).join("");
      } else {
        if ("object" != typeof l4 || !("Buffer" in l4)) throw new Error("Unable to convert string to hex: No available method.");
        t4 = l4.Buffer.from(e10, "utf8").toString("hex");
      }
      return `0x${t4}`;
    }(t3);
    return e9.activeProvider.request({ method: oh.METAMASK_CONNECTWITH, params: [{ method: oh.PERSONAL_SIGN, params: [n6] }] });
  });
}
function vh(e9) {
  var t3, n6;
  return c2(this, void 0, void 0, function* () {
    Iu("[MetaMaskSDK: connectWithExtensionProvider()] ", e9), e9.sdkProvider = e9.activeProvider, e9.activeProvider = window.extension, window.ethereum = window.extension;
    try {
      const e10 = yield null === (t3 = window.extension) || void 0 === t3 ? void 0 : t3.request({ method: "eth_requestAccounts" });
      Iu(`[MetaMaskSDK: connectWithExtensionProvider()] accounts=${e10}`);
    } catch (e10) {
      return void console.warn("[MetaMaskSDK: connectWithExtensionProvider()] can't request accounts error", e10);
    }
    localStorage.setItem(dh, "extension"), e9.extensionActive = true, e9.emit(Vu.ProviderUpdate, gh.EXTENSION), e9.options.enableAnalytics && (null === (n6 = e9.analytics) || void 0 === n6 || n6.send({ event: Ao.SDK_USE_EXTENSION }));
  });
}
function bh(e9) {
  let t3;
  if (void 0 !== C3) t3 = C3.from(e9, "utf8").toString("base64");
  else if ("function" == typeof btoa) t3 = btoa(encodeURIComponent(e9).replace(/%([0-9A-F]{2})/gu, (e10, t4) => String.fromCharCode(parseInt(t4, 16))));
  else {
    if ("object" != typeof l4 || !("Buffer" in l4)) throw new Error("Unable to base64 encode: No available method.");
    t3 = l4.Buffer.from(e9, "utf8").toString("base64");
  }
  return t3;
}
function wh(e9, t3, n6, r2) {
  var i4, o3, s2, a, l5, d3, u2, h3, f4, p4, g2, m4, y2, v2, b3, w5, E4, S5, _2, k3;
  return c2(this, void 0, void 0, function* () {
    const n7 = null === (i4 = e9.state.remote) || void 0 === i4 ? void 0 : i4.isReady(), c3 = null === (o3 = e9.state.remote) || void 0 === o3 ? void 0 : o3.isConnected(), A3 = null === (s2 = e9.state.remote) || void 0 === s2 ? void 0 : s2.isPaused(), x3 = Gu.getProvider(), M4 = null === (a = e9.state.remote) || void 0 === a ? void 0 : a.getChannelId(), I2 = null === (l5 = e9.state.remote) || void 0 === l5 ? void 0 : l5.isAuthorized(), { deeplinkProtocol: T3 } = e9.state, { method: R3, data: P5, triggeredInstaller: O4 } = ((e10) => {
      var t4, n8, r3, i5;
      let o4;
      C3.isBuffer(e10) ? (o4 = e10.toJSON(), o4._isBuffer = true) : o4 = e10;
      const s3 = null === (t4 = null == o4 ? void 0 : o4.data) || void 0 === t4 ? void 0 : t4.method;
      let a2 = false;
      return "object" == typeof (null === (n8 = null == o4 ? void 0 : o4.data) || void 0 === n8 ? void 0 : n8.params) && true === (null === (i5 = null === (r3 = null == o4 ? void 0 : o4.data) || void 0 === r3 ? void 0 : r3.params) || void 0 === i5 ? void 0 : i5.__triggeredInstaller) && (a2 = true, o4.data.params = o4.data.params.wrappedParams), { method: s3, data: o4, triggeredInstaller: a2 };
    })(t3);
    if (Iu(`[RCPMS: write()] method='${R3}' isRemoteReady=${n7} channelId=${M4} isSocketConnected=${c3} isRemotePaused=${A3} providerConnected=${x3.isConnected()}`, t3), !M4) return R3 !== oh.METAMASK_GETPROVIDERSTATE && Iu(`[RCPMS: write()] ${R3} --> channelId is undefined`), r2(new Error("disconnected"));
    Iu(`[RCPMS: write()] remote.isPaused()=${null === (d3 = e9.state.remote) || void 0 === d3 ? void 0 : d3.isPaused()} authorized=${I2} ready=${n7} socketConnected=${c3}`, t3);
    const N3 = null === (u2 = e9.state.platformManager) || void 0 === u2 ? void 0 : u2.isSecure(), L5 = null !== (f4 = null === (h3 = e9.state.platformManager) || void 0 === h3 ? void 0 : h3.isMobileWeb()) && void 0 !== f4 && f4, D3 = null !== (g2 = null === (p4 = e9.state.remote) || void 0 === p4 ? void 0 : p4.hasDeeplinkProtocol()) && void 0 !== g2 && g2 && L5 && I2;
    try {
      if (!O4) {
        const t5 = JSON.stringify(null == P5 ? void 0 : P5.data);
        if (t5.length > ph) return r2(new Error(`Message size ${t5.length} exceeds maximum allowed size of 1000000 bytes`));
        null === (m4 = e9.state.remote) || void 0 === m4 || m4.sendMessage(null == P5 ? void 0 : P5.data).then(() => {
          Iu(`[RCPMS: _write()] ${R3} sent successfully`);
        }).catch((e10) => {
          Iu("[RCPMS: _write()] error sending message", e10);
        });
      }
      if (!N3) return Iu(`[RCPMS: _write()] unsecure platform for method ${R3} -- return callback`), r2();
      if (O4) return Iu("[RCPMS: _write()] prevent deeplink -- installation completed separately."), r2();
      const t4 = null !== (b3 = null === (v2 = null === (y2 = e9.state.remote) || void 0 === y2 ? void 0 : y2.getKeyInfo()) || void 0 === v2 ? void 0 : v2.ecies.public) && void 0 !== b3 ? b3 : "";
      let n8 = encodeURI(`channelId=${M4}&pubkey=${t4}&comm=socket&t=d&v=2`);
      if (D3) {
        const t5 = JSON.stringify(null == P5 ? void 0 : P5.data), i5 = null === (w5 = e9.state.remote) || void 0 === w5 ? void 0 : w5.encrypt(t5);
        if (!i5) return Iu("[RCPMS: _write()] error encrypting message"), r2(new Error("RemoteCommunicationPostMessageStream - disconnected"));
        n8 += `&scheme=${T3}&rpc=${bh(i5)}`;
      }
      if (!(null === (E4 = e9.state.platformManager) || void 0 === E4 ? void 0 : E4.isMetaMaskInstalled())) return Iu("[RCPMS: _write()] prevent deeplink until installation is completed."), r2();
      sh[R3] ? (Iu(`[RCPMS: _write()] redirect link for '${R3}' socketConnected=${c3} connect?${n8}`), null === (S5 = e9.state.platformManager) || void 0 === S5 || S5.openDeeplink(`${th}?${n8}`, `${nh}?${n8}`, "_self")) : (null === (_2 = e9.state.remote) || void 0 === _2 ? void 0 : _2.isPaused()) ? (Iu(`[RCPMS: _write()] MM is PAUSED! deeplink with connect! targetMethod=${R3}`), null === (k3 = e9.state.platformManager) || void 0 === k3 || k3.openDeeplink(`${th}?redirect=true&${n8}`, `${nh}?redirect=true&${n8}`, "_self")) : Iu(`[RCPMS: _write()] method ${R3} doesn't need redirect.`);
    } catch (e10) {
      return Iu("[RCPMS: _write()] error sending message", e10), r2(new Error("RemoteCommunicationPostMessageStream - disconnected"));
    }
    return r2();
  });
}
var Eh = class extends ou.Duplex {
  constructor({ name: e9, remote: t3, deeplinkProtocol: n6, platformManager: r2 }) {
    super({ objectMode: true }), this.state = { _name: null, remote: null, deeplinkProtocol: false, platformManager: null }, this.state._name = e9, this.state.remote = t3, this.state.deeplinkProtocol = n6, this.state.platformManager = r2, this._onMessage = this._onMessage.bind(this), this.state.remote.on(So.MESSAGE, this._onMessage);
  }
  _write(e9, t3, n6) {
    return c2(this, void 0, void 0, function* () {
      return wh(this, e9, 0, n6);
    });
  }
  _read() {
  }
  _onMessage(e9) {
    return function(e10, t3) {
      try {
        if (Iu("[RCPMS: onMessage()] message", t3), !t3 || "object" != typeof t3) return;
        if ("object" != typeof (null == t3 ? void 0 : t3.data)) return;
        if (!(null == t3 ? void 0 : t3.name)) return void Iu("[RCPMS: onMessage()] ignore message without name", t3);
        if ((null == t3 ? void 0 : t3.name) !== Qu.PROVIDER) return void Iu(`[RCPMS: onMessage()] ignore message with wrong name message=${t3}`);
        if (C3.isBuffer(t3)) {
          const n6 = C3.from(t3);
          e10.push(n6);
        } else e10.push(t3);
      } catch (e11) {
        Iu(`[RCPMS: onMessage()] ignore message error err=${e11}`);
      }
    }(this, e9);
  }
  start() {
  }
};
var Sh = 1;
var _h = (e9) => new Promise((t3) => {
  setTimeout(() => {
    t3(true);
  }, e9);
});
var Ch = ({ checkInstallationOnAllCalls: t3 = false, communicationLayerPreference: n6, injectProvider: r2, shouldShimWeb3: i4, platformManager: o3, installer: s2, sdk: a, remoteConnection: l5, debug: d3 }) => c2(void 0, void 0, void 0, function* () {
  var u2, h3;
  const f4 = (({ name: e9, remoteConnection: t4 }) => {
    if (!t4 || !(null == t4 ? void 0 : t4.getConnector())) throw new Error("Missing remote connection parameter");
    return new Eh({ name: e9, remote: null == t4 ? void 0 : t4.getConnector(), deeplinkProtocol: null == t4 ? void 0 : t4.state.deeplinkProtocol, platformManager: null == t4 ? void 0 : t4.getPlatformManager() });
  })({ name: Qu.INPAGE, target: Qu.CONTENT_SCRIPT, platformManager: o3, communicationLayerPreference: n6, remoteConnection: l5 }), p4 = o3.getPlatformType(), g2 = a.options.dappMetadata, m4 = `Sdk/Javascript SdkVersion/${Xu.version} Platform/${p4} dApp/${null !== (u2 = g2.url) && void 0 !== u2 ? u2 : g2.name} dAppTitle/${g2.name}`;
  let y2 = null, v2 = null;
  const b3 = null === (h3 = a.options.storage) || void 0 === h3 ? void 0 : h3.storageManager;
  if (b3) {
    try {
      const e9 = yield b3.getCachedAccounts();
      e9.length > 0 && (y2 = e9[0]);
    } catch (e9) {
      console.error(`[initializeMobileProvider] failed to get cached addresses: ${e9}`);
    }
    try {
      const e9 = yield b3.getCachedChainId();
      e9 && (v2 = e9);
    } catch (e9) {
      console.error(`[initializeMobileProvider] failed to parse cached chainId: ${e9}`);
    }
  }
  Iu(`[initializeMobileProvider] cachedAccountAddress: ${y2}, cachedChainId: ${v2}`);
  const w5 = !(!r2 || p4 === Uo.NonBrowser || p4 === Uo.ReactNative), E4 = Gu.init({ shouldSetOnWindow: w5, connectionStream: f4, shouldShimWeb3: i4, sdkInstance: a });
  let S5 = false;
  const _2 = (e9) => {
    S5 = e9;
  }, C4 = () => S5, k3 = (n7, r3, i5, d4) => c2(void 0, void 0, void 0, function* () {
    var u3, h4, f5, p5, g3, w6, E5, k4, A4;
    const x4 = Gu.getProvider();
    if (S5) {
      x4.emit("display_uri", (null == l5 ? void 0 : l5.state.qrcodeLink) || ""), null == l5 || l5.showActiveModal();
      let e9 = C4();
      for (; e9; ) {
        const t4 = C4(), n8 = null == l5 ? void 0 : l5.isAuthorized();
        e9 = t4 && !n8, Iu(`[initializeMobileProvider: sendRequest()] waiting for initialization to complete - initializing: ${t4} authorized: ${n8}`), yield _h(1e3);
      }
      return Iu("[initializeMobileProvider: sendRequest()] initial method completed -- prevent installation and call provider"), i5(...r3);
    }
    const M4 = o3.isMetaMaskInstalled(), I2 = null == l5 ? void 0 : l5.isConnected();
    let T3 = null, R3 = null, P5 = null;
    if (T3 = null !== (u3 = x4.getSelectedAddress()) && void 0 !== u3 ? u3 : y2, P5 = x4.getChainId() || v2, T3 && b3 && T3 !== y2 && b3.persistAccounts([T3]).catch((e9) => {
      console.error(`[initializeMobileProvider] failed to persist account: ${e9}`);
    }), P5 && (v2 = P5, b3 && b3.persistChainId(P5).catch((e9) => {
      console.error(`[initializeMobileProvider] failed to persist chainId: ${e9}`);
    })), Iu("[initializeMobileProvider: sendRequest()]", { selectedAddress: T3, chainId: P5 }), d4 && Iu(`[initializeMobileProvider: sendRequest()] method=${n7} ongoing=${S5} selectedAddress=${T3} isInstalled=${M4} checkInstallationOnAllCalls=${t3} socketConnected=${I2}`), T3 && n7.toLowerCase() === oh.ETH_ACCOUNTS.toLowerCase()) return [T3];
    if (P5 && n7.toLowerCase() === oh.ETH_CHAINID.toLowerCase()) return P5;
    const O4 = [oh.ETH_REQUESTACCOUNTS, oh.WALLET_REQUESTPERMISSIONS, oh.METAMASK_CONNECTSIGN, oh.METAMASK_CONNECTWITH], N3 = !sh[n7], L5 = null === (h4 = a.options.readonlyRPCMap) || void 0 === h4 ? void 0 : h4[P5];
    if (L5 && N3) try {
      const t4 = null === (f5 = null == r3 ? void 0 : r3[0]) || void 0 === f5 ? void 0 : f5.params, i6 = yield (({ rpcEndpoint: t5, method: n8, sdkInfo: r4, params: i7 }) => c2(void 0, void 0, void 0, function* () {
        const o4 = JSON.stringify({ jsonrpc: "2.0", method: n8, params: i7, id: (Sh += 1, Sh) }), s3 = { Accept: "application/json", "Content-Type": "application/json" };
        let a2;
        t5.includes("infura") && (s3["Metamask-Sdk-Info"] = r4);
        try {
          a2 = yield (0, import_cross_fetch.default)(t5, { method: "POST", headers: s3, body: o4 });
        } catch (e9) {
          throw e9 instanceof Error ? new Error(`Failed to fetch from RPC: ${e9.message}`) : new Error(`Failed to fetch from RPC: ${e9}`);
        }
        if (!a2.ok) throw new Error(`Server responded with a status of ${a2.status}`);
        return (yield a2.json()).result;
      }))({ rpcEndpoint: L5, sdkInfo: m4, method: n7, params: t4 || [] });
      return d4 && Iu(`initializeProvider::ReadOnlyRPCResponse ${i6}`), i6;
    } catch (e9) {
      console.warn(`[initializeMobileProvider: sendRequest()] method=${n7} readOnlyRPCRequest failed:`, e9);
    }
    if ((!M4 || M4 && !I2) && n7 !== oh.METAMASK_GETPROVIDERSTATE) {
      const e9 = (null === (p5 = null == r3 ? void 0 : r3[0]) || void 0 === p5 ? void 0 : p5.params) || [];
      if (-1 !== O4.indexOf(n7) || t3) {
        _2(true);
        const t4 = n7 === oh.METAMASK_CONNECTWITH, o4 = `${Date.now()}`;
        try {
          yield s2.start({ wait: false, connectWith: t4 ? { method: n7, id: o4, params: e9 } : void 0 }), yield new Promise((e10, t5) => {
            (null == l5 ? void 0 : l5.isAuthorized()) && (Iu("[initializeMobileProvider: sendRequest()] already authorized"), e10(true)), null == l5 || l5.getConnector().once(So.AUTHORIZED, () => {
              e10(true);
            }), a.once(So.PROVIDER_UPDATE, (e11) => {
              Iu(`[initializeMobileProvider: sendRequest()] PROVIDER_UPDATE --- remote provider request interupted type=${e11}`), e11 === gh.EXTENSION ? t5(So.PROVIDER_UPDATE) : t5(new Error("Connection Terminated"));
            });
          });
        } catch (t5) {
          if (gh.EXTENSION === t5) {
            if (Iu(`[initializeMobileProvider: sendRequest()] extension provider detect: re-create ${n7} on the active provider`), n7.toLowerCase() === oh.METAMASK_CONNECTSIGN.toLowerCase()) {
              const t6 = yield null === (g3 = a.getProvider()) || void 0 === g3 ? void 0 : g3.request({ method: oh.ETH_REQUESTACCOUNTS, params: [] });
              if (!t6.length) throw new Error("SDK state invalid -- undefined accounts");
              const n8 = yield null === (w6 = a.getProvider()) || void 0 === w6 ? void 0 : w6.request({ method: oh.PERSONAL_SIGN, params: [e9[0], t6[0]] });
              return a.emit(Vu.ConnectWithResponse, n8), n8;
            }
            if (n7.toLowerCase() === oh.METAMASK_CONNECTWITH.toLowerCase()) {
              const [t6] = e9, n8 = yield (({ method: e10, sdk: t7, params: n9 }) => c2(void 0, void 0, void 0, function* () {
                var r4, i6, o5, s3;
                if (!t7.isExtensionActive()) throw new Error("SDK state invalid -- extension is not active");
                Iu("[MetaMaskProvider: extensionConnectWithOverwrite()] Overwriting request method", e10, n9);
                const a2 = yield null === (r4 = t7.getProvider()) || void 0 === r4 ? void 0 : r4.request({ method: oh.ETH_REQUESTACCOUNTS, params: [] });
                if (!a2.length) throw new Error("SDK state invalid -- undefined accounts");
                if ((null == e10 ? void 0 : e10.toLowerCase()) === oh.PERSONAL_SIGN.toLowerCase()) {
                  const r5 = { method: e10, params: [n9[0], a2[0]] };
                  return yield null === (i6 = t7.getProvider()) || void 0 === i6 ? void 0 : i6.request(r5);
                }
                if ((null == e10 ? void 0 : e10.toLowerCase()) === oh.ETH_SENDTRANSACTION.toLowerCase()) {
                  const r5 = { method: e10, params: [Object.assign(Object.assign({}, n9[0]), { from: a2[0] })] };
                  return yield null === (o5 = t7.getProvider()) || void 0 === o5 ? void 0 : o5.request(r5);
                }
                return ch.includes(e10.toLowerCase()) ? (console.warn(`MetaMaskSDK connectWith method=${e10} -- not handled by the extension -- call separately`), a2) : yield null === (s3 = t7.getProvider()) || void 0 === s3 ? void 0 : s3.request({ method: e10, params: n9 });
              }))({ method: t6.method, sdk: a, params: t6.params });
              return a.emit(Vu.ConnectWithResponse, n8), n8;
            }
            return Iu(`[initializeMobileProvider: sendRequest()] sending '${n7}' on active provider`, e9), yield null === (E5 = a.getProvider()) || void 0 === E5 ? void 0 : E5.request({ method: n7, params: e9 });
          }
          if (t5 === So.REJECTED) throw null == l5 || l5.closeModal(), null === (k4 = a.getProvider()) || void 0 === k4 || k4.handleDisconnect({ terminate: false }), Object.assign(new Error("User rejected connection"), { code: 4001 });
          throw Iu(`[initializeMobileProvider: sendRequest()] failed to start installer: ${t5}`), t5;
        } finally {
          _2(false);
        }
        if (n7 === oh.ETH_REQUESTACCOUNTS) return R3 = yield new Promise((e10) => {
          const t5 = setInterval(() => {
            const { accounts: n8 } = x4.getState();
            n8 && (clearInterval(t5), e10(n8));
          }, 100);
        }), Iu(`[initializeMobileProvider: sendRequest()] selectedAddress: ${T3} --- SKIP rpc call`), R3;
        if (n7 === oh.METAMASK_CONNECTWITH) try {
          let e10 = 0;
          const t5 = 5, n8 = ({ resolve: n9, reject: r5 }) => {
            e10 += 1;
            const i7 = null == l5 ? void 0 : l5.getConnector().getRPCMethodTracker(), s4 = null == i7 ? void 0 : i7[o4];
            return Iu(`TRACKER: update method ${o4}`, s4), (null == s4 ? void 0 : s4.result) ? (Iu("[initializeMobileProvider: sendRequest()] found result", s4.result), a.emit(Vu.ConnectWithResponse, s4.result), void n9(s4.result)) : (null == s4 ? void 0 : s4.error) ? (Iu("[initializeMobileProvider: sendRequest()] found error", s4.error), void r5(s4.error)) : e10 >= t5 ? (Iu("[initializeMobileProvider: sendRequest()] max message count reached without result"), void r5(new Error("Max message count reached without result"))) : void Iu("[initializeMobileProvider: sendRequest()] not found yet, need to wait for next update");
          };
          let r4, i6;
          const s3 = yield new Promise((e11, t6) => {
            const s4 = null == l5 ? void 0 : l5.getConnector().getRPCMethodTracker();
            Iu(`TRACKER: method ${o4}`, s4), (null == s4 ? void 0 : s4[o4].result) ? (Iu("[initializeMobileProvider: sendRequest()] found result", null == s4 ? void 0 : s4[o4].result), e11(null == s4 ? void 0 : s4[o4].result)) : (null == s4 ? void 0 : s4[o4].error) && (Iu("[initializeMobileProvider: sendRequest()] found error", null == s4 ? void 0 : s4[o4].error), t6(null == s4 ? void 0 : s4[o4].error)), i6 = () => n8({ resolve: e11, reject: t6 }), r4 = null == l5 ? void 0 : l5.getConnector().on(So.RPC_UPDATE, i6);
          });
          return i6 && (null == r4 || r4.off(So.RPC_UPDATE, i6)), Iu("TRACKER: result", s3), s3;
        } catch (e10) {
          throw Iu("[initializeMobileProvider: sendRequest()] error:", e10), e10;
        }
        r3[0] && "object" == typeof r3[0] && (r3[0].params = { __triggeredInstaller: true, wrappedParams: r3[0].params });
        return i5(...r3);
      }
      if (o3.isSecure() && sh[n7]) return i5(...r3);
      if (a.isExtensionActive()) return Iu(`[initializeMobileProvider: sendRequest()] EXTENSION active - redirect request '${n7}' to it`, r3, e9), yield null === (A4 = a.getProvider()) || void 0 === A4 ? void 0 : A4.request({ method: n7, params: e9 });
      throw Iu(`[initializeMobileProvider: sendRequest()] method=${n7} --- skip --- not connected/installed`), new Error("MetaMask is not connected/installed, please call eth_requestAccounts to connect first.");
    }
    try {
      const e9 = yield i5(...r3);
      if (Iu(`[initializeMobileProvider: sendRequest()] method=${n7} rpcResponse`, e9), n7 === oh.WALLET_REQUESTPERMISSIONS) {
        const t4 = e9.reduce((e10, t5) => {
          var n8;
          if ("eth_accounts" === t5.parentCapability) {
            const r4 = null === (n8 = t5.caveats.find((e11) => "restrictReturnedAccounts" === e11.type)) || void 0 === n8 ? void 0 : n8.value;
            r4 && e10.push(...r4);
          }
          return e10;
        }, []);
        Iu("[initializeMobileProvider: sendRequest()] accountsToPersist:", t4), t4.length > 0 && (x4.handleAccountsChanged(t4, false), null == b3 || b3.persistAccounts(t4));
      }
      return e9;
    } catch (e9) {
      throw console.error("[initializeMobileProvider: sendRequest()] error:", e9), e9;
    }
  }), { request: A3 } = E4;
  E4.request = (...e9) => c2(void 0, void 0, void 0, function* () {
    return k3(null == e9 ? void 0 : e9[0].method, e9, A3, d3);
  });
  const { send: x3 } = E4;
  return E4.send = (...e9) => c2(void 0, void 0, void 0, function* () {
    return k3(null == e9 ? void 0 : e9[0], e9, x3, d3);
  }), Iu("[initializeMobileProvider: sendRequest()] metamaskStream.start()"), f4.start(), E4;
});
function kh(e9) {
  var t3, n6, r2, i4;
  return c2(this, void 0, void 0, function* () {
    const { options: o3 } = e9, s2 = { communicationLayerPreference: null !== (t3 = o3.communicationLayerPreference) && void 0 !== t3 ? t3 : jo.SOCKET, platformManager: e9.platformManager, sdk: e9, checkInstallationOnAllCalls: o3.checkInstallationOnAllCalls, injectProvider: null === (n6 = o3.injectProvider) || void 0 === n6 || n6, shouldShimWeb3: null === (r2 = o3.shouldShimWeb3) || void 0 === r2 || r2, extensionOnly: null === (i4 = o3.extensionOnly) || void 0 === i4 || i4, installer: e9.installer, remoteConnection: e9.remoteConnection, debug: e9.debug }, a = yield Ch(s2);
    e9.activeProvider = a, function(e10) {
      var t4, n7, r3, i5;
      null === (n7 = null === (t4 = e10.remoteConnection) || void 0 === t4 ? void 0 : t4.getConnector()) || void 0 === n7 || n7.on(Vu.ConnectionStatus, (t5) => {
        e10.emit(Vu.ConnectionStatus, t5);
      }), null === (i5 = null === (r3 = e10.remoteConnection) || void 0 === r3 ? void 0 : r3.getConnector()) || void 0 === i5 || i5.on(Vu.ServiceStatus, (t5) => {
        e10.emit(Vu.ServiceStatus, t5);
      });
    }(e9);
  });
}
var Ah = "sdk";
var xh = class {
  constructor({ serverUrl: e9, enabled: t3, originatorInfo: n6 }) {
    this.serverURL = fo, this.serverURL = e9, this.originatorInfo = n6, this.enabled = null == t3 || t3;
  }
  send({ event: e9, params: t3 }) {
    if (!this.enabled) return;
    const n6 = Object.assign(Object.assign({ id: Ah, event: e9, sdkVersion: Xu.version }, this.originatorInfo), { params: t3 });
    Iu(`[Analytics: send()] event: ${e9}`, n6), lo(n6, this.serverURL).catch((e10) => {
      Iu(`[Analytics: send()] error: ${e10}`);
    });
  }
};
var Mh = () => {
  if ("undefined" == typeof document) return;
  let e9;
  const t3 = document.getElementsByTagName("link");
  for (let n6 = 0; n6 < t3.length; n6++) "icon" !== t3[n6].getAttribute("rel") && "shortcut icon" !== t3[n6].getAttribute("rel") || (e9 = t3[n6].getAttribute("href"));
  return e9;
};
var Ih = 163400;
function Th(e9) {
  var t3, n6, r2;
  const { dappMetadata: i4 } = e9, o3 = function({ url: e10, name: t4 }) {
    var n7;
    const r3 = e10 + t4, i5 = bh(r3);
    if (!localStorage) return "";
    let o4 = null !== (n7 = localStorage.getItem(i5)) && void 0 !== n7 ? n7 : "";
    if (!o4) {
      o4 = v4_default();
      try {
        localStorage.setItem(i5, o4);
      } catch (e11) {
        return "";
      }
    }
    return o4;
  }({ url: null !== (t3 = null == i4 ? void 0 : i4.url) && void 0 !== t3 ? t3 : "no_url", name: null !== (n6 = null == i4 ? void 0 : i4.name) && void 0 !== n6 ? n6 : "no_name" }), a = null === (r2 = e9.platformManager) || void 0 === r2 ? void 0 : r2.getPlatformType(), c3 = a === Uo.DesktopWeb, l5 = a === Uo.MetaMaskMobileWebview;
  let d3 = "N/A";
  return c3 ? d3 = "extension" : l5 && (d3 = "mobile"), { id: o3, from: d3 };
}
var Rh = (e9, t3, r2) => {
  if (bo(e9)) {
    if (r2 || t3 && "object" == typeof t3 && null !== t3 && "error" in t3) {
      const i4 = r2 || (null == t3 ? void 0 : t3.error);
      i4 && 4001 === i4.code ? import_sdk_analytics.analytics.track("sdk_action_rejected", { action: e9 }) : import_sdk_analytics.analytics.track("sdk_action_failed", { action: e9 });
    } else import_sdk_analytics.analytics.track("sdk_action_succeeded", { action: e9 });
  }
};
var Ph = ({ provider: e9, sdkInstance: t3 }) => {
  if ("state" in e9) throw new Error("INVALID EXTENSION PROVIDER");
  return new Proxy(e9, { get: (r2, i4) => "request" === i4 ? function(e10) {
    var i5, o3;
    return c2(this, void 0, void 0, function* () {
      Iu("[wrapExtensionProvider()] Overwriting request method", e10);
      const { method: s2, params: a } = e10, l5 = ah.includes(s2.toLowerCase()), { id: d3, from: u2 } = Th(t3);
      if (l5 && (null === (i5 = t3.analytics) || void 0 === i5 || i5.send({ event: Ao.SDK_RPC_REQUEST, params: { method: s2, from: u2, id: d3 } })), bo(s2) && import_sdk_analytics.analytics.track("sdk_action_requested", { action: s2 }), s2 === oh.METAMASK_BATCH && Array.isArray(a)) return (({ target: e11, args: t4, trackEvent: n6, sdkInstance: r3 }) => c2(void 0, void 0, void 0, function* () {
        var i6, o4;
        if ("metamask_batch" !== t4.method) throw new Error("Invalid usage");
        const s3 = [], a2 = null !== (i6 = null == t4 ? void 0 : t4.params) && void 0 !== i6 ? i6 : [];
        for (const t5 of a2) {
          const n7 = yield null == e11 ? void 0 : e11.request({ method: t5.method, params: t5.params });
          s3.push(n7);
        }
        const { id: c3, from: l6 } = Th(r3);
        n6 && (null === (o4 = r3.analytics) || void 0 === o4 || o4.send({ event: Ao.SDK_RPC_REQUEST_DONE, params: { method: t4.method, from: l6, id: c3 } }));
        for (const e12 of s3) Rh(t4.method, e12, null);
        return s3;
      }))({ target: r2, args: e10, trackEvent: l5, sdkInstance: t3 });
      if (s2.toLowerCase() === oh.METAMASK_CONNECTSIGN.toLowerCase() && Array.isArray(a)) return (({ target: e11, params: t4 }) => c2(void 0, void 0, void 0, function* () {
        let n6, r3 = null;
        try {
          const r4 = yield e11.request({ method: oh.ETH_REQUESTACCOUNTS, params: [] });
          if (!r4.length) throw new Error("SDK state invalid -- undefined accounts");
          return n6 = yield e11.request({ method: oh.PERSONAL_SIGN, params: [t4[0], r4[0]] }), n6;
        } catch (e12) {
          throw r3 = e12, e12;
        } finally {
          Rh(oh.PERSONAL_SIGN, n6, r3);
        }
      }))({ target: r2, params: a });
      if (s2.toLowerCase() === oh.METAMASK_CONNECTWITH.toLowerCase() && Array.isArray(a)) return (({ target: e11, params: t4 }) => c2(void 0, void 0, void 0, function* () {
        const [n6] = t4, r3 = n6.method, i6 = n6.params;
        let o4, s3 = null;
        try {
          const t5 = yield e11.request({ method: oh.ETH_REQUESTACCOUNTS, params: [] });
          if (!Array.isArray(t5) || !t5.length) throw new Error("SDK state invalid -- undefined accounts");
          return (null == r3 ? void 0 : r3.toLowerCase()) === oh.PERSONAL_SIGN.toLowerCase() ? (o4 = yield e11.request({ method: r3, params: [i6[0], t5[0]] }), o4) : (null == r3 ? void 0 : r3.toLowerCase()) === oh.ETH_SENDTRANSACTION.toLowerCase() ? (o4 = yield e11.request({ method: r3, params: [Object.assign(Object.assign({}, i6[0]), { from: t5[0] })] }), o4) : ch.includes(r3.toLowerCase()) ? (console.warn(`MetaMaskSDK connectWith method=${r3} -- not handled by the extension -- call separately`), o4 = t5, o4) : (o4 = yield e11.request({ method: r3, params: i6 }), o4);
        } catch (e12) {
          throw s3 = e12, e12;
        } finally {
          Rh(r3, o4, s3);
        }
      }))({ target: r2, params: a });
      let h3, f4 = null;
      try {
        return h3 = yield r2.request(e10), h3;
      } catch (e11) {
        throw f4 = e11, e11;
      } finally {
        l5 && (null === (o3 = t3.analytics) || void 0 === o3 || o3.send({ event: Ao.SDK_RPC_REQUEST_DONE, params: { method: s2, from: u2, id: d3 } })), Rh(s2, h3, f4);
      }
    });
  } : "getChainId" === i4 ? function() {
    return e9.chainId;
  } : "getNetworkVersion" === i4 ? function() {
    return e9.networkVersion;
  } : "getSelectedAddress" === i4 ? function() {
    return e9.selectedAddress;
  } : "isConnected" === i4 ? function() {
    return e9._state.isConnected;
  } : r2[i4] });
};
var Oh;
function Nh({ mustBeMetaMask: e9, sdkInstance: t3 }) {
  return c2(this, void 0, void 0, function* () {
    if ("undefined" == typeof window) throw new Error("window not available");
    try {
      const e10 = yield new Promise((e11, t4) => {
        const n6 = setTimeout(() => {
          t4(new Error("eip6963RequestProvider timed out"));
        }, 500);
        window.addEventListener(Oh.Announce, (t5) => {
          const r2 = t5, { detail: { info: i4, provider: o3 } = {} } = r2, { name: s2, rdns: a, uuid: c3 } = null != i4 ? i4 : {};
          ih.test(c3) && s2.startsWith(rh.NAME) && rh.RDNS.includes(a) && (clearTimeout(n6), e11(o3));
        }), window.dispatchEvent(new Event(Oh.Request));
      });
      return Ph({ provider: e10, sdkInstance: t3 });
    } catch (n6) {
      if (!e9 && window.ethereum) return Ph({ provider: window.ethereum, sdkInstance: t3 });
      throw new Error("Provider not found");
    }
  });
}
!function(e9) {
  e9.Announce = "eip6963:announceProvider", e9.Request = "eip6963:requestProvider";
}(Oh || (Oh = {}));
var Lh = (e9) => c2(void 0, void 0, void 0, function* () {
  const { options: t3 } = e9, { infuraAPIKey: n6 } = t3;
  if (!n6) return;
  const r2 = { "0x1": `https://mainnet.infura.io/v3/${n6}`, "0x5": `https://goerli.infura.io/v3/${n6}`, "0xaa36a7": `https://sepolia.infura.io/v3/${n6}`, "0xe708": `https://linea-mainnet.infura.io/v3/${n6}`, "0xe704": `https://linea-goerli.infura.io/v3/${n6}`, "0x89": `https://polygon-mainnet.infura.io/v3/${n6}`, "0x13881": `https://polygon-mumbai.infura.io/v3/${n6}`, "0x45": `https://optimism-mainnet.infura.io/v3/${n6}`, "0x1a4": `https://optimism-goerli.infura.io/v3/${n6}`, "0xa4b1": `https://arbitrum-mainnet.infura.io/v3/${n6}`, "0x66eed": `https://arbitrum-goerli.infura.io/v3/${n6}`, "0x2a15c308d": `https://palm-mainnet.infura.io/v3/${n6}`, "0x2a15c3083": `https://palm-testnet.infura.io/v3/${n6}`, "0xa86a": `https://avalanche-mainnet.infura.io/v3/${n6}`, "0xa869": `https://avalanche-fuji.infura.io/v3/${n6}`, "0x4e454152": `https://aurora-mainnet.infura.io/v3/${n6}`, "0x4e454153": `https://aurora-testnet.infura.io/v3/${n6}`, "0x534e5f4d41494e": `https://starknet-mainnet.infura.io/v3/${n6}`, "0x534e5f474f45524c49": `https://starknet-goerli.infura.io/v3/${n6}`, "0x534e5f474f45524c4932": `https://starknet-goerli2.infura.io/v3/${n6}`, "0xa4ec": `https://celo-mainnet.infura.io/v3/${n6}`, "0xaef3": `https://celo-alfajores.infura.io/v3/${n6}` };
  e9.options.readonlyRPCMap ? e9.options.readonlyRPCMap = Object.assign(Object.assign({}, e9.options.readonlyRPCMap), r2) : e9.options.readonlyRPCMap = r2;
});
var Dh = (e9) => c2(void 0, void 0, void 0, function* () {
  const { options: t3 } = e9, { readonlyRPCMap: n6 } = t3;
  if (n6) try {
    Iu("[MetaMaskSDK: setupReadOnlyRPCProviders()] Setting up Readonly RPC Providers", n6), e9.setReadOnlyRPCCalls(true);
  } catch (e10) {
    throw new Error("Invalid Infura Settings");
  }
});
function $h(e9, t3, n6, r2) {
  return new (n6 || (n6 = Promise))(function(t4, i4) {
    function o3(e10) {
      try {
        a(r2.next(e10));
      } catch (e11) {
        i4(e11);
      }
    }
    function s2(e10) {
      try {
        a(r2.throw(e10));
      } catch (e11) {
        i4(e11);
      }
    }
    function a(e10) {
      var r3;
      e10.done ? t4(e10.value) : (r3 = e10.value, r3 instanceof n6 ? r3 : new n6(function(e11) {
        e11(r3);
      })).then(o3, s2);
    }
    a((r2 = r2.apply(e9, [])).next());
  });
}
function Bh(e9, t3) {
  var n6, r2, i4, o3, s2 = { label: 0, sent: function() {
    if (1 & i4[0]) throw i4[1];
    return i4[1];
  }, trys: [], ops: [] };
  return o3 = { next: a(0), throw: a(1), return: a(2) }, "function" == typeof Symbol && (o3[Symbol.iterator] = function() {
    return this;
  }), o3;
  function a(o4) {
    return function(a2) {
      return function(o5) {
        if (n6) throw new TypeError("Generator is already executing.");
        for (; s2; ) try {
          if (n6 = 1, r2 && (i4 = 2 & o5[0] ? r2.return : o5[0] ? r2.throw || ((i4 = r2.return) && i4.call(r2), 0) : r2.next) && !(i4 = i4.call(r2, o5[1])).done) return i4;
          switch (r2 = 0, i4 && (o5 = [2 & o5[0], i4.value]), o5[0]) {
            case 0:
            case 1:
              i4 = o5;
              break;
            case 4:
              return s2.label++, { value: o5[1], done: false };
            case 5:
              s2.label++, r2 = o5[1], o5 = [0];
              continue;
            case 7:
              o5 = s2.ops.pop(), s2.trys.pop();
              continue;
            default:
              if (!(i4 = s2.trys, (i4 = i4.length > 0 && i4[i4.length - 1]) || 6 !== o5[0] && 2 !== o5[0])) {
                s2 = 0;
                continue;
              }
              if (3 === o5[0] && (!i4 || o5[1] > i4[0] && o5[1] < i4[3])) {
                s2.label = o5[1];
                break;
              }
              if (6 === o5[0] && s2.label < i4[1]) {
                s2.label = i4[1], i4 = o5;
                break;
              }
              if (i4 && s2.label < i4[2]) {
                s2.label = i4[2], s2.ops.push(o5);
                break;
              }
              i4[2] && s2.ops.pop(), s2.trys.pop();
              continue;
          }
          o5 = t3.call(e9, s2);
        } catch (e10) {
          o5 = [6, e10], r2 = 0;
        } finally {
          n6 = i4 = 0;
        }
        if (5 & o5[0]) throw o5[1];
        return { value: o5[0] ? o5[1] : void 0, done: true };
      }([o4, a2]);
    };
  }
}
var Kh = "INSTALLED";
var jh = "NOT_INSTALLED";
var Uh = "REGISTERED";
var Hh = "REGISTERING";
var Fh = "RELOADING";
var zh = { CHROME: "https://chrome.google.com/webstore/detail/metamask/nkbihfbeogaeaoehlefnkodbefgpgknn", FIREFOX: "https://addons.mozilla.org/firefox/addon/ether-metamask/", DEFAULT: "https://metamask.io" };
var qh = "REGISTRATION_IN_PROGRESS";
var Wh = "FORWARDER_ID";
var Vh = function() {
  function e9(t3) {
    var n6 = void 0 === t3 ? {} : t3, r2 = n6.forwarderOrigin, i4 = void 0 === r2 ? "https://fwd.metamask.io" : r2, o3 = n6.forwarderMode, s2 = void 0 === o3 ? e9.FORWARDER_MODE.INJECT : o3;
    this.forwarderOrigin = i4, this.forwarderMode = s2, this.state = e9.isMetaMaskInstalled() ? Kh : jh;
    var a = e9._detectBrowser();
    this.downloadUrl = a ? zh[a] : zh.DEFAULT, this._onMessage = this._onMessage.bind(this), this._onMessageFromForwarder = this._onMessageFromForwarder.bind(this), this._openForwarder = this._openForwarder.bind(this), this._openDownloadPage = this._openDownloadPage.bind(this), this.startOnboarding = this.startOnboarding.bind(this), this.stopOnboarding = this.stopOnboarding.bind(this), window.addEventListener("message", this._onMessage), s2 === e9.FORWARDER_MODE.INJECT && "true" === sessionStorage.getItem(qh) && e9._injectForwarder(this.forwarderOrigin);
  }
  return e9.prototype._onMessage = function(e10) {
    if (e10.origin === this.forwarderOrigin) return "metamask:reload" === e10.data.type ? this._onMessageFromForwarder(e10) : void console.debug("Unknown message from '" + e10.origin + "' with data " + JSON.stringify(e10.data));
  }, e9.prototype._onMessageUnknownStateError = function(e10) {
    throw new Error("Unknown state: '" + e10 + "'");
  }, e9.prototype._onMessageFromForwarder = function(t3) {
    return $h(this, 0, void 0, function() {
      return Bh(this, function(n6) {
        switch (n6.label) {
          case 0:
            switch (this.state) {
              case Fh:
                return [3, 1];
              case jh:
                return [3, 2];
              case Kh:
                return [3, 3];
              case Hh:
                return [3, 5];
              case Uh:
                return [3, 6];
            }
            return [3, 7];
          case 1:
            return console.debug("Ignoring message while reloading"), [3, 8];
          case 2:
            return console.debug("Reloading now to register with MetaMask"), this.state = Fh, location.reload(), [3, 8];
          case 3:
            return console.debug("Registering with MetaMask"), this.state = Hh, [4, e9._register()];
          case 4:
            return n6.sent(), this.state = Uh, t3.source.postMessage({ type: "metamask:registrationCompleted" }, t3.origin), this.stopOnboarding(), [3, 8];
          case 5:
            return console.debug("Already registering - ignoring reload message"), [3, 8];
          case 6:
            return console.debug("Already registered - ignoring reload message"), [3, 8];
          case 7:
            this._onMessageUnknownStateError(this.state), n6.label = 8;
          case 8:
            return [2];
        }
      });
    });
  }, e9.prototype.startOnboarding = function() {
    sessionStorage.setItem(qh, "true"), this._openDownloadPage(), this._openForwarder();
  }, e9.prototype.stopOnboarding = function() {
    "true" === sessionStorage.getItem(qh) && (this.forwarderMode === e9.FORWARDER_MODE.INJECT && (console.debug("Removing forwarder"), e9._removeForwarder()), sessionStorage.setItem(qh, "false"));
  }, e9.prototype._openForwarder = function() {
    this.forwarderMode === e9.FORWARDER_MODE.OPEN_TAB ? window.open(this.forwarderOrigin, "_blank") : e9._injectForwarder(this.forwarderOrigin);
  }, e9.prototype._openDownloadPage = function() {
    window.open(this.downloadUrl, "_blank");
  }, e9.isMetaMaskInstalled = function() {
    return Boolean(window.ethereum && window.ethereum.isMetaMask);
  }, e9._register = function() {
    return window.ethereum.request({ method: "wallet_registerOnboarding" });
  }, e9._injectForwarder = function(e10) {
    var t3 = document.body, n6 = document.createElement("iframe");
    n6.setAttribute("height", "0"), n6.setAttribute("width", "0"), n6.setAttribute("style", "display: none;"), n6.setAttribute("src", e10), n6.setAttribute("id", Wh), t3.insertBefore(n6, t3.children[0]);
  }, e9._removeForwarder = function() {
    var e10;
    null === (e10 = document.getElementById(Wh)) || void 0 === e10 || e10.remove();
  }, e9._detectBrowser = function() {
    var e10 = Wu.parse(window.navigator.userAgent);
    return "Firefox" === e10.browser.name ? "FIREFOX" : ["Chrome", "Chromium"].includes(e10.browser.name || "") ? "CHROME" : null;
  }, e9.FORWARDER_MODE = { INJECT: "INJECT", OPEN_TAB: "OPEN_TAB" }, e9;
}();
function Gh(e9, { wait: t3 = false }) {
  return c2(this, void 0, void 0, function* () {
    return Iu(`[MetamaskInstaller: startInstaller()] wait=${t3}`), t3 && (yield _h(1e3)), yield e9.checkInstallation();
  });
}
var Yh = class {
  constructor({ remote: e9, preferDesktop: t3, platformManager: n6, debug: r2 = false }) {
    this.state = { isInstalling: false, hasInstalled: false, resendRequest: null, preferDesktop: false, platformManager: null, remote: null, debug: false, connectWith: void 0 }, this.state.remote = e9, this.state.preferDesktop = t3, this.state.platformManager = n6, this.state.debug = r2;
  }
  startDesktopOnboarding() {
    return function() {
      return c2(this, void 0, void 0, function* () {
        Iu("[MetamaskInstaller: startDesktopOnboarding() starting desktop onboarding"), window.ethereum && (window.ethereum = void 0), new Vh().startOnboarding();
      });
    }();
  }
  redirectToProperInstall() {
    return c2(this, void 0, void 0, function* () {
      return function(e9) {
        var t3, n6;
        return c2(this, void 0, void 0, function* () {
          const { state: r2 } = e9, i4 = null === (t3 = r2.platformManager) || void 0 === t3 ? void 0 : t3.getPlatformType();
          if (Iu(`[MetamaskInstaller: redirectToProperInstall()] platform=${i4}`), i4 === Uo.MetaMaskMobileWebview) return false;
          r2.isInstalling = true;
          try {
            yield null === (n6 = r2.remote) || void 0 === n6 ? void 0 : n6.startConnection({ connectWith: r2.connectWith }), r2.isInstalling = false, r2.hasInstalled = true;
          } catch (e10) {
            throw r2.isInstalling = false, e10;
          }
          return true;
        });
      }(this);
    });
  }
  checkInstallation() {
    return c2(this, void 0, void 0, function* () {
      return function(e9) {
        var t3;
        return c2(this, void 0, void 0, function* () {
          const { state: n6 } = e9, r2 = null === (t3 = n6.platformManager) || void 0 === t3 ? void 0 : t3.isMetaMaskInstalled();
          return Iu(`[MetamaskInstaller: checkInstallation()] isInstalled=${r2}`), !!r2 || (yield e9.redirectToProperInstall());
        });
      }(this);
    });
  }
  start({ wait: e9 = false, connectWith: t3 }) {
    return c2(this, void 0, void 0, function* () {
      this.state.connectWith = t3, Iu(`[MetaMaskInstaller: start()] wait=${e9}`, t3), yield Gh(this, { wait: e9 });
    });
  }
};
var Zh = class {
  constructor({ debug: e9, sdkVersion: t3 }) {
    this.containers = { install: void 0, pending: void 0, select: void 0 }, this.defined = { install: false, pending: false, select: false }, this.debug = null != e9 && e9, this.sdkVersion = t3;
  }
  loadComponent(e9) {
    return c2(this, void 0, void 0, function* () {
      if (!this.defined[e9]) {
        this.defined[e9] = true;
        try {
          const e10 = yield Promise.resolve().then(function() {
            return Lp;
          });
          console.log("loader", e10), e10.defineCustomElements();
        } catch (t3) {
          console.error(`Failed to load ${e9} modal:`, t3);
        }
      }
    });
  }
  renderInstallModal(e9) {
    var t3;
    return c2(this, void 0, void 0, function* () {
      this.debug && console.debug("ModalLoader: renderInstallModal", e9), this.containers.install = e9.parentElement, yield this.loadComponent("install");
      const n6 = document.createElement("mm-install-modal");
      n6.link = e9.link, n6.preferDesktop = e9.preferDesktop, n6.sdkVersion = null !== (t3 = e9.sdkVersion) && void 0 !== t3 ? t3 : this.sdkVersion, n6.addEventListener("close", ({ detail: { shouldTerminate: t4 } }) => e9.onClose(t4)), n6.addEventListener("startDesktopOnboarding", e9.metaMaskInstaller.startDesktopOnboarding), n6.addEventListener("trackAnalytics", (t4) => {
        var n7;
        return null === (n7 = e9.onAnalyticsEvent) || void 0 === n7 ? void 0 : n7.call(e9, t4.detail);
      }), e9.parentElement.appendChild(n6);
    });
  }
  renderSelectModal(e9) {
    var t3;
    return c2(this, void 0, void 0, function* () {
      this.containers.select = e9.parentElement, yield this.loadComponent("select");
      const n6 = document.createElement("mm-select-modal");
      n6.link = e9.link, n6.sdkVersion = null !== (t3 = e9.sdkVersion) && void 0 !== t3 ? t3 : this.sdkVersion, n6.preferDesktop = e9.preferDesktop, n6.addEventListener("close", ({ detail: { shouldTerminate: t4 } }) => e9.onClose(t4)), n6.addEventListener("connectWithExtension", e9.connectWithExtension), e9.parentElement.appendChild(n6), setTimeout(() => this.updateQRCode(e9.link), 100);
    });
  }
  renderPendingModal(e9) {
    var t3;
    return c2(this, void 0, void 0, function* () {
      this.containers.pending = e9.parentElement, yield this.loadComponent("pending");
      const n6 = document.createElement("mm-pending-modal");
      n6.sdkVersion = null !== (t3 = e9.sdkVersion) && void 0 !== t3 ? t3 : this.sdkVersion, n6.displayOTP = e9.displayOTP, n6.addEventListener("close", e9.onClose), n6.addEventListener("updateOTPValue", ({ detail: { otpValue: t4 } }) => e9.updateOTPValue(t4)), e9.onDisconnect && n6.addEventListener("disconnect", e9.onDisconnect), e9.parentElement.appendChild(n6);
    });
  }
  updateOTPValue(e9) {
    const t3 = () => {
      var t4;
      const n6 = null === (t4 = this.containers.pending) || void 0 === t4 ? void 0 : t4.querySelector("mm-pending-modal");
      return !!n6 && (n6.otpCode = e9, true);
    };
    setTimeout(() => {
      t3();
    }, 800);
  }
  updateQRCode(e9) {
    var t3, n6;
    const r2 = null === (t3 = this.containers.install) || void 0 === t3 ? void 0 : t3.querySelector("mm-install-modal");
    if (r2) r2.link = e9;
    else {
      const t4 = null === (n6 = this.containers.select) || void 0 === n6 ? void 0 : n6.querySelector("mm-select-modal");
      t4 && (t4.link = e9);
    }
  }
  unmount() {
    Object.entries(this.containers).forEach(([e9, t3]) => {
      var n6;
      null === (n6 = null == t3 ? void 0 : t3.parentNode) || void 0 === n6 || n6.removeChild(t3), this.containers[e9] = void 0;
    });
  }
};
var Jh = ({ link: e9, debug: t3, installer: n6, terminate: r2, connectWithExtension: i4, preferDesktop: o3, onAnalyticsEvent: s2 }) => {
  let a = null, c3 = null;
  Iu("[UI: InstallModal-web: sdkWebInstallModal()] ################## Installing Modal #################"), Iu(`[UI: InstallModal-web: sdkWebInstallModal()] link=${e9}`), Iu(`[UI: InstallModal-web: sdkWebInstallModal()] npx uri-scheme open "${e9}" --ios`), Iu(`[UI: InstallModal-web: sdkWebInstallModal()] npx uri-scheme open "${e9}" --android`), Iu(`[UI: InstallModal-web: sdkWebInstallModal()] adb shell am start -a android.intent.action.VIEW -d "${e9}"`);
  const l5 = (e10) => {
    var t4;
    Iu("[UI: InstallModal-web: sdkWebInstallModal()] installModal-web unmounting install modal -- shouldTerminate:", e10, c3), (null == c3 ? void 0 : c3.parentNode) && (null === (t4 = c3.parentNode) || void 0 === t4 || t4.removeChild(c3)), c3 = null, a = null, true === e10 && (null == r2 || r2());
  };
  return { mount: (r3) => {
    if (Iu("[UI: InstallModal-web: sdkWebInstallModal()] installModal-web mounting install modal", c3), c3) return c3.style.display = "block", void (null == a || a.updateQRCode(r3));
    a = new Zh({ debug: t3, sdkVersion: Xu.version }), c3 = document.createElement("div"), document.body.appendChild(c3), window.extension ? a.renderSelectModal({ parentElement: c3, connectWithExtension: () => {
      l5(), null == i4 || i4();
    }, onClose: l5, link: e9, preferDesktop: null != o3 && o3 }).catch((e10) => {
      console.error(e10);
    }) : a.renderInstallModal({ parentElement: c3, preferDesktop: null != o3 && o3, link: e9, metaMaskInstaller: n6, onClose: l5, onAnalyticsEvent: s2 }).catch((e10) => {
      console.error("[UI: InstallModal-web: sdkWebInstallModal()]", e10);
    });
  }, unmount: l5 };
};
var Qh = ({ onDisconnect: e9, debug: t3 }) => {
  let n6 = null, r2 = null;
  const i4 = () => {
    Iu("[UI: pendingModal-web: sdkWebPendingModal()] pendingModal-web unmount", n6), (null == n6 ? void 0 : n6.parentNode) && n6.parentNode.removeChild(n6), n6 = null, r2 = null;
  }, o3 = (e10) => {
    Iu("[UI: pendingModal-web: sdkWebPendingModal()] pendingModal-web updateOTPValue", e10), r2 && r2.updateOTPValue(e10);
  }, s2 = ({ displayOTP: s3 } = { displayOTP: true }) => {
    Iu("[UI: pendingModal-web: sdkWebPendingModal()] pendingModal-web mount", n6), n6 ? n6.style.display = "block" : (r2 = new Zh({ debug: t3, sdkVersion: Xu.version }), n6 = document.createElement("div"), document.body.appendChild(n6), r2.renderPendingModal({ parentElement: n6, onClose: i4, onDisconnect: e9, updateOTPValue: o3, displayOTP: s3 }).catch((e10) => {
      console.error("[UI: pendingModal-web: sdkWebPendingModal()]", e10);
    }));
  };
  return s2(), { mount: s2, unmount: i4, updateOTPValue: o3 };
};
function Xh(e9, t3) {
  var n6, r2, i4, o3;
  e9.connector || (Iu("[RemoteConnection: initializeConnector()] initialize connector"), e9.connector = new ts({ anonId: t3.anonId, platformType: t3.platformManager.getPlatformType(), communicationLayerPreference: t3.communicationLayerPreference, transports: t3.transports, dappMetadata: Object.assign(Object.assign({}, t3.dappMetadata), { source: t3._source }), analytics: t3.enableAnalytics, communicationServerUrl: t3.communicationServerUrl, sdkVersion: Xu.version, context: "dapp", ecies: t3.ecies, storage: t3.storage, logging: t3.logging }), t3.timer && (Iu("[RemoteConnection: initializeConnector()] reset background timer", t3.timer), null === (r2 = null === (n6 = t3.timer) || void 0 === n6 ? void 0 : n6.stopBackgroundTimer) || void 0 === r2 || r2.call(n6), null === (o3 = null === (i4 = t3.timer) || void 0 === i4 ? void 0 : i4.runBackgroundTimer) || void 0 === o3 || o3.call(i4, () => false, 1e4)));
}
function ef(e9) {
  e9.listeners.forEach(({ event: t3, handler: n6 }) => {
    var r2;
    null === (r2 = e9.connector) || void 0 === r2 || r2.off(t3, n6);
  }), e9.listeners = [];
}
function tf(e9, t3, r2) {
  return c2(this, void 0, void 0, function* () {
    const i4 = setTimeout(() => {
      import_sdk_analytics.analytics.track("sdk_connection_failed", { transport_type: "websocket" });
    }, 6e4);
    return new Promise((n6, o3) => {
      if (!e9.connector) return void o3(new Error("No connector available"));
      Iu("[RemoteConnection: connectWithModalInstaller()]", { state: e9, options: t3, linkParams: r2 });
      const s2 = `${e9.useDeeplink ? nh : th}?${r2}`;
      !function(e10, t4, n7) {
        var r3, i5, o4, s3;
        e10.installModal = null === (i5 = (r3 = t4.modals).install) || void 0 === i5 ? void 0 : i5.call(r3, { link: n7, preferDesktop: e10.preferDesktop, installer: t4.getMetaMaskInstaller(), terminate: () => {
          Iu("[RemoteConnection: showInstallModal() => terminate()] terminate connection"), t4.sdk.terminate().catch((e11) => {
            console.warn("[MMSDK] failed to terminate connection", e11);
          });
        }, debug: e10.developerMode, connectWithExtension: () => {
          var e11;
          return null === (e11 = t4.connectWithExtensionProvider) || void 0 === e11 || e11.call(t4), false;
        }, onAnalyticsEvent: ({ event: n8, params: r4 }) => {
          var i6, o5, s4;
          const a = Object.assign(Object.assign({}, r4), { sdkVersion: t4.sdk.getVersion(), dappId: null === (i6 = t4.dappMetadata) || void 0 === i6 ? void 0 : i6.name, source: t4._source, url: null === (o5 = t4.dappMetadata) || void 0 === o5 ? void 0 : o5.url });
          null === (s4 = e10.analytics) || void 0 === s4 || s4.send({ event: n8, params: a });
        } }), null === (s3 = null === (o4 = e10.installModal) || void 0 === o4 ? void 0 : o4.mount) || void 0 === s3 || s3.call(o4, n7);
      }(e9, t3, s2), t3.sdk.once(So.PROVIDER_UPDATE, (e10) => c2(this, void 0, void 0, function* () {
        if (Iu("[RemoteConnection: connectWithModalInstaller()] once provider_update -- resolving startConnection promise"), e10 === gh.TERMINATE) {
          const e11 = { code: 4001, message: "User rejected the request." };
          return clearTimeout(i4), void o3(e11);
        }
        o3(e10);
      })), e9.connector.once(So.AUTHORIZED, () => {
        clearTimeout(i4), n6();
      }), e9.connector.once(So.REJECTED, () => {
        clearTimeout(i4), o3(So.REJECTED);
      }), e9.connector.once(So.CLIENTS_READY, () => c2(this, void 0, void 0, function* () {
        Iu("[RemoteConnection: connectWithModalInstaller()] once clients_ready -- resolving startConnection promise"), clearTimeout(i4), n6();
      }));
    });
  });
}
function nf(e9, t3) {
  function n6(t4, n7) {
    var r2;
    null === (r2 = e9.connector) || void 0 === r2 || r2.on(t4, n7), e9.listeners.push({ event: t4, handler: n7 });
  }
  e9.connector && (ef(e9), n6(So.WALLET_INIT, ({ accounts: e10, chainId: t4 }) => c2(this, void 0, void 0, function* () {
    Iu(`[RemoteConnection: setupListeners() => EventType.WALLET_INIT] 'wallet_init' accounts=${e10} chainId=${t4}`);
    const n7 = Gu.getProvider();
    n7._setConnected();
    const r2 = { accounts: e10, chainId: t4, isUnlocked: false };
    n7._initializeState(r2), n7.emit("chainChanged", t4), n7.emit("accountsChanged", e10);
  })), n6(So.AUTHORIZED, () => c2(this, void 0, void 0, function* () {
    var t4, n7, r2, i4;
    try {
      Iu("[RemoteConnection: setupListeners() => EventType.AUTHORIZED] 'authorized' closing modals", e9.pendingModal, e9.installModal);
      const o3 = Gu.getProvider();
      o3._setConnected(), null === (n7 = null === (t4 = e9.pendingModal) || void 0 === t4 ? void 0 : t4.unmount) || void 0 === n7 || n7.call(t4), null === (i4 = null === (r2 = e9.installModal) || void 0 === r2 ? void 0 : r2.unmount) || void 0 === i4 || i4.call(r2, false), e9.otpAnswer = void 0, e9.authorized = true, Iu("[RemoteConnection: setupListeners() => EventType.AUTHORIZED] 'authorized' provider.state", o3.getState()), yield o3.forceInitializeState();
    } catch (e10) {
    }
  })), n6(So.TERMINATE, () => {
    var t4, n7, r2, i4, o3;
    null === (n7 = null === (t4 = e9.pendingModal) || void 0 === t4 ? void 0 : t4.unmount) || void 0 === n7 || n7.call(t4), null === (i4 = null === (r2 = e9.installModal) || void 0 === r2 ? void 0 : r2.unmount) || void 0 === i4 || i4.call(r2, true), e9.pendingModal = void 0, e9.installModal = void 0, e9.otpAnswer = void 0, null === (o3 = e9.connector) || void 0 === o3 || o3.disconnect({ terminate: true }), e9.authorized = false;
    Gu.getProvider().handleDisconnect({ terminate: true }), ef(e9), Iu("[RemoteConnection: setupListeners()] All listeners cleaned up");
  }));
}
function rf(e9, t3, { initialCheck: r2, connectWith: i4 } = {}) {
  var o3, s2, a, l5, d3, u2, h3, f4, p4, g2, m4, y2, v2, b3, w5, E4, S5, _2, C4;
  return c2(this, void 0, void 0, function* () {
    try {
      if (Xh(e9, t3), !e9.connector) throw new Error("no connector defined");
      nf(e9);
      const k3 = Gu.getProvider();
      e9.authorized = false, k3.emit("connecting");
      const A3 = yield null === (o3 = e9.connector) || void 0 === o3 ? void 0 : o3.originatorSessionConnect();
      Iu(`[RemoteConnection: startConnection()] after originatorSessionConnect initialCheck=${r2}`, A3);
      let x3 = null !== (s2 = null == A3 ? void 0 : A3.channelId) && void 0 !== s2 ? s2 : "", M4 = null !== (l5 = null === (a = e9.connector.getKeyInfo()) || void 0 === a ? void 0 : a.ecies.public) && void 0 !== l5 ? l5 : "", I2 = null !== (u2 = null === (d3 = e9.connector.getKeyInfo()) || void 0 === d3 ? void 0 : d3.ecies.private) && void 0 !== u2 ? u2 : "";
      if (r2 && !A3) return Promise.resolve();
      if (!A3 && !r2) {
        const t4 = yield e9.connector.generateChannelIdConnect();
        x3 = null !== (h3 = t4.channelId) && void 0 !== h3 ? h3 : "", M4 = null !== (f4 = t4.pubKey) && void 0 !== f4 ? f4 : "", I2 = null !== (p4 = t4.privKey) && void 0 !== p4 ? p4 : "";
        const n6 = Date.now();
        null === (g2 = e9.connector.state.storageManager) || void 0 === g2 || g2.persistChannelConfig({ channelId: x3, localKey: I2, lastActive: n6, validUntil: n6 + go });
      }
      if (r2 && (null == A3 ? void 0 : A3.channelId)) return (null === (m4 = e9.connector) || void 0 === m4 ? void 0 : m4.isConnected()) || (Iu(`[RemoteConnection: startConnection()] reconnecting to channel initialCheck=${r2}`, A3), yield null === (y2 = e9.connector) || void 0 === y2 ? void 0 : y2.connectToChannel({ channelId: x3 })), Promise.resolve();
      A3 && !(null === (v2 = e9.connector) || void 0 === v2 ? void 0 : v2.isConnected()) && (Iu("[RemoteConnection: startConnection()] reconnecting to channel", A3), yield null === (b3 = e9.connector) || void 0 === b3 ? void 0 : b3.connectToChannel({ channelId: x3 }));
      const T3 = (null === (w5 = e9.platformManager) || void 0 === w5 ? void 0 : w5.isSecure()) ? "" : "&t=q", R3 = Xu.version, { iconUrl: P5, name: O4, url: N3, scheme: L5 } = t3.dappMetadata || {}, D3 = null === (E4 = e9.platformManager) || void 0 === E4 ? void 0 : E4.getPlatformType();
      let $2 = "N/A";
      "undefined" != typeof window && window.location && window.location.hostname ? $2 = window.location.hostname : void 0 !== O4 ? $2 = O4 : void 0 !== N3 && ($2 = N3);
      const B3 = { url: null != N3 ? N3 : "", title: null != O4 ? O4 : "", icon: P5, scheme: null != L5 ? L5 : "", apiVersion: R3, dappId: $2 || N3 || "N/A", anonId: t3.anonId, platform: null != D3 ? D3 : "", source: null !== (S5 = t3._source) && void 0 !== S5 ? S5 : "" }, K4 = bh(JSON.stringify(B3));
      let j4 = `channelId=${x3}&v=2&comm=${null !== (_2 = e9.communicationLayerPreference) && void 0 !== _2 ? _2 : ""}&pubkey=${M4}${T3}&originatorInfo=${K4}`;
      if (i4) {
        j4 += `&rpc=${bh(JSON.stringify(i4))}`;
        const t4 = e9.connector.getRPCMethodTracker();
        t4 && (t4[`${i4.id}`] = Object.assign(Object.assign({}, i4), { id: `${i4.id}`, timestamp: Date.now() }));
      }
      const U5 = encodeURI(j4), H3 = `${e9.useDeeplink ? nh : th}?${j4}`;
      if (e9.qrcodeLink = H3, e9.developerMode && Iu(`[RemoteConnection: startConnection()] qrcodeLink=${U5}`), k3.emit("display_uri", H3), import_sdk_analytics.analytics.track("sdk_connection_initiated", { transport_type: "websocket" }), null === (C4 = e9.platformManager) || void 0 === C4 ? void 0 : C4.isSecure()) {
        const t4 = setTimeout(() => {
          import_sdk_analytics.analytics.track("sdk_connection_failed", { transport_type: "websocket" });
        }, 6e4);
        return yield function(e10, t5) {
          var n6, r3;
          return c2(this, void 0, void 0, function* () {
            const i5 = `${th}?${t5}`, o4 = `${nh}?${t5}`;
            null === (r3 = null === (n6 = e10.platformManager) || void 0 === n6 ? void 0 : n6.openDeeplink) || void 0 === r3 || r3.call(n6, i5, o4, "_self");
          });
        }(e9, U5), new Promise((n6, r3) => {
          var i5, o4, s3;
          if (null === (i5 = e9.connector) || void 0 === i5 ? void 0 : i5.isAuthorized()) return clearTimeout(t4), void n6();
          null === (o4 = e9.connector) || void 0 === o4 || o4.once(So.AUTHORIZED, () => {
            clearTimeout(t4), n6();
          }), null === (s3 = e9.connector) || void 0 === s3 || s3.once(So.REJECTED, () => {
            clearTimeout(t4), r3(So.REJECTED);
          });
        });
      }
      return tf(e9, t3, U5);
    } catch (e10) {
      throw console.error("[startConnection] error", e10), e10;
    }
  });
}
var of = class {
  constructor(e9) {
    var t3, n6, r2;
    this.state = { connector: void 0, qrcodeLink: void 0, analytics: void 0, developerMode: false, authorized: false, reconnection: false, preferDesktop: false, deeplinkProtocol: false, listeners: [], communicationLayerPreference: void 0, platformManager: void 0, pendingModal: void 0, installModal: void 0, otpAnswer: void 0 }, this.options = e9;
    const i4 = true === (null === (t3 = e9.logging) || void 0 === t3 ? void 0 : t3.developerMode) || true === (null === (n6 = e9.logging) || void 0 === n6 ? void 0 : n6.sdk);
    this.state.developerMode = i4, this.state.analytics = e9.analytics, this.state.preferDesktop = null !== (r2 = e9.preferDesktop) && void 0 !== r2 && r2, this.state.useDeeplink = e9.sdk.options.useDeeplink, this.state.communicationLayerPreference = e9.communicationLayerPreference, this.state.platformManager = e9.platformManager, e9.modals.install || (e9.modals.install = Jh), e9.modals.otp || (e9.modals.otp = Qh);
  }
  startConnection(e9) {
    return c2(this, void 0, void 0, function* () {
      return rf(this.state, this.options, e9);
    });
  }
  initRemoteCommunication({ sdkInstance: e9 }) {
    var t3, n6, r2;
    return c2(this, void 0, void 0, function* () {
      const i4 = yield null === (n6 = null === (t3 = e9.options.storage) || void 0 === t3 ? void 0 : t3.storageManager) || void 0 === n6 ? void 0 : n6.getPersistedChannelConfig();
      if (!this.options.ecies) {
        const e10 = { privateKey: null == i4 ? void 0 : i4.localKey };
        this.options.ecies = e10;
      }
      Xh(this.state, this.options), yield null === (r2 = this.getConnector()) || void 0 === r2 ? void 0 : r2.initFromDappStorage(), nf(this.state, this.options);
    });
  }
  showActiveModal() {
    return function(e9) {
      var t3, n6, r2, i4;
      e9.authorized ? Iu("[RemoteConnection: showActiveModal()] already authorized") : e9.pendingModal ? null === (n6 = (t3 = e9.pendingModal).mount) || void 0 === n6 || n6.call(t3) : e9.installModal && (null === (i4 = (r2 = e9.installModal).mount) || void 0 === i4 || i4.call(r2, e9.qrcodeLink || ""));
    }(this.state);
  }
  closeModal() {
    var e9, t3, n6, r2;
    null === (t3 = null === (e9 = this.state.pendingModal) || void 0 === e9 ? void 0 : e9.unmount) || void 0 === t3 || t3.call(e9), null === (r2 = null === (n6 = this.state.installModal) || void 0 === n6 ? void 0 : n6.unmount) || void 0 === r2 || r2.call(n6, false);
  }
  getUniversalLink() {
    if (!this.state.qrcodeLink) throw new Error("connection not started. run startConnection() first.");
    return this.state.qrcodeLink;
  }
  getChannelConfig() {
    var e9;
    return null === (e9 = this.state.connector) || void 0 === e9 ? void 0 : e9.getChannelConfig();
  }
  getKeyInfo() {
    var e9;
    return null === (e9 = this.state.connector) || void 0 === e9 ? void 0 : e9.getKeyInfo();
  }
  getConnector() {
    if (!this.state.connector) throw new Error("invalid remote connector");
    return this.state.connector;
  }
  getPlatformManager() {
    if (!this.state.platformManager) throw new Error("PlatformManager not available");
    return this.state.platformManager;
  }
  isConnected() {
    var e9;
    return (null === (e9 = this.state.connector) || void 0 === e9 ? void 0 : e9.isReady()) || false;
  }
  isAuthorized() {
    var e9;
    return (null === (e9 = this.state.connector) || void 0 === e9 ? void 0 : e9.isAuthorized()) || false;
  }
  isPaused() {
    var e9;
    return null === (e9 = this.state.connector) || void 0 === e9 ? void 0 : e9.isPaused();
  }
  disconnect(e9) {
    var t3, n6, r2;
    Iu("[RemoteConnection: disconnect()]", e9), (null == e9 ? void 0 : e9.terminate) && (Gu.getProvider().handleDisconnect({ terminate: true }), null === (n6 = null === (t3 = this.state.pendingModal) || void 0 === t3 ? void 0 : t3.unmount) || void 0 === n6 || n6.call(t3), this.state.otpAnswer = void 0), null === (r2 = this.state.connector) || void 0 === r2 || r2.disconnect(e9), function(e10) {
      Iu("[RemoteConnection: cleanupConnector()] cleaning up connector"), e10.connector && (ef(e10), e10.connector.disconnect({ terminate: true }).catch((e11) => {
        Iu("[RemoteConnection: cleanupConnector()] error disconnecting connector", e11);
      }));
    }(this.state);
  }
};
function sf(e9) {
  var r2, i4, o3, s2, a, l5, d3, u2, h3, f4, p4;
  return c2(this, void 0, void 0, function* () {
    const { options: g2 } = e9;
    if (g2.logging = null !== (r2 = g2.logging) && void 0 !== r2 ? r2 : {}, g2.communicationLayerPreference = null !== (i4 = g2.communicationLayerPreference) && void 0 !== i4 ? i4 : jo.SOCKET, void 0 !== g2.enableDebug && (import_debug.default.enable("MM_SDK"), console.warn("enableDebug is removed. Please use enableAnalytics instead.")), g2.enableAnalytics = null === (o3 = g2.enableAnalytics) || void 0 === o3 || o3, g2.injectProvider = null === (s2 = g2.injectProvider) || void 0 === s2 || s2, g2.shouldShimWeb3 = null === (a = g2.shouldShimWeb3) || void 0 === a || a, g2.extensionOnly = null === (l5 = g2.extensionOnly) || void 0 === l5 || l5, g2.useDeeplink = null === (d3 = g2.useDeeplink) || void 0 === d3 || d3, g2.storage = null !== (u2 = g2.storage) && void 0 !== u2 ? u2 : { enabled: true }, g2.headless) {
      (0, import_debug.default)("[MetaMaskSDK: performSDKInitialization()] headless mode enabled");
      const e10 = () => {
      }, n6 = { install: () => ({ mount: e10, unmount: e10 }) }, r3 = { installer: e10 };
      g2.modals = n6, g2.ui = r3;
    }
    const m4 = true === (null === (h3 = g2.logging) || void 0 === h3 ? void 0 : h3.developerMode);
    e9.debug = (null === (f4 = g2.logging) || void 0 === f4 ? void 0 : f4.sdk) || m4, Iu("[MetaMaskSDK: performSDKInitialization()] options", e9.options);
    const y2 = Object.assign({}, g2.logging);
    m4 && (y2.sdk = true, y2.eciesLayer = true, y2.keyExchangeLayer = true, y2.remoteLayer = true, y2.serviceLayer = true, y2.plaintext = true), yield function(e10) {
      var t3;
      return c2(this, void 0, void 0, function* () {
        const { options: n6 } = e10;
        e10.platformManager = new Yu({ useDeepLink: null !== (t3 = n6.useDeeplink) && void 0 !== t3 && t3, preferredOpenLink: n6.openDeeplink, debug: e10.debug });
      });
    }(e9), yield function(e10) {
      var t3, n6, r3, i5, o4;
      return c2(this, void 0, void 0, function* () {
        const { options: s3 } = e10, a2 = null === (t3 = e10.platformManager) || void 0 === t3 ? void 0 : t3.getPlatformType();
        e10.analytics = new xh({ serverUrl: null !== (n6 = s3.communicationServerUrl) && void 0 !== n6 ? n6 : fo, enabled: s3.enableAnalytics, originatorInfo: { url: null !== (r3 = s3.dappMetadata.url) && void 0 !== r3 ? r3 : "", title: null !== (i5 = s3.dappMetadata.name) && void 0 !== i5 ? i5 : "", dappId: e10.getDappId(), platform: null != a2 ? a2 : "", source: null !== (o4 = s3._source) && void 0 !== o4 ? o4 : "", anonId: "" } });
      });
    }(e9), yield function(e10) {
      var t3, r3, i5;
      return c2(this, void 0, void 0, function* () {
        if (!e10.options.enableAnalytics) return;
        if (!(null === (t3 = e10.platformManager) || void 0 === t3 ? void 0 : t3.isBrowser()) && !(null === (r3 = e10.platformManager) || void 0 === r3 ? void 0 : r3.isReactNative())) return;
        const o4 = e10.getVersion(), s3 = e10.getDappId(), a2 = yield e10.getAnonId(), c3 = null === (i5 = e10.platformManager) || void 0 === i5 ? void 0 : i5.getPlatformType(), l6 = e10.options._source;
        import_sdk_analytics.analytics.setGlobalProperty("sdk_version", o4), import_sdk_analytics.analytics.setGlobalProperty("dapp_id", s3), import_sdk_analytics.analytics.setGlobalProperty("anon_id", a2), import_sdk_analytics.analytics.setGlobalProperty("platform", c3), import_sdk_analytics.analytics.setGlobalProperty("integration_type", l6), import_sdk_analytics.analytics.enable(), import_sdk_analytics.analytics.track("sdk_initialized", {});
      });
    }(e9), yield function(e10) {
      var t3;
      return c2(this, void 0, void 0, function* () {
        const { options: n6 } = e10;
        true !== (null === (t3 = n6.storage) || void 0 === t3 ? void 0 : t3.enabled) || n6.storage.storageManager || (n6.storage.storageManager = yield Zu(n6.storage));
      });
    }(e9), yield function(e10) {
      return c2(this, void 0, void 0, function* () {
        const { options: t3 } = e10, n6 = /^(http|https):\/\/[^\s]*$/;
        if (t3.dappMetadata) {
          t3.dappMetadata.iconUrl && !n6.test(t3.dappMetadata.iconUrl) && (console.warn("Invalid dappMetadata.iconUrl: URL must start with http:// or https://"), t3.dappMetadata.iconUrl = void 0), t3.dappMetadata.base64Icon && t3.dappMetadata.base64Icon.length > Ih && (console.warn("Invalid dappMetadata.base64Icon: Base64-encoded icon string length must be less than 163400 characters"), t3.dappMetadata.base64Icon = void 0), t3.dappMetadata.url && !n6.test(t3.dappMetadata.url) && console.warn("Invalid dappMetadata.url: URL must start with http:// or https://");
          const e11 = Mh();
          if (e11 && !t3.dappMetadata.iconUrl && !t3.dappMetadata.base64Icon) {
            const n7 = `${window.location.protocol}//${window.location.host}${e11}`;
            t3.dappMetadata.iconUrl = n7;
          }
        }
        e10.dappMetadata = t3.dappMetadata;
      });
    }(e9), yield Lh(e9), yield Dh(e9);
    const { metamaskBrowserExtension: v2, preferExtension: b3, shouldReturn: w5 } = yield function(e10) {
      var t3, n6, r3, i5;
      return c2(this, void 0, void 0, function* () {
        const { options: o4 } = e10;
        let s3, a2 = false, l6 = false;
        if ("undefined" != typeof window && window.ethereum && !(null === (t3 = e10.platformManager) || void 0 === t3 ? void 0 : t3.isMetaMaskMobileWebView())) {
          a2 = "extension" === localStorage.getItem(dh);
          try {
            s3 = yield Nh({ mustBeMetaMask: true, sdkInstance: e10 }), window.extension = s3, s3.on(fh.CHAIN_CHANGED, (t4) => {
              Iu(`[MetaMaskSDK: setupExtensionPreferences()] PROPAGATE chainChanged chainId=${t4}`), Boolean(e10.sdkProvider) && e10.getMobileProvider().emit(fh.CHAIN_CHANGED, t4);
            }), s3.on(fh.ACCOUNTS_CHANGED, (t4) => c2(this, void 0, void 0, function* () {
              var n7;
              Iu(`[MetaMaskSDK: setupExtensionPreferences()] PROPAGATE accountsChanged accounts=${t4}`);
              const r4 = Boolean(e10.sdkProvider), i6 = Boolean(e10.extensionActive);
              if (r4 && e10.getMobileProvider().emit(fh.ACCOUNTS_CHANGED, t4), i6 && 0 === (null == t4 ? void 0 : t4.length) && 0 === (yield null === (n7 = e10.getProvider()) || void 0 === n7 ? void 0 : n7.request({ method: oh.WALLET_GETPERMISSIONS, params: [] })).length) try {
                yield e10.terminate();
              } catch (e11) {
                Iu("[MetaMaskSDK: setupExtensionPreferences()] error terminating on permissions revoked", e11);
              }
            })), s3.on(fh.DISCONNECT, (t4) => {
              Iu(`[MetaMaskSDK: setupExtensionPreferences()] PROPAGATE disconnect error=${t4}`), Boolean(e10.sdkProvider) && e10.getMobileProvider().emit(fh.DISCONNECT, t4);
            }), s3.on(fh.CONNECT, (t4) => {
              Iu(`[MetaMaskSDK: setupExtensionPreferences()] PROPAGATE connect args=${t4}`), Boolean(e10.sdkProvider) && e10.getMobileProvider().emit(fh.CONNECT, t4);
            }), s3.on(fh.CONNECTED, (t4) => {
              Iu("[MetaMaskSDK: setupExtensionPreferences()] PROPAGATE connected", t4), Boolean(e10.sdkProvider) && e10.getMobileProvider().emit(fh.CONNECTED, t4);
            });
          } catch (e11) {
            window.extension = void 0;
          }
        } else (null === (n6 = e10.platformManager) || void 0 === n6 ? void 0 : n6.isMetaMaskMobileWebView()) && (null === (r3 = e10.analytics) || void 0 === r3 || r3.send({ event: Ao.SDK_USE_INAPP_BROWSER }), e10.activeProvider = Ph({ provider: window.ethereum, sdkInstance: e10 }), e10._initialized = true, l6 = true);
        return s3 && o4.extensionOnly && (Iu("[MetaMaskSDK: setupExtensionPreferences()] EXTENSION ONLY --- prevent sdk initialization"), null === (i5 = e10.analytics) || void 0 === i5 || i5.send({ event: Ao.SDK_USE_EXTENSION }), e10.activeProvider = s3, e10.extensionActive = true, e10.extension = s3, e10._initialized = true, l6 = true), { preferExtension: a2, shouldReturn: l6, metamaskBrowserExtension: s3 };
      });
    }(e9);
    if (w5) Iu("[MetaMaskSDK: performSDKInitialization()] shouldReturn=true --- prevent sdk initialization");
    else {
      yield function(e10, t3) {
        var n6, r3, i5, o4, s3;
        return c2(this, void 0, void 0, function* () {
          const { options: a2 } = e10, c3 = Object.assign({}, a2.logging);
          e10.remoteConnection = new of({ anonId: yield e10.getAnonId(), preferDesktop: null !== (n6 = a2.preferDesktop) && void 0 !== n6 && n6, communicationLayerPreference: null !== (r3 = a2.communicationLayerPreference) && void 0 !== r3 ? r3 : jo.SOCKET, analytics: e10.analytics, dappMetadata: a2.dappMetadata, _source: a2._source, enableAnalytics: null === (i5 = a2.enableAnalytics) || void 0 === i5 || i5, timer: a2.timer, sdk: e10, platformManager: e10.platformManager, transports: a2.transports, communicationServerUrl: a2.communicationServerUrl, storage: null !== (o4 = a2.storage) && void 0 !== o4 ? o4 : { enabled: true }, getMetaMaskInstaller: () => {
            if (!e10.installer) throw new Error("Invalid SDK status -- installer not initialized");
            return e10.installer;
          }, logging: c3, connectWithExtensionProvider: void 0 === t3 ? void 0 : () => vh(e10), modals: Object.assign(Object.assign({}, a2.modals), { onPendingModalDisconnect: e10.terminate.bind(e10) }) }), yield e10.remoteConnection.initRemoteCommunication({ sdkInstance: e10 }), e10.installer = new Yh({ remote: e10.remoteConnection, preferDesktop: null !== (s3 = a2.preferDesktop) && void 0 !== s3 && s3, platformManager: e10.platformManager, debug: e10.debug });
        });
      }(e9, v2), yield kh(e9), yield function(e10, t3) {
        var n6, r3;
        return c2(this, void 0, void 0, function* () {
          const { options: i5 } = e10;
          t3 ? (Iu("[MetaMaskSDK: handleAutoAndExtensionConnections()] preferExtension is detected -- connect with it."), null === (n6 = e10.analytics) || void 0 === n6 || n6.send({ event: Ao.SDK_EXTENSION_UTILIZED }), vh(e10).catch((e11) => {
            console.warn("Can't connect with MetaMask extension...", e11), localStorage.removeItem(dh);
          })) : i5.checkInstallationImmediately && ((null === (r3 = e10.platformManager) || void 0 === r3 ? void 0 : r3.isDesktopWeb()) ? (Iu("[MetaMaskSDK: handleAutoAndExtensionConnections()] checkInstallationImmediately"), e10.connect().catch((e11) => {
            Iu(`[MetaMaskSDK: handleAutoAndExtensionConnections()] checkInstallationImmediately --- IGNORED --- error on autoconnect _err=${e11}`);
          })) : console.warn("[handleAutoAndExtensionConnections()] checkInstallationImmediately --- IGNORED --- only for web desktop")), e10._initialized = true;
        });
      }(e9, b3);
      try {
        yield null === (p4 = e9.remoteConnection) || void 0 === p4 ? void 0 : p4.startConnection({ initialCheck: true });
      } catch (e10) {
        console.error("[MetaMaskSDK: setupRemoteConnectionAndInstaller()] Error while checking installation", e10);
      }
      e9.emit(Vu.ProviderUpdate, gh.INITIALIZED);
    }
  });
}
var af = class extends import_eventemitter2.default {
  constructor(e9 = { storage: { enabled: true }, injectProvider: true, forceInjectProvider: false, enableAnalytics: true, shouldShimWeb3: true, useDeeplink: true, extensionOnly: true, headless: false, dappMetadata: { name: "", url: "", iconUrl: "" }, _source: eh, i18nOptions: { enabled: false } }) {
    var n6, r2, i4;
    super(), this.extensionActive = false, this._initialized = false, this.sdkInitPromise = void 0, this.debug = false, this.readonlyRPCCalls = false, this.availableLanguages = ["en"], this.ANON_ID_STORAGE_KEY = "mm-sdk-anon-id", import_debug.default.disable();
    const o3 = true === (null === (n6 = e9.logging) || void 0 === n6 ? void 0 : n6.developerMode);
    if (((null === (r2 = e9.logging) || void 0 === r2 ? void 0 : r2.sdk) || o3) && import_debug.default.enable("MM_SDK"), Iu("[MetaMaskSDK: constructor()]: begin."), this.setMaxListeners(50), !(null === (i4 = e9.dappMetadata) || void 0 === i4 ? void 0 : i4.url)) {
      if ("undefined" == typeof window || "undefined" == typeof document) throw new Error("You must provide dAppMetadata url");
      e9.dappMetadata = Object.assign(Object.assign({}, e9.dappMetadata), { url: `${window.location.protocol}//${window.location.host}` });
    }
    this.options = e9, this.options._source || (e9._source = eh), this.init().then(() => {
      Iu("[MetaMaskSDK: constructor()]: initialized successfully."), "undefined" != typeof window && (window.mmsdk = this);
    }).catch((e10) => {
      console.error("[MetaMaskSDK: constructor()] error during initialization", e10);
    });
  }
  init() {
    return c2(this, void 0, void 0, function* () {
      return function(e9) {
        var t3;
        return c2(this, void 0, void 0, function* () {
          if ("undefined" != typeof window && (null === (t3 = window.mmsdk) || void 0 === t3 ? void 0 : t3.isInitialized())) return Iu("[MetaMaskSDK: initializeMetaMaskSDK()] already initialized"), Promise.resolve(window.mmsdk);
          if (e9._initialized) return Iu("[MetaMaskSDK: initializeMetaMaskSDK()] already initialized"), e9.sdkInitPromise;
          if (e9.sdkInitPromise) return Iu("[MetaMaskSDK: initializeMetaMaskSDK()] already initializing"), e9.sdkInitPromise;
          try {
            e9.sdkInitPromise = sf(e9), yield e9.sdkInitPromise;
          } catch (e10) {
            throw console.error(e10), e10;
          }
          return e9.sdkInitPromise;
        });
      }(this);
    });
  }
  isExtensionActive() {
    return this.extensionActive;
  }
  checkExtensionAvailability() {
    var e9;
    return "undefined" != typeof window && Boolean(null === (e9 = window.ethereum) || void 0 === e9 ? void 0 : e9.isMetaMask);
  }
  connect() {
    return c2(this, void 0, void 0, function* () {
      return function(e9) {
        return c2(this, void 0, void 0, function* () {
          if (e9._initialized || (Iu("[MetaMaskSDK: connect()] provider not ready -- wait for init()"), yield e9.init()), Iu(`[MetaMaskSDK: connect()] isExtensionActive=${e9.isExtensionActive()} activeProvider`, e9.activeProvider), !e9.activeProvider) throw new Error("SDK state invalid -- undefined provider");
          const t3 = e9.activeProvider.getSelectedAddress();
          return t3 ? [t3] : e9.activeProvider.request({ method: oh.ETH_REQUESTACCOUNTS, params: [] });
        });
      }(this);
    });
  }
  connectAndSign({ msg: e9 }) {
    return c2(this, void 0, void 0, function* () {
      return yh({ instance: this, msg: e9 });
    });
  }
  connectWith(e9) {
    return c2(this, void 0, void 0, function* () {
      return function({ instance: e10, rpc: t3 }) {
        return c2(this, void 0, void 0, function* () {
          if (e10._initialized || (Iu("[MetaMaskSDK: connectWith()] provider not ready -- wait for init()"), yield e10.init()), Iu(`[MetaMaskSDK: connectWith()] method: ${t3.method} rpc=${t3}`), !e10.activeProvider) throw new Error("SDK state invalid -- undefined provider");
          return e10.activeProvider.request({ method: oh.METAMASK_CONNECTWITH, params: [t3] });
        });
      }({ instance: this, rpc: e9 });
    });
  }
  resume() {
    return function(e9) {
      var t3, n6, r2;
      return c2(this, void 0, void 0, function* () {
        if (!(null === (n6 = null === (t3 = e9.remoteConnection) || void 0 === t3 ? void 0 : t3.getConnector()) || void 0 === n6 ? void 0 : n6.isReady())) return Iu("[MetaMaskSDK: resume()] channel is not ready -- starting connection"), void (null === (r2 = e9.remoteConnection) || void 0 === r2 || r2.startConnection());
        Iu("[MetaMaskSDK: resume()] channel is ready");
      });
    }(this);
  }
  disconnect() {
    return console.warn("MetaMaskSDK.disconnect() is deprecated, use terminate()"), this.terminate();
  }
  isAuthorized() {
    var e9;
    null === (e9 = this.remoteConnection) || void 0 === e9 || e9.isAuthorized();
  }
  terminate() {
    return function(e9) {
      var t3, n6, r2;
      return c2(this, void 0, void 0, function* () {
        if (!(null === (t3 = e9.platformManager) || void 0 === t3 ? void 0 : t3.isMetaMaskMobileWebView())) {
          if (mh && (window.localStorage.removeItem(dh), window.localStorage.removeItem(hh), window.localStorage.removeItem(uh)), e9.extensionActive) {
            try {
              yield null === (n6 = e9.activeProvider) || void 0 === n6 ? void 0 : n6.request({ method: oh.WALLET_REVOKEPERMISSIONS, params: [{ eth_accounts: {} }] });
            } catch (e10) {
              Iu("[MetaMaskSDK: terminate()] error revoking permissions", e10);
            }
            return e9.options.extensionOnly ? (e9.emit(Vu.ProviderUpdate, gh.TERMINATE), void Iu("[MetaMaskSDK: terminate()] extensionOnly --- prevent switching providers")) : (e9.activeProvider = e9.sdkProvider, window.ethereum = e9.activeProvider, e9.extensionActive = false, void e9.emit(Vu.ProviderUpdate, gh.TERMINATE));
          }
          e9.emit(Vu.ProviderUpdate, gh.TERMINATE), Iu(`[MetaMaskSDK: terminate()] remoteConnection=${e9.remoteConnection}`), null === (r2 = e9.remoteConnection) || void 0 === r2 || r2.disconnect({ terminate: true, sendMessage: true });
        }
      });
    }(this);
  }
  isInitialized() {
    return this._initialized;
  }
  setReadOnlyRPCCalls(e9) {
    this.readonlyRPCCalls = e9;
  }
  hasReadOnlyRPCCalls() {
    return this.readonlyRPCCalls;
  }
  getProvider() {
    if (this.activeProvider) return this.activeProvider;
    console.warn("MetaMaskSDK: No active provider found");
  }
  getMobileProvider() {
    if (!this.sdkProvider) throw new Error("SDK state invalid -- undefined mobile provider");
    return this.sdkProvider;
  }
  getUniversalLink() {
    var e9;
    const t3 = null === (e9 = this.remoteConnection) || void 0 === e9 ? void 0 : e9.getUniversalLink();
    if (!t3) throw new Error("No Universal Link available, please call eth_requestAccounts first.");
    return t3;
  }
  getChannelId() {
    var e9, t3;
    return null === (t3 = null === (e9 = this.remoteConnection) || void 0 === e9 ? void 0 : e9.getChannelConfig()) || void 0 === t3 ? void 0 : t3.channelId;
  }
  getRPCHistory() {
    var e9, t3;
    return null === (t3 = null === (e9 = this.remoteConnection) || void 0 === e9 ? void 0 : e9.getConnector()) || void 0 === t3 ? void 0 : t3.getRPCMethodTracker();
  }
  getVersion() {
    return Xu.version;
  }
  getDappId() {
    var e9, t3, n6, r2;
    return "undefined" == typeof window || void 0 === window.location ? null !== (r2 = null !== (t3 = null === (e9 = this.options.dappMetadata) || void 0 === e9 ? void 0 : e9.name) && void 0 !== t3 ? t3 : null === (n6 = this.options.dappMetadata) || void 0 === n6 ? void 0 : n6.url) && void 0 !== r2 ? r2 : "N/A" : window.location.hostname;
  }
  getAnonId() {
    var e9, t3;
    return c2(this, void 0, void 0, function* () {
      if (this._anonId) return this._anonId;
      let n6;
      return n6 = (null === (e9 = this.platformManager) || void 0 === e9 ? void 0 : e9.isBrowser()) ? this.getBrowserAnonId() : (null === (t3 = this.platformManager) || void 0 === t3 ? void 0 : t3.isReactNative()) ? yield this.getReactNativeAnonId() : v4_default(), this._anonId = n6, n6;
    });
  }
  getBrowserAnonId() {
    const e9 = this.ANON_ID_STORAGE_KEY;
    try {
      const t3 = localStorage.getItem(e9);
      if (t3) return t3;
      const n6 = v4_default();
      return localStorage.setItem(e9, n6), n6;
    } catch (e10) {
      return console.error("[MetaMaskSDK: getBrowserAnonId()] LocalStorage access error:", e10), v4_default();
    }
  }
  getReactNativeAnonId() {
    return c2(this, void 0, void 0, function* () {
      const e9 = this.ANON_ID_STORAGE_KEY;
      try {
        const t3 = __require("@react-native-async-storage/async-storage").default, n6 = yield t3.getItem(e9);
        if (n6) return n6;
        const r2 = v4_default();
        return yield t3.setItem(e9, r2), r2;
      } catch (e10) {
        return console.error("[MetaMaskSDK: getReactNativeAnonId()] Error accessing AsyncStorage:", e10), v4_default();
      }
    });
  }
  getWalletStatus() {
    var e9, t3;
    return null === (t3 = null === (e9 = this.remoteConnection) || void 0 === e9 ? void 0 : e9.getConnector()) || void 0 === t3 ? void 0 : t3.getConnectionStatus();
  }
  _getChannelConfig() {
    var e9;
    return null === (e9 = this.remoteConnection) || void 0 === e9 ? void 0 : e9.getChannelConfig();
  }
  _ping() {
    var e9, t3;
    null === (t3 = null === (e9 = this.remoteConnection) || void 0 === e9 ? void 0 : e9.getConnector()) || void 0 === t3 || t3.ping();
  }
  _keyCheck() {
    var e9, t3;
    null === (t3 = null === (e9 = this.remoteConnection) || void 0 === e9 ? void 0 : e9.getConnector()) || void 0 === t3 || t3.keyCheck();
  }
  _getServiceStatus() {
    var e9, t3;
    return null === (t3 = null === (e9 = this.remoteConnection) || void 0 === e9 ? void 0 : e9.getConnector()) || void 0 === t3 ? void 0 : t3.getServiceStatus();
  }
  _getRemoteConnection() {
    return this.remoteConnection;
  }
  _getDappMetadata() {
    return this.dappMetadata;
  }
  _getKeyInfo() {
    var e9;
    return null === (e9 = this.remoteConnection) || void 0 === e9 ? void 0 : e9.getKeyInfo();
  }
  _resetKeys() {
    var e9, t3;
    null === (t3 = null === (e9 = this.remoteConnection) || void 0 === e9 ? void 0 : e9.getConnector()) || void 0 === t3 || t3.resetKeys();
  }
  _getConnection() {
    return this.remoteConnection;
  }
  emit(e9, t3) {
    return super.emit(e9, t3);
  }
  on(e9, t3) {
    return super.on(e9, t3);
  }
};
var cf = Object.freeze({ __proto__: null, StorageManagerWeb: class {
  constructor({ enabled: e9 } = { enabled: false }) {
    this.enabled = false, this.enabled = e9;
  }
  persistChannelConfig(e9) {
    return c2(this, void 0, void 0, function* () {
      const t3 = JSON.stringify(e9);
      Iu(`[StorageManagerWeb: persistChannelConfig()] enabled=${this.enabled}`, e9), localStorage.setItem(lh, t3);
    });
  }
  getPersistedChannelConfig() {
    return c2(this, void 0, void 0, function* () {
      let e9;
      try {
        if (Iu(`[StorageManagerWeb: getPersistedChannelConfig()] enabled=${this.enabled}`), e9 = localStorage.getItem(lh), Iu("[StorageManagerWeb: getPersistedChannelConfig()]", e9), !e9) return;
        const t3 = JSON.parse(e9);
        return Iu("[StorageManagerWeb: getPersistedChannelConfig()] channelConfig", t3), t3;
      } catch (e10) {
        return void console.error("[StorageManagerWeb: getPersistedChannelConfig()] Can't find existing channel config", e10);
      }
    });
  }
  persistAccounts(e9) {
    return c2(this, void 0, void 0, function* () {
      Iu(`[StorageManagerWeb: persistAccounts()] enabled=${this.enabled}`, e9);
      const t3 = JSON.stringify(e9);
      localStorage.setItem(uh, t3);
    });
  }
  getCachedAccounts() {
    return c2(this, void 0, void 0, function* () {
      try {
        const e9 = localStorage.getItem(uh);
        return e9 ? JSON.parse(e9) : [];
      } catch (e9) {
        throw console.error("[StorageManagerWeb: getCachedAccounts()] Error reading cached accounts", e9), e9;
      }
    });
  }
  persistChainId(e9) {
    return c2(this, void 0, void 0, function* () {
      Iu(`[StorageManagerWeb: persistChainId()] enabled=${this.enabled}`, e9), localStorage.setItem(hh, e9);
    });
  }
  getCachedChainId() {
    return c2(this, void 0, void 0, function* () {
      try {
        const e9 = localStorage.getItem(hh);
        return null != e9 ? e9 : void 0;
      } catch (e9) {
        throw console.error("[StorageManagerWeb: getCachedChainId()] Error reading cached chainId", e9), e9;
      }
    });
  }
  terminate() {
    return c2(this, void 0, void 0, function* () {
      Iu(`[StorageManagerWeb: terminate()] enabled=${this.enabled}`), localStorage.removeItem(lh);
    });
  }
} });
var lf = "hydrated";
var df = false;
var uf = false;
var hf = true;
var ff = Object.defineProperty;
var pf = /* @__PURE__ */ new WeakMap();
var gf = (e9) => pf.get(e9);
var mf = (e9, t3) => pf.set(t3.$lazyInstance$ = e9, t3);
var yf = (e9, t3) => t3 in e9;
var vf = (e9, t3) => (0, console.error)(e9, t3);
var bf = /* @__PURE__ */ new Map();
var wf = /* @__PURE__ */ new Map();
var Ef = "slot-fb{display:contents}slot-fb[hidden]{display:none}";
var Sf = "undefined" != typeof window ? window : {};
var _f = Sf.document || { head: {} };
var Cf = { $flags$: 0, $resourcesUrl$: "", jmp: (e9) => e9(), raf: (e9) => requestAnimationFrame(e9), ael: (e9, t3, n6, r2) => e9.addEventListener(t3, n6, r2), rel: (e9, t3, n6, r2) => e9.removeEventListener(t3, n6, r2), ce: (e9, t3) => new CustomEvent(e9, t3) };
var kf = (() => {
  try {
    return new CSSStyleSheet(), "function" == typeof new CSSStyleSheet().replaceSync;
  } catch (e9) {
  }
  return false;
})();
var Af = false;
var xf = [];
var Mf = [];
var If = (e9, t3) => (t4) => {
  e9.push(t4), Af || (Af = true, 4 & Cf.$flags$ ? Pf(Rf) : Cf.raf(Rf));
};
var Tf = (e9) => {
  for (let t3 = 0; t3 < e9.length; t3++) try {
    e9[t3](performance.now());
  } catch (e10) {
    vf(e10);
  }
  e9.length = 0;
};
var Rf = () => {
  Tf(xf), Tf(Mf), (Af = xf.length > 0) && Cf.raf(Rf);
};
var Pf = (e9) => ((e10) => Promise.resolve(e10))().then(e9);
var Of = If(Mf);
var Nf = {};
var Lf = (e9) => "object" === (e9 = typeof e9) || "function" === e9;
function Df(e9) {
  var t3, n6, r2;
  return null != (r2 = null == (n6 = null == (t3 = e9.head) ? void 0 : t3.querySelector('meta[name="csp-nonce"]')) ? void 0 : n6.getAttribute("content")) ? r2 : void 0;
}
((e9, t3) => {
  for (var n6 in t3) ff(e9, n6, { get: t3[n6], enumerable: true });
})({}, { err: () => Bf, map: () => Kf, ok: () => $f, unwrap: () => Hf, unwrapErr: () => Ff });
var $f = (e9) => ({ isOk: true, isErr: false, value: e9 });
var Bf = (e9) => ({ isOk: false, isErr: true, value: e9 });
function Kf(e9, t3) {
  if (e9.isOk) {
    const n6 = t3(e9.value);
    return n6 instanceof Promise ? n6.then((e10) => $f(e10)) : $f(n6);
  }
  if (e9.isErr) {
    const t4 = e9.value;
    return Bf(t4);
  }
  throw "should never get here";
}
var jf;
var Uf;
var Hf = (e9) => {
  if (e9.isOk) return e9.value;
  throw e9.value;
};
var Ff = (e9) => {
  if (e9.isErr) return e9.value;
  throw e9.value;
};
var zf = (e9, t3, ...n6) => {
  let r2 = null, i4 = false, o3 = false;
  const s2 = [], a = (t4) => {
    for (let n7 = 0; n7 < t4.length; n7++) r2 = t4[n7], Array.isArray(r2) ? a(r2) : null != r2 && "boolean" != typeof r2 && ((i4 = "function" != typeof e9 && !Lf(r2)) && (r2 = String(r2)), i4 && o3 ? s2[s2.length - 1].$text$ += r2 : s2.push(i4 ? qf(null, r2) : r2), o3 = i4);
  };
  if (a(n6), t3) {
    const e10 = t3.className || t3.class;
    e10 && (t3.class = "object" != typeof e10 ? e10 : Object.keys(e10).filter((t4) => e10[t4]).join(" "));
  }
  if ("function" == typeof e9) return e9(null === t3 ? {} : t3, s2, Vf);
  const c3 = qf(e9, null);
  return c3.$attrs$ = t3, s2.length > 0 && (c3.$children$ = s2), c3;
};
var qf = (e9, t3) => {
  const n6 = { $flags$: 0, $tag$: e9, $text$: t3, $elm$: null, $children$: null, $attrs$: null };
  return n6;
};
var Wf = {};
var Vf = { forEach: (e9, t3) => e9.map(Gf).forEach(t3), map: (e9, t3) => e9.map(Gf).map(t3).map(Yf) };
var Gf = (e9) => ({ vattrs: e9.$attrs$, vchildren: e9.$children$, vkey: e9.$key$, vname: e9.$name$, vtag: e9.$tag$, vtext: e9.$text$ });
var Yf = (e9) => {
  if ("function" == typeof e9.vtag) {
    const t4 = { ...e9.vattrs };
    return e9.vkey && (t4.key = e9.vkey), e9.vname && (t4.name = e9.vname), zf(e9.vtag, t4, ...e9.vchildren || []);
  }
  const t3 = qf(e9.vtag, e9.vtext);
  return t3.$attrs$ = e9.vattrs, t3.$children$ = e9.vchildren, t3.$key$ = e9.vkey, t3.$name$ = e9.vname, t3;
};
var Zf = (e9) => gf(e9).$hostElement$;
var Jf = (e9, t3, n6) => {
  const r2 = Zf(e9);
  return { emit: (e10) => Qf(r2, t3, { bubbles: !!(4 & n6), composed: !!(2 & n6), cancelable: !!(1 & n6), detail: e10 }) };
};
var Qf = (e9, t3, n6) => {
  const r2 = Cf.ce(t3, n6);
  return e9.dispatchEvent(r2), r2;
};
var Xf = /* @__PURE__ */ new WeakMap();
var ep = (e9) => {
  const t3 = e9.$cmpMeta$, n6 = e9.$hostElement$, r2 = t3.$flags$, i4 = (t3.$tagName$, () => {
  }), o3 = ((e10, t4, n7) => {
    var r3;
    const i5 = tp(t4), o4 = wf.get(i5);
    if (e10 = 11 === e10.nodeType ? e10 : _f, o4) if ("string" == typeof o4) {
      e10 = e10.head || e10;
      let n8, s2 = Xf.get(e10);
      if (s2 || Xf.set(e10, s2 = /* @__PURE__ */ new Set()), !s2.has(i5)) {
        {
          n8 = _f.createElement("style"), n8.innerHTML = o4;
          const i6 = null != (r3 = Cf.$nonce$) ? r3 : Df(_f);
          if (null != i6 && n8.setAttribute("nonce", i6), !(1 & t4.$flags$)) if ("HEAD" === e10.nodeName) {
            const t5 = e10.querySelectorAll("link[rel=preconnect]"), r4 = t5.length > 0 ? t5[t5.length - 1].nextSibling : e10.querySelector("style");
            e10.insertBefore(n8, r4);
          } else if ("host" in e10) if (kf) {
            const t5 = new CSSStyleSheet();
            t5.replaceSync(o4), e10.adoptedStyleSheets = [t5, ...e10.adoptedStyleSheets];
          } else {
            const t5 = e10.querySelector("style");
            t5 ? t5.innerHTML = o4 + t5.innerHTML : e10.prepend(n8);
          }
          else e10.append(n8);
          1 & t4.$flags$ && "HEAD" !== e10.nodeName && e10.insertBefore(n8, null);
        }
        4 & t4.$flags$ && (n8.innerHTML += Ef), s2 && s2.add(i5);
      }
    } else e10.adoptedStyleSheets.includes(o4) || (e10.adoptedStyleSheets = [...e10.adoptedStyleSheets, o4]);
    return i5;
  })(n6.shadowRoot ? n6.shadowRoot : n6.getRootNode(), t3);
  10 & r2 && 2 & r2 && (n6["s-sc"] = o3, n6.classList.add(o3 + "-h")), i4();
};
var tp = (e9, t3) => "sc-" + e9.$tagName$;
var np = (e9, t3, n6, r2, i4, o3) => {
  if (n6 !== r2) {
    let s2 = yf(e9, t3), a = t3.toLowerCase();
    if ("class" === t3) {
      const t4 = e9.classList, i5 = ip(n6), o4 = ip(r2);
      t4.remove(...i5.filter((e10) => e10 && !o4.includes(e10))), t4.add(...o4.filter((e10) => e10 && !i5.includes(e10)));
    } else if ("style" === t3) {
      for (const t4 in n6) r2 && null != r2[t4] || (t4.includes("-") ? e9.style.removeProperty(t4) : e9.style[t4] = "");
      for (const t4 in r2) n6 && r2[t4] === n6[t4] || (t4.includes("-") ? e9.style.setProperty(t4, r2[t4]) : e9.style[t4] = r2[t4]);
    } else if (s2 || "o" !== t3[0] || "n" !== t3[1]) {
      const a2 = Lf(r2);
      if ((s2 || a2 && null !== r2) && !i4) try {
        if (e9.tagName.includes("-")) e9[t3] = r2;
        else {
          const i5 = null == r2 ? "" : r2;
          "list" === t3 ? s2 = false : null != n6 && e9[t3] == i5 || ("function" == typeof e9.__lookupSetter__(t3) ? e9[t3] = i5 : e9.setAttribute(t3, i5));
        }
      } catch (e10) {
      }
      null == r2 || false === r2 ? false === r2 && "" !== e9.getAttribute(t3) || e9.removeAttribute(t3) : (!s2 || 4 & o3 || i4) && !a2 && (r2 = true === r2 ? "" : r2, e9.setAttribute(t3, r2));
    } else if (t3 = "-" === t3[2] ? t3.slice(3) : yf(Sf, a) ? a.slice(2) : a[2] + t3.slice(3), n6 || r2) {
      const i5 = t3.endsWith(op);
      t3 = t3.replace(sp, ""), n6 && Cf.rel(e9, t3, n6, i5), r2 && Cf.ael(e9, t3, r2, i5);
    }
  }
};
var rp = /\s/;
var ip = (e9) => e9 ? e9.split(rp) : [];
var op = "Capture";
var sp = new RegExp(op + "$");
var ap = (e9, t3, n6) => {
  const r2 = 11 === t3.$elm$.nodeType && t3.$elm$.host ? t3.$elm$.host : t3.$elm$, i4 = e9 && e9.$attrs$ || Nf, o3 = t3.$attrs$ || Nf;
  for (const e10 of cp(Object.keys(i4))) e10 in o3 || np(r2, e10, i4[e10], void 0, n6, t3.$flags$);
  for (const e10 of cp(Object.keys(o3))) np(r2, e10, i4[e10], o3[e10], n6, t3.$flags$);
};
function cp(e9) {
  return e9.includes("ref") ? [...e9.filter((e10) => "ref" !== e10), "ref"] : e9;
}
var lp = false;
var dp = false;
var up = (e9, t3, n6, r2) => {
  const i4 = t3.$children$[n6];
  let o3, s2, a = 0;
  if (null !== i4.$text$) o3 = i4.$elm$ = _f.createTextNode(i4.$text$);
  else {
    dp || (dp = "svg" === i4.$tag$), o3 = i4.$elm$ = _f.createElementNS(dp ? "http://www.w3.org/2000/svg" : "http://www.w3.org/1999/xhtml", !lp && uf && 2 & i4.$flags$ ? "slot-fb" : i4.$tag$), dp && "foreignObject" === i4.$tag$ && (dp = false), ap(null, i4, dp);
    if (!!o3.getRootNode().querySelector("body") && df && ((e10) => null != e10)(jf) && o3["s-si"] !== jf && o3.classList.add(o3["s-si"] = jf), i4.$children$) for (a = 0; a < i4.$children$.length; ++a) s2 = up(e9, i4, a), s2 && o3.appendChild(s2);
    "svg" === i4.$tag$ ? dp = false : "foreignObject" === o3.tagName && (dp = true);
  }
  return o3["s-hn"] = Uf, o3;
};
var hp = (e9, t3, n6, r2, i4, o3) => {
  let s2, a = e9;
  for (a.shadowRoot && a.tagName === Uf && (a = a.shadowRoot); i4 <= o3; ++i4) r2[i4] && (s2 = up(null, n6, i4), s2 && (r2[i4].$elm$ = s2, mp(a, s2, t3)));
};
var fp = (e9, t3, n6) => {
  for (let r2 = t3; r2 <= n6; ++r2) {
    const t4 = e9[r2];
    if (t4) {
      const e10 = t4.$elm$;
      e10 && e10.remove();
    }
  }
};
var pp = (e9, t3, n6 = false) => e9.$tag$ === t3.$tag$;
var gp = (e9, t3, n6 = false) => {
  const r2 = t3.$elm$ = e9.$elm$, i4 = e9.$children$, o3 = t3.$children$, s2 = t3.$tag$, a = t3.$text$;
  null === a ? (ap(e9, t3, dp = "svg" === s2 || "foreignObject" !== s2 && dp), null !== i4 && null !== o3 ? ((e10, t4, n7, r3, i5 = false) => {
    let o4, s3 = 0, a2 = 0, c3 = t4.length - 1, l5 = t4[0], d3 = t4[c3], u2 = r3.length - 1, h3 = r3[0], f4 = r3[u2];
    for (; s3 <= c3 && a2 <= u2; ) null == l5 ? l5 = t4[++s3] : null == d3 ? d3 = t4[--c3] : null == h3 ? h3 = r3[++a2] : null == f4 ? f4 = r3[--u2] : pp(l5, h3, i5) ? (gp(l5, h3, i5), l5 = t4[++s3], h3 = r3[++a2]) : pp(d3, f4, i5) ? (gp(d3, f4, i5), d3 = t4[--c3], f4 = r3[--u2]) : pp(l5, f4, i5) ? (gp(l5, f4, i5), mp(e10, l5.$elm$, d3.$elm$.nextSibling), l5 = t4[++s3], f4 = r3[--u2]) : pp(d3, h3, i5) ? (gp(d3, h3, i5), mp(e10, d3.$elm$, l5.$elm$), d3 = t4[--c3], h3 = r3[++a2]) : (o4 = up(t4 && t4[a2], n7, a2), h3 = r3[++a2], o4 && mp(l5.$elm$.parentNode, o4, l5.$elm$));
    s3 > c3 ? hp(e10, null == r3[u2 + 1] ? null : r3[u2 + 1].$elm$, n7, r3, a2, u2) : a2 > u2 && fp(t4, s3, c3);
  })(r2, i4, t3, o3, n6) : null !== o3 ? (null !== e9.$text$ && (r2.textContent = ""), hp(r2, null, t3, o3, 0, o3.length - 1)) : !n6 && hf && null !== i4 && fp(i4, 0, i4.length - 1), dp && "svg" === s2 && (dp = false)) : e9.$text$ !== a && (r2.data = a);
};
var mp = (e9, t3, n6) => null == e9 ? void 0 : e9.insertBefore(t3, n6);
var yp = (e9, t3, n6 = false) => {
  const r2 = e9.$hostElement$, i4 = e9.$cmpMeta$, o3 = e9.$vnode$ || qf(null, null), s2 = (a = t3) && a.$tag$ === Wf ? t3 : zf(null, null, t3);
  var a;
  if (Uf = r2.tagName, n6 && s2.$attrs$) for (const e10 of Object.keys(s2.$attrs$)) r2.hasAttribute(e10) && !["key", "ref", "style", "class"].includes(e10) && (s2.$attrs$[e10] = r2[e10]);
  s2.$tag$ = null, s2.$flags$ |= 4, e9.$vnode$ = s2, s2.$elm$ = o3.$elm$ = r2.shadowRoot || r2, jf = r2["s-sc"], lp = 0 != (1 & i4.$flags$), gp(o3, s2, n6);
};
var vp = (e9, t3) => {
  t3 && !e9.$onRenderResolve$ && t3["s-p"] && t3["s-p"].push(new Promise((t4) => e9.$onRenderResolve$ = t4));
};
var bp = (e9, t3) => {
  if (e9.$flags$ |= 16, 4 & e9.$flags$) return void (e9.$flags$ |= 512);
  vp(e9, e9.$ancestorComponent$);
  return Of(() => wp(e9, t3));
};
var wp = (e9, t3) => {
  const n6 = e9.$hostElement$, r2 = (e9.$cmpMeta$.$tagName$, () => {
  }), i4 = e9.$lazyInstance$;
  if (!i4) throw new Error(`Can't render component <${n6.tagName.toLowerCase()} /> with invalid Stencil runtime! Make sure this imported component is compiled with a \`externalRuntime: true\` flag. For more information, please refer to https://stenciljs.com/docs/custom-elements#externalruntime`);
  return r2(), Ep(void 0, () => _p(e9, i4, t3));
};
var Ep = (e9, t3) => Sp(e9) ? e9.then(t3).catch((e10) => {
  console.error(e10), t3();
}) : t3();
var Sp = (e9) => e9 instanceof Promise || e9 && e9.then && "function" == typeof e9.then;
var _p = async (e9, t3, n6) => {
  var r2;
  const i4 = e9.$hostElement$, o3 = (e9.$cmpMeta$.$tagName$, () => {
  }), s2 = i4["s-rc"];
  n6 && ep(e9);
  const a = (e9.$cmpMeta$.$tagName$, () => {
  });
  Cp(e9, t3, i4, n6), s2 && (s2.map((e10) => e10()), i4["s-rc"] = void 0), a(), o3();
  {
    const t4 = null != (r2 = i4["s-p"]) ? r2 : [], n7 = () => kp(e9);
    0 === t4.length ? n7() : (Promise.all(t4).then(n7), e9.$flags$ |= 4, t4.length = 0);
  }
};
var Cp = (e9, t3, n6, r2) => {
  try {
    t3 = t3.render(), e9.$flags$ &= -17, e9.$flags$ |= 2, yp(e9, t3, r2);
  } catch (t4) {
    vf(t4, e9.$hostElement$);
  }
  return null;
};
var kp = (e9) => {
  e9.$cmpMeta$.$tagName$;
  const t3 = e9.$hostElement$, n6 = () => {
  }, r2 = e9.$lazyInstance$, i4 = e9.$ancestorComponent$;
  64 & e9.$flags$ ? n6() : (e9.$flags$ |= 64, Mp(t3), xp(r2, "componentDidLoad"), n6(), e9.$onReadyResolve$(t3), i4 || Ap()), e9.$onRenderResolve$ && (e9.$onRenderResolve$(), e9.$onRenderResolve$ = void 0), 512 & e9.$flags$ && Pf(() => bp(e9, false)), e9.$flags$ &= -517;
};
var Ap = (e9) => {
  Mp(_f.documentElement), Pf(() => Qf(Sf, "appload", { detail: { namespace: "sdk-install-modal-web" } }));
};
var xp = (e9, t3, n6) => {
  if (e9 && e9[t3]) try {
    return e9[t3](n6);
  } catch (e10) {
    vf(e10);
  }
};
var Mp = (e9) => {
  var t3;
  return e9.classList.add(null != (t3 = lf) ? t3 : "hydrated");
};
var Ip = (e9, t3, n6, r2) => {
  const i4 = gf(e9);
  if (!i4) throw new Error(`Couldn't find host element for "${r2.$tagName$}" as it is unknown to this Stencil runtime. This usually happens when integrating a 3rd party Stencil component with another Stencil component or application. Please reach out to the maintainers of the 3rd party Stencil component or report this on the Stencil Discord server (https://chat.stenciljs.com) or comment on this similar [GitHub issue](https://github.com/ionic-team/stencil/issues/5457).`);
  const o3 = i4.$hostElement$, s2 = i4.$instanceValues$.get(t3), a = i4.$flags$, c3 = i4.$lazyInstance$;
  var l5, d3;
  l5 = n6, d3 = r2.$members$[t3][0], n6 = null == l5 || Lf(l5) ? l5 : 4 & d3 ? "false" !== l5 && ("" === l5 || !!l5) : 1 & d3 ? String(l5) : l5;
  const u2 = Number.isNaN(s2) && Number.isNaN(n6);
  if ((!(8 & a) || void 0 === s2) && (n6 !== s2 && !u2) && (i4.$instanceValues$.set(t3, n6), c3)) {
    if (r2.$watchers$ && 128 & a) {
      const e10 = r2.$watchers$[t3];
      e10 && e10.map((e11) => {
        try {
          c3[e11](n6, s2, t3);
        } catch (e12) {
          vf(e12, o3);
        }
      });
    }
    2 == (18 & a) && bp(i4, false);
  }
};
var Tp = (e9, t3, n6) => {
  var r2, i4;
  const o3 = e9.prototype;
  if (t3.$members$ || t3.$watchers$ || e9.watchers) {
    e9.watchers && !t3.$watchers$ && (t3.$watchers$ = e9.watchers);
    const s2 = Object.entries(null != (r2 = t3.$members$) ? r2 : {});
    if (s2.map(([e10, [r3]]) => {
      (31 & r3 || 2 & n6 && 32 & r3) && Object.defineProperty(o3, e10, { get() {
        return t4 = e10, gf(this).$instanceValues$.get(t4);
        var t4;
      }, set(n7) {
        Ip(this, e10, n7, t3);
      }, configurable: true, enumerable: true });
    }), 1 & n6) {
      const n7 = /* @__PURE__ */ new Map();
      o3.attributeChangedCallback = function(e10, r3, i5) {
        Cf.jmp(() => {
          var s3;
          const a = n7.get(e10);
          if (this.hasOwnProperty(a)) i5 = this[a], delete this[a];
          else {
            if (o3.hasOwnProperty(a) && "number" == typeof this[a] && this[a] == i5) return;
            if (null == a) {
              const n8 = gf(this), o4 = null == n8 ? void 0 : n8.$flags$;
              if (o4 && !(8 & o4) && 128 & o4 && i5 !== r3) {
                const o5 = n8.$lazyInstance$, a2 = null == (s3 = t3.$watchers$) ? void 0 : s3[e10];
                null == a2 || a2.forEach((t4) => {
                  null != o5[t4] && o5[t4].call(o5, i5, r3, e10);
                });
              }
              return;
            }
          }
          this[a] = (null !== i5 || "boolean" != typeof this[a]) && i5;
        });
      }, e9.observedAttributes = Array.from(/* @__PURE__ */ new Set([...Object.keys(null != (i4 = t3.$watchers$) ? i4 : {}), ...s2.filter(([e10, t4]) => 15 & t4[0]).map(([e10, t4]) => {
        const r3 = t4[1] || e10;
        return n7.set(r3, e10), r3;
      })]));
    }
  }
  return e9;
};
var Rp = async (e9, t3, n6, r2) => {
  let i4;
  if (0 == (32 & t3.$flags$)) {
    t3.$flags$ |= 32;
    if (n6.$lazyBundleId$) {
      const e10 = ((e11, t4, n7) => {
        const r4 = e11.$tagName$.replace(/-/g, "_"), i5 = e11.$lazyBundleId$;
        if (!i5) return;
        const o4 = bf.get(i5);
        if (o4) return o4[r4];
        {
          const e12 = (e13) => (bf.set(i5, e13), e13[r4]);
          if ("mm-install-modal_3" === i5) return Promise.resolve().then(function() {
            return wg;
          }).then(e12, vf);
        }
        return /* webpackIgnore: true */ /* @vite-ignore */ /* webpackInclude: /\.entry\.js$/ */ /* webpackExclude: /\.system\.entry\.js$/ */ /* webpackMode: "lazy" */ globImport_entry_js(`./${i5}.entry.js`).then((e12) => (bf.set(i5, e12), e12[r4]), vf);
      })(n6);
      if (e10 && "then" in e10) {
        const t4 = () => {
        };
        i4 = await e10, t4();
      } else i4 = e10;
      if (!i4) throw new Error(`Constructor for "${n6.$tagName$}#${t3.$modeName$}" was not found`);
      i4.isProxied || (n6.$watchers$ = i4.watchers, Tp(i4, n6, 2), i4.isProxied = true);
      const r3 = (n6.$tagName$, () => {
      });
      t3.$flags$ |= 8;
      try {
        new i4(t3);
      } catch (e11) {
        vf(e11);
      }
      t3.$flags$ &= -9, t3.$flags$ |= 128, r3(), Pp(t3.$lazyInstance$);
    } else {
      i4 = e9.constructor;
      const n7 = e9.localName;
      customElements.whenDefined(n7).then(() => t3.$flags$ |= 128);
    }
    if (i4 && i4.style) {
      let e10;
      "string" == typeof i4.style && (e10 = i4.style);
      const t4 = tp(n6);
      if (!wf.has(t4)) {
        const r3 = (n6.$tagName$, () => {
        });
        ((e11, t5, n7) => {
          let r4 = wf.get(e11);
          kf && n7 ? (r4 = r4 || new CSSStyleSheet(), "string" == typeof r4 ? r4 = t5 : r4.replaceSync(t5)) : r4 = t5, wf.set(e11, r4);
        })(t4, e10, !!(1 & n6.$flags$)), r3();
      }
    }
  }
  const o3 = t3.$ancestorComponent$, s2 = () => bp(t3, true);
  o3 && o3["s-rc"] ? o3["s-rc"].push(s2) : s2();
};
var Pp = (e9) => {
  xp(e9, "connectedCallback");
};
var Op = (e9) => {
  xp(e9, "disconnectedCallback");
};
var Np = (e9, t3 = {}) => {
  var n6;
  const r2 = () => {
  }, i4 = [], o3 = t3.exclude || [], s2 = Sf.customElements, a = _f.head, c3 = a.querySelector("meta[charset]"), l5 = _f.createElement("style"), d3 = [];
  let u2, h3 = true;
  Object.assign(Cf, t3), Cf.$resourcesUrl$ = new URL(t3.resourcesUrl || "./", _f.baseURI).href;
  let f4 = false;
  if (e9.map((e10) => {
    e10[1].map((t4) => {
      var n7;
      const r3 = { $flags$: t4[0], $tagName$: t4[1], $members$: t4[2], $listeners$: t4[3] };
      4 & r3.$flags$ && (f4 = true), r3.$members$ = t4[2], r3.$watchers$ = null != (n7 = t4[4]) ? n7 : {};
      const a2 = r3.$tagName$, c4 = class extends HTMLElement {
        constructor(e11) {
          if (super(e11), this.hasRegisteredEventListeners = false, ((e12, t5) => {
            const n8 = { $flags$: 0, $hostElement$: e12, $cmpMeta$: t5, $instanceValues$: /* @__PURE__ */ new Map() };
            n8.$onReadyPromise$ = new Promise((e13) => n8.$onReadyResolve$ = e13), e12["s-p"] = [], e12["s-rc"] = [], pf.set(e12, n8);
          })(e11 = this, r3), 1 & r3.$flags$) if (e11.shadowRoot) {
            if ("open" !== e11.shadowRoot.mode) throw new Error(`Unable to re-use existing shadow root for ${r3.$tagName$}! Mode is set to ${e11.shadowRoot.mode} but Stencil only supports open shadow roots.`);
          } else e11.attachShadow({ mode: "open" });
        }
        connectedCallback() {
          gf(this), this.hasRegisteredEventListeners || (this.hasRegisteredEventListeners = true), u2 && (clearTimeout(u2), u2 = null), h3 ? d3.push(this) : Cf.jmp(() => ((e11) => {
            if (0 == (1 & Cf.$flags$)) {
              const t5 = gf(e11), n8 = t5.$cmpMeta$, r4 = (n8.$tagName$, () => {
              });
              if (1 & t5.$flags$) (null == t5 ? void 0 : t5.$lazyInstance$) ? Pp(t5.$lazyInstance$) : (null == t5 ? void 0 : t5.$onReadyPromise$) && t5.$onReadyPromise$.then(() => Pp(t5.$lazyInstance$));
              else {
                t5.$flags$ |= 1;
                {
                  let n9 = e11;
                  for (; n9 = n9.parentNode || n9.host; ) if (n9["s-p"]) {
                    vp(t5, t5.$ancestorComponent$ = n9);
                    break;
                  }
                }
                n8.$members$ && Object.entries(n8.$members$).map(([t6, [n9]]) => {
                  if (31 & n9 && e11.hasOwnProperty(t6)) {
                    const n10 = e11[t6];
                    delete e11[t6], e11[t6] = n10;
                  }
                }), Rp(e11, t5, n8);
              }
              r4();
            }
          })(this));
        }
        disconnectedCallback() {
          Cf.jmp(() => (async (e11) => {
            if (0 == (1 & Cf.$flags$)) {
              const t5 = gf(e11);
              (null == t5 ? void 0 : t5.$lazyInstance$) ? Op(t5.$lazyInstance$) : (null == t5 ? void 0 : t5.$onReadyPromise$) && t5.$onReadyPromise$.then(() => Op(t5.$lazyInstance$));
            }
          })(this));
        }
        componentOnReady() {
          return gf(this).$onReadyPromise$;
        }
      };
      r3.$lazyBundleId$ = e10[0], o3.includes(a2) || s2.get(a2) || (i4.push(a2), s2.define(a2, Tp(c4, r3, 1)));
    });
  }), i4.length > 0 && (f4 && (l5.textContent += Ef), l5.textContent += i4.sort() + "{visibility:hidden}.hydrated{visibility:inherit}", l5.innerHTML.length)) {
    l5.setAttribute("data-styles", "");
    const e10 = null != (n6 = Cf.$nonce$) ? n6 : Df(_f);
    null != e10 && l5.setAttribute("nonce", e10), a.insertBefore(l5, c3 ? c3.nextSibling : a.firstChild);
  }
  h3 = false, d3.length ? d3.map((e10) => e10.connectedCallback()) : Cf.jmp(() => u2 = setTimeout(Ap, 30)), r2();
};
!function() {
  if ("undefined" != typeof window && void 0 !== window.Reflect && void 0 !== window.customElements) {
    var e9 = HTMLElement;
    window.HTMLElement = function() {
      return Reflect.construct(e9, [], this.constructor);
    }, HTMLElement.prototype = e9.prototype, HTMLElement.prototype.constructor = HTMLElement, Object.setPrototypeOf(HTMLElement, e9);
  }
}();
var Lp = Object.freeze({ __proto__: null, defineCustomElements: async (e9, t3) => {
  if ("undefined" != typeof window) return await void 0, Np([["mm-install-modal_3", [[1, "mm-install-modal", { link: [1], sdkVersion: [1, "sdk-version"], preferDesktop: [4, "prefer-desktop"], tab: [32], isDefaultTab: [32], translationsLoaded: [32] }, null, { preferDesktop: ["updatePreferDesktop"] }], [1, "mm-pending-modal", { displayOTP: [4, "display-o-t-p"], sdkVersion: [1, "sdk-version"], otpCode: [1, "otp-code"], translationsLoaded: [32] }], [1, "mm-select-modal", { link: [1], sdkVersion: [1, "sdk-version"], preferDesktop: [4, "prefer-desktop"], tab: [32], isDefaultTab: [32], translationsLoaded: [32] }, null, { preferDesktop: ["updatePreferDesktop"] }]]]], t3);
}, setNonce: (e9) => Cf.$nonce$ = e9 });
var Dp = { fontFamily: "Roboto, sans-serif" };
var $p = ({ className: e9 }, t3) => zf("div", { style: Dp, class: e9 }, t3);
var Bp = ({ Icon: e9, text: t3 }) => zf("div", { class: "flexContainer", style: { padding: "6", flexDirection: "row" } }, zf("div", { class: "flexItem1" }, zf(e9, null)), zf("div", { class: "flexItem11" }, zf("span", { style: { lineHeight: "2", color: "black" } }, t3)));
var Kp = () => zf("svg", { width: "20", height: "18", viewBox: "0 0 20 18", fill: "none", xmlns: "http://www.w3.org/2000/svg" }, zf("path", { d: "M20.0002 7.9702V10.0302C20.0002 10.5802 19.5602 11.0302 19.0002 11.0502H17.0402C15.9602 11.0502 14.9702 10.2602 14.8802 9.1802C14.8202 8.5502 15.0602 7.9602 15.4802 7.5502C15.8502 7.1702 16.3602 6.9502 16.9202 6.9502H19.0002C19.5602 6.9702 20.0002 7.4202 20.0002 7.9702Z", fill: "#037DD6" }), zf("path", { d: "M18.47 12.55H17.04C15.14 12.55 13.54 11.12 13.38 9.3C13.29 8.26 13.67 7.22 14.43 6.48C15.07 5.82 15.96 5.45 16.92 5.45H18.47C18.76 5.45 19 5.21 18.97 4.92C18.75 2.49 17.14 0.83 14.75 0.55C14.51 0.51 14.26 0.5 14 0.5H5C4.72 0.5 4.45 0.52 4.19 0.56C1.64 0.88 0 2.78 0 5.5V12.5C0 15.26 2.24 17.5 5 17.5H14C16.8 17.5 18.73 15.75 18.97 13.08C19 12.79 18.76 12.55 18.47 12.55ZM11 6.75H5C4.59 6.75 4.25 6.41 4.25 6C4.25 5.59 4.59 5.25 5 5.25H11C11.41 5.25 11.75 5.59 11.75 6C11.75 6.41 11.41 6.75 11 6.75Z", fill: "#037DD6" }));
var jp = () => zf("svg", { width: "20", height: "18", viewBox: "0 0 20 18", fill: "none", xmlns: "http://www.w3.org/2000/svg" }, zf("path", { d: "M14.44 0.0999756C12.63 0.0999756 11.01 0.979976 10 2.32998C8.99 0.979976 7.37 0.0999756 5.56 0.0999756C2.49 0.0999756 0 2.59998 0 5.68998C0 6.87998 0.19 7.97998 0.52 8.99998C2.1 14 6.97 16.99 9.38 17.81C9.72 17.93 10.28 17.93 10.62 17.81C13.03 16.99 17.9 14 19.48 8.99998C19.81 7.97998 20 6.87998 20 5.68998C20 2.59998 17.51 0.0999756 14.44 0.0999756Z", fill: "#037DD6" }));
var Up = () => zf("svg", { width: "20", height: "20", viewBox: "0 0 20 20", fill: "none", xmlns: "http://www.w3.org/2000/svg" }, zf("path", { d: "M16.28 7.53V6.28C16.28 3.58 15.63 0 10 0C4.37 0 3.72 3.58 3.72 6.28V7.53C0.92 7.88 0 9.3 0 12.79V14.65C0 18.75 1.25 20 5.35 20H14.65C18.75 20 20 18.75 20 14.65V12.79C20 9.3 19.08 7.88 16.28 7.53ZM10 16.74C8.33 16.74 6.98 15.38 6.98 13.72C6.98 12.05 8.34 10.7 10 10.7C11.66 10.7 13.02 12.06 13.02 13.72C13.02 15.39 11.67 16.74 10 16.74ZM5.35 7.44C5.27 7.44 5.2 7.44 5.12 7.44V6.28C5.12 3.35 5.95 1.4 10 1.4C14.05 1.4 14.88 3.35 14.88 6.28V7.45C14.8 7.45 14.73 7.45 14.65 7.45H5.35V7.44Z", fill: "#037DD6" }));
var Hp = () => zf("svg", { width: "20", height: "20", viewBox: "0 0 24 24", fill: "none", xmlns: "http://www.w3.org/2000/svg" }, zf("path", { d: "M16.4405 8.8999C20.0405 9.2099 21.5105 11.0599 21.5105 15.1099V15.2399C21.5105 19.7099 19.7205 21.4999 15.2505 21.4999H8.74047C4.27047 21.4999 2.48047 19.7099 2.48047 15.2399V15.1099C2.48047 11.0899 3.93047 9.2399 7.47047 8.9099", stroke: "white", "stroke-width": "1.5", "stroke-linecap": "round", "stroke-linejoin": "round" }), zf("path", { d: "M12 2V14.88", stroke: "white", "stroke-width": "1.5", "stroke-linecap": "round", "stroke-linejoin": "round" }), zf("path", { d: "M15.3504 12.6499L12.0004 15.9999L8.65039 12.6499", stroke: "white", "stroke-width": "1.5", "stroke-linecap": "round", "stroke-linejoin": "round" }));
function Fp({ version: e9 }) {
  return zf("div", { style: { textAlign: "center", color: "#BBC0C5", fontSize: "12" } }, "SDK Version ", e9 ? `v${e9}` : "unknown");
}
var zp = () => zf("svg", { width: "14", height: "14", viewBox: "0 0 16 16", fill: "none", xmlns: "http://www.w3.org/2000/svg" }, zf("rect", { width: "16", height: "16", fill: "white" }), zf("path", { "fill-rule": "evenodd", "clip-rule": "evenodd", d: "M2.40554 2.40554C2.94627 1.86482 3.82296 1.86482 4.36369 2.40554L8 6.04186L11.6363 2.40554C12.177 1.86482 13.0537 1.86482 13.5945 2.40554C14.1352 2.94627 14.1352 3.82296 13.5945 4.36369L9.95814 8L13.5945 11.6363C14.1352 12.177 14.1352 13.0537 13.5945 13.5945C13.0537 14.1352 12.177 14.1352 11.6363 13.5945L8 9.95814L4.36369 13.5945C3.82296 14.1352 2.94627 14.1352 2.40554 13.5945C1.86482 13.0537 1.86482 12.177 2.40554 11.6363L6.04186 8L2.40554 4.36369C1.86482 3.82296 1.86482 2.94627 2.40554 2.40554Z", fill: "#BBC0C5" }));
var qp = () => zf("svg", { width: "120", xmlns: "http://www.w3.org/2000/svg", fill: "none", viewBox: "0 0 127 63" }, zf("path", { fill: "currentColor", d: "M71.554 48.607v13.81h-7.072v-9.568l-8.059.945c-1.77.205-2.548.79-2.548 1.864 0 1.575 1.478 2.239 4.648 2.239 1.932 0 4.073-.29 5.963-.79l-3.66 5.225c-1.479.332-2.92.496-4.44.496-6.414 0-10.074-2.57-10.074-7.132 0-4.023 2.877-6.136 9.416-6.884l8.638-1.012c-.467-2.532-2.362-3.633-6.13-3.633-3.537 0-7.443.912-10.937 2.613l1.111-6.18c3.248-1.369 6.95-2.074 10.69-2.074 8.226 0 12.461 3.444 12.461 10.075l-.008.005ZM7.938 31.315.208 62.416h7.73l3.836-15.628 6.65 8.039h8.06l6.65-8.039 3.836 15.628h7.73l-7.73-31.105-14.518 17.388L7.934 31.311l.004.004ZM36.97.21 22.452 17.598 7.938.21.208 31.315h7.73l3.836-15.628 6.65 8.039h8.06l6.65-8.039 3.836 15.628h7.73L36.97.21Zm53.17 48.107-6.25-.912c-1.562-.247-2.178-.747-2.178-1.617 0-1.41 1.52-2.032 4.647-2.032 3.62 0 6.868.747 10.283 2.364l-.862-6.094c-2.757-.995-5.922-1.491-9.212-1.491-7.688 0-11.886 2.696-11.886 7.547 0 3.776 2.303 5.889 7.196 6.636l6.335.954c1.603.248 2.261.87 2.261 1.865 0 1.41-1.478 2.074-4.481 2.074-3.948 0-8.225-.953-11.72-2.654l.7 6.094c3.003 1.122 6.91 1.785 10.57 1.785 7.896 0 12.007-2.78 12.007-7.715 0-3.94-2.303-6.057-7.4-6.8l-.01-.004ZM100.3 34.09v28.325h7.071V34.091H100.3Zm15.334 15.595 9.833-10.744h-8.8l-9.296 11.114 9.912 12.356h8.925l-10.574-12.73v.004Zm-16.321-25.09c0 4.56 3.66 7.13 10.074 7.13 1.52 0 2.961-.167 4.44-.495l3.66-5.225c-1.89.496-4.031.79-5.963.79-3.166 0-4.648-.664-4.648-2.239 0-1.079.783-1.659 2.549-1.864l8.058-.945v9.567h7.072v-13.81c0-6.635-4.236-10.075-12.461-10.075-3.744 0-7.442.705-10.691 2.075l-1.112 6.178c3.495-1.701 7.401-2.613 10.937-2.613 3.769 0 5.664 1.1 6.13 3.633l-8.637 1.013c-6.539.747-9.417 2.86-9.417 6.883l.009-.004Zm-19.779-1.492c0 5.725 3.29 8.627 9.787 8.627 2.59 0 4.732-.416 6.785-1.37l.903-6.261c-1.974 1.2-3.99 1.822-6.005 1.822-3.044 0-4.402-1.243-4.402-4.023v-8.295h10.732V7.84H86.601V2.948l-13.448 7.174v3.482h6.372V23.1l.008.004Zm-6.95-2.612v1.411H53.47c.862 2.873 3.423 4.187 7.97 4.187 3.62 0 6.993-.747 9.992-2.196l-.862 6.056c-2.757 1.16-6.251 1.785-9.829 1.785-9.5 0-14.68-4.23-14.68-12.066 0-7.838 5.264-12.235 13.406-12.235s13.119 4.771 13.119 13.062l-.005-.004ZM53.378 17.09h12.086c-.637-2.751-2.732-4.188-6.08-4.188-3.349 0-5.335 1.399-6.006 4.188Z" }));
function Wp(e9, t3) {
  return e9.toString(2).padStart(t3, "0");
}
function Vp(e9, t3) {
  const n6 = e9 % t3;
  return n6 >= 0 ? n6 : t3 + n6;
}
function Gp(e9, t3) {
  return new Array(e9).fill(t3);
}
function Yp(...e9) {
  let t3 = 0;
  for (const n7 of e9) t3 = Math.max(t3, n7.length);
  const n6 = [];
  for (let r2 = 0; r2 < t3; r2++) for (const t4 of e9) r2 >= t4.length || n6.push(t4[r2]);
  return new Uint8Array(n6);
}
function Zp(e9, t3, n6) {
  if (n6 < 0 || n6 + t3.length > e9.length) return false;
  for (let r2 = 0; r2 < t3.length; r2++) if (t3[r2] !== e9[n6 + r2]) return false;
  return true;
}
function Jp(e9) {
  return { has: (t3) => e9.includes(t3), decode: (t3) => {
    if (!Array.isArray(t3) || t3.length && "string" != typeof t3[0]) throw new Error("alphabet.decode input should be array of strings");
    return t3.map((t4) => {
      if ("string" != typeof t4) throw new Error(`alphabet.decode: not string element=${t4}`);
      const n6 = e9.indexOf(t4);
      if (-1 === n6) throw new Error(`Unknown letter: "${t4}". Allowed: ${e9}`);
      return n6;
    });
  }, encode: (t3) => {
    if (!Array.isArray(t3) || t3.length && "number" != typeof t3[0]) throw new Error("alphabet.encode input should be an array of numbers");
    return t3.map((t4) => {
      if (function(e10) {
        if (!Number.isSafeInteger(e10)) throw new Error(`Wrong integer: ${e10}`);
      }(t4), t4 < 0 || t4 >= e9.length) throw new Error(`Digit index outside alphabet: ${t4} (alphabet: ${e9.length})`);
      return e9[t4];
    });
  } };
}
var Qp = class _Qp {
  static size(e9, t3) {
    if ("number" == typeof e9 && (e9 = { height: e9, width: e9 }), !Number.isSafeInteger(e9.height) && e9.height !== 1 / 0) throw new Error(`Bitmap: wrong height=${e9.height} (${typeof e9.height})`);
    if (!Number.isSafeInteger(e9.width) && e9.width !== 1 / 0) throw new Error(`Bitmap: wrong width=${e9.width} (${typeof e9.width})`);
    return void 0 !== t3 && (e9 = { width: Math.min(e9.width, t3.width), height: Math.min(e9.height, t3.height) }), e9;
  }
  static fromString(e9) {
    const t3 = (e9 = e9.replace(/^\n+/g, "").replace(/\n+$/g, "")).split("\n"), n6 = t3.length, r2 = new Array(n6);
    let i4;
    for (const e10 of t3) {
      const t4 = e10.split("").map((e11) => {
        if ("X" === e11) return true;
        if (" " === e11) return false;
        if ("?" !== e11) throw new Error(`Bitmap.fromString: unknown symbol=${e11}`);
      });
      if (i4 && t4.length !== i4) throw new Error(`Bitmap.fromString different row sizes: width=${i4} cur=${t4.length}`);
      i4 = t4.length, r2.push(t4);
    }
    return i4 || (i4 = 0), new _Qp({ height: n6, width: i4 }, r2);
  }
  constructor(e9, t3) {
    const { height: n6, width: r2 } = _Qp.size(e9);
    this.data = t3 || Array.from({ length: n6 }, () => Gp(r2, void 0)), this.height = n6, this.width = r2;
  }
  point(e9) {
    return this.data[e9.y][e9.x];
  }
  isInside(e9) {
    return 0 <= e9.x && e9.x < this.width && 0 <= e9.y && e9.y < this.height;
  }
  size(e9) {
    if (!e9) return { height: this.height, width: this.width };
    const { x: t3, y: n6 } = this.xy(e9);
    return { height: this.height - n6, width: this.width - t3 };
  }
  xy(e9) {
    if ("number" == typeof e9 && (e9 = { x: e9, y: e9 }), !Number.isSafeInteger(e9.x)) throw new Error(`Bitmap: wrong x=${e9.x}`);
    if (!Number.isSafeInteger(e9.y)) throw new Error(`Bitmap: wrong y=${e9.y}`);
    return e9.x = Vp(e9.x, this.width), e9.y = Vp(e9.y, this.height), e9;
  }
  rect(e9, t3, n6) {
    const { x: r2, y: i4 } = this.xy(e9), { height: o3, width: s2 } = _Qp.size(t3, this.size({ x: r2, y: i4 }));
    for (let e10 = 0; e10 < o3; e10++) for (let t4 = 0; t4 < s2; t4++) this.data[i4 + e10][r2 + t4] = "function" == typeof n6 ? n6({ x: t4, y: e10 }, this.data[i4 + e10][r2 + t4]) : n6;
    return this;
  }
  rectRead(e9, t3, n6) {
    return this.rect(e9, t3, (e10, t4) => (n6(e10, t4), t4));
  }
  hLine(e9, t3, n6) {
    return this.rect(e9, { width: t3, height: 1 }, n6);
  }
  vLine(e9, t3, n6) {
    return this.rect(e9, { width: 1, height: t3 }, n6);
  }
  border(e9 = 2, t3) {
    const n6 = this.height + 2 * e9, r2 = this.width + 2 * e9, i4 = Gp(e9, t3), o3 = Array.from({ length: e9 }, () => Gp(r2, t3));
    return new _Qp({ height: n6, width: r2 }, [...o3, ...this.data.map((e10) => [...i4, ...e10, ...i4]), ...o3]);
  }
  embed(e9, t3) {
    return this.rect(e9, t3.size(), ({ x: e10, y: n6 }) => t3.data[n6][e10]);
  }
  rectSlice(e9, t3 = this.size()) {
    const n6 = new _Qp(_Qp.size(t3, this.size(this.xy(e9))));
    return this.rect(e9, t3, ({ x: e10, y: t4 }, r2) => n6.data[t4][e10] = r2), n6;
  }
  inverse() {
    const { height: e9, width: t3 } = this;
    return new _Qp({ height: t3, width: e9 }).rect({ x: 0, y: 0 }, 1 / 0, ({ x: e10, y: t4 }) => this.data[e10][t4]);
  }
  scale(e9) {
    if (!Number.isSafeInteger(e9) || e9 > 1024) throw new Error(`Wrong scale factor: ${e9}`);
    const { height: t3, width: n6 } = this;
    return new _Qp({ height: e9 * t3, width: e9 * n6 }).rect({ x: 0, y: 0 }, 1 / 0, ({ x: t4, y: n7 }) => this.data[Math.floor(n7 / e9)][Math.floor(t4 / e9)]);
  }
  clone() {
    return new _Qp(this.size()).rect({ x: 0, y: 0 }, this.size(), ({ x: e9, y: t3 }) => this.data[t3][e9]);
  }
  assertDrawn() {
    this.rectRead(0, 1 / 0, (e9, t3) => {
      if ("boolean" != typeof t3) throw new Error("Invalid color type=" + typeof t3);
    });
  }
  toString() {
    return this.data.map((e9) => e9.map((e10) => void 0 === e10 ? "?" : e10 ? "X" : " ").join("")).join("\n");
  }
  toASCII() {
    const { height: e9, width: t3, data: n6 } = this;
    let r2 = "";
    for (let i4 = 0; i4 < e9; i4 += 2) {
      for (let o3 = 0; o3 < t3; o3++) {
        const t4 = n6[i4][o3], s2 = i4 + 1 >= e9 || n6[i4 + 1][o3];
        t4 || s2 ? !t4 && s2 ? r2 += "▀" : t4 && !s2 ? r2 += "▄" : t4 && s2 && (r2 += " ") : r2 += "█";
      }
      r2 += "\n";
    }
    return r2;
  }
  toTerm() {
    const e9 = "\x1B[0m", t3 = `\x1B[1;47m  ${e9}`, n6 = `\x1B[40m  ${e9}`;
    return this.data.map((e10) => e10.map((e11) => e11 ? n6 : t3).join("")).join("\n");
  }
  toSVG() {
    let e9 = `<svg xmlns:svg="http://www.w3.org/2000/svg" viewBox="0 0 ${this.width} ${this.height}" version="1.1" xmlns="http://www.w3.org/2000/svg">`;
    return this.rectRead(0, 1 / 0, ({ x: t3, y: n6 }, r2) => {
      r2 && (e9 += `<rect x="${t3}" y="${n6}" width="1" height="1" />`);
    }), e9 += "</svg>", e9;
  }
  toGIF() {
    const e9 = (e10) => [255 & e10, e10 >>> 8 & 255], t3 = [...e9(this.width), ...e9(this.height)], n6 = [];
    this.rectRead(0, 1 / 0, (e10, t4) => n6.push(+(true === t4)));
    const r2 = 126, i4 = [71, 73, 70, 56, 55, 97, ...t3, 246, 0, 0, 255, 255, 255, ...Gp(381, 0), 44, 0, 0, 0, 0, ...t3, 0, 7], o3 = Math.floor(n6.length / r2);
    for (let e10 = 0; e10 < o3; e10++) i4.push(127, 128, ...n6.slice(r2 * e10, r2 * (e10 + 1)).map((e11) => +e11));
    return i4.push(n6.length % r2 + 1, 128, ...n6.slice(o3 * r2).map((e10) => +e10)), i4.push(1, 129, 0, 59), new Uint8Array(i4);
  }
  toImage(e9 = false) {
    const { height: t3, width: n6 } = this.size(), r2 = new Uint8Array(t3 * n6 * (e9 ? 3 : 4));
    let i4 = 0;
    for (let o3 = 0; o3 < t3; o3++) for (let t4 = 0; t4 < n6; t4++) {
      const n7 = this.data[o3][t4] ? 0 : 255;
      r2[i4++] = n7, r2[i4++] = n7, r2[i4++] = n7, e9 || (r2[i4++] = 255);
    }
    return { height: t3, width: n6, data: r2 };
  }
};
var Xp = ["low", "medium", "quartile", "high"];
var eg = ["numeric", "alphanumeric", "byte", "kanji", "eci"];
var tg = [26, 44, 70, 100, 134, 172, 196, 242, 292, 346, 404, 466, 532, 581, 655, 733, 815, 901, 991, 1085, 1156, 1258, 1364, 1474, 1588, 1706, 1828, 1921, 2051, 2185, 2323, 2465, 2611, 2761, 2876, 3034, 3196, 3362, 3532, 3706];
var ng = { low: [7, 10, 15, 20, 26, 18, 20, 24, 30, 18, 20, 24, 26, 30, 22, 24, 28, 30, 28, 28, 28, 28, 30, 30, 26, 28, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30], medium: [10, 16, 26, 18, 24, 16, 18, 22, 22, 26, 30, 22, 22, 24, 24, 28, 28, 26, 26, 26, 26, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28], quartile: [13, 22, 18, 26, 18, 24, 18, 22, 20, 24, 28, 26, 24, 20, 30, 24, 28, 28, 26, 30, 28, 30, 30, 30, 30, 28, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30], high: [17, 28, 22, 16, 22, 28, 26, 26, 24, 28, 24, 28, 22, 24, 24, 30, 28, 28, 26, 28, 30, 24, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30] };
var rg = { low: [1, 1, 1, 1, 1, 2, 2, 2, 2, 4, 4, 4, 4, 4, 6, 6, 6, 6, 7, 8, 8, 9, 9, 10, 12, 12, 12, 13, 14, 15, 16, 17, 18, 19, 19, 20, 21, 22, 24, 25], medium: [1, 1, 1, 2, 2, 4, 4, 4, 5, 5, 5, 8, 9, 9, 10, 10, 11, 13, 14, 16, 17, 17, 18, 20, 21, 23, 25, 26, 28, 29, 31, 33, 35, 37, 38, 40, 43, 45, 47, 49], quartile: [1, 1, 2, 2, 4, 4, 6, 6, 8, 8, 8, 10, 12, 16, 12, 17, 16, 18, 21, 20, 23, 23, 25, 27, 29, 34, 34, 35, 38, 40, 43, 45, 48, 51, 53, 56, 59, 62, 65, 68], high: [1, 1, 2, 4, 4, 4, 5, 6, 8, 8, 11, 11, 16, 16, 18, 16, 19, 21, 25, 25, 25, 34, 30, 32, 35, 37, 40, 42, 45, 48, 51, 54, 57, 60, 63, 66, 70, 74, 77, 81] };
var ig = { size: { encode: (e9) => 21 + 4 * (e9 - 1), decode: (e9) => (e9 - 17) / 4 }, sizeType: (e9) => Math.floor((e9 + 7) / 17), alignmentPatterns(e9) {
  if (1 === e9) return [];
  const t3 = ig.size.encode(e9) - 6 - 1, n6 = t3 - 6, r2 = Math.ceil(n6 / 28);
  let i4 = Math.floor(n6 / r2);
  i4 % 2 ? i4 += 1 : n6 % r2 * 2 >= r2 && (i4 += 2);
  const o3 = [6];
  for (let e10 = 1; e10 < r2; e10++) o3.push(t3 - (r2 - e10) * i4);
  return o3.push(t3), o3;
}, ECCode: { low: 1, medium: 0, quartile: 3, high: 2 }, formatMask: 21522, formatBits(e9, t3) {
  const n6 = ig.ECCode[e9] << 3 | t3;
  let r2 = n6;
  for (let e10 = 0; e10 < 10; e10++) r2 = r2 << 1 ^ 1335 * (r2 >> 9);
  return (n6 << 10 | r2) ^ ig.formatMask;
}, versionBits(e9) {
  let t3 = e9;
  for (let e10 = 0; e10 < 12; e10++) t3 = t3 << 1 ^ 7973 * (t3 >> 11);
  return e9 << 12 | t3;
}, alphabet: { numeric: Jp("0123456789"), alphanumerc: Jp("0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ $%*+-./:") }, lengthBits: (e9, t3) => ({ numeric: [10, 12, 14], alphanumeric: [9, 11, 13], byte: [8, 16, 16], kanji: [8, 10, 12], eci: [0, 0, 0] })[t3][ig.sizeType(e9)], modeBits: { numeric: "0001", alphanumeric: "0010", byte: "0100", kanji: "1000", eci: "0111" }, capacity(e9, t3) {
  const n6 = tg[e9 - 1], r2 = ng[t3][e9 - 1], i4 = rg[t3][e9 - 1], o3 = Math.floor(n6 / i4) - r2, s2 = i4 - n6 % i4;
  return { words: r2, numBlocks: i4, shortBlocks: s2, blockLen: o3, capacity: 8 * (n6 - r2 * i4), total: (r2 + o3) * i4 + i4 - s2 };
} };
var og = [(e9, t3) => (e9 + t3) % 2 == 0, (e9, t3) => t3 % 2 == 0, (e9, t3) => e9 % 3 == 0, (e9, t3) => (e9 + t3) % 3 == 0, (e9, t3) => (Math.floor(t3 / 2) + Math.floor(e9 / 3)) % 2 == 0, (e9, t3) => e9 * t3 % 2 + e9 * t3 % 3 == 0, (e9, t3) => (e9 * t3 % 2 + e9 * t3 % 3) % 2 == 0, (e9, t3) => ((e9 + t3) % 2 + e9 * t3 % 3) % 2 == 0];
var sg = { tables: ((e9) => {
  const t3 = Gp(256, 0), n6 = Gp(256, 0);
  for (let e10 = 0, r2 = 1; e10 < 256; e10++) t3[e10] = r2, n6[r2] = e10, r2 <<= 1, 256 & r2 && (r2 ^= 285);
  return { exp: t3, log: n6 };
})(), exp: (e9) => sg.tables.exp[e9], log(e9) {
  if (0 === e9) throw new Error(`GF.log: wrong arg=${e9}`);
  return sg.tables.log[e9] % 255;
}, mul: (e9, t3) => 0 === e9 || 0 === t3 ? 0 : sg.tables.exp[(sg.tables.log[e9] + sg.tables.log[t3]) % 255], add: (e9, t3) => e9 ^ t3, pow: (e9, t3) => sg.tables.exp[sg.tables.log[e9] * t3 % 255], inv(e9) {
  if (0 === e9) throw new Error(`GF.inverse: wrong arg=${e9}`);
  return sg.tables.exp[255 - sg.tables.log[e9]];
}, polynomial(e9) {
  if (0 == e9.length) throw new Error("GF.polymomial: wrong length");
  if (0 !== e9[0]) return e9;
  let t3 = 0;
  for (; t3 < e9.length - 1 && 0 == e9[t3]; t3++) ;
  return e9.slice(t3);
}, monomial(e9, t3) {
  if (e9 < 0) throw new Error(`GF.monomial: wrong degree=${e9}`);
  if (0 == t3) return [0];
  let n6 = Gp(e9 + 1, 0);
  return n6[0] = t3, sg.polynomial(n6);
}, degree: (e9) => e9.length - 1, coefficient: (e9, t3) => e9[sg.degree(e9) - t3], mulPoly(e9, t3) {
  if (0 === e9[0] || 0 === t3[0]) return [0];
  const n6 = Gp(e9.length + t3.length - 1, 0);
  for (let r2 = 0; r2 < e9.length; r2++) for (let i4 = 0; i4 < t3.length; i4++) n6[r2 + i4] = sg.add(n6[r2 + i4], sg.mul(e9[r2], t3[i4]));
  return sg.polynomial(n6);
}, mulPolyScalar(e9, t3) {
  if (0 == t3) return [0];
  if (1 == t3) return e9;
  const n6 = Gp(e9.length, 0);
  for (let r2 = 0; r2 < e9.length; r2++) n6[r2] = sg.mul(e9[r2], t3);
  return sg.polynomial(n6);
}, mulPolyMonomial(e9, t3, n6) {
  if (t3 < 0) throw new Error("GF.mulPolyMonomial: wrong degree");
  if (0 == n6) return [0];
  const r2 = Gp(e9.length + t3, 0);
  for (let t4 = 0; t4 < e9.length; t4++) r2[t4] = sg.mul(e9[t4], n6);
  return sg.polynomial(r2);
}, addPoly(e9, t3) {
  if (0 === e9[0]) return t3;
  if (0 === t3[0]) return e9;
  let n6 = e9, r2 = t3;
  n6.length > r2.length && ([n6, r2] = [r2, n6]);
  let i4 = Gp(r2.length, 0), o3 = r2.length - n6.length, s2 = r2.slice(0, o3);
  for (let e10 = 0; e10 < s2.length; e10++) i4[e10] = s2[e10];
  for (let e10 = o3; e10 < r2.length; e10++) i4[e10] = sg.add(n6[e10 - o3], r2[e10]);
  return sg.polynomial(i4);
}, remainderPoly(e9, t3) {
  const n6 = Array.from(e9);
  for (let r2 = 0; r2 < e9.length - t3.length + 1; r2++) {
    const e10 = n6[r2];
    if (0 !== e10) for (let i4 = 1; i4 < t3.length; i4++) 0 !== t3[i4] && (n6[r2 + i4] = sg.add(n6[r2 + i4], sg.mul(t3[i4], e10)));
  }
  return n6.slice(e9.length - t3.length + 1, n6.length);
}, divisorPoly(e9) {
  let t3 = [1];
  for (let n6 = 0; n6 < e9; n6++) t3 = sg.mulPoly(t3, [1, sg.pow(2, n6)]);
  return t3;
}, evalPoly(e9, t3) {
  if (0 == t3) return sg.coefficient(e9, 0);
  let n6 = e9[0];
  for (let r2 = 1; r2 < e9.length; r2++) n6 = sg.add(sg.mul(t3, n6), e9[r2]);
  return n6;
}, euclidian(e9, t3, n6) {
  sg.degree(e9) < sg.degree(t3) && ([e9, t3] = [t3, e9]);
  let r2 = e9, i4 = t3, o3 = [0], s2 = [1];
  for (; 2 * sg.degree(i4) >= n6; ) {
    let e10 = r2, t4 = o3;
    if (r2 = i4, o3 = s2, 0 === r2[0]) throw new Error("rLast[0] === 0");
    i4 = e10;
    let n7 = [0];
    const a2 = sg.inv(r2[0]);
    for (; sg.degree(i4) >= sg.degree(r2) && 0 !== i4[0]; ) {
      const e11 = sg.degree(i4) - sg.degree(r2), t5 = sg.mul(i4[0], a2);
      n7 = sg.addPoly(n7, sg.monomial(e11, t5)), i4 = sg.addPoly(i4, sg.mulPolyMonomial(r2, e11, t5));
    }
    if (n7 = sg.mulPoly(n7, o3), s2 = sg.addPoly(n7, t4), sg.degree(i4) >= sg.degree(r2)) throw new Error(`Division failed r: ${i4}, rLast: ${r2}`);
  }
  const a = sg.coefficient(s2, 0);
  if (0 == a) throw new Error("sigmaTilde(0) was zero");
  const c3 = sg.inv(a);
  return [sg.mulPolyScalar(s2, c3), sg.mulPolyScalar(i4, c3)];
} };
function ag(e9, t3) {
  const { words: n6, shortBlocks: r2, numBlocks: i4, blockLen: o3, total: s2 } = ig.capacity(e9, t3), a = (c3 = n6, { encode(e10) {
    const t4 = sg.divisorPoly(c3), n7 = Array.from(e10);
    return n7.push(...t4.slice(0, -1).fill(0)), Uint8Array.from(sg.remainderPoly(n7, t4));
  }, decode(e10) {
    const t4 = e10.slice(), n7 = sg.polynomial(Array.from(e10));
    let r3 = Gp(c3, 0), i5 = false;
    for (let e11 = 0; e11 < c3; e11++) {
      const t5 = sg.evalPoly(n7, sg.exp(e11));
      r3[r3.length - 1 - e11] = t5, 0 !== t5 && (i5 = true);
    }
    if (!i5) return t4;
    r3 = sg.polynomial(r3);
    const o4 = sg.monomial(c3, 1), [s3, a2] = sg.euclidian(o4, r3, c3), l5 = Gp(sg.degree(s3), 0);
    let d3 = 0;
    for (let e11 = 1; e11 < 256 && d3 < l5.length; e11++) 0 === sg.evalPoly(s3, e11) && (l5[d3++] = sg.inv(e11));
    if (d3 !== l5.length) throw new Error("RS.decode: wrong errors number");
    for (let e11 = 0; e11 < l5.length; e11++) {
      const n8 = t4.length - 1 - sg.log(l5[e11]);
      if (n8 < 0) throw new Error("RS.decode: wrong error location");
      const r4 = sg.inv(l5[e11]);
      let i6 = 1;
      for (let t5 = 0; t5 < l5.length; t5++) e11 !== t5 && (i6 = sg.mul(i6, sg.add(1, sg.mul(l5[t5], r4))));
      t4[n8] = sg.add(t4[n8], sg.mul(sg.evalPoly(a2, r4), sg.inv(i6)));
    }
    return t4;
  } });
  var c3;
  return { encode(e10) {
    const t4 = [], n7 = [];
    for (let s4 = 0; s4 < i4; s4++) {
      const i5 = o3 + (s4 < r2 ? 0 : 1);
      t4.push(e10.subarray(0, i5)), n7.push(a.encode(e10.subarray(0, i5))), e10 = e10.subarray(i5);
    }
    const s3 = Yp(...t4), c4 = Yp(...n7), l5 = new Uint8Array(s3.length + c4.length);
    return l5.set(s3), l5.set(c4, s3.length), l5;
  }, decode(e10) {
    if (e10.length !== s2) throw new Error(`interleave.decode: len(data)=${e10.length}, total=${s2}`);
    const t4 = [];
    for (let e11 = 0; e11 < i4; e11++) {
      const i5 = e11 < r2;
      t4.push(new Uint8Array(n6 + o3 + (i5 ? 0 : 1)));
    }
    let c4 = 0;
    for (let n7 = 0; n7 < o3; n7++) for (let r3 = 0; r3 < i4; r3++) t4[r3][n7] = e10[c4++];
    for (let n7 = r2; n7 < i4; n7++) t4[n7][o3] = e10[c4++];
    for (let s3 = o3; s3 < o3 + n6; s3++) for (let n7 = 0; n7 < i4; n7++) {
      const i5 = n7 < r2;
      t4[n7][s3 + (i5 ? 0 : 1)] = e10[c4++];
    }
    const l5 = [];
    for (const e11 of t4) l5.push(...Array.from(a.decode(e11)).slice(0, -n6));
    return Uint8Array.from(l5);
  } };
}
function cg(e9, t3, n6, r2) {
  let i4 = "", o3 = n6.length;
  if ("numeric" === r2) {
    const e10 = ig.alphabet.numeric.decode(n6.split("")), t4 = e10.length;
    for (let n7 = 0; n7 < t4 - 2; n7 += 3) i4 += Wp(100 * e10[n7] + 10 * e10[n7 + 1] + e10[n7 + 2], 10);
    t4 % 3 == 1 ? i4 += Wp(e10[t4 - 1], 4) : t4 % 3 == 2 && (i4 += Wp(10 * e10[t4 - 2] + e10[t4 - 1], 7));
  } else if ("alphanumeric" === r2) {
    const e10 = ig.alphabet.alphanumerc.decode(n6.split("")), t4 = e10.length;
    for (let n7 = 0; n7 < t4 - 1; n7 += 2) i4 += Wp(45 * e10[n7] + e10[n7 + 1], 11);
    t4 % 2 == 1 && (i4 += Wp(e10[t4 - 1], 6));
  } else {
    if ("byte" !== r2) throw new Error("encode: unsupported type");
    {
      const e10 = function(e11) {
        if ("string" != typeof e11) throw new Error("utf8ToBytes expected string, got " + typeof e11);
        return new Uint8Array(new TextEncoder().encode(e11));
      }(n6);
      o3 = e10.length, i4 = Array.from(e10).map((e11) => Wp(e11, 8)).join("");
    }
  }
  const { capacity: s2 } = ig.capacity(e9, t3), a = Wp(o3, ig.lengthBits(e9, r2));
  let c3 = ig.modeBits[r2] + a + i4;
  if (c3.length > s2) throw new Error("Capacity overflow");
  c3 += "0".repeat(Math.min(4, Math.max(0, s2 - c3.length))), c3.length % 8 && (c3 += "0".repeat(8 - c3.length % 8));
  const l5 = "1110110000010001";
  for (let e10 = 0; c3.length !== s2; e10++) c3 += l5[e10 % 16];
  const d3 = Uint8Array.from(c3.match(/(.{8})/g).map((e10) => Number(`0b${e10}`)));
  return ag(e9, t3).encode(d3);
}
function lg(e9, t3, n6, r2, i4 = false) {
  const o3 = function(e10, t4, n7, r3 = false) {
    const i5 = ig.size.encode(e10);
    let o4 = new Qp(i5 + 2);
    const s3 = new Qp(3).rect(0, 3, true).border(1, false).border(1, true).border(1, false);
    o4 = o4.embed(0, s3).embed({ x: -s3.width, y: 0 }, s3).embed({ x: 0, y: -s3.height }, s3), o4 = o4.rectSlice(1, i5);
    const a2 = new Qp(1).rect(0, 1, true).border(1, false).border(1, true), c3 = ig.alignmentPatterns(e10);
    for (const e11 of c3) for (const t5 of c3) void 0 === o4.data[e11][t5] && o4.embed({ x: t5 - 2, y: e11 - 2 }, a2);
    o4 = o4.hLine({ x: 0, y: 6 }, 1 / 0, ({ x: e11 }, t5) => void 0 === t5 ? e11 % 2 == 0 : t5).vLine({ x: 6, y: 0 }, 1 / 0, ({ y: e11 }, t5) => void 0 === t5 ? e11 % 2 == 0 : t5);
    {
      const e11 = ig.formatBits(t4, n7), s4 = (t5) => !r3 && 1 == (e11 >> t5 & 1);
      for (let e12 = 0; e12 < 6; e12++) o4.data[e12][8] = s4(e12);
      for (let e12 = 6; e12 < 8; e12++) o4.data[e12 + 1][8] = s4(e12);
      for (let e12 = 8; e12 < 15; e12++) o4.data[i5 - 15 + e12][8] = s4(e12);
      for (let e12 = 0; e12 < 8; e12++) o4.data[8][i5 - e12 - 1] = s4(e12);
      for (let e12 = 8; e12 < 9; e12++) o4.data[8][15 - e12 - 1 + 1] = s4(e12);
      for (let e12 = 9; e12 < 15; e12++) o4.data[8][15 - e12 - 1] = s4(e12);
      o4.data[i5 - 8][8] = !r3;
    }
    if (e10 >= 7) {
      const t5 = ig.versionBits(e10);
      for (let e11 = 0; e11 < 18; e11 += 1) {
        const n8 = !r3 && 1 == (t5 >> e11 & 1), s4 = Math.floor(e11 / 3), a3 = e11 % 3 + i5 - 8 - 3;
        o4.data[s4][a3] = n8, o4.data[a3][s4] = n8;
      }
    }
    return o4;
  }(e9, t3, r2, i4);
  let s2 = 0;
  const a = 8 * n6.length;
  if (function(e10, t4, n7) {
    const r3 = e10.height, i5 = og[t4];
    let o4 = -1, s3 = r3 - 1;
    for (let t5 = r3 - 1; t5 > 0; t5 -= 2) {
      for (6 == t5 && (t5 = 5); ; s3 += o4) {
        for (let r4 = 0; r4 < 2; r4 += 1) {
          const o5 = t5 - r4;
          void 0 === e10.data[s3][o5] && n7(o5, s3, i5(o5, s3));
        }
        if (s3 + o4 < 0 || s3 + o4 >= r3) break;
      }
      o4 = -o4;
    }
  }(o3, r2, (e10, t4, r3) => {
    let i5 = false;
    s2 < a && (i5 = 0 != (n6[s2 >>> 3] >> (7 - s2 & 7) & 1), s2++), o3.data[t4][e10] = i5 !== r3;
  }), s2 !== a) throw new Error("QR: bytes left after draw");
  return o3;
}
function dg(e9) {
  const t3 = e9.inverse(), n6 = (e10) => {
    let t4 = 0;
    for (let n7, r3 = 0, i5 = 1; r3 < e10.length; r3++) n7 === e10[r3] && (i5++, r3 !== e10.length - 1) || (i5 >= 5 && (t4 += i5 - 5 + 3), n7 = e10[r3], i5 = 1);
    return t4;
  };
  let r2 = 0;
  e9.data.forEach((e10) => r2 += n6(e10)), t3.data.forEach((e10) => r2 += n6(e10));
  let i4 = 0, o3 = e9.data;
  const s2 = e9.width - 1, a = e9.height - 1;
  for (let e10 = 0; e10 < s2; e10++) for (let t4 = 0; t4 < a; t4++) {
    const n7 = e10 + 1, r3 = t4 + 1;
    o3[e10][t4] === o3[n7][t4] && o3[n7][t4] === o3[e10][r3] && o3[n7][t4] === o3[n7][r3] && (i4 += 3);
  }
  const c3 = (e10) => {
    const t4 = [true, false, true, true, true, false, true], n7 = [false, false, false, false], r3 = [...t4, ...n7], i5 = [...n7, ...t4];
    let o4 = 0;
    for (let t5 = 0; t5 < e10.length; t5++) Zp(e10, r3, t5) && (o4 += 40), Zp(e10, i5, t5) && (o4 += 40);
    return o4;
  };
  let l5 = 0;
  for (const t4 of e9.data) l5 += c3(t4);
  for (const e10 of t3.data) l5 += c3(e10);
  let d3 = 0;
  e9.rectRead(0, 1 / 0, (e10, t4) => d3 += t4 ? 1 : 0);
  const u2 = d3 / (e9.height * e9.width) * 100, h3 = 10 * Math.floor(Math.abs(u2 - 50) / 5);
  return r2 + i4 + l5 + h3;
}
function ug(e9, t3 = "raw", n6 = {}) {
  const r2 = void 0 !== n6.ecc ? n6.ecc : "medium";
  !function(e10) {
    if (!Xp.includes(e10)) throw new Error(`Invalid error correction mode=${e10}. Expected: ${Xp}`);
  }(r2);
  const i4 = void 0 !== n6.encoding ? n6.encoding : function(e10) {
    let t4 = "numeric";
    for (let n7 of e10) if (!ig.alphabet.numeric.has(n7) && (t4 = "alphanumeric", !ig.alphabet.alphanumerc.has(n7))) return "byte";
    return t4;
  }(e9);
  !function(e10) {
    if (!eg.includes(e10)) throw new Error(`Encoding: invalid mode=${e10}. Expected: ${eg}`);
    if ("kanji" === e10 || "eci" === e10) throw new Error(`Encoding: ${e10} is not supported (yet?).`);
  }(i4), void 0 !== n6.mask && function(e10) {
    if (![0, 1, 2, 3, 4, 5, 6, 7].includes(e10) || !og[e10]) throw new Error(`Invalid mask=${e10}. Expected number [0..7]`);
  }(n6.mask);
  let o3, s2 = n6.version, a = new Error("Unknown error");
  if (void 0 !== s2) !function(e10) {
    if (!Number.isSafeInteger(e10) || e10 < 1 || e10 > 40) throw new Error(`Invalid version=${e10}. Expected number [1..40]`);
  }(s2), o3 = cg(s2, r2, e9, i4);
  else for (let t4 = 1; t4 <= 40; t4++) try {
    o3 = cg(t4, r2, e9, i4), s2 = t4;
    break;
  } catch (e10) {
    a = e10;
  }
  if (!s2 || !o3) throw a;
  let c3 = function(e10, t4, n7, r3) {
    if (void 0 === r3) {
      const i5 = function() {
        let e11, t5 = 1 / 0;
        return { add(n8, r4) {
          n8 >= t5 || (e11 = r4, t5 = n8);
        }, get: () => e11, score: () => t5 };
      }();
      for (let r4 = 0; r4 < og.length; r4++) i5.add(dg(lg(e10, t4, n7, r4, true)), r4);
      r3 = i5.get();
    }
    if (void 0 === r3) throw new Error("Cannot find mask");
    return lg(e10, t4, n7, r3);
  }(s2, r2, o3, n6.mask);
  c3.assertDrawn();
  const l5 = void 0 === n6.border ? 2 : n6.border;
  if (!Number.isSafeInteger(l5)) throw new Error("Wrong border type=" + typeof l5);
  if (c3 = c3.border(l5, false), void 0 !== n6.scale && (c3 = c3.scale(n6.scale)), "raw" === t3) return c3.data;
  if ("ascii" === t3) return c3.toASCII();
  if ("svg" === t3) return c3.toSVG();
  if ("gif" === t3) return c3.toGIF();
  if ("term" === t3) return c3.toTerm();
  throw new Error(`Unknown output: ${t3}`);
}
var hg = { DESKTOP: "Desktop", MOBILE: "Mobile", META_MASK_MOBILE_APP: "MetaMask mobile app", SCAN_TO_CONNECT: "Scan to connect and sign with", CONNECT_WITH_EXTENSION: "Connect With MetaMask Extension", INSTALL_MODAL: { TRUSTED_BY_USERS: "Trusted by over 30 million users to buy, store, send and swap crypto securely", LEADING_CRYPTO_WALLET: "The leading crypto wallet & gateway to blockchain apps built on Ethereum Mainnet, Polygon, Optimism, and many other networks", CONTROL_DIGITAL_INTERACTIONS: "Puts you in control of your digital interactions by making power of cryptography more accessible", INSTALL_META_MASK_EXTENSION: "Install MetaMask Extension" }, PENDING_MODAL: { OPEN_META_MASK_SELECT_CODE: "Please open the MetaMask wallet app and select the code on the screen OR disconnect", OPEN_META_MASK_CONTINUE: "Open the MetaMask app to continue with your session.", NUMBER_AFTER_OPEN_NOTICE: "If a number doesn't appear after opening MetaMask, please click disconnect and re-scan the QRCode.", DISCONNECT: "Disconnect" }, SELECT_MODAL: { CRYPTO_TAKE_CONTROL_TEXT: "Take control of your crypto and explore the blockchain with the wallet trusted by over 30 million people worldwide" }, META_MASK_MODAL: { ADDRESS_COPIED: "Address copied to clipboard!", DISCONNECT: "Disconnect", ACTIVE_NETWORK: "Active Network" } };
var fg = class {
  constructor(e9) {
    var t3;
    this.translations = hg, this.supportedLocales = ["es", "fr", "he", "it", "pt", "tr"], this.baseUrl = null !== (t3 = null == e9 ? void 0 : e9.baseUrl) && void 0 !== t3 ? t3 : "https://raw.githubusercontent.com/MetaMask/metamask-sdk/refs/heads/gh-pages/locales";
  }
  getBrowserLanguage() {
    if ((navigator.languages || [navigator.language]).some((e10) => e10.toLowerCase().startsWith("en"))) return "en";
    const e9 = navigator.language.toLowerCase().split("-")[0];
    return this.supportedLocales.includes(e9) ? e9 : "en";
  }
  async init(e9) {
    const t3 = this.getBrowserLanguage() || e9.fallbackLng;
    await this.loadTranslations(t3);
  }
  async loadTranslations(e9) {
    const t3 = e9.split("-")[0];
    if ("en" !== t3 && this.supportedLocales.includes(t3)) try {
      const e10 = `${this.baseUrl}/${t3}.json`, n6 = await fetch(e10);
      if (!n6.ok) throw new Error(`HTTP error! status: ${n6.status}`);
      this.translations = await n6.json();
    } catch (e10) {
      console.warn(`❌ Failed to load ${t3} translations, falling back to English:`, e10), this.translations = hg;
    }
    else this.translations = hg;
  }
  t(e9) {
    return this.getNestedTranslation(e9, this.translations) || e9;
  }
  getNestedTranslation(e9, t3) {
    const n6 = e9.split(".");
    let r2 = t3;
    for (const e10 of n6) {
      if ("object" != typeof r2) return "";
      r2 = r2[e10];
    }
    return "string" == typeof r2 ? r2 : "";
  }
};
var pg;
!function(e9) {
  e9.SDK_MODAL_VIEWED = "sdk_modal_viewed", e9.SDK_MODAL_BUTTON_CLICKED = "sdk_modal_button_clicked", e9.SDK_MODAL_TOGGLE_CHANGED = "sdk_modal_toggle_changed";
}(pg || (pg = {}));
var gg = class {
  constructor(e9) {
    mf(this, e9), this.close = Jf(this, "close", 7), this.startDesktopOnboarding = Jf(this, "startDesktopOnboarding", 7), this.trackAnalytics = Jf(this, "trackAnalytics", 7), this.link = void 0, this.sdkVersion = void 0, this.preferDesktop = void 0, this.tab = 1, this.isDefaultTab = true, this.translationsLoaded = false, this.onClose = this.onClose.bind(this), this.onStartDesktopOnboardingHandler = this.onStartDesktopOnboardingHandler.bind(this), this.setTab = this.setTab.bind(this), this.render = this.render.bind(this), this.setTab(this.preferDesktop ? 1 : 2), this.i18nInstance = new fg();
  }
  componentDidLoad() {
    this.trackAnalytics.emit({ event: pg.SDK_MODAL_VIEWED, params: { extensionInstalled: false, tab: 1 === this.tab ? "desktop" : "mobile" } });
  }
  async connectedCallback() {
    await this.i18nInstance.init({ fallbackLng: "en" }), this.translationsLoaded = true;
  }
  updatePreferDesktop(e9) {
    e9 ? this.setTab(1) : this.setTab(2);
  }
  onClose(e9 = false) {
    this.close.emit({ shouldTerminate: e9 });
  }
  onStartDesktopOnboardingHandler() {
    this.trackAnalytics.emit({ event: pg.SDK_MODAL_BUTTON_CLICKED, params: { button_type: "install_extension", tab: "desktop" } }), this.startDesktopOnboarding.emit();
  }
  setTab(e9, t3 = false) {
    t3 && this.trackAnalytics.emit({ event: pg.SDK_MODAL_TOGGLE_CHANGED, params: { toggle: 1 === this.tab ? "desktop_to_mobile" : "mobile_to_desktop" } }), this.tab = e9, this.isDefaultTab = false;
  }
  render() {
    if (!this.translationsLoaded) return null;
    const e9 = (e10) => this.i18nInstance.t(e10), t3 = this.isDefaultTab ? this.preferDesktop ? 1 : 2 : this.tab, n6 = ug(this.link, "svg", { ecc: "medium", scale: 2 });
    return zf($p, { className: "install-model" }, zf("div", { class: "backdrop", onClick: () => this.onClose(true) }), zf("div", { class: "modal" }, zf("div", { class: "closeButtonContainer" }, zf("div", { class: "right" }, zf("span", { class: "closeButton", onClick: () => this.onClose(true) }, zf(zp, null)))), zf("div", { class: "logoContainer" }, zf(qp, null)), zf("div", null, zf("div", { class: "tabcontainer" }, zf("div", { class: "flexContainer" }, zf("div", { onClick: () => this.setTab(1, true), class: "tab flexItem " + (1 === t3 ? "tabactive" : "") }, e9("DESKTOP")), zf("div", { onClick: () => this.setTab(2, true), class: "tab flexItem " + (2 === t3 ? "tabactive" : "") }, e9("MOBILE")))), zf("div", { style: { display: 1 === t3 ? "none" : "block" } }, zf("div", { class: "flexContainer" }, zf("div", { class: "flexItem", style: { textAlign: "center", marginTop: "4" } }, n6 && zf("div", { id: "sdk-mm-qrcode", class: "center", innerHTML: n6 }), zf("div", { class: "connectMobileText" }, e9("SCAN_TO_CONNECT"), " ", zf("br", null), zf("span", { class: "blue" }, zf("b", null, e9("META_MASK_MOBILE_APP"))))))), zf("div", { style: { display: 2 === t3 ? "none" : "block" } }, zf("div", { class: "item" }, zf(Bp, { Icon: jp, text: e9("INSTALL_MODAL.TRUSTED_BY_USERS") })), zf("div", { class: "item" }, zf(Bp, { Icon: Kp, text: e9("INSTALL_MODAL.LEADING_CRYPTO_WALLET") })), zf("div", { class: "item" }, zf(Bp, { Icon: Up, text: e9("INSTALL_MODAL.CONTROL_DIGITAL_INTERACTIONS") })), zf("button", { class: "button", onClick: () => this.onStartDesktopOnboardingHandler() }, zf(Hp, null), zf("span", { class: "installExtensionText" }, e9("INSTALL_MODAL.INSTALL_META_MASK_EXTENSION"))))), zf(Fp, { version: this.sdkVersion })));
  }
  get el() {
    return Zf(this);
  }
  static get watchers() {
    return { preferDesktop: ["updatePreferDesktop"] };
  }
};
gg.style = ".flexContainer {\n    display: flex;\n    justify-content: center;\n    align-items: center;\n    flex-direction: row;\n}\n\n.flexItem {\n    flex: 1;\n    justify-content: center;\n    align-items: center;\n}\n\n.flexItem11 {\n    flex: 11;\n    justify-content: center;\n    align-items: center;\n}\n\n.flexItem1 {\n    flex: 1;\n    justify-content: center;\n    align-items: center;\n}\n\n.tab {\n    padding: 8px;\n    cursor: pointer;\n    background-color: #F2F4F6;\n    font-size: 12px;\n    text-align: center;\n    color: #24292E;\n}\n\n.tabcontainer {\n    padding: 4px;\n    background-color: #F2F4F6;\n    border-radius: 8px;\n    margin-bottom: 30px;\n    margin-top: 30px;\n}\n\n.tabactive {\n    background-color: white;\n    -webkit-transition: background-color 300ms linear;\n    -ms-transition: background-color 300ms linear;\n    transition: background-color 300ms linear;\n    border-radius: 8px;\n}\n\n.item {\n    font-size: 12px;\n    margin-bottom: 16px;\n    border-radius: 8px;\n    padding: 10px;\n    border: 2px #F2F4F6 solid;\n    color: #24292E;\n}\n\n.extensionLabel {\n    font-style: normal;\n    font-weight: bold;\n    font-size: 14px;\n    text-align: cetner;\n    color: #24272A;\n}\n\n.notice {\n    font-size: 12px;\n    margin-left: 10px;\n    margin-right: 10px;\n    color: grey;\n}\n\n.button {\n    margin-top: 41.5px;\n    margin-bottom: 20px;\n    width: 100%;\n    display: flex;\n    flex-direction: row;\n    justify-content: center;\n    align-items: center;\n    padding: 12px 20px;\n    background: #037DD6;\n    border-radius: 32px;\n    color: white;\n    border: 0;\n    font-size: 14px;\n    cursor: pointer;\n}\n\n.backdrop {\n    visibility: visible;\n    position: fixed;\n    top: 0;\n    left: 0;\n    right: 0;\n    bottom: 0;\n    width: 100%;\n    z-index: 99998;\n    background: rgba(0, 0, 0, 0.87);\n    opacity: 0.3;\n}\n\n.modal {\n    visibility: visible;\n    position: fixed;\n    left: 50%;\n    transform: translate(-50%, -50%);\n    z-index: 99999;\n    background: white;\n    padding: 20px;\n    border-radius: 8px;\n    top: 50%;\n    max-width: 100%;\n    width: 460px;\n    min-width: 300px;\n    box-shadow: rgba(0, 0, 0, 0.2) 0px 11px 15px -7px, rgba(0, 0, 0, 0.14) 0px 24px 38px 3px, rgba(0, 0, 0, 0.12) 0px 9px 46px 8px;\n    -webkit-font-smoothing: antialiased;\n}\n\n.closeButton {\n    color: #BBC0C5;\n    cursor: pointer;\n}\n\n.logoContainer {\n    margin-left: 24px;\n    margin-right: 24px;\n    margin-top: 24px;\n    display: flex;\n    align-items: center;\n    justify-content: center;\n}\n\n.connectMobileText {\n    font-size: 14px;\n    color: black;\n    margin-top: 28px;\n    margin-bottom: 28px;\n    line-height: 2;\n}\n\n.blue {\n    color: #037DD6;\n    font-weight: 700;\n}\n\n.installExtensionText {\n    margin-left: 10px;\n}\n\n.center {\n    display: flex;\n    justify-content: center;\n    align-items: center;\n}\n\n.right {\n    display: flex;\n    align-items: center;\n    justify-content: right;\n}\n\n#sdk-mm-qrcode {\n    svg {\n        width: 50%;\n    }\n}";
var mg = class {
  constructor(e9) {
    mf(this, e9), this.close = Jf(this, "close", 7), this.disconnect = Jf(this, "disconnect", 7), this.updateOTPValue = Jf(this, "updateOTPValue", 7), this.displayOTP = void 0, this.sdkVersion = void 0, this.otpCode = void 0, this.translationsLoaded = false, this.i18nInstance = new fg();
  }
  async connectedCallback() {
    await this.i18nInstance.init({ fallbackLng: "en" }), this.translationsLoaded = true;
  }
  onClose() {
    this.close.emit();
  }
  onDisconnect() {
    this.disconnect.emit();
  }
  onUpdateOTPValueHandler(e9) {
    this.updateOTPValue.emit({ otpValue: e9 });
  }
  disconnectedCallback() {
    this.onClose();
  }
  render() {
    var e9;
    if (!this.translationsLoaded) return null;
    const t3 = null === (e9 = this.displayOTP) || void 0 === e9 || e9, n6 = this.sdkVersion, r2 = (e10) => this.i18nInstance.t(e10);
    return zf($p, { className: "pending-modal" }, zf("div", { class: "backdrop", onClick: () => this.onClose() }), zf("div", { class: "modal" }, zf("div", { class: "closeButtonContainer" }, zf("div", { class: "right" }, zf("span", { class: "closeButton", onClick: () => this.onClose() }, zf(zp, null)))), zf("div", { class: "logoContainer" }, zf(qp, null)), zf("div", null, zf("div", { class: "flexContainer", style: { flexDirection: "column", color: "black" } }, zf("div", { class: "flexItem", style: { textAlign: "center", marginTop: "30px", marginBottom: "30px", fontSize: "16px" } }, r2(t3 ? "PENDING_MODAL.OPEN_META_MASK_SELECT_CODE" : "PENDING_MODAL.OPEN_META_MASK_CONTINUE")), zf("div", { id: "sdk-mm-otp-value", style: { padding: "10px", fontSize: "32px", display: this.otpCode ? "block" : "none" } }, this.otpCode), t3 && zf("div", { class: "notice" }, "* ", r2("PENDING_MODAL.NUMBER_AFTER_OPEN_NOTICE"))), zf("div", { style: { marginTop: "20px" } }, zf("button", { class: "button blue", style: { marginTop: "5px", color: "#0376C9", borderColor: "#0376C9", borderWidth: "1px", borderStyle: "solid", backgroundColor: "white" }, onClick: () => this.onDisconnect() }, r2("PENDING_MODAL.DISCONNECT")))), zf(Fp, { version: n6 })));
  }
  get el() {
    return Zf(this);
  }
};
mg.style = ".flexContainer {\n    display: flex;\n    justify-content: center;\n    align-items: center;\n    flex-direction: row;\n}\n\n.flexItem {\n    flex: 1;\n    justify-content: center;\n    align-items: center;\n}\n\n.flexItem11 {\n    flex: 11;\n    justify-content: center;\n    align-items: center;\n}\n\n.flexItem1 {\n    flex: 1;\n    justify-content: center;\n    align-items: center;\n}\n\n.tab {\n    padding: 8px;\n    cursor: pointer;\n    background-color: #F2F4F6;\n    font-size: 12px;\n    text-align: center;\n    color: #24292E;\n}\n\n.tabcontainer {\n    padding: 4px;\n    background-color: #F2F4F6;\n    border-radius: 8px;\n    margin-bottom: 30px;\n    margin-top: 30px;\n}\n\n.tabactive {\n    background-color: white;\n    -webkit-transition: background-color 300ms linear;\n    -ms-transition: background-color 300ms linear;\n    transition: background-color 300ms linear;\n    border-radius: 8px;\n}\n\n.item {\n    font-size: 12px;\n    margin-bottom: 16px;\n    border-radius: 8px;\n    padding: 10px;\n    border: 2px #F2F4F6 solid;\n    color: #24292E;\n}\n\n.extensionLabel {\n    font-style: normal;\n    font-weight: bold;\n    font-size: 14px;\n    text-align: cetner;\n    color: #24272A;\n}\n\n.notice {\n    font-size: 12px;\n    margin-left: 10px;\n    margin-right: 10px;\n    color: grey;\n}\n\n.button {\n    margin-top: 41.5px;\n    margin-bottom: 20px;\n    width: 100%;\n    display: flex;\n    flex-direction: row;\n    justify-content: center;\n    align-items: center;\n    padding: 12px 20px;\n    background: #037DD6;\n    border-radius: 32px;\n    color: white;\n    border: 0;\n    font-size: 14px;\n    cursor: pointer;\n}\n\n.backdrop {\n    visibility: visible;\n    position: fixed;\n    top: 0;\n    left: 0;\n    right: 0;\n    bottom: 0;\n    width: 100%;\n    z-index: 99998;\n    background: rgba(0, 0, 0, 0.87);\n    opacity: 0.3;\n}\n\n.modal {\n    visibility: visible;\n    position: fixed;\n    left: 50%;\n    transform: translate(-50%, -50%);\n    z-index: 99999;\n    background: white;\n    padding: 20px;\n    border-radius: 8px;\n    top: 50%;\n    max-width: 100%;\n    width: 460px;\n    min-width: 300px;\n    box-shadow: rgba(0, 0, 0, 0.2) 0px 11px 15px -7px, rgba(0, 0, 0, 0.14) 0px 24px 38px 3px, rgba(0, 0, 0, 0.12) 0px 9px 46px 8px;\n    -webkit-font-smoothing: antialiased;\n}\n\n.closeButton {\n    color: #BBC0C5;\n    cursor: pointer;\n}\n\n.logoContainer {\n    margin-left: 24px;\n    margin-right: 24px;\n    margin-top: 24px;\n    display: flex;\n    align-items: center;\n    justify-content: center;\n}\n\n.connectMobileText {\n    font-size: 14px;\n    color: black;\n    margin-top: 28px;\n    margin-bottom: 28px;\n    line-height: 2;\n}\n\n.blue {\n    color: #037DD6;\n    font-weight: 700;\n}\n\n.installExtensionText {\n    margin-left: 10px;\n}\n\n.center {\n    display: flex;\n    justify-content: center;\n    align-items: center;\n}\n\n.right {\n    display: flex;\n    align-items: center;\n    justify-content: right;\n}\n\n#sdk-mm-qrcode {\n    svg {\n        width: 50%;\n    }\n}";
var yg = () => zf("svg", { width: "21", height: "15", viewBox: "0 0 21 15", fill: "none", xmlns: "http://www.w3.org/2000/svg" }, zf("path", { d: "M14.1364 14.9851C13.5909 14.9851 13.2273 14.5851 13.2273 13.9851C13.2273 13.3851 13.5909 12.9851 14.1364 12.9851C16.6818 12.9851 18.6818 10.7851 18.6818 7.98508C18.6818 5.18508 16.6818 2.98508 14.1364 2.98508C11.5909 2.98508 9.59091 5.18508 9.59091 7.98508C9.59091 8.58508 9.22727 8.98508 8.68182 8.98508C8.13636 8.98508 7.77273 8.58508 7.77273 7.98508C7.77273 4.08508 10.5909 0.985077 14.1364 0.985077C17.6818 0.985077 20.5 4.08508 20.5 7.98508C20.5 11.8851 17.6818 14.9851 14.1364 14.9851ZM6.68182 14.7851C3.22727 14.7851 0.5 11.6851 0.5 7.98508C0.5 4.28508 3.22727 1.18508 6.68182 1.18508C7.22727 1.18508 7.59091 1.58508 7.59091 2.18508C7.59091 2.78508 7.22727 3.18508 6.68182 3.18508C4.22727 3.18508 2.31818 5.38508 2.31818 7.98508C2.31818 10.5851 4.22727 12.7851 6.68182 12.7851C9.13636 12.7851 11.0455 10.6851 11.0455 7.98508C11.0455 7.38508 11.4091 6.98508 11.9545 6.98508C12.5 6.98508 12.8636 7.38508 12.8636 7.98508C12.7727 11.6851 10.0455 14.7851 6.68182 14.7851Z", fill: "white" }));
var vg = () => zf("svg", { width: "400", height: "300", viewBox: "0 0 400 300", fill: "none", xmlns: "http://www.w3.org/2000/svg" }, zf("rect", { width: "400", height: "300", fill: "white" }), zf("path", { d: "M300.116 242.46L250.485 227.681L213.057 250.055L186.944 250.045L149.493 227.681L99.8843 242.46L84.7939 191.518L99.8843 134.979L84.7939 87.1777L99.8843 27.9336L177.402 74.2466H222.598L300.116 27.9336L315.206 87.1777L300.116 134.979L315.206 191.518L300.116 242.46Z", fill: "#FF5C16" }), zf("path", { d: "M99.8955 27.9336L177.414 74.2792L174.331 106.085L99.8955 27.9336Z", fill: "#FF5C16" }), zf("path", { d: "M149.505 191.539L183.612 217.521L149.505 227.681V191.539Z", fill: "#FF5C16" }), zf("path", { d: "M180.886 148.585L174.33 106.107L132.369 134.991L132.348 134.98V135.001L132.477 164.732L149.493 148.585H149.504H180.886Z", fill: "#FF5C16" }), zf("path", { d: "M300.116 27.9336L222.598 74.2792L225.67 106.085L300.116 27.9336Z", fill: "#FF5C16" }), zf("path", { d: "M250.508 191.539L216.4 217.521L250.508 227.681V191.539Z", fill: "#FF5C16" }), zf("path", { d: "M267.652 135.001H267.663H267.652V134.98L267.641 134.991L225.68 106.107L219.125 148.585H250.507L267.533 164.732L267.652 135.001Z", fill: "#FF5C16" }), zf("path", { d: "M149.493 227.681L99.8843 242.46L84.7939 191.54H149.493V227.681Z", fill: "#E34807" }), zf("path", { d: "M180.875 148.574L190.351 209.98L177.219 175.838L132.456 164.732L149.483 148.574H180.864H180.875Z", fill: "#E34807" }), zf("path", { d: "M250.507 227.681L300.116 242.46L315.206 191.54H250.507V227.681Z", fill: "#E34807" }), zf("path", { d: "M219.126 148.574L209.649 209.98L222.782 175.838L267.545 164.732L250.507 148.574H219.126Z", fill: "#E34807" }), zf("path", { d: "M84.7939 191.517L99.8843 134.979H132.337L132.456 164.721L177.219 175.826L190.351 209.969L183.601 217.488L149.493 191.506H84.7939V191.517Z", fill: "#FF8D5D" }), zf("path", { d: "M315.206 191.517L300.116 134.979H267.664L267.545 164.721L222.782 175.826L209.649 209.969L216.4 217.488L250.507 191.506H315.206V191.517Z", fill: "#FF8D5D" }), zf("path", { d: "M222.598 74.2466H200H177.402L174.33 106.053L190.351 209.936H209.649L225.681 106.053L222.598 74.2466Z", fill: "#FF8D5D" }), zf("path", { d: "M99.8843 27.9336L84.7939 87.1777L99.8843 134.979H132.337L174.319 106.085L99.8843 27.9336Z", fill: "#661800" }), zf("path", { d: "M171.496 160.906H156.795L148.79 168.752L177.229 175.804L171.496 160.896V160.906Z", fill: "#661800" }), zf("path", { d: "M300.116 27.9336L315.206 87.1777L300.116 134.979H267.663L225.681 106.085L300.116 27.9336Z", fill: "#661800" }), zf("path", { d: "M228.525 160.906H243.248L251.253 168.763L222.781 175.826L228.525 160.896V160.906Z", fill: "#661800" }), zf("path", { d: "M213.046 229.789L216.399 217.51L209.649 209.991H190.34L183.59 217.51L186.943 229.789", fill: "#661800" }), zf("path", { d: "M213.047 229.789V250.066H186.944V229.789H213.047Z", fill: "#C0C4CD" }), zf("path", { d: "M149.504 227.66L186.965 250.056V229.779L183.611 217.5L149.504 227.66Z", fill: "#E7EBF6" }), zf("path", { d: "M250.506 227.66L213.045 250.056V229.779L216.398 217.5L250.506 227.66Z", fill: "#E7EBF6" }));
var bg = class {
  constructor(e9) {
    mf(this, e9), this.close = Jf(this, "close", 7), this.connectWithExtension = Jf(this, "connectWithExtension", 7), this.link = void 0, this.sdkVersion = void 0, this.preferDesktop = void 0, this.tab = 1, this.isDefaultTab = true, this.translationsLoaded = false, this.i18nInstance = new fg(), this.setTab(this.preferDesktop ? 1 : 2);
  }
  async connectedCallback() {
    await this.i18nInstance.init({ fallbackLng: "en" }), this.translationsLoaded = true;
  }
  onClose(e9 = false) {
    this.close.emit({ shouldTerminate: e9 });
  }
  connectWithExtensionHandler() {
    this.connectWithExtension.emit();
  }
  setTab(e9) {
    this.tab = e9, this.isDefaultTab = false;
  }
  disconnectedCallback() {
    this.onClose();
  }
  updatePreferDesktop(e9) {
    e9 ? this.setTab(1) : this.setTab(2);
  }
  render() {
    if (!this.translationsLoaded) return null;
    const e9 = (e10) => this.i18nInstance.t(e10), t3 = this.sdkVersion, n6 = this.isDefaultTab ? this.preferDesktop ? 1 : 2 : this.tab, r2 = ug(this.link, "svg", { ecc: "medium", scale: 2 });
    return zf($p, { className: "select-modal" }, zf("div", { class: "backdrop", onClick: () => this.onClose(true) }), zf("div", { class: "modal" }, zf("div", { class: "closeButtonContainer" }, zf("div", { class: "right" }, zf("span", { class: "closeButton", onClick: () => this.onClose(true) }, zf(zp, null)))), zf("div", { class: "logoContainer" }, zf(qp, null)), zf("div", null, zf("div", { class: "tabcontainer" }, zf("div", { class: "flexContainer" }, zf("div", { onClick: () => this.setTab(1), class: "tab flexItem " + (1 === n6 ? "tabactive" : "") }, e9("DESKTOP")), zf("div", { onClick: () => this.setTab(2), class: "tab flexItem " + (2 === n6 ? "tabactive" : "") }, e9("MOBILE")))), zf("div", { style: { display: 1 === n6 ? "none" : "block" } }, zf("div", { class: "flexContainer" }, zf("div", { class: "flexItem", style: { textAlign: "center", marginTop: "4" } }, zf("div", { class: "center", id: "sdk-mm-qrcode", innerHTML: r2 }), zf("div", { class: "connectMobileText" }, e9("SCAN_TO_CONNECT"), zf("br", null), zf("span", { class: "blue" }, zf("b", null, e9("META_MASK_MOBILE_APP"))))))), zf("div", { style: { display: 2 === n6 ? "none" : "block" } }, zf("div", { style: { display: "flex", justifyContent: "center", height: "300", marginTop: "-20" } }, zf(vg, null)), zf("div", { class: "extensionLabel" }, e9("SELECT_MODAL.CRYPTO_TAKE_CONTROL_TEXT")), zf("button", { class: "button", onClick: () => this.connectWithExtensionHandler() }, zf(yg, null), zf("span", { class: "installExtensionText" }, e9("CONNECT_WITH_EXTENSION"))))), zf(Fp, { version: t3 })));
  }
  get el() {
    return Zf(this);
  }
  static get watchers() {
    return { preferDesktop: ["updatePreferDesktop"] };
  }
};
bg.style = ".flexContainer {\n    display: flex;\n    justify-content: center;\n    align-items: center;\n    flex-direction: row;\n}\n\n.flexItem {\n    flex: 1;\n    justify-content: center;\n    align-items: center;\n}\n\n.flexItem11 {\n    flex: 11;\n    justify-content: center;\n    align-items: center;\n}\n\n.flexItem1 {\n    flex: 1;\n    justify-content: center;\n    align-items: center;\n}\n\n.tab {\n    padding: 8px;\n    cursor: pointer;\n    background-color: #F2F4F6;\n    font-size: 12px;\n    text-align: center;\n    color: #24292E;\n}\n\n.tabcontainer {\n    padding: 4px;\n    background-color: #F2F4F6;\n    border-radius: 8px;\n    margin-bottom: 30px;\n    margin-top: 30px;\n}\n\n.tabactive {\n    background-color: white;\n    -webkit-transition: background-color 300ms linear;\n    -ms-transition: background-color 300ms linear;\n    transition: background-color 300ms linear;\n    border-radius: 8px;\n}\n\n.item {\n    font-size: 12px;\n    margin-bottom: 16px;\n    border-radius: 8px;\n    padding: 10px;\n    border: 2px #F2F4F6 solid;\n    color: #24292E;\n}\n\n.extensionLabel {\n    font-style: normal;\n    font-weight: bold;\n    font-size: 14px;\n    text-align: cetner;\n    color: #24272A;\n}\n\n.notice {\n    font-size: 12px;\n    margin-left: 10px;\n    margin-right: 10px;\n    color: grey;\n}\n\n.button {\n    margin-top: 41.5px;\n    margin-bottom: 20px;\n    width: 100%;\n    display: flex;\n    flex-direction: row;\n    justify-content: center;\n    align-items: center;\n    padding: 12px 20px;\n    background: #037DD6;\n    border-radius: 32px;\n    color: white;\n    border: 0;\n    font-size: 14px;\n    cursor: pointer;\n}\n\n.backdrop {\n    visibility: visible;\n    position: fixed;\n    top: 0;\n    left: 0;\n    right: 0;\n    bottom: 0;\n    width: 100%;\n    z-index: 99998;\n    background: rgba(0, 0, 0, 0.87);\n    opacity: 0.3;\n}\n\n.modal {\n    visibility: visible;\n    position: fixed;\n    left: 50%;\n    transform: translate(-50%, -50%);\n    z-index: 99999;\n    background: white;\n    padding: 20px;\n    border-radius: 8px;\n    top: 50%;\n    max-width: 100%;\n    width: 460px;\n    min-width: 300px;\n    box-shadow: rgba(0, 0, 0, 0.2) 0px 11px 15px -7px, rgba(0, 0, 0, 0.14) 0px 24px 38px 3px, rgba(0, 0, 0, 0.12) 0px 9px 46px 8px;\n    -webkit-font-smoothing: antialiased;\n}\n\n.closeButton {\n    color: #BBC0C5;\n    cursor: pointer;\n}\n\n.logoContainer {\n    margin-left: 24px;\n    margin-right: 24px;\n    margin-top: 24px;\n    display: flex;\n    align-items: center;\n    justify-content: center;\n}\n\n.connectMobileText {\n    font-size: 14px;\n    color: black;\n    margin-top: 28px;\n    margin-bottom: 28px;\n    line-height: 2;\n}\n\n.blue {\n    color: #037DD6;\n    font-weight: 700;\n}\n\n.installExtensionText {\n    margin-left: 10px;\n}\n\n.center {\n    display: flex;\n    justify-content: center;\n    align-items: center;\n}\n\n.right {\n    display: flex;\n    align-items: center;\n    justify-content: right;\n}\n\n#sdk-mm-qrcode {\n    svg {\n        width: 50%;\n    }\n}";
var wg = Object.freeze({ __proto__: null, mm_install_modal: gg, mm_pending_modal: mg, mm_select_modal: bg });

// node_modules/@solana/web3.js/lib/index.browser.esm.js
var import_buffer2 = __toESM(require_buffer());

// node_modules/@noble/hashes/esm/sha512.js
var [SHA512_Kh, SHA512_Kl] = (() => u64_default.split([
  "0x428a2f98d728ae22",
  "0x7137449123ef65cd",
  "0xb5c0fbcfec4d3b2f",
  "0xe9b5dba58189dbbc",
  "0x3956c25bf348b538",
  "0x59f111f1b605d019",
  "0x923f82a4af194f9b",
  "0xab1c5ed5da6d8118",
  "0xd807aa98a3030242",
  "0x12835b0145706fbe",
  "0x243185be4ee4b28c",
  "0x550c7dc3d5ffb4e2",
  "0x72be5d74f27b896f",
  "0x80deb1fe3b1696b1",
  "0x9bdc06a725c71235",
  "0xc19bf174cf692694",
  "0xe49b69c19ef14ad2",
  "0xefbe4786384f25e3",
  "0x0fc19dc68b8cd5b5",
  "0x240ca1cc77ac9c65",
  "0x2de92c6f592b0275",
  "0x4a7484aa6ea6e483",
  "0x5cb0a9dcbd41fbd4",
  "0x76f988da831153b5",
  "0x983e5152ee66dfab",
  "0xa831c66d2db43210",
  "0xb00327c898fb213f",
  "0xbf597fc7beef0ee4",
  "0xc6e00bf33da88fc2",
  "0xd5a79147930aa725",
  "0x06ca6351e003826f",
  "0x142929670a0e6e70",
  "0x27b70a8546d22ffc",
  "0x2e1b21385c26c926",
  "0x4d2c6dfc5ac42aed",
  "0x53380d139d95b3df",
  "0x650a73548baf63de",
  "0x766a0abb3c77b2a8",
  "0x81c2c92e47edaee6",
  "0x92722c851482353b",
  "0xa2bfe8a14cf10364",
  "0xa81a664bbc423001",
  "0xc24b8b70d0f89791",
  "0xc76c51a30654be30",
  "0xd192e819d6ef5218",
  "0xd69906245565a910",
  "0xf40e35855771202a",
  "0x106aa07032bbd1b8",
  "0x19a4c116b8d2d0c8",
  "0x1e376c085141ab53",
  "0x2748774cdf8eeb99",
  "0x34b0bcb5e19b48a8",
  "0x391c0cb3c5c95a63",
  "0x4ed8aa4ae3418acb",
  "0x5b9cca4f7763e373",
  "0x682e6ff3d6b2b8a3",
  "0x748f82ee5defb2fc",
  "0x78a5636f43172f60",
  "0x84c87814a1f0ab72",
  "0x8cc702081a6439ec",
  "0x90befffa23631e28",
  "0xa4506cebde82bde9",
  "0xbef9a3f7b2c67915",
  "0xc67178f2e372532b",
  "0xca273eceea26619c",
  "0xd186b8c721c0c207",
  "0xeada7dd6cde0eb1e",
  "0xf57d4f7fee6ed178",
  "0x06f067aa72176fba",
  "0x0a637dc5a2c898a6",
  "0x113f9804bef90dae",
  "0x1b710b35131c471b",
  "0x28db77f523047d84",
  "0x32caab7b40c72493",
  "0x3c9ebe0a15c9bebc",
  "0x431d67c49c100d4c",
  "0x4cc5d4becb3e42b6",
  "0x597f299cfc657e2a",
  "0x5fcb6fab3ad6faec",
  "0x6c44198c4a475817"
].map((n6) => BigInt(n6))))();
var SHA512_W_H = new Uint32Array(80);
var SHA512_W_L = new Uint32Array(80);
var SHA512 = class extends HashMD {
  constructor() {
    super(128, 64, 16, false);
    this.Ah = 1779033703 | 0;
    this.Al = 4089235720 | 0;
    this.Bh = 3144134277 | 0;
    this.Bl = 2227873595 | 0;
    this.Ch = 1013904242 | 0;
    this.Cl = 4271175723 | 0;
    this.Dh = 2773480762 | 0;
    this.Dl = 1595750129 | 0;
    this.Eh = 1359893119 | 0;
    this.El = 2917565137 | 0;
    this.Fh = 2600822924 | 0;
    this.Fl = 725511199 | 0;
    this.Gh = 528734635 | 0;
    this.Gl = 4215389547 | 0;
    this.Hh = 1541459225 | 0;
    this.Hl = 327033209 | 0;
  }
  // prettier-ignore
  get() {
    const { Ah: Ah2, Al: Al2, Bh: Bh2, Bl: Bl2, Ch: Ch2, Cl: Cl2, Dh: Dh2, Dl: Dl2, Eh: Eh2, El: El2, Fh: Fh2, Fl: Fl2, Gh: Gh2, Gl: Gl2, Hh: Hh2, Hl: Hl2 } = this;
    return [Ah2, Al2, Bh2, Bl2, Ch2, Cl2, Dh2, Dl2, Eh2, El2, Fh2, Fl2, Gh2, Gl2, Hh2, Hl2];
  }
  // prettier-ignore
  set(Ah2, Al2, Bh2, Bl2, Ch2, Cl2, Dh2, Dl2, Eh2, El2, Fh2, Fl2, Gh2, Gl2, Hh2, Hl2) {
    this.Ah = Ah2 | 0;
    this.Al = Al2 | 0;
    this.Bh = Bh2 | 0;
    this.Bl = Bl2 | 0;
    this.Ch = Ch2 | 0;
    this.Cl = Cl2 | 0;
    this.Dh = Dh2 | 0;
    this.Dl = Dl2 | 0;
    this.Eh = Eh2 | 0;
    this.El = El2 | 0;
    this.Fh = Fh2 | 0;
    this.Fl = Fl2 | 0;
    this.Gh = Gh2 | 0;
    this.Gl = Gl2 | 0;
    this.Hh = Hh2 | 0;
    this.Hl = Hl2 | 0;
  }
  process(view, offset2) {
    for (let i4 = 0; i4 < 16; i4++, offset2 += 4) {
      SHA512_W_H[i4] = view.getUint32(offset2);
      SHA512_W_L[i4] = view.getUint32(offset2 += 4);
    }
    for (let i4 = 16; i4 < 80; i4++) {
      const W15h = SHA512_W_H[i4 - 15] | 0;
      const W15l = SHA512_W_L[i4 - 15] | 0;
      const s0h = u64_default.rotrSH(W15h, W15l, 1) ^ u64_default.rotrSH(W15h, W15l, 8) ^ u64_default.shrSH(W15h, W15l, 7);
      const s0l = u64_default.rotrSL(W15h, W15l, 1) ^ u64_default.rotrSL(W15h, W15l, 8) ^ u64_default.shrSL(W15h, W15l, 7);
      const W2h = SHA512_W_H[i4 - 2] | 0;
      const W2l = SHA512_W_L[i4 - 2] | 0;
      const s1h = u64_default.rotrSH(W2h, W2l, 19) ^ u64_default.rotrBH(W2h, W2l, 61) ^ u64_default.shrSH(W2h, W2l, 6);
      const s1l = u64_default.rotrSL(W2h, W2l, 19) ^ u64_default.rotrBL(W2h, W2l, 61) ^ u64_default.shrSL(W2h, W2l, 6);
      const SUMl = u64_default.add4L(s0l, s1l, SHA512_W_L[i4 - 7], SHA512_W_L[i4 - 16]);
      const SUMh = u64_default.add4H(SUMl, s0h, s1h, SHA512_W_H[i4 - 7], SHA512_W_H[i4 - 16]);
      SHA512_W_H[i4] = SUMh | 0;
      SHA512_W_L[i4] = SUMl | 0;
    }
    let { Ah: Ah2, Al: Al2, Bh: Bh2, Bl: Bl2, Ch: Ch2, Cl: Cl2, Dh: Dh2, Dl: Dl2, Eh: Eh2, El: El2, Fh: Fh2, Fl: Fl2, Gh: Gh2, Gl: Gl2, Hh: Hh2, Hl: Hl2 } = this;
    for (let i4 = 0; i4 < 80; i4++) {
      const sigma1h = u64_default.rotrSH(Eh2, El2, 14) ^ u64_default.rotrSH(Eh2, El2, 18) ^ u64_default.rotrBH(Eh2, El2, 41);
      const sigma1l = u64_default.rotrSL(Eh2, El2, 14) ^ u64_default.rotrSL(Eh2, El2, 18) ^ u64_default.rotrBL(Eh2, El2, 41);
      const CHIh = Eh2 & Fh2 ^ ~Eh2 & Gh2;
      const CHIl = El2 & Fl2 ^ ~El2 & Gl2;
      const T1ll = u64_default.add5L(Hl2, sigma1l, CHIl, SHA512_Kl[i4], SHA512_W_L[i4]);
      const T1h = u64_default.add5H(T1ll, Hh2, sigma1h, CHIh, SHA512_Kh[i4], SHA512_W_H[i4]);
      const T1l = T1ll | 0;
      const sigma0h = u64_default.rotrSH(Ah2, Al2, 28) ^ u64_default.rotrBH(Ah2, Al2, 34) ^ u64_default.rotrBH(Ah2, Al2, 39);
      const sigma0l = u64_default.rotrSL(Ah2, Al2, 28) ^ u64_default.rotrBL(Ah2, Al2, 34) ^ u64_default.rotrBL(Ah2, Al2, 39);
      const MAJh = Ah2 & Bh2 ^ Ah2 & Ch2 ^ Bh2 & Ch2;
      const MAJl = Al2 & Bl2 ^ Al2 & Cl2 ^ Bl2 & Cl2;
      Hh2 = Gh2 | 0;
      Hl2 = Gl2 | 0;
      Gh2 = Fh2 | 0;
      Gl2 = Fl2 | 0;
      Fh2 = Eh2 | 0;
      Fl2 = El2 | 0;
      ({ h: Eh2, l: El2 } = u64_default.add(Dh2 | 0, Dl2 | 0, T1h | 0, T1l | 0));
      Dh2 = Ch2 | 0;
      Dl2 = Cl2 | 0;
      Ch2 = Bh2 | 0;
      Cl2 = Bl2 | 0;
      Bh2 = Ah2 | 0;
      Bl2 = Al2 | 0;
      const All = u64_default.add3L(T1l, sigma0l, MAJl);
      Ah2 = u64_default.add3H(All, T1h, sigma0h, MAJh);
      Al2 = All | 0;
    }
    ({ h: Ah2, l: Al2 } = u64_default.add(this.Ah | 0, this.Al | 0, Ah2 | 0, Al2 | 0));
    ({ h: Bh2, l: Bl2 } = u64_default.add(this.Bh | 0, this.Bl | 0, Bh2 | 0, Bl2 | 0));
    ({ h: Ch2, l: Cl2 } = u64_default.add(this.Ch | 0, this.Cl | 0, Ch2 | 0, Cl2 | 0));
    ({ h: Dh2, l: Dl2 } = u64_default.add(this.Dh | 0, this.Dl | 0, Dh2 | 0, Dl2 | 0));
    ({ h: Eh2, l: El2 } = u64_default.add(this.Eh | 0, this.El | 0, Eh2 | 0, El2 | 0));
    ({ h: Fh2, l: Fl2 } = u64_default.add(this.Fh | 0, this.Fl | 0, Fh2 | 0, Fl2 | 0));
    ({ h: Gh2, l: Gl2 } = u64_default.add(this.Gh | 0, this.Gl | 0, Gh2 | 0, Gl2 | 0));
    ({ h: Hh2, l: Hl2 } = u64_default.add(this.Hh | 0, this.Hl | 0, Hh2 | 0, Hl2 | 0));
    this.set(Ah2, Al2, Bh2, Bl2, Ch2, Cl2, Dh2, Dl2, Eh2, El2, Fh2, Fl2, Gh2, Gl2, Hh2, Hl2);
  }
  roundClean() {
    SHA512_W_H.fill(0);
    SHA512_W_L.fill(0);
  }
  destroy() {
    this.buffer.fill(0);
    this.set(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);
  }
};
var SHA512_224 = class extends SHA512 {
  constructor() {
    super();
    this.Ah = 2352822216 | 0;
    this.Al = 424955298 | 0;
    this.Bh = 1944164710 | 0;
    this.Bl = 2312950998 | 0;
    this.Ch = 502970286 | 0;
    this.Cl = 855612546 | 0;
    this.Dh = 1738396948 | 0;
    this.Dl = 1479516111 | 0;
    this.Eh = 258812777 | 0;
    this.El = 2077511080 | 0;
    this.Fh = 2011393907 | 0;
    this.Fl = 79989058 | 0;
    this.Gh = 1067287976 | 0;
    this.Gl = 1780299464 | 0;
    this.Hh = 286451373 | 0;
    this.Hl = 2446758561 | 0;
    this.outputLen = 28;
  }
};
var SHA512_256 = class extends SHA512 {
  constructor() {
    super();
    this.Ah = 573645204 | 0;
    this.Al = 4230739756 | 0;
    this.Bh = 2673172387 | 0;
    this.Bl = 3360449730 | 0;
    this.Ch = 596883563 | 0;
    this.Cl = 1867755857 | 0;
    this.Dh = 2520282905 | 0;
    this.Dl = 1497426621 | 0;
    this.Eh = 2519219938 | 0;
    this.El = 2827943907 | 0;
    this.Fh = 3193839141 | 0;
    this.Fl = 1401305490 | 0;
    this.Gh = 721525244 | 0;
    this.Gl = 746961066 | 0;
    this.Hh = 246885852 | 0;
    this.Hl = 2177182882 | 0;
    this.outputLen = 32;
  }
};
var SHA384 = class extends SHA512 {
  constructor() {
    super();
    this.Ah = 3418070365 | 0;
    this.Al = 3238371032 | 0;
    this.Bh = 1654270250 | 0;
    this.Bl = 914150663 | 0;
    this.Ch = 2438529370 | 0;
    this.Cl = 812702999 | 0;
    this.Dh = 355462360 | 0;
    this.Dl = 4144912697 | 0;
    this.Eh = 1731405415 | 0;
    this.El = 4290775857 | 0;
    this.Fh = 2394180231 | 0;
    this.Fl = 1750603025 | 0;
    this.Gh = 3675008525 | 0;
    this.Gl = 1694076839 | 0;
    this.Hh = 1203062813 | 0;
    this.Hl = 3204075428 | 0;
    this.outputLen = 48;
  }
};
var sha512 = wrapConstructor(() => new SHA512());
var sha512_224 = wrapConstructor(() => new SHA512_224());
var sha512_256 = wrapConstructor(() => new SHA512_256());
var sha384 = wrapConstructor(() => new SHA384());

// node_modules/@noble/curves/esm/abstract/edwards.js
var _0n = BigInt(0);
var _1n = BigInt(1);
var _2n = BigInt(2);
var _8n = BigInt(8);
var VERIFY_DEFAULT = { zip215: true };
function validateOpts(curve) {
  const opts = validateBasic(curve);
  validateObject(curve, {
    hash: "function",
    a: "bigint",
    d: "bigint",
    randomBytes: "function"
  }, {
    adjustScalarBytes: "function",
    domain: "function",
    uvRatio: "function",
    mapToCurve: "function"
  });
  return Object.freeze({ ...opts });
}
function twistedEdwards(curveDef) {
  const CURVE = validateOpts(curveDef);
  const { Fp: Fp3, n: CURVE_ORDER, prehash, hash: cHash, randomBytes: randomBytes2, nByteLength, h: cofactor } = CURVE;
  const MASK = _2n << BigInt(nByteLength * 8) - _1n;
  const modP = Fp3.create;
  const Fn2 = Field(CURVE.n, CURVE.nBitLength);
  const uvRatio2 = CURVE.uvRatio || ((u2, v2) => {
    try {
      return { isValid: true, value: Fp3.sqrt(u2 * Fp3.inv(v2)) };
    } catch (e9) {
      return { isValid: false, value: _0n };
    }
  });
  const adjustScalarBytes2 = CURVE.adjustScalarBytes || ((bytes) => bytes);
  const domain = CURVE.domain || ((data, ctx, phflag) => {
    abool("phflag", phflag);
    if (ctx.length || phflag)
      throw new Error("Contexts/pre-hash are not supported");
    return data;
  });
  function aCoordinate(title, n6) {
    aInRange("coordinate " + title, n6, _0n, MASK);
  }
  function assertPoint(other) {
    if (!(other instanceof Point))
      throw new Error("ExtendedPoint expected");
  }
  const toAffineMemo = memoized((p4, iz) => {
    const { ex: x3, ey: y2, ez: z3 } = p4;
    const is0 = p4.is0();
    if (iz == null)
      iz = is0 ? _8n : Fp3.inv(z3);
    const ax = modP(x3 * iz);
    const ay = modP(y2 * iz);
    const zz = modP(z3 * iz);
    if (is0)
      return { x: _0n, y: _1n };
    if (zz !== _1n)
      throw new Error("invZ was invalid");
    return { x: ax, y: ay };
  });
  const assertValidMemo = memoized((p4) => {
    const { a, d: d3 } = CURVE;
    if (p4.is0())
      throw new Error("bad point: ZERO");
    const { ex: X3, ey: Y3, ez: Z4, et: T3 } = p4;
    const X22 = modP(X3 * X3);
    const Y22 = modP(Y3 * Y3);
    const Z22 = modP(Z4 * Z4);
    const Z42 = modP(Z22 * Z22);
    const aX2 = modP(X22 * a);
    const left = modP(Z22 * modP(aX2 + Y22));
    const right = modP(Z42 + modP(d3 * modP(X22 * Y22)));
    if (left !== right)
      throw new Error("bad point: equation left != right (1)");
    const XY = modP(X3 * Y3);
    const ZT = modP(Z4 * T3);
    if (XY !== ZT)
      throw new Error("bad point: equation left != right (2)");
    return true;
  });
  class Point {
    constructor(ex, ey, ez, et3) {
      this.ex = ex;
      this.ey = ey;
      this.ez = ez;
      this.et = et3;
      aCoordinate("x", ex);
      aCoordinate("y", ey);
      aCoordinate("z", ez);
      aCoordinate("t", et3);
      Object.freeze(this);
    }
    get x() {
      return this.toAffine().x;
    }
    get y() {
      return this.toAffine().y;
    }
    static fromAffine(p4) {
      if (p4 instanceof Point)
        throw new Error("extended point not allowed");
      const { x: x3, y: y2 } = p4 || {};
      aCoordinate("x", x3);
      aCoordinate("y", y2);
      return new Point(x3, y2, _1n, modP(x3 * y2));
    }
    static normalizeZ(points) {
      const toInv = Fp3.invertBatch(points.map((p4) => p4.ez));
      return points.map((p4, i4) => p4.toAffine(toInv[i4])).map(Point.fromAffine);
    }
    // Multiscalar Multiplication
    static msm(points, scalars) {
      return pippenger(Point, Fn2, points, scalars);
    }
    // "Private method", don't use it directly
    _setWindowSize(windowSize) {
      wnaf.setWindowSize(this, windowSize);
    }
    // Not required for fromHex(), which always creates valid points.
    // Could be useful for fromAffine().
    assertValidity() {
      assertValidMemo(this);
    }
    // Compare one point to another.
    equals(other) {
      assertPoint(other);
      const { ex: X1, ey: Y1, ez: Z1 } = this;
      const { ex: X22, ey: Y22, ez: Z22 } = other;
      const X1Z2 = modP(X1 * Z22);
      const X2Z1 = modP(X22 * Z1);
      const Y1Z2 = modP(Y1 * Z22);
      const Y2Z1 = modP(Y22 * Z1);
      return X1Z2 === X2Z1 && Y1Z2 === Y2Z1;
    }
    is0() {
      return this.equals(Point.ZERO);
    }
    negate() {
      return new Point(modP(-this.ex), this.ey, this.ez, modP(-this.et));
    }
    // Fast algo for doubling Extended Point.
    // https://hyperelliptic.org/EFD/g1p/auto-twisted-extended.html#doubling-dbl-2008-hwcd
    // Cost: 4M + 4S + 1*a + 6add + 1*2.
    double() {
      const { a } = CURVE;
      const { ex: X1, ey: Y1, ez: Z1 } = this;
      const A3 = modP(X1 * X1);
      const B3 = modP(Y1 * Y1);
      const C4 = modP(_2n * modP(Z1 * Z1));
      const D3 = modP(a * A3);
      const x1y1 = X1 + Y1;
      const E4 = modP(modP(x1y1 * x1y1) - A3 - B3);
      const G4 = D3 + B3;
      const F3 = G4 - C4;
      const H3 = D3 - B3;
      const X3 = modP(E4 * F3);
      const Y3 = modP(G4 * H3);
      const T3 = modP(E4 * H3);
      const Z32 = modP(F3 * G4);
      return new Point(X3, Y3, Z32, T3);
    }
    // Fast algo for adding 2 Extended Points.
    // https://hyperelliptic.org/EFD/g1p/auto-twisted-extended.html#addition-add-2008-hwcd
    // Cost: 9M + 1*a + 1*d + 7add.
    add(other) {
      assertPoint(other);
      const { a, d: d3 } = CURVE;
      const { ex: X1, ey: Y1, ez: Z1, et: T1 } = this;
      const { ex: X22, ey: Y22, ez: Z22, et: T22 } = other;
      if (a === BigInt(-1)) {
        const A4 = modP((Y1 - X1) * (Y22 + X22));
        const B4 = modP((Y1 + X1) * (Y22 - X22));
        const F4 = modP(B4 - A4);
        if (F4 === _0n)
          return this.double();
        const C5 = modP(Z1 * _2n * T22);
        const D4 = modP(T1 * _2n * Z22);
        const E5 = D4 + C5;
        const G5 = B4 + A4;
        const H4 = D4 - C5;
        const X32 = modP(E5 * F4);
        const Y32 = modP(G5 * H4);
        const T32 = modP(E5 * H4);
        const Z33 = modP(F4 * G5);
        return new Point(X32, Y32, Z33, T32);
      }
      const A3 = modP(X1 * X22);
      const B3 = modP(Y1 * Y22);
      const C4 = modP(T1 * d3 * T22);
      const D3 = modP(Z1 * Z22);
      const E4 = modP((X1 + Y1) * (X22 + Y22) - A3 - B3);
      const F3 = D3 - C4;
      const G4 = D3 + C4;
      const H3 = modP(B3 - a * A3);
      const X3 = modP(E4 * F3);
      const Y3 = modP(G4 * H3);
      const T3 = modP(E4 * H3);
      const Z32 = modP(F3 * G4);
      return new Point(X3, Y3, Z32, T3);
    }
    subtract(other) {
      return this.add(other.negate());
    }
    wNAF(n6) {
      return wnaf.wNAFCached(this, n6, Point.normalizeZ);
    }
    // Constant-time multiplication.
    multiply(scalar) {
      const n6 = scalar;
      aInRange("scalar", n6, _1n, CURVE_ORDER);
      const { p: p4, f: f4 } = this.wNAF(n6);
      return Point.normalizeZ([p4, f4])[0];
    }
    // Non-constant-time multiplication. Uses double-and-add algorithm.
    // It's faster, but should only be used when you don't care about
    // an exposed private key e.g. sig verification.
    // Does NOT allow scalars higher than CURVE.n.
    // Accepts optional accumulator to merge with multiply (important for sparse scalars)
    multiplyUnsafe(scalar, acc = Point.ZERO) {
      const n6 = scalar;
      aInRange("scalar", n6, _0n, CURVE_ORDER);
      if (n6 === _0n)
        return I2;
      if (this.is0() || n6 === _1n)
        return this;
      return wnaf.wNAFCachedUnsafe(this, n6, Point.normalizeZ, acc);
    }
    // Checks if point is of small order.
    // If you add something to small order point, you will have "dirty"
    // point with torsion component.
    // Multiplies point by cofactor and checks if the result is 0.
    isSmallOrder() {
      return this.multiplyUnsafe(cofactor).is0();
    }
    // Multiplies point by curve order and checks if the result is 0.
    // Returns `false` is the point is dirty.
    isTorsionFree() {
      return wnaf.unsafeLadder(this, CURVE_ORDER).is0();
    }
    // Converts Extended point to default (x, y) coordinates.
    // Can accept precomputed Z^-1 - for example, from invertBatch.
    toAffine(iz) {
      return toAffineMemo(this, iz);
    }
    clearCofactor() {
      const { h: cofactor2 } = CURVE;
      if (cofactor2 === _1n)
        return this;
      return this.multiplyUnsafe(cofactor2);
    }
    // Converts hash string or Uint8Array to Point.
    // Uses algo from RFC8032 5.1.3.
    static fromHex(hex, zip215 = false) {
      const { d: d3, a } = CURVE;
      const len = Fp3.BYTES;
      hex = ensureBytes("pointHex", hex, len);
      abool("zip215", zip215);
      const normed = hex.slice();
      const lastByte = hex[len - 1];
      normed[len - 1] = lastByte & ~128;
      const y2 = bytesToNumberLE(normed);
      const max = zip215 ? MASK : Fp3.ORDER;
      aInRange("pointHex.y", y2, _0n, max);
      const y22 = modP(y2 * y2);
      const u2 = modP(y22 - _1n);
      const v2 = modP(d3 * y22 - a);
      let { isValid, value: x3 } = uvRatio2(u2, v2);
      if (!isValid)
        throw new Error("Point.fromHex: invalid y coordinate");
      const isXOdd = (x3 & _1n) === _1n;
      const isLastByteOdd = (lastByte & 128) !== 0;
      if (!zip215 && x3 === _0n && isLastByteOdd)
        throw new Error("Point.fromHex: x=0 and x_0=1");
      if (isLastByteOdd !== isXOdd)
        x3 = modP(-x3);
      return Point.fromAffine({ x: x3, y: y2 });
    }
    static fromPrivateKey(privKey) {
      return getExtendedPublicKey(privKey).point;
    }
    toRawBytes() {
      const { x: x3, y: y2 } = this.toAffine();
      const bytes = numberToBytesLE(y2, Fp3.BYTES);
      bytes[bytes.length - 1] |= x3 & _1n ? 128 : 0;
      return bytes;
    }
    toHex() {
      return bytesToHex(this.toRawBytes());
    }
  }
  Point.BASE = new Point(CURVE.Gx, CURVE.Gy, _1n, modP(CURVE.Gx * CURVE.Gy));
  Point.ZERO = new Point(_0n, _1n, _1n, _0n);
  const { BASE: G3, ZERO: I2 } = Point;
  const wnaf = wNAF(Point, nByteLength * 8);
  function modN(a) {
    return mod(a, CURVE_ORDER);
  }
  function modN_LE(hash) {
    return modN(bytesToNumberLE(hash));
  }
  function getExtendedPublicKey(key) {
    const len = Fp3.BYTES;
    key = ensureBytes("private key", key, len);
    const hashed = ensureBytes("hashed private key", cHash(key), 2 * len);
    const head = adjustScalarBytes2(hashed.slice(0, len));
    const prefix = hashed.slice(len, 2 * len);
    const scalar = modN_LE(head);
    const point = G3.multiply(scalar);
    const pointBytes = point.toRawBytes();
    return { head, prefix, scalar, point, pointBytes };
  }
  function getPublicKey2(privKey) {
    return getExtendedPublicKey(privKey).pointBytes;
  }
  function hashDomainToScalar(context = new Uint8Array(), ...msgs) {
    const msg = concatBytes(...msgs);
    return modN_LE(cHash(domain(msg, ensureBytes("context", context), !!prehash)));
  }
  function sign2(msg, privKey, options = {}) {
    msg = ensureBytes("message", msg);
    if (prehash)
      msg = prehash(msg);
    const { prefix, scalar, pointBytes } = getExtendedPublicKey(privKey);
    const r2 = hashDomainToScalar(options.context, prefix, msg);
    const R3 = G3.multiply(r2).toRawBytes();
    const k3 = hashDomainToScalar(options.context, R3, pointBytes, msg);
    const s2 = modN(r2 + k3 * scalar);
    aInRange("signature.s", s2, _0n, CURVE_ORDER);
    const res = concatBytes(R3, numberToBytesLE(s2, Fp3.BYTES));
    return ensureBytes("result", res, Fp3.BYTES * 2);
  }
  const verifyOpts = VERIFY_DEFAULT;
  function verify2(sig, msg, publicKey2, options = verifyOpts) {
    const { context, zip215 } = options;
    const len = Fp3.BYTES;
    sig = ensureBytes("signature", sig, 2 * len);
    msg = ensureBytes("message", msg);
    publicKey2 = ensureBytes("publicKey", publicKey2, len);
    if (zip215 !== void 0)
      abool("zip215", zip215);
    if (prehash)
      msg = prehash(msg);
    const s2 = bytesToNumberLE(sig.slice(len, 2 * len));
    let A3, R3, SB;
    try {
      A3 = Point.fromHex(publicKey2, zip215);
      R3 = Point.fromHex(sig.slice(0, len), zip215);
      SB = G3.multiplyUnsafe(s2);
    } catch (error) {
      return false;
    }
    if (!zip215 && A3.isSmallOrder())
      return false;
    const k3 = hashDomainToScalar(context, R3.toRawBytes(), A3.toRawBytes(), msg);
    const RkA = R3.add(A3.multiplyUnsafe(k3));
    return RkA.subtract(SB).clearCofactor().equals(Point.ZERO);
  }
  G3._setWindowSize(8);
  const utils = {
    getExtendedPublicKey,
    // ed25519 private keys are uniform 32b. No need to check for modulo bias, like in secp256k1.
    randomPrivateKey: () => randomBytes2(Fp3.BYTES),
    /**
     * We're doing scalar multiplication (used in getPublicKey etc) with precomputed BASE_POINT
     * values. This slows down first getPublicKey() by milliseconds (see Speed section),
     * but allows to speed-up subsequent getPublicKey() calls up to 20x.
     * @param windowSize 2, 4, 8, 16
     */
    precompute(windowSize = 8, point = Point.BASE) {
      point._setWindowSize(windowSize);
      point.multiply(BigInt(3));
      return point;
    }
  };
  return {
    CURVE,
    getPublicKey: getPublicKey2,
    sign: sign2,
    verify: verify2,
    ExtendedPoint: Point,
    utils
  };
}

// node_modules/@noble/curves/esm/abstract/montgomery.js
var _0n2 = BigInt(0);
var _1n2 = BigInt(1);
function validateOpts2(curve) {
  validateObject(curve, {
    a: "bigint"
  }, {
    montgomeryBits: "isSafeInteger",
    nByteLength: "isSafeInteger",
    adjustScalarBytes: "function",
    domain: "function",
    powPminus2: "function",
    Gu: "bigint"
  });
  return Object.freeze({ ...curve });
}
function montgomery(curveDef) {
  const CURVE = validateOpts2(curveDef);
  const { P: P5 } = CURVE;
  const modP = (n6) => mod(n6, P5);
  const montgomeryBits = CURVE.montgomeryBits;
  const montgomeryBytes = Math.ceil(montgomeryBits / 8);
  const fieldLen = CURVE.nByteLength;
  const adjustScalarBytes2 = CURVE.adjustScalarBytes || ((bytes) => bytes);
  const powPminus2 = CURVE.powPminus2 || ((x3) => pow(x3, P5 - BigInt(2), P5));
  function cswap(swap, x_2, x_3) {
    const dummy = modP(swap * (x_2 - x_3));
    x_2 = modP(x_2 - dummy);
    x_3 = modP(x_3 + dummy);
    return [x_2, x_3];
  }
  const a24 = (CURVE.a - BigInt(2)) / BigInt(4);
  function montgomeryLadder(u2, scalar) {
    aInRange("u", u2, _0n2, P5);
    aInRange("scalar", scalar, _0n2, P5);
    const k3 = scalar;
    const x_1 = u2;
    let x_2 = _1n2;
    let z_2 = _0n2;
    let x_3 = u2;
    let z_3 = _1n2;
    let swap = _0n2;
    let sw;
    for (let t3 = BigInt(montgomeryBits - 1); t3 >= _0n2; t3--) {
      const k_t = k3 >> t3 & _1n2;
      swap ^= k_t;
      sw = cswap(swap, x_2, x_3);
      x_2 = sw[0];
      x_3 = sw[1];
      sw = cswap(swap, z_2, z_3);
      z_2 = sw[0];
      z_3 = sw[1];
      swap = k_t;
      const A3 = x_2 + z_2;
      const AA = modP(A3 * A3);
      const B3 = x_2 - z_2;
      const BB = modP(B3 * B3);
      const E4 = AA - BB;
      const C4 = x_3 + z_3;
      const D3 = x_3 - z_3;
      const DA = modP(D3 * A3);
      const CB = modP(C4 * B3);
      const dacb = DA + CB;
      const da_cb = DA - CB;
      x_3 = modP(dacb * dacb);
      z_3 = modP(x_1 * modP(da_cb * da_cb));
      x_2 = modP(AA * BB);
      z_2 = modP(E4 * (AA + modP(a24 * E4)));
    }
    sw = cswap(swap, x_2, x_3);
    x_2 = sw[0];
    x_3 = sw[1];
    sw = cswap(swap, z_2, z_3);
    z_2 = sw[0];
    z_3 = sw[1];
    const z22 = powPminus2(z_2);
    return modP(x_2 * z22);
  }
  function encodeUCoordinate(u2) {
    return numberToBytesLE(modP(u2), montgomeryBytes);
  }
  function decodeUCoordinate(uEnc) {
    const u2 = ensureBytes("u coordinate", uEnc, montgomeryBytes);
    if (fieldLen === 32)
      u2[31] &= 127;
    return bytesToNumberLE(u2);
  }
  function decodeScalar(n6) {
    const bytes = ensureBytes("scalar", n6);
    const len = bytes.length;
    if (len !== montgomeryBytes && len !== fieldLen) {
      let valid = "" + montgomeryBytes + " or " + fieldLen;
      throw new Error("invalid scalar, expected " + valid + " bytes, got " + len);
    }
    return bytesToNumberLE(adjustScalarBytes2(bytes));
  }
  function scalarMult(scalar, u2) {
    const pointU = decodeUCoordinate(u2);
    const _scalar = decodeScalar(scalar);
    const pu2 = montgomeryLadder(pointU, _scalar);
    if (pu2 === _0n2)
      throw new Error("invalid private or public key received");
    return encodeUCoordinate(pu2);
  }
  const GuBytes = encodeUCoordinate(CURVE.Gu);
  function scalarMultBase(scalar) {
    return scalarMult(scalar, GuBytes);
  }
  return {
    scalarMult,
    scalarMultBase,
    getSharedSecret: (privateKey, publicKey2) => scalarMult(privateKey, publicKey2),
    getPublicKey: (privateKey) => scalarMultBase(privateKey),
    utils: { randomPrivateKey: () => CURVE.randomBytes(CURVE.nByteLength) },
    GuBytes
  };
}

// node_modules/@noble/curves/esm/ed25519.js
var ED25519_P = BigInt("57896044618658097711785492504343953926634992332820282019728792003956564819949");
var ED25519_SQRT_M1 = BigInt("19681161376707505956807079304988542015446066515923890162744021073123829784752");
var _0n3 = BigInt(0);
var _1n3 = BigInt(1);
var _2n2 = BigInt(2);
var _3n = BigInt(3);
var _5n = BigInt(5);
var _8n2 = BigInt(8);
function ed25519_pow_2_252_3(x3) {
  const _10n = BigInt(10), _20n = BigInt(20), _40n = BigInt(40), _80n = BigInt(80);
  const P5 = ED25519_P;
  const x22 = x3 * x3 % P5;
  const b22 = x22 * x3 % P5;
  const b4 = pow2(b22, _2n2, P5) * b22 % P5;
  const b5 = pow2(b4, _1n3, P5) * x3 % P5;
  const b10 = pow2(b5, _5n, P5) * b5 % P5;
  const b20 = pow2(b10, _10n, P5) * b10 % P5;
  const b40 = pow2(b20, _20n, P5) * b20 % P5;
  const b80 = pow2(b40, _40n, P5) * b40 % P5;
  const b160 = pow2(b80, _80n, P5) * b80 % P5;
  const b240 = pow2(b160, _80n, P5) * b80 % P5;
  const b250 = pow2(b240, _10n, P5) * b10 % P5;
  const pow_p_5_8 = pow2(b250, _2n2, P5) * x3 % P5;
  return { pow_p_5_8, b2: b22 };
}
function adjustScalarBytes(bytes) {
  bytes[0] &= 248;
  bytes[31] &= 127;
  bytes[31] |= 64;
  return bytes;
}
function uvRatio(u2, v2) {
  const P5 = ED25519_P;
  const v32 = mod(v2 * v2 * v2, P5);
  const v7 = mod(v32 * v32 * v2, P5);
  const pow3 = ed25519_pow_2_252_3(u2 * v7).pow_p_5_8;
  let x3 = mod(u2 * v32 * pow3, P5);
  const vx2 = mod(v2 * x3 * x3, P5);
  const root1 = x3;
  const root2 = mod(x3 * ED25519_SQRT_M1, P5);
  const useRoot1 = vx2 === u2;
  const useRoot2 = vx2 === mod(-u2, P5);
  const noRoot = vx2 === mod(-u2 * ED25519_SQRT_M1, P5);
  if (useRoot1)
    x3 = root1;
  if (useRoot2 || noRoot)
    x3 = root2;
  if (isNegativeLE(x3, P5))
    x3 = mod(-x3, P5);
  return { isValid: useRoot1 || useRoot2, value: x3 };
}
var Fp2 = (() => Field(ED25519_P, void 0, true))();
var ed25519Defaults = (() => ({
  // Param: a
  a: BigInt(-1),
  // Fp.create(-1) is proper; our way still works and is faster
  // d is equal to -121665/121666 over finite field.
  // Negative number is P - number, and division is invert(number, P)
  d: BigInt("37095705934669439343138083508754565189542113879843219016388785533085940283555"),
  // Finite field 𝔽p over which we'll do calculations; 2n**255n - 19n
  Fp: Fp2,
  // Subgroup order: how many points curve has
  // 2n**252n + 27742317777372353535851937790883648493n;
  n: BigInt("7237005577332262213973186563042994240857116359379907606001950938285454250989"),
  // Cofactor
  h: _8n2,
  // Base point (x, y) aka generator point
  Gx: BigInt("15112221349535400772501151409588531511454012693041857206046113283949847762202"),
  Gy: BigInt("46316835694926478169428394003475163141307993866256225615783033603165251855960"),
  hash: sha512,
  randomBytes,
  adjustScalarBytes,
  // dom2
  // Ratio of u to v. Allows us to combine inversion and square root. Uses algo from RFC8032 5.1.3.
  // Constant-time, u/√v
  uvRatio
}))();
var ed25519 = (() => twistedEdwards(ed25519Defaults))();
function ed25519_domain(data, ctx, phflag) {
  if (ctx.length > 255)
    throw new Error("Context is too big");
  return concatBytes2(utf8ToBytes("SigEd25519 no Ed25519 collisions"), new Uint8Array([phflag ? 1 : 0, ctx.length]), ctx, data);
}
var ed25519ctx = (() => twistedEdwards({
  ...ed25519Defaults,
  domain: ed25519_domain
}))();
var ed25519ph = (() => twistedEdwards(Object.assign({}, ed25519Defaults, {
  domain: ed25519_domain,
  prehash: sha512
})))();
var x25519 = (() => montgomery({
  P: ED25519_P,
  a: BigInt(486662),
  montgomeryBits: 255,
  // n is 253 bits
  nByteLength: 32,
  Gu: BigInt(9),
  powPminus2: (x3) => {
    const P5 = ED25519_P;
    const { pow_p_5_8, b2: b22 } = ed25519_pow_2_252_3(x3);
    return mod(pow2(pow_p_5_8, _3n, P5) * b22, P5);
  },
  adjustScalarBytes,
  randomBytes
}))();
var ELL2_C1 = (() => (Fp2.ORDER + _3n) / _8n2)();
var ELL2_C2 = (() => Fp2.pow(_2n2, ELL2_C1))();
var ELL2_C3 = (() => Fp2.sqrt(Fp2.neg(Fp2.ONE)))();
function map_to_curve_elligator2_curve25519(u2) {
  const ELL2_C4 = (Fp2.ORDER - _5n) / _8n2;
  const ELL2_J = BigInt(486662);
  let tv1 = Fp2.sqr(u2);
  tv1 = Fp2.mul(tv1, _2n2);
  let xd2 = Fp2.add(tv1, Fp2.ONE);
  let x1n = Fp2.neg(ELL2_J);
  let tv2 = Fp2.sqr(xd2);
  let gxd = Fp2.mul(tv2, xd2);
  let gx1 = Fp2.mul(tv1, ELL2_J);
  gx1 = Fp2.mul(gx1, x1n);
  gx1 = Fp2.add(gx1, tv2);
  gx1 = Fp2.mul(gx1, x1n);
  let tv3 = Fp2.sqr(gxd);
  tv2 = Fp2.sqr(tv3);
  tv3 = Fp2.mul(tv3, gxd);
  tv3 = Fp2.mul(tv3, gx1);
  tv2 = Fp2.mul(tv2, tv3);
  let y11 = Fp2.pow(tv2, ELL2_C4);
  y11 = Fp2.mul(y11, tv3);
  let y12 = Fp2.mul(y11, ELL2_C3);
  tv2 = Fp2.sqr(y11);
  tv2 = Fp2.mul(tv2, gxd);
  let e1 = Fp2.eql(tv2, gx1);
  let y1 = Fp2.cmov(y12, y11, e1);
  let x2n = Fp2.mul(x1n, tv1);
  let y21 = Fp2.mul(y11, u2);
  y21 = Fp2.mul(y21, ELL2_C2);
  let y22 = Fp2.mul(y21, ELL2_C3);
  let gx2 = Fp2.mul(gx1, tv1);
  tv2 = Fp2.sqr(y21);
  tv2 = Fp2.mul(tv2, gxd);
  let e22 = Fp2.eql(tv2, gx2);
  let y2 = Fp2.cmov(y22, y21, e22);
  tv2 = Fp2.sqr(y1);
  tv2 = Fp2.mul(tv2, gxd);
  let e32 = Fp2.eql(tv2, gx1);
  let xn2 = Fp2.cmov(x2n, x1n, e32);
  let y3 = Fp2.cmov(y2, y1, e32);
  let e42 = Fp2.isOdd(y3);
  y3 = Fp2.cmov(y3, Fp2.neg(y3), e32 !== e42);
  return { xMn: xn2, xMd: xd2, yMn: y3, yMd: _1n3 };
}
var ELL2_C1_EDWARDS = (() => FpSqrtEven(Fp2, Fp2.neg(BigInt(486664))))();
function map_to_curve_elligator2_edwards25519(u2) {
  const { xMn, xMd, yMn, yMd } = map_to_curve_elligator2_curve25519(u2);
  let xn2 = Fp2.mul(xMn, yMd);
  xn2 = Fp2.mul(xn2, ELL2_C1_EDWARDS);
  let xd2 = Fp2.mul(xMd, yMn);
  let yn2 = Fp2.sub(xMn, xMd);
  let yd2 = Fp2.add(xMn, xMd);
  let tv1 = Fp2.mul(xd2, yd2);
  let e9 = Fp2.eql(tv1, Fp2.ZERO);
  xn2 = Fp2.cmov(xn2, Fp2.ZERO, e9);
  xd2 = Fp2.cmov(xd2, Fp2.ONE, e9);
  yn2 = Fp2.cmov(yn2, Fp2.ONE, e9);
  yd2 = Fp2.cmov(yd2, Fp2.ONE, e9);
  const inv = Fp2.invertBatch([xd2, yd2]);
  return { x: Fp2.mul(xn2, inv[0]), y: Fp2.mul(yn2, inv[1]) };
}
var htf = (() => createHasher(ed25519.ExtendedPoint, (scalars) => map_to_curve_elligator2_edwards25519(scalars[0]), {
  DST: "edwards25519_XMD:SHA-512_ELL2_RO_",
  encodeDST: "edwards25519_XMD:SHA-512_ELL2_NU_",
  p: Fp2.ORDER,
  m: 1,
  k: 128,
  expand: "xmd",
  hash: sha512
}))();
var hashToCurve = (() => htf.hashToCurve)();
var encodeToCurve = (() => htf.encodeToCurve)();
function assertRstPoint(other) {
  if (!(other instanceof RistPoint))
    throw new Error("RistrettoPoint expected");
}
var SQRT_M1 = ED25519_SQRT_M1;
var SQRT_AD_MINUS_ONE = BigInt("25063068953384623474111414158702152701244531502492656460079210482610430750235");
var INVSQRT_A_MINUS_D = BigInt("54469307008909316920995813868745141605393597292927456921205312896311721017578");
var ONE_MINUS_D_SQ = BigInt("1159843021668779879193775521855586647937357759715417654439879720876111806838");
var D_MINUS_ONE_SQ = BigInt("40440834346308536858101042469323190826248399146238708352240133220865137265952");
var invertSqrt = (number2) => uvRatio(_1n3, number2);
var MAX_255B = BigInt("0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff");
var bytes255ToNumberLE = (bytes) => ed25519.CURVE.Fp.create(bytesToNumberLE(bytes) & MAX_255B);
function calcElligatorRistrettoMap(r0) {
  const { d: d3 } = ed25519.CURVE;
  const P5 = ed25519.CURVE.Fp.ORDER;
  const mod2 = ed25519.CURVE.Fp.create;
  const r2 = mod2(SQRT_M1 * r0 * r0);
  const Ns2 = mod2((r2 + _1n3) * ONE_MINUS_D_SQ);
  let c3 = BigInt(-1);
  const D3 = mod2((c3 - d3 * r2) * mod2(r2 + d3));
  let { isValid: Ns_D_is_sq, value: s2 } = uvRatio(Ns2, D3);
  let s_ = mod2(s2 * r0);
  if (!isNegativeLE(s_, P5))
    s_ = mod2(-s_);
  if (!Ns_D_is_sq)
    s2 = s_;
  if (!Ns_D_is_sq)
    c3 = r2;
  const Nt3 = mod2(c3 * (r2 - _1n3) * D_MINUS_ONE_SQ - D3);
  const s22 = s2 * s2;
  const W0 = mod2((s2 + s2) * D3);
  const W1 = mod2(Nt3 * SQRT_AD_MINUS_ONE);
  const W22 = mod2(_1n3 - s22);
  const W3 = mod2(_1n3 + s22);
  return new ed25519.ExtendedPoint(mod2(W0 * W3), mod2(W22 * W1), mod2(W1 * W3), mod2(W0 * W22));
}
var RistPoint = class _RistPoint {
  // Private property to discourage combining ExtendedPoint + RistrettoPoint
  // Always use Ristretto encoding/decoding instead.
  constructor(ep2) {
    this.ep = ep2;
  }
  static fromAffine(ap2) {
    return new _RistPoint(ed25519.ExtendedPoint.fromAffine(ap2));
  }
  /**
   * Takes uniform output of 64-byte hash function like sha512 and converts it to `RistrettoPoint`.
   * The hash-to-group operation applies Elligator twice and adds the results.
   * **Note:** this is one-way map, there is no conversion from point to hash.
   * https://ristretto.group/formulas/elligator.html
   * @param hex 64-byte output of a hash function
   */
  static hashToCurve(hex) {
    hex = ensureBytes("ristrettoHash", hex, 64);
    const r1 = bytes255ToNumberLE(hex.slice(0, 32));
    const R1 = calcElligatorRistrettoMap(r1);
    const r2 = bytes255ToNumberLE(hex.slice(32, 64));
    const R22 = calcElligatorRistrettoMap(r2);
    return new _RistPoint(R1.add(R22));
  }
  /**
   * Converts ristretto-encoded string to ristretto point.
   * https://ristretto.group/formulas/decoding.html
   * @param hex Ristretto-encoded 32 bytes. Not every 32-byte string is valid ristretto encoding
   */
  static fromHex(hex) {
    hex = ensureBytes("ristrettoHex", hex, 32);
    const { a, d: d3 } = ed25519.CURVE;
    const P5 = ed25519.CURVE.Fp.ORDER;
    const mod2 = ed25519.CURVE.Fp.create;
    const emsg = "RistrettoPoint.fromHex: the hex is not valid encoding of RistrettoPoint";
    const s2 = bytes255ToNumberLE(hex);
    if (!equalBytes(numberToBytesLE(s2, 32), hex) || isNegativeLE(s2, P5))
      throw new Error(emsg);
    const s22 = mod2(s2 * s2);
    const u1 = mod2(_1n3 + a * s22);
    const u2 = mod2(_1n3 - a * s22);
    const u1_2 = mod2(u1 * u1);
    const u2_2 = mod2(u2 * u2);
    const v2 = mod2(a * d3 * u1_2 - u2_2);
    const { isValid, value: I2 } = invertSqrt(mod2(v2 * u2_2));
    const Dx = mod2(I2 * u2);
    const Dy = mod2(I2 * Dx * v2);
    let x3 = mod2((s2 + s2) * Dx);
    if (isNegativeLE(x3, P5))
      x3 = mod2(-x3);
    const y2 = mod2(u1 * Dy);
    const t3 = mod2(x3 * y2);
    if (!isValid || isNegativeLE(t3, P5) || y2 === _0n3)
      throw new Error(emsg);
    return new _RistPoint(new ed25519.ExtendedPoint(x3, y2, _1n3, t3));
  }
  /**
   * Encodes ristretto point to Uint8Array.
   * https://ristretto.group/formulas/encoding.html
   */
  toRawBytes() {
    let { ex: x3, ey: y2, ez: z3, et: t3 } = this.ep;
    const P5 = ed25519.CURVE.Fp.ORDER;
    const mod2 = ed25519.CURVE.Fp.create;
    const u1 = mod2(mod2(z3 + y2) * mod2(z3 - y2));
    const u2 = mod2(x3 * y2);
    const u2sq = mod2(u2 * u2);
    const { value: invsqrt } = invertSqrt(mod2(u1 * u2sq));
    const D1 = mod2(invsqrt * u1);
    const D22 = mod2(invsqrt * u2);
    const zInv = mod2(D1 * D22 * t3);
    let D3;
    if (isNegativeLE(t3 * zInv, P5)) {
      let _x = mod2(y2 * SQRT_M1);
      let _y = mod2(x3 * SQRT_M1);
      x3 = _x;
      y2 = _y;
      D3 = mod2(D1 * INVSQRT_A_MINUS_D);
    } else {
      D3 = D22;
    }
    if (isNegativeLE(x3 * zInv, P5))
      y2 = mod2(-y2);
    let s2 = mod2((z3 - y2) * D3);
    if (isNegativeLE(s2, P5))
      s2 = mod2(-s2);
    return numberToBytesLE(s2, 32);
  }
  toHex() {
    return bytesToHex(this.toRawBytes());
  }
  toString() {
    return this.toHex();
  }
  // Compare one point to another.
  equals(other) {
    assertRstPoint(other);
    const { ex: X1, ey: Y1 } = this.ep;
    const { ex: X22, ey: Y22 } = other.ep;
    const mod2 = ed25519.CURVE.Fp.create;
    const one = mod2(X1 * Y22) === mod2(Y1 * X22);
    const two = mod2(Y1 * Y22) === mod2(X1 * X22);
    return one || two;
  }
  add(other) {
    assertRstPoint(other);
    return new _RistPoint(this.ep.add(other.ep));
  }
  subtract(other) {
    assertRstPoint(other);
    return new _RistPoint(this.ep.subtract(other.ep));
  }
  multiply(scalar) {
    return new _RistPoint(this.ep.multiply(scalar));
  }
  multiplyUnsafe(scalar) {
    return new _RistPoint(this.ep.multiplyUnsafe(scalar));
  }
  double() {
    return new _RistPoint(this.ep.double());
  }
  negate() {
    return new _RistPoint(this.ep.negate());
  }
};
var RistrettoPoint = (() => {
  if (!RistPoint.BASE)
    RistPoint.BASE = new RistPoint(ed25519.ExtendedPoint.BASE);
  if (!RistPoint.ZERO)
    RistPoint.ZERO = new RistPoint(ed25519.ExtendedPoint.ZERO);
  return RistPoint;
})();

// node_modules/@solana/web3.js/lib/index.browser.esm.js
var import_bn = __toESM(require_bn());
var import_bs58 = __toESM(require_bs58());
var import_borsh = __toESM(require_lib());
var BufferLayout = __toESM(require_Layout());
var import_buffer_layout = __toESM(require_Layout());

// node_modules/@solana/errors/dist/index.browser.mjs
var SOLANA_ERROR__BLOCK_HEIGHT_EXCEEDED = 1;
var SOLANA_ERROR__INVALID_NONCE = 2;
var SOLANA_ERROR__NONCE_ACCOUNT_NOT_FOUND = 3;
var SOLANA_ERROR__BLOCKHASH_STRING_LENGTH_OUT_OF_RANGE = 4;
var SOLANA_ERROR__INVALID_BLOCKHASH_BYTE_LENGTH = 5;
var SOLANA_ERROR__LAMPORTS_OUT_OF_RANGE = 6;
var SOLANA_ERROR__MALFORMED_BIGINT_STRING = 7;
var SOLANA_ERROR__MALFORMED_NUMBER_STRING = 8;
var SOLANA_ERROR__TIMESTAMP_OUT_OF_RANGE = 9;
var SOLANA_ERROR__MALFORMED_JSON_RPC_ERROR = 10;
var SOLANA_ERROR__JSON_RPC__PARSE_ERROR = -32700;
var SOLANA_ERROR__JSON_RPC__INTERNAL_ERROR = -32603;
var SOLANA_ERROR__JSON_RPC__INVALID_PARAMS = -32602;
var SOLANA_ERROR__JSON_RPC__METHOD_NOT_FOUND = -32601;
var SOLANA_ERROR__JSON_RPC__INVALID_REQUEST = -32600;
var SOLANA_ERROR__JSON_RPC__SERVER_ERROR_MIN_CONTEXT_SLOT_NOT_REACHED = -32016;
var SOLANA_ERROR__JSON_RPC__SERVER_ERROR_UNSUPPORTED_TRANSACTION_VERSION = -32015;
var SOLANA_ERROR__JSON_RPC__SERVER_ERROR_BLOCK_STATUS_NOT_AVAILABLE_YET = -32014;
var SOLANA_ERROR__JSON_RPC__SERVER_ERROR_TRANSACTION_SIGNATURE_LEN_MISMATCH = -32013;
var SOLANA_ERROR__JSON_RPC__SCAN_ERROR = -32012;
var SOLANA_ERROR__JSON_RPC__SERVER_ERROR_TRANSACTION_HISTORY_NOT_AVAILABLE = -32011;
var SOLANA_ERROR__JSON_RPC__SERVER_ERROR_KEY_EXCLUDED_FROM_SECONDARY_INDEX = -32010;
var SOLANA_ERROR__JSON_RPC__SERVER_ERROR_LONG_TERM_STORAGE_SLOT_SKIPPED = -32009;
var SOLANA_ERROR__JSON_RPC__SERVER_ERROR_NO_SNAPSHOT = -32008;
var SOLANA_ERROR__JSON_RPC__SERVER_ERROR_SLOT_SKIPPED = -32007;
var SOLANA_ERROR__JSON_RPC__SERVER_ERROR_TRANSACTION_PRECOMPILE_VERIFICATION_FAILURE = -32006;
var SOLANA_ERROR__JSON_RPC__SERVER_ERROR_NODE_UNHEALTHY = -32005;
var SOLANA_ERROR__JSON_RPC__SERVER_ERROR_BLOCK_NOT_AVAILABLE = -32004;
var SOLANA_ERROR__JSON_RPC__SERVER_ERROR_TRANSACTION_SIGNATURE_VERIFICATION_FAILURE = -32003;
var SOLANA_ERROR__JSON_RPC__SERVER_ERROR_SEND_TRANSACTION_PREFLIGHT_FAILURE = -32002;
var SOLANA_ERROR__JSON_RPC__SERVER_ERROR_BLOCK_CLEANED_UP = -32001;
var SOLANA_ERROR__ADDRESSES__INVALID_BYTE_LENGTH = 28e5;
var SOLANA_ERROR__ADDRESSES__STRING_LENGTH_OUT_OF_RANGE = 2800001;
var SOLANA_ERROR__ADDRESSES__INVALID_BASE58_ENCODED_ADDRESS = 2800002;
var SOLANA_ERROR__ADDRESSES__INVALID_ED25519_PUBLIC_KEY = 2800003;
var SOLANA_ERROR__ADDRESSES__MALFORMED_PDA = 2800004;
var SOLANA_ERROR__ADDRESSES__PDA_BUMP_SEED_OUT_OF_RANGE = 2800005;
var SOLANA_ERROR__ADDRESSES__MAX_NUMBER_OF_PDA_SEEDS_EXCEEDED = 2800006;
var SOLANA_ERROR__ADDRESSES__MAX_PDA_SEED_LENGTH_EXCEEDED = 2800007;
var SOLANA_ERROR__ADDRESSES__INVALID_SEEDS_POINT_ON_CURVE = 2800008;
var SOLANA_ERROR__ADDRESSES__FAILED_TO_FIND_VIABLE_PDA_BUMP_SEED = 2800009;
var SOLANA_ERROR__ADDRESSES__PDA_ENDS_WITH_PDA_MARKER = 2800010;
var SOLANA_ERROR__ACCOUNTS__ACCOUNT_NOT_FOUND = 323e4;
var SOLANA_ERROR__ACCOUNTS__ONE_OR_MORE_ACCOUNTS_NOT_FOUND = 32300001;
var SOLANA_ERROR__ACCOUNTS__FAILED_TO_DECODE_ACCOUNT = 3230002;
var SOLANA_ERROR__ACCOUNTS__EXPECTED_DECODED_ACCOUNT = 3230003;
var SOLANA_ERROR__ACCOUNTS__EXPECTED_ALL_ACCOUNTS_TO_BE_DECODED = 3230004;
var SOLANA_ERROR__SUBTLE_CRYPTO__DISALLOWED_IN_INSECURE_CONTEXT = 361e4;
var SOLANA_ERROR__SUBTLE_CRYPTO__DIGEST_UNIMPLEMENTED = 3610001;
var SOLANA_ERROR__SUBTLE_CRYPTO__ED25519_ALGORITHM_UNIMPLEMENTED = 3610002;
var SOLANA_ERROR__SUBTLE_CRYPTO__EXPORT_FUNCTION_UNIMPLEMENTED = 3610003;
var SOLANA_ERROR__SUBTLE_CRYPTO__GENERATE_FUNCTION_UNIMPLEMENTED = 3610004;
var SOLANA_ERROR__SUBTLE_CRYPTO__SIGN_FUNCTION_UNIMPLEMENTED = 3610005;
var SOLANA_ERROR__SUBTLE_CRYPTO__VERIFY_FUNCTION_UNIMPLEMENTED = 3610006;
var SOLANA_ERROR__SUBTLE_CRYPTO__CANNOT_EXPORT_NON_EXTRACTABLE_KEY = 3610007;
var SOLANA_ERROR__CRYPTO__RANDOM_VALUES_FUNCTION_UNIMPLEMENTED = 3611e3;
var SOLANA_ERROR__KEYS__INVALID_KEY_PAIR_BYTE_LENGTH = 3704e3;
var SOLANA_ERROR__KEYS__INVALID_PRIVATE_KEY_BYTE_LENGTH = 3704001;
var SOLANA_ERROR__KEYS__INVALID_SIGNATURE_BYTE_LENGTH = 3704002;
var SOLANA_ERROR__KEYS__SIGNATURE_STRING_LENGTH_OUT_OF_RANGE = 3704003;
var SOLANA_ERROR__KEYS__PUBLIC_KEY_MUST_MATCH_PRIVATE_KEY = 3704004;
var SOLANA_ERROR__INSTRUCTION__EXPECTED_TO_HAVE_ACCOUNTS = 4128e3;
var SOLANA_ERROR__INSTRUCTION__EXPECTED_TO_HAVE_DATA = 4128001;
var SOLANA_ERROR__INSTRUCTION__PROGRAM_ID_MISMATCH = 4128002;
var SOLANA_ERROR__INSTRUCTION_ERROR__UNKNOWN = 4615e3;
var SOLANA_ERROR__INSTRUCTION_ERROR__GENERIC_ERROR = 4615001;
var SOLANA_ERROR__INSTRUCTION_ERROR__INVALID_ARGUMENT = 4615002;
var SOLANA_ERROR__INSTRUCTION_ERROR__INVALID_INSTRUCTION_DATA = 4615003;
var SOLANA_ERROR__INSTRUCTION_ERROR__INVALID_ACCOUNT_DATA = 4615004;
var SOLANA_ERROR__INSTRUCTION_ERROR__ACCOUNT_DATA_TOO_SMALL = 4615005;
var SOLANA_ERROR__INSTRUCTION_ERROR__INSUFFICIENT_FUNDS = 4615006;
var SOLANA_ERROR__INSTRUCTION_ERROR__INCORRECT_PROGRAM_ID = 4615007;
var SOLANA_ERROR__INSTRUCTION_ERROR__MISSING_REQUIRED_SIGNATURE = 4615008;
var SOLANA_ERROR__INSTRUCTION_ERROR__ACCOUNT_ALREADY_INITIALIZED = 4615009;
var SOLANA_ERROR__INSTRUCTION_ERROR__UNINITIALIZED_ACCOUNT = 4615010;
var SOLANA_ERROR__INSTRUCTION_ERROR__UNBALANCED_INSTRUCTION = 4615011;
var SOLANA_ERROR__INSTRUCTION_ERROR__MODIFIED_PROGRAM_ID = 4615012;
var SOLANA_ERROR__INSTRUCTION_ERROR__EXTERNAL_ACCOUNT_LAMPORT_SPEND = 4615013;
var SOLANA_ERROR__INSTRUCTION_ERROR__EXTERNAL_ACCOUNT_DATA_MODIFIED = 4615014;
var SOLANA_ERROR__INSTRUCTION_ERROR__READONLY_LAMPORT_CHANGE = 4615015;
var SOLANA_ERROR__INSTRUCTION_ERROR__READONLY_DATA_MODIFIED = 4615016;
var SOLANA_ERROR__INSTRUCTION_ERROR__DUPLICATE_ACCOUNT_INDEX = 4615017;
var SOLANA_ERROR__INSTRUCTION_ERROR__EXECUTABLE_MODIFIED = 4615018;
var SOLANA_ERROR__INSTRUCTION_ERROR__RENT_EPOCH_MODIFIED = 4615019;
var SOLANA_ERROR__INSTRUCTION_ERROR__NOT_ENOUGH_ACCOUNT_KEYS = 4615020;
var SOLANA_ERROR__INSTRUCTION_ERROR__ACCOUNT_DATA_SIZE_CHANGED = 4615021;
var SOLANA_ERROR__INSTRUCTION_ERROR__ACCOUNT_NOT_EXECUTABLE = 4615022;
var SOLANA_ERROR__INSTRUCTION_ERROR__ACCOUNT_BORROW_FAILED = 4615023;
var SOLANA_ERROR__INSTRUCTION_ERROR__ACCOUNT_BORROW_OUTSTANDING = 4615024;
var SOLANA_ERROR__INSTRUCTION_ERROR__DUPLICATE_ACCOUNT_OUT_OF_SYNC = 4615025;
var SOLANA_ERROR__INSTRUCTION_ERROR__CUSTOM = 4615026;
var SOLANA_ERROR__INSTRUCTION_ERROR__INVALID_ERROR = 4615027;
var SOLANA_ERROR__INSTRUCTION_ERROR__EXECUTABLE_DATA_MODIFIED = 4615028;
var SOLANA_ERROR__INSTRUCTION_ERROR__EXECUTABLE_LAMPORT_CHANGE = 4615029;
var SOLANA_ERROR__INSTRUCTION_ERROR__EXECUTABLE_ACCOUNT_NOT_RENT_EXEMPT = 4615030;
var SOLANA_ERROR__INSTRUCTION_ERROR__UNSUPPORTED_PROGRAM_ID = 4615031;
var SOLANA_ERROR__INSTRUCTION_ERROR__CALL_DEPTH = 4615032;
var SOLANA_ERROR__INSTRUCTION_ERROR__MISSING_ACCOUNT = 4615033;
var SOLANA_ERROR__INSTRUCTION_ERROR__REENTRANCY_NOT_ALLOWED = 4615034;
var SOLANA_ERROR__INSTRUCTION_ERROR__MAX_SEED_LENGTH_EXCEEDED = 4615035;
var SOLANA_ERROR__INSTRUCTION_ERROR__INVALID_SEEDS = 4615036;
var SOLANA_ERROR__INSTRUCTION_ERROR__INVALID_REALLOC = 4615037;
var SOLANA_ERROR__INSTRUCTION_ERROR__COMPUTATIONAL_BUDGET_EXCEEDED = 4615038;
var SOLANA_ERROR__INSTRUCTION_ERROR__PRIVILEGE_ESCALATION = 4615039;
var SOLANA_ERROR__INSTRUCTION_ERROR__PROGRAM_ENVIRONMENT_SETUP_FAILURE = 4615040;
var SOLANA_ERROR__INSTRUCTION_ERROR__PROGRAM_FAILED_TO_COMPLETE = 4615041;
var SOLANA_ERROR__INSTRUCTION_ERROR__PROGRAM_FAILED_TO_COMPILE = 4615042;
var SOLANA_ERROR__INSTRUCTION_ERROR__IMMUTABLE = 4615043;
var SOLANA_ERROR__INSTRUCTION_ERROR__INCORRECT_AUTHORITY = 4615044;
var SOLANA_ERROR__INSTRUCTION_ERROR__BORSH_IO_ERROR = 4615045;
var SOLANA_ERROR__INSTRUCTION_ERROR__ACCOUNT_NOT_RENT_EXEMPT = 4615046;
var SOLANA_ERROR__INSTRUCTION_ERROR__INVALID_ACCOUNT_OWNER = 4615047;
var SOLANA_ERROR__INSTRUCTION_ERROR__ARITHMETIC_OVERFLOW = 4615048;
var SOLANA_ERROR__INSTRUCTION_ERROR__UNSUPPORTED_SYSVAR = 4615049;
var SOLANA_ERROR__INSTRUCTION_ERROR__ILLEGAL_OWNER = 4615050;
var SOLANA_ERROR__INSTRUCTION_ERROR__MAX_ACCOUNTS_DATA_ALLOCATIONS_EXCEEDED = 4615051;
var SOLANA_ERROR__INSTRUCTION_ERROR__MAX_ACCOUNTS_EXCEEDED = 4615052;
var SOLANA_ERROR__INSTRUCTION_ERROR__MAX_INSTRUCTION_TRACE_LENGTH_EXCEEDED = 4615053;
var SOLANA_ERROR__INSTRUCTION_ERROR__BUILTIN_PROGRAMS_MUST_CONSUME_COMPUTE_UNITS = 4615054;
var SOLANA_ERROR__SIGNER__ADDRESS_CANNOT_HAVE_MULTIPLE_SIGNERS = 5508e3;
var SOLANA_ERROR__SIGNER__EXPECTED_KEY_PAIR_SIGNER = 5508001;
var SOLANA_ERROR__SIGNER__EXPECTED_MESSAGE_SIGNER = 5508002;
var SOLANA_ERROR__SIGNER__EXPECTED_MESSAGE_MODIFYING_SIGNER = 5508003;
var SOLANA_ERROR__SIGNER__EXPECTED_MESSAGE_PARTIAL_SIGNER = 5508004;
var SOLANA_ERROR__SIGNER__EXPECTED_TRANSACTION_SIGNER = 5508005;
var SOLANA_ERROR__SIGNER__EXPECTED_TRANSACTION_MODIFYING_SIGNER = 5508006;
var SOLANA_ERROR__SIGNER__EXPECTED_TRANSACTION_PARTIAL_SIGNER = 5508007;
var SOLANA_ERROR__SIGNER__EXPECTED_TRANSACTION_SENDING_SIGNER = 5508008;
var SOLANA_ERROR__SIGNER__TRANSACTION_CANNOT_HAVE_MULTIPLE_SENDING_SIGNERS = 5508009;
var SOLANA_ERROR__SIGNER__TRANSACTION_SENDING_SIGNER_MISSING = 5508010;
var SOLANA_ERROR__SIGNER__WALLET_MULTISIGN_UNIMPLEMENTED = 5508011;
var SOLANA_ERROR__TRANSACTION__INVOKED_PROGRAMS_CANNOT_PAY_FEES = 5663e3;
var SOLANA_ERROR__TRANSACTION__INVOKED_PROGRAMS_MUST_NOT_BE_WRITABLE = 5663001;
var SOLANA_ERROR__TRANSACTION__EXPECTED_BLOCKHASH_LIFETIME = 5663002;
var SOLANA_ERROR__TRANSACTION__EXPECTED_NONCE_LIFETIME = 5663003;
var SOLANA_ERROR__TRANSACTION__VERSION_NUMBER_OUT_OF_RANGE = 5663004;
var SOLANA_ERROR__TRANSACTION__FAILED_TO_DECOMPILE_ADDRESS_LOOKUP_TABLE_CONTENTS_MISSING = 5663005;
var SOLANA_ERROR__TRANSACTION__FAILED_TO_DECOMPILE_ADDRESS_LOOKUP_TABLE_INDEX_OUT_OF_RANGE = 5663006;
var SOLANA_ERROR__TRANSACTION__FAILED_TO_DECOMPILE_INSTRUCTION_PROGRAM_ADDRESS_NOT_FOUND = 5663007;
var SOLANA_ERROR__TRANSACTION__FAILED_TO_DECOMPILE_FEE_PAYER_MISSING = 5663008;
var SOLANA_ERROR__TRANSACTION__SIGNATURES_MISSING = 5663009;
var SOLANA_ERROR__TRANSACTION__ADDRESS_MISSING = 5663010;
var SOLANA_ERROR__TRANSACTION__FEE_PAYER_MISSING = 5663011;
var SOLANA_ERROR__TRANSACTION__FEE_PAYER_SIGNATURE_MISSING = 5663012;
var SOLANA_ERROR__TRANSACTION__INVALID_NONCE_TRANSACTION_INSTRUCTIONS_MISSING = 5663013;
var SOLANA_ERROR__TRANSACTION__INVALID_NONCE_TRANSACTION_FIRST_INSTRUCTION_MUST_BE_ADVANCE_NONCE = 5663014;
var SOLANA_ERROR__TRANSACTION__ADDRESSES_CANNOT_SIGN_TRANSACTION = 5663015;
var SOLANA_ERROR__TRANSACTION__CANNOT_ENCODE_WITH_EMPTY_SIGNATURES = 5663016;
var SOLANA_ERROR__TRANSACTION__MESSAGE_SIGNATURES_MISMATCH = 5663017;
var SOLANA_ERROR__TRANSACTION__FAILED_TO_ESTIMATE_COMPUTE_LIMIT = 5663018;
var SOLANA_ERROR__TRANSACTION__FAILED_WHEN_SIMULATING_TO_ESTIMATE_COMPUTE_LIMIT = 5663019;
var SOLANA_ERROR__TRANSACTION_ERROR__UNKNOWN = 705e4;
var SOLANA_ERROR__TRANSACTION_ERROR__ACCOUNT_IN_USE = 7050001;
var SOLANA_ERROR__TRANSACTION_ERROR__ACCOUNT_LOADED_TWICE = 7050002;
var SOLANA_ERROR__TRANSACTION_ERROR__ACCOUNT_NOT_FOUND = 7050003;
var SOLANA_ERROR__TRANSACTION_ERROR__PROGRAM_ACCOUNT_NOT_FOUND = 7050004;
var SOLANA_ERROR__TRANSACTION_ERROR__INSUFFICIENT_FUNDS_FOR_FEE = 7050005;
var SOLANA_ERROR__TRANSACTION_ERROR__INVALID_ACCOUNT_FOR_FEE = 7050006;
var SOLANA_ERROR__TRANSACTION_ERROR__ALREADY_PROCESSED = 7050007;
var SOLANA_ERROR__TRANSACTION_ERROR__BLOCKHASH_NOT_FOUND = 7050008;
var SOLANA_ERROR__TRANSACTION_ERROR__CALL_CHAIN_TOO_DEEP = 7050009;
var SOLANA_ERROR__TRANSACTION_ERROR__MISSING_SIGNATURE_FOR_FEE = 7050010;
var SOLANA_ERROR__TRANSACTION_ERROR__INVALID_ACCOUNT_INDEX = 7050011;
var SOLANA_ERROR__TRANSACTION_ERROR__SIGNATURE_FAILURE = 7050012;
var SOLANA_ERROR__TRANSACTION_ERROR__INVALID_PROGRAM_FOR_EXECUTION = 7050013;
var SOLANA_ERROR__TRANSACTION_ERROR__SANITIZE_FAILURE = 7050014;
var SOLANA_ERROR__TRANSACTION_ERROR__CLUSTER_MAINTENANCE = 7050015;
var SOLANA_ERROR__TRANSACTION_ERROR__ACCOUNT_BORROW_OUTSTANDING = 7050016;
var SOLANA_ERROR__TRANSACTION_ERROR__WOULD_EXCEED_MAX_BLOCK_COST_LIMIT = 7050017;
var SOLANA_ERROR__TRANSACTION_ERROR__UNSUPPORTED_VERSION = 7050018;
var SOLANA_ERROR__TRANSACTION_ERROR__INVALID_WRITABLE_ACCOUNT = 7050019;
var SOLANA_ERROR__TRANSACTION_ERROR__WOULD_EXCEED_MAX_ACCOUNT_COST_LIMIT = 7050020;
var SOLANA_ERROR__TRANSACTION_ERROR__WOULD_EXCEED_ACCOUNT_DATA_BLOCK_LIMIT = 7050021;
var SOLANA_ERROR__TRANSACTION_ERROR__TOO_MANY_ACCOUNT_LOCKS = 7050022;
var SOLANA_ERROR__TRANSACTION_ERROR__ADDRESS_LOOKUP_TABLE_NOT_FOUND = 7050023;
var SOLANA_ERROR__TRANSACTION_ERROR__INVALID_ADDRESS_LOOKUP_TABLE_OWNER = 7050024;
var SOLANA_ERROR__TRANSACTION_ERROR__INVALID_ADDRESS_LOOKUP_TABLE_DATA = 7050025;
var SOLANA_ERROR__TRANSACTION_ERROR__INVALID_ADDRESS_LOOKUP_TABLE_INDEX = 7050026;
var SOLANA_ERROR__TRANSACTION_ERROR__INVALID_RENT_PAYING_ACCOUNT = 7050027;
var SOLANA_ERROR__TRANSACTION_ERROR__WOULD_EXCEED_MAX_VOTE_COST_LIMIT = 7050028;
var SOLANA_ERROR__TRANSACTION_ERROR__WOULD_EXCEED_ACCOUNT_DATA_TOTAL_LIMIT = 7050029;
var SOLANA_ERROR__TRANSACTION_ERROR__DUPLICATE_INSTRUCTION = 7050030;
var SOLANA_ERROR__TRANSACTION_ERROR__INSUFFICIENT_FUNDS_FOR_RENT = 7050031;
var SOLANA_ERROR__TRANSACTION_ERROR__MAX_LOADED_ACCOUNTS_DATA_SIZE_EXCEEDED = 7050032;
var SOLANA_ERROR__TRANSACTION_ERROR__INVALID_LOADED_ACCOUNTS_DATA_SIZE_LIMIT = 7050033;
var SOLANA_ERROR__TRANSACTION_ERROR__RESANITIZATION_NEEDED = 7050034;
var SOLANA_ERROR__TRANSACTION_ERROR__PROGRAM_EXECUTION_TEMPORARILY_RESTRICTED = 7050035;
var SOLANA_ERROR__TRANSACTION_ERROR__UNBALANCED_TRANSACTION = 7050036;
var SOLANA_ERROR__CODECS__CANNOT_DECODE_EMPTY_BYTE_ARRAY = 8078e3;
var SOLANA_ERROR__CODECS__INVALID_BYTE_LENGTH = 8078001;
var SOLANA_ERROR__CODECS__EXPECTED_FIXED_LENGTH = 8078002;
var SOLANA_ERROR__CODECS__EXPECTED_VARIABLE_LENGTH = 8078003;
var SOLANA_ERROR__CODECS__ENCODER_DECODER_SIZE_COMPATIBILITY_MISMATCH = 8078004;
var SOLANA_ERROR__CODECS__ENCODER_DECODER_FIXED_SIZE_MISMATCH = 8078005;
var SOLANA_ERROR__CODECS__ENCODER_DECODER_MAX_SIZE_MISMATCH = 8078006;
var SOLANA_ERROR__CODECS__INVALID_NUMBER_OF_ITEMS = 8078007;
var SOLANA_ERROR__CODECS__ENUM_DISCRIMINATOR_OUT_OF_RANGE = 8078008;
var SOLANA_ERROR__CODECS__INVALID_DISCRIMINATED_UNION_VARIANT = 8078009;
var SOLANA_ERROR__CODECS__INVALID_ENUM_VARIANT = 8078010;
var SOLANA_ERROR__CODECS__NUMBER_OUT_OF_RANGE = 8078011;
var SOLANA_ERROR__CODECS__INVALID_STRING_FOR_BASE = 8078012;
var SOLANA_ERROR__CODECS__EXPECTED_POSITIVE_BYTE_LENGTH = 8078013;
var SOLANA_ERROR__CODECS__OFFSET_OUT_OF_RANGE = 8078014;
var SOLANA_ERROR__CODECS__INVALID_LITERAL_UNION_VARIANT = 8078015;
var SOLANA_ERROR__CODECS__LITERAL_UNION_DISCRIMINATOR_OUT_OF_RANGE = 8078016;
var SOLANA_ERROR__CODECS__UNION_VARIANT_OUT_OF_RANGE = 8078017;
var SOLANA_ERROR__CODECS__INVALID_CONSTANT = 8078018;
var SOLANA_ERROR__CODECS__EXPECTED_ZERO_VALUE_TO_MATCH_ITEM_FIXED_SIZE = 8078019;
var SOLANA_ERROR__CODECS__ENCODED_BYTES_MUST_NOT_INCLUDE_SENTINEL = 8078020;
var SOLANA_ERROR__CODECS__SENTINEL_MISSING_IN_DECODED_BYTES = 8078021;
var SOLANA_ERROR__CODECS__CANNOT_USE_LEXICAL_VALUES_AS_ENUM_DISCRIMINATORS = 8078022;
var SOLANA_ERROR__RPC__INTEGER_OVERFLOW = 81e5;
var SOLANA_ERROR__RPC__TRANSPORT_HTTP_HEADER_FORBIDDEN = 8100001;
var SOLANA_ERROR__RPC__TRANSPORT_HTTP_ERROR = 8100002;
var SOLANA_ERROR__RPC__API_PLAN_MISSING_FOR_RPC_METHOD = 8100003;
var SOLANA_ERROR__RPC_SUBSCRIPTIONS__CANNOT_CREATE_SUBSCRIPTION_PLAN = 819e4;
var SOLANA_ERROR__RPC_SUBSCRIPTIONS__EXPECTED_SERVER_SUBSCRIPTION_ID = 8190001;
var SOLANA_ERROR__RPC_SUBSCRIPTIONS__CHANNEL_CLOSED_BEFORE_MESSAGE_BUFFERED = 8190002;
var SOLANA_ERROR__RPC_SUBSCRIPTIONS__CHANNEL_CONNECTION_CLOSED = 8190003;
var SOLANA_ERROR__RPC_SUBSCRIPTIONS__CHANNEL_FAILED_TO_CONNECT = 8190004;
var SOLANA_ERROR__INVARIANT_VIOLATION__SUBSCRIPTION_ITERATOR_STATE_MISSING = 99e5;
var SOLANA_ERROR__INVARIANT_VIOLATION__SUBSCRIPTION_ITERATOR_MUST_NOT_POLL_BEFORE_RESOLVING_EXISTING_MESSAGE_PROMISE = 9900001;
var SOLANA_ERROR__INVARIANT_VIOLATION__CACHED_ABORTABLE_ITERABLE_CACHE_ENTRY_MISSING = 9900002;
var SOLANA_ERROR__INVARIANT_VIOLATION__SWITCH_MUST_BE_EXHAUSTIVE = 9900003;
var SOLANA_ERROR__INVARIANT_VIOLATION__DATA_PUBLISHER_CHANNEL_UNIMPLEMENTED = 9900004;
var SolanaErrorMessages = {
  [SOLANA_ERROR__ACCOUNTS__ACCOUNT_NOT_FOUND]: "Account not found at address: $address",
  [SOLANA_ERROR__ACCOUNTS__EXPECTED_ALL_ACCOUNTS_TO_BE_DECODED]: "Not all accounts were decoded. Encoded accounts found at addresses: $addresses.",
  [SOLANA_ERROR__ACCOUNTS__EXPECTED_DECODED_ACCOUNT]: "Expected decoded account at address: $address",
  [SOLANA_ERROR__ACCOUNTS__FAILED_TO_DECODE_ACCOUNT]: "Failed to decode account data at address: $address",
  [SOLANA_ERROR__ACCOUNTS__ONE_OR_MORE_ACCOUNTS_NOT_FOUND]: "Accounts not found at addresses: $addresses",
  [SOLANA_ERROR__ADDRESSES__FAILED_TO_FIND_VIABLE_PDA_BUMP_SEED]: "Unable to find a viable program address bump seed.",
  [SOLANA_ERROR__ADDRESSES__INVALID_BASE58_ENCODED_ADDRESS]: "$putativeAddress is not a base58-encoded address.",
  [SOLANA_ERROR__ADDRESSES__INVALID_BYTE_LENGTH]: "Expected base58 encoded address to decode to a byte array of length 32. Actual length: $actualLength.",
  [SOLANA_ERROR__ADDRESSES__INVALID_ED25519_PUBLIC_KEY]: "The `CryptoKey` must be an `Ed25519` public key.",
  [SOLANA_ERROR__ADDRESSES__INVALID_SEEDS_POINT_ON_CURVE]: "Invalid seeds; point must fall off the Ed25519 curve.",
  [SOLANA_ERROR__ADDRESSES__MALFORMED_PDA]: "Expected given program derived address to have the following format: [Address, ProgramDerivedAddressBump].",
  [SOLANA_ERROR__ADDRESSES__MAX_NUMBER_OF_PDA_SEEDS_EXCEEDED]: "A maximum of $maxSeeds seeds, including the bump seed, may be supplied when creating an address. Received: $actual.",
  [SOLANA_ERROR__ADDRESSES__MAX_PDA_SEED_LENGTH_EXCEEDED]: "The seed at index $index with length $actual exceeds the maximum length of $maxSeedLength bytes.",
  [SOLANA_ERROR__ADDRESSES__PDA_BUMP_SEED_OUT_OF_RANGE]: "Expected program derived address bump to be in the range [0, 255], got: $bump.",
  [SOLANA_ERROR__ADDRESSES__PDA_ENDS_WITH_PDA_MARKER]: "Program address cannot end with PDA marker.",
  [SOLANA_ERROR__ADDRESSES__STRING_LENGTH_OUT_OF_RANGE]: "Expected base58-encoded address string of length in the range [32, 44]. Actual length: $actualLength.",
  [SOLANA_ERROR__BLOCKHASH_STRING_LENGTH_OUT_OF_RANGE]: "Expected base58-encoded blockash string of length in the range [32, 44]. Actual length: $actualLength.",
  [SOLANA_ERROR__BLOCK_HEIGHT_EXCEEDED]: "The network has progressed past the last block for which this transaction could have been committed.",
  [SOLANA_ERROR__CODECS__CANNOT_DECODE_EMPTY_BYTE_ARRAY]: "Codec [$codecDescription] cannot decode empty byte arrays.",
  [SOLANA_ERROR__CODECS__CANNOT_USE_LEXICAL_VALUES_AS_ENUM_DISCRIMINATORS]: "Enum codec cannot use lexical values [$stringValues] as discriminators. Either remove all lexical values or set `useValuesAsDiscriminators` to `false`.",
  [SOLANA_ERROR__CODECS__ENCODED_BYTES_MUST_NOT_INCLUDE_SENTINEL]: "Sentinel [$hexSentinel] must not be present in encoded bytes [$hexEncodedBytes].",
  [SOLANA_ERROR__CODECS__ENCODER_DECODER_FIXED_SIZE_MISMATCH]: "Encoder and decoder must have the same fixed size, got [$encoderFixedSize] and [$decoderFixedSize].",
  [SOLANA_ERROR__CODECS__ENCODER_DECODER_MAX_SIZE_MISMATCH]: "Encoder and decoder must have the same max size, got [$encoderMaxSize] and [$decoderMaxSize].",
  [SOLANA_ERROR__CODECS__ENCODER_DECODER_SIZE_COMPATIBILITY_MISMATCH]: "Encoder and decoder must either both be fixed-size or variable-size.",
  [SOLANA_ERROR__CODECS__ENUM_DISCRIMINATOR_OUT_OF_RANGE]: "Enum discriminator out of range. Expected a number in [$formattedValidDiscriminators], got $discriminator.",
  [SOLANA_ERROR__CODECS__EXPECTED_FIXED_LENGTH]: "Expected a fixed-size codec, got a variable-size one.",
  [SOLANA_ERROR__CODECS__EXPECTED_POSITIVE_BYTE_LENGTH]: "Codec [$codecDescription] expected a positive byte length, got $bytesLength.",
  [SOLANA_ERROR__CODECS__EXPECTED_VARIABLE_LENGTH]: "Expected a variable-size codec, got a fixed-size one.",
  [SOLANA_ERROR__CODECS__EXPECTED_ZERO_VALUE_TO_MATCH_ITEM_FIXED_SIZE]: "Codec [$codecDescription] expected zero-value [$hexZeroValue] to have the same size as the provided fixed-size item [$expectedSize bytes].",
  [SOLANA_ERROR__CODECS__INVALID_BYTE_LENGTH]: "Codec [$codecDescription] expected $expected bytes, got $bytesLength.",
  [SOLANA_ERROR__CODECS__INVALID_CONSTANT]: "Expected byte array constant [$hexConstant] to be present in data [$hexData] at offset [$offset].",
  [SOLANA_ERROR__CODECS__INVALID_DISCRIMINATED_UNION_VARIANT]: "Invalid discriminated union variant. Expected one of [$variants], got $value.",
  [SOLANA_ERROR__CODECS__INVALID_ENUM_VARIANT]: "Invalid enum variant. Expected one of [$stringValues] or a number in [$formattedNumericalValues], got $variant.",
  [SOLANA_ERROR__CODECS__INVALID_LITERAL_UNION_VARIANT]: "Invalid literal union variant. Expected one of [$variants], got $value.",
  [SOLANA_ERROR__CODECS__INVALID_NUMBER_OF_ITEMS]: "Expected [$codecDescription] to have $expected items, got $actual.",
  [SOLANA_ERROR__CODECS__INVALID_STRING_FOR_BASE]: "Invalid value $value for base $base with alphabet $alphabet.",
  [SOLANA_ERROR__CODECS__LITERAL_UNION_DISCRIMINATOR_OUT_OF_RANGE]: "Literal union discriminator out of range. Expected a number between $minRange and $maxRange, got $discriminator.",
  [SOLANA_ERROR__CODECS__NUMBER_OUT_OF_RANGE]: "Codec [$codecDescription] expected number to be in the range [$min, $max], got $value.",
  [SOLANA_ERROR__CODECS__OFFSET_OUT_OF_RANGE]: "Codec [$codecDescription] expected offset to be in the range [0, $bytesLength], got $offset.",
  [SOLANA_ERROR__CODECS__SENTINEL_MISSING_IN_DECODED_BYTES]: "Expected sentinel [$hexSentinel] to be present in decoded bytes [$hexDecodedBytes].",
  [SOLANA_ERROR__CODECS__UNION_VARIANT_OUT_OF_RANGE]: "Union variant out of range. Expected an index between $minRange and $maxRange, got $variant.",
  [SOLANA_ERROR__CRYPTO__RANDOM_VALUES_FUNCTION_UNIMPLEMENTED]: "No random values implementation could be found.",
  [SOLANA_ERROR__INSTRUCTION_ERROR__ACCOUNT_ALREADY_INITIALIZED]: "instruction requires an uninitialized account",
  [SOLANA_ERROR__INSTRUCTION_ERROR__ACCOUNT_BORROW_FAILED]: "instruction tries to borrow reference for an account which is already borrowed",
  [SOLANA_ERROR__INSTRUCTION_ERROR__ACCOUNT_BORROW_OUTSTANDING]: "instruction left account with an outstanding borrowed reference",
  [SOLANA_ERROR__INSTRUCTION_ERROR__ACCOUNT_DATA_SIZE_CHANGED]: "program other than the account's owner changed the size of the account data",
  [SOLANA_ERROR__INSTRUCTION_ERROR__ACCOUNT_DATA_TOO_SMALL]: "account data too small for instruction",
  [SOLANA_ERROR__INSTRUCTION_ERROR__ACCOUNT_NOT_EXECUTABLE]: "instruction expected an executable account",
  [SOLANA_ERROR__INSTRUCTION_ERROR__ACCOUNT_NOT_RENT_EXEMPT]: "An account does not have enough lamports to be rent-exempt",
  [SOLANA_ERROR__INSTRUCTION_ERROR__ARITHMETIC_OVERFLOW]: "Program arithmetic overflowed",
  [SOLANA_ERROR__INSTRUCTION_ERROR__BORSH_IO_ERROR]: "Failed to serialize or deserialize account data: $encodedData",
  [SOLANA_ERROR__INSTRUCTION_ERROR__BUILTIN_PROGRAMS_MUST_CONSUME_COMPUTE_UNITS]: "Builtin programs must consume compute units",
  [SOLANA_ERROR__INSTRUCTION_ERROR__CALL_DEPTH]: "Cross-program invocation call depth too deep",
  [SOLANA_ERROR__INSTRUCTION_ERROR__COMPUTATIONAL_BUDGET_EXCEEDED]: "Computational budget exceeded",
  [SOLANA_ERROR__INSTRUCTION_ERROR__CUSTOM]: "custom program error: #$code",
  [SOLANA_ERROR__INSTRUCTION_ERROR__DUPLICATE_ACCOUNT_INDEX]: "instruction contains duplicate accounts",
  [SOLANA_ERROR__INSTRUCTION_ERROR__DUPLICATE_ACCOUNT_OUT_OF_SYNC]: "instruction modifications of multiply-passed account differ",
  [SOLANA_ERROR__INSTRUCTION_ERROR__EXECUTABLE_ACCOUNT_NOT_RENT_EXEMPT]: "executable accounts must be rent exempt",
  [SOLANA_ERROR__INSTRUCTION_ERROR__EXECUTABLE_DATA_MODIFIED]: "instruction changed executable accounts data",
  [SOLANA_ERROR__INSTRUCTION_ERROR__EXECUTABLE_LAMPORT_CHANGE]: "instruction changed the balance of an executable account",
  [SOLANA_ERROR__INSTRUCTION_ERROR__EXECUTABLE_MODIFIED]: "instruction changed executable bit of an account",
  [SOLANA_ERROR__INSTRUCTION_ERROR__EXTERNAL_ACCOUNT_DATA_MODIFIED]: "instruction modified data of an account it does not own",
  [SOLANA_ERROR__INSTRUCTION_ERROR__EXTERNAL_ACCOUNT_LAMPORT_SPEND]: "instruction spent from the balance of an account it does not own",
  [SOLANA_ERROR__INSTRUCTION_ERROR__GENERIC_ERROR]: "generic instruction error",
  [SOLANA_ERROR__INSTRUCTION_ERROR__ILLEGAL_OWNER]: "Provided owner is not allowed",
  [SOLANA_ERROR__INSTRUCTION_ERROR__IMMUTABLE]: "Account is immutable",
  [SOLANA_ERROR__INSTRUCTION_ERROR__INCORRECT_AUTHORITY]: "Incorrect authority provided",
  [SOLANA_ERROR__INSTRUCTION_ERROR__INCORRECT_PROGRAM_ID]: "incorrect program id for instruction",
  [SOLANA_ERROR__INSTRUCTION_ERROR__INSUFFICIENT_FUNDS]: "insufficient funds for instruction",
  [SOLANA_ERROR__INSTRUCTION_ERROR__INVALID_ACCOUNT_DATA]: "invalid account data for instruction",
  [SOLANA_ERROR__INSTRUCTION_ERROR__INVALID_ACCOUNT_OWNER]: "Invalid account owner",
  [SOLANA_ERROR__INSTRUCTION_ERROR__INVALID_ARGUMENT]: "invalid program argument",
  [SOLANA_ERROR__INSTRUCTION_ERROR__INVALID_ERROR]: "program returned invalid error code",
  [SOLANA_ERROR__INSTRUCTION_ERROR__INVALID_INSTRUCTION_DATA]: "invalid instruction data",
  [SOLANA_ERROR__INSTRUCTION_ERROR__INVALID_REALLOC]: "Failed to reallocate account data",
  [SOLANA_ERROR__INSTRUCTION_ERROR__INVALID_SEEDS]: "Provided seeds do not result in a valid address",
  [SOLANA_ERROR__INSTRUCTION_ERROR__MAX_ACCOUNTS_DATA_ALLOCATIONS_EXCEEDED]: "Accounts data allocations exceeded the maximum allowed per transaction",
  [SOLANA_ERROR__INSTRUCTION_ERROR__MAX_ACCOUNTS_EXCEEDED]: "Max accounts exceeded",
  [SOLANA_ERROR__INSTRUCTION_ERROR__MAX_INSTRUCTION_TRACE_LENGTH_EXCEEDED]: "Max instruction trace length exceeded",
  [SOLANA_ERROR__INSTRUCTION_ERROR__MAX_SEED_LENGTH_EXCEEDED]: "Length of the seed is too long for address generation",
  [SOLANA_ERROR__INSTRUCTION_ERROR__MISSING_ACCOUNT]: "An account required by the instruction is missing",
  [SOLANA_ERROR__INSTRUCTION_ERROR__MISSING_REQUIRED_SIGNATURE]: "missing required signature for instruction",
  [SOLANA_ERROR__INSTRUCTION_ERROR__MODIFIED_PROGRAM_ID]: "instruction illegally modified the program id of an account",
  [SOLANA_ERROR__INSTRUCTION_ERROR__NOT_ENOUGH_ACCOUNT_KEYS]: "insufficient account keys for instruction",
  [SOLANA_ERROR__INSTRUCTION_ERROR__PRIVILEGE_ESCALATION]: "Cross-program invocation with unauthorized signer or writable account",
  [SOLANA_ERROR__INSTRUCTION_ERROR__PROGRAM_ENVIRONMENT_SETUP_FAILURE]: "Failed to create program execution environment",
  [SOLANA_ERROR__INSTRUCTION_ERROR__PROGRAM_FAILED_TO_COMPILE]: "Program failed to compile",
  [SOLANA_ERROR__INSTRUCTION_ERROR__PROGRAM_FAILED_TO_COMPLETE]: "Program failed to complete",
  [SOLANA_ERROR__INSTRUCTION_ERROR__READONLY_DATA_MODIFIED]: "instruction modified data of a read-only account",
  [SOLANA_ERROR__INSTRUCTION_ERROR__READONLY_LAMPORT_CHANGE]: "instruction changed the balance of a read-only account",
  [SOLANA_ERROR__INSTRUCTION_ERROR__REENTRANCY_NOT_ALLOWED]: "Cross-program invocation reentrancy not allowed for this instruction",
  [SOLANA_ERROR__INSTRUCTION_ERROR__RENT_EPOCH_MODIFIED]: "instruction modified rent epoch of an account",
  [SOLANA_ERROR__INSTRUCTION_ERROR__UNBALANCED_INSTRUCTION]: "sum of account balances before and after instruction do not match",
  [SOLANA_ERROR__INSTRUCTION_ERROR__UNINITIALIZED_ACCOUNT]: "instruction requires an initialized account",
  [SOLANA_ERROR__INSTRUCTION_ERROR__UNKNOWN]: "",
  [SOLANA_ERROR__INSTRUCTION_ERROR__UNSUPPORTED_PROGRAM_ID]: "Unsupported program id",
  [SOLANA_ERROR__INSTRUCTION_ERROR__UNSUPPORTED_SYSVAR]: "Unsupported sysvar",
  [SOLANA_ERROR__INSTRUCTION__EXPECTED_TO_HAVE_ACCOUNTS]: "The instruction does not have any accounts.",
  [SOLANA_ERROR__INSTRUCTION__EXPECTED_TO_HAVE_DATA]: "The instruction does not have any data.",
  [SOLANA_ERROR__INSTRUCTION__PROGRAM_ID_MISMATCH]: "Expected instruction to have progress address $expectedProgramAddress, got $actualProgramAddress.",
  [SOLANA_ERROR__INVALID_BLOCKHASH_BYTE_LENGTH]: "Expected base58 encoded blockhash to decode to a byte array of length 32. Actual length: $actualLength.",
  [SOLANA_ERROR__INVALID_NONCE]: "The nonce `$expectedNonceValue` is no longer valid. It has advanced to `$actualNonceValue`",
  [SOLANA_ERROR__INVARIANT_VIOLATION__CACHED_ABORTABLE_ITERABLE_CACHE_ENTRY_MISSING]: "Invariant violation: Found no abortable iterable cache entry for key `$cacheKey`. It should be impossible to hit this error; please file an issue at https://sola.na/web3invariant",
  [SOLANA_ERROR__INVARIANT_VIOLATION__DATA_PUBLISHER_CHANNEL_UNIMPLEMENTED]: "Invariant violation: This data publisher does not publish to the channel named `$channelName`. Supported channels include $supportedChannelNames.",
  [SOLANA_ERROR__INVARIANT_VIOLATION__SUBSCRIPTION_ITERATOR_MUST_NOT_POLL_BEFORE_RESOLVING_EXISTING_MESSAGE_PROMISE]: "Invariant violation: WebSocket message iterator state is corrupt; iterated without first resolving existing message promise. It should be impossible to hit this error; please file an issue at https://sola.na/web3invariant",
  [SOLANA_ERROR__INVARIANT_VIOLATION__SUBSCRIPTION_ITERATOR_STATE_MISSING]: "Invariant violation: WebSocket message iterator is missing state storage. It should be impossible to hit this error; please file an issue at https://sola.na/web3invariant",
  [SOLANA_ERROR__INVARIANT_VIOLATION__SWITCH_MUST_BE_EXHAUSTIVE]: "Invariant violation: Switch statement non-exhaustive. Received unexpected value `$unexpectedValue`. It should be impossible to hit this error; please file an issue at https://sola.na/web3invariant",
  [SOLANA_ERROR__JSON_RPC__INTERNAL_ERROR]: "JSON-RPC error: Internal JSON-RPC error ($__serverMessage)",
  [SOLANA_ERROR__JSON_RPC__INVALID_PARAMS]: "JSON-RPC error: Invalid method parameter(s) ($__serverMessage)",
  [SOLANA_ERROR__JSON_RPC__INVALID_REQUEST]: "JSON-RPC error: The JSON sent is not a valid `Request` object ($__serverMessage)",
  [SOLANA_ERROR__JSON_RPC__METHOD_NOT_FOUND]: "JSON-RPC error: The method does not exist / is not available ($__serverMessage)",
  [SOLANA_ERROR__JSON_RPC__PARSE_ERROR]: "JSON-RPC error: An error occurred on the server while parsing the JSON text ($__serverMessage)",
  [SOLANA_ERROR__JSON_RPC__SCAN_ERROR]: "$__serverMessage",
  [SOLANA_ERROR__JSON_RPC__SERVER_ERROR_BLOCK_CLEANED_UP]: "$__serverMessage",
  [SOLANA_ERROR__JSON_RPC__SERVER_ERROR_BLOCK_NOT_AVAILABLE]: "$__serverMessage",
  [SOLANA_ERROR__JSON_RPC__SERVER_ERROR_BLOCK_STATUS_NOT_AVAILABLE_YET]: "$__serverMessage",
  [SOLANA_ERROR__JSON_RPC__SERVER_ERROR_KEY_EXCLUDED_FROM_SECONDARY_INDEX]: "$__serverMessage",
  [SOLANA_ERROR__JSON_RPC__SERVER_ERROR_LONG_TERM_STORAGE_SLOT_SKIPPED]: "$__serverMessage",
  [SOLANA_ERROR__JSON_RPC__SERVER_ERROR_MIN_CONTEXT_SLOT_NOT_REACHED]: "Minimum context slot has not been reached",
  [SOLANA_ERROR__JSON_RPC__SERVER_ERROR_NODE_UNHEALTHY]: "Node is unhealthy; behind by $numSlotsBehind slots",
  [SOLANA_ERROR__JSON_RPC__SERVER_ERROR_NO_SNAPSHOT]: "No snapshot",
  [SOLANA_ERROR__JSON_RPC__SERVER_ERROR_SEND_TRANSACTION_PREFLIGHT_FAILURE]: "Transaction simulation failed",
  [SOLANA_ERROR__JSON_RPC__SERVER_ERROR_SLOT_SKIPPED]: "$__serverMessage",
  [SOLANA_ERROR__JSON_RPC__SERVER_ERROR_TRANSACTION_HISTORY_NOT_AVAILABLE]: "Transaction history is not available from this node",
  [SOLANA_ERROR__JSON_RPC__SERVER_ERROR_TRANSACTION_PRECOMPILE_VERIFICATION_FAILURE]: "$__serverMessage",
  [SOLANA_ERROR__JSON_RPC__SERVER_ERROR_TRANSACTION_SIGNATURE_LEN_MISMATCH]: "Transaction signature length mismatch",
  [SOLANA_ERROR__JSON_RPC__SERVER_ERROR_TRANSACTION_SIGNATURE_VERIFICATION_FAILURE]: "Transaction signature verification failure",
  [SOLANA_ERROR__JSON_RPC__SERVER_ERROR_UNSUPPORTED_TRANSACTION_VERSION]: "$__serverMessage",
  [SOLANA_ERROR__KEYS__INVALID_KEY_PAIR_BYTE_LENGTH]: "Key pair bytes must be of length 64, got $byteLength.",
  [SOLANA_ERROR__KEYS__INVALID_PRIVATE_KEY_BYTE_LENGTH]: "Expected private key bytes with length 32. Actual length: $actualLength.",
  [SOLANA_ERROR__KEYS__INVALID_SIGNATURE_BYTE_LENGTH]: "Expected base58-encoded signature to decode to a byte array of length 64. Actual length: $actualLength.",
  [SOLANA_ERROR__KEYS__PUBLIC_KEY_MUST_MATCH_PRIVATE_KEY]: "The provided private key does not match the provided public key.",
  [SOLANA_ERROR__KEYS__SIGNATURE_STRING_LENGTH_OUT_OF_RANGE]: "Expected base58-encoded signature string of length in the range [64, 88]. Actual length: $actualLength.",
  [SOLANA_ERROR__LAMPORTS_OUT_OF_RANGE]: "Lamports value must be in the range [0, 2e64-1]",
  [SOLANA_ERROR__MALFORMED_BIGINT_STRING]: "`$value` cannot be parsed as a `BigInt`",
  [SOLANA_ERROR__MALFORMED_JSON_RPC_ERROR]: "$message",
  [SOLANA_ERROR__MALFORMED_NUMBER_STRING]: "`$value` cannot be parsed as a `Number`",
  [SOLANA_ERROR__NONCE_ACCOUNT_NOT_FOUND]: "No nonce account could be found at address `$nonceAccountAddress`",
  [SOLANA_ERROR__RPC_SUBSCRIPTIONS__CANNOT_CREATE_SUBSCRIPTION_PLAN]: "The notification name must end in 'Notifications' and the API must supply a subscription plan creator function for the notification '$notificationName'.",
  [SOLANA_ERROR__RPC_SUBSCRIPTIONS__CHANNEL_CLOSED_BEFORE_MESSAGE_BUFFERED]: "WebSocket was closed before payload could be added to the send buffer",
  [SOLANA_ERROR__RPC_SUBSCRIPTIONS__CHANNEL_CONNECTION_CLOSED]: "WebSocket connection closed",
  [SOLANA_ERROR__RPC_SUBSCRIPTIONS__CHANNEL_FAILED_TO_CONNECT]: "WebSocket failed to connect",
  [SOLANA_ERROR__RPC_SUBSCRIPTIONS__EXPECTED_SERVER_SUBSCRIPTION_ID]: "Failed to obtain a subscription id from the server",
  [SOLANA_ERROR__RPC__API_PLAN_MISSING_FOR_RPC_METHOD]: "Could not find an API plan for RPC method: `$method`",
  [SOLANA_ERROR__RPC__INTEGER_OVERFLOW]: "The $argumentLabel argument to the `$methodName` RPC method$optionalPathLabel was `$value`. This number is unsafe for use with the Solana JSON-RPC because it exceeds `Number.MAX_SAFE_INTEGER`.",
  [SOLANA_ERROR__RPC__TRANSPORT_HTTP_ERROR]: "HTTP error ($statusCode): $message",
  [SOLANA_ERROR__RPC__TRANSPORT_HTTP_HEADER_FORBIDDEN]: "HTTP header(s) forbidden: $headers. Learn more at https://developer.mozilla.org/en-US/docs/Glossary/Forbidden_header_name.",
  [SOLANA_ERROR__SIGNER__ADDRESS_CANNOT_HAVE_MULTIPLE_SIGNERS]: "Multiple distinct signers were identified for address `$address`. Please ensure that you are using the same signer instance for each address.",
  [SOLANA_ERROR__SIGNER__EXPECTED_KEY_PAIR_SIGNER]: "The provided value does not implement the `KeyPairSigner` interface",
  [SOLANA_ERROR__SIGNER__EXPECTED_MESSAGE_MODIFYING_SIGNER]: "The provided value does not implement the `MessageModifyingSigner` interface",
  [SOLANA_ERROR__SIGNER__EXPECTED_MESSAGE_PARTIAL_SIGNER]: "The provided value does not implement the `MessagePartialSigner` interface",
  [SOLANA_ERROR__SIGNER__EXPECTED_MESSAGE_SIGNER]: "The provided value does not implement any of the `MessageSigner` interfaces",
  [SOLANA_ERROR__SIGNER__EXPECTED_TRANSACTION_MODIFYING_SIGNER]: "The provided value does not implement the `TransactionModifyingSigner` interface",
  [SOLANA_ERROR__SIGNER__EXPECTED_TRANSACTION_PARTIAL_SIGNER]: "The provided value does not implement the `TransactionPartialSigner` interface",
  [SOLANA_ERROR__SIGNER__EXPECTED_TRANSACTION_SENDING_SIGNER]: "The provided value does not implement the `TransactionSendingSigner` interface",
  [SOLANA_ERROR__SIGNER__EXPECTED_TRANSACTION_SIGNER]: "The provided value does not implement any of the `TransactionSigner` interfaces",
  [SOLANA_ERROR__SIGNER__TRANSACTION_CANNOT_HAVE_MULTIPLE_SENDING_SIGNERS]: "More than one `TransactionSendingSigner` was identified.",
  [SOLANA_ERROR__SIGNER__TRANSACTION_SENDING_SIGNER_MISSING]: "No `TransactionSendingSigner` was identified. Please provide a valid `ITransactionWithSingleSendingSigner` transaction.",
  [SOLANA_ERROR__SIGNER__WALLET_MULTISIGN_UNIMPLEMENTED]: "Wallet account signers do not support signing multiple messages/transactions in a single operation",
  [SOLANA_ERROR__SUBTLE_CRYPTO__CANNOT_EXPORT_NON_EXTRACTABLE_KEY]: "Cannot export a non-extractable key.",
  [SOLANA_ERROR__SUBTLE_CRYPTO__DIGEST_UNIMPLEMENTED]: "No digest implementation could be found.",
  [SOLANA_ERROR__SUBTLE_CRYPTO__DISALLOWED_IN_INSECURE_CONTEXT]: "Cryptographic operations are only allowed in secure browser contexts. Read more here: https://developer.mozilla.org/en-US/docs/Web/Security/Secure_Contexts.",
  [SOLANA_ERROR__SUBTLE_CRYPTO__ED25519_ALGORITHM_UNIMPLEMENTED]: "This runtime does not support the generation of Ed25519 key pairs.\n\nInstall @solana/webcrypto-ed25519-polyfill and call its `install` function before generating keys in environments that do not support Ed25519.\n\nFor a list of runtimes that currently support Ed25519 operations, visit https://github.com/WICG/webcrypto-secure-curves/issues/20.",
  [SOLANA_ERROR__SUBTLE_CRYPTO__EXPORT_FUNCTION_UNIMPLEMENTED]: "No signature verification implementation could be found.",
  [SOLANA_ERROR__SUBTLE_CRYPTO__GENERATE_FUNCTION_UNIMPLEMENTED]: "No key generation implementation could be found.",
  [SOLANA_ERROR__SUBTLE_CRYPTO__SIGN_FUNCTION_UNIMPLEMENTED]: "No signing implementation could be found.",
  [SOLANA_ERROR__SUBTLE_CRYPTO__VERIFY_FUNCTION_UNIMPLEMENTED]: "No key export implementation could be found.",
  [SOLANA_ERROR__TIMESTAMP_OUT_OF_RANGE]: "Timestamp value must be in the range [-(2n ** 63n), (2n ** 63n) - 1]. `$value` given",
  [SOLANA_ERROR__TRANSACTION_ERROR__ACCOUNT_BORROW_OUTSTANDING]: "Transaction processing left an account with an outstanding borrowed reference",
  [SOLANA_ERROR__TRANSACTION_ERROR__ACCOUNT_IN_USE]: "Account in use",
  [SOLANA_ERROR__TRANSACTION_ERROR__ACCOUNT_LOADED_TWICE]: "Account loaded twice",
  [SOLANA_ERROR__TRANSACTION_ERROR__ACCOUNT_NOT_FOUND]: "Attempt to debit an account but found no record of a prior credit.",
  [SOLANA_ERROR__TRANSACTION_ERROR__ADDRESS_LOOKUP_TABLE_NOT_FOUND]: "Transaction loads an address table account that doesn't exist",
  [SOLANA_ERROR__TRANSACTION_ERROR__ALREADY_PROCESSED]: "This transaction has already been processed",
  [SOLANA_ERROR__TRANSACTION_ERROR__BLOCKHASH_NOT_FOUND]: "Blockhash not found",
  [SOLANA_ERROR__TRANSACTION_ERROR__CALL_CHAIN_TOO_DEEP]: "Loader call chain is too deep",
  [SOLANA_ERROR__TRANSACTION_ERROR__CLUSTER_MAINTENANCE]: "Transactions are currently disabled due to cluster maintenance",
  [SOLANA_ERROR__TRANSACTION_ERROR__DUPLICATE_INSTRUCTION]: "Transaction contains a duplicate instruction ($index) that is not allowed",
  [SOLANA_ERROR__TRANSACTION_ERROR__INSUFFICIENT_FUNDS_FOR_FEE]: "Insufficient funds for fee",
  [SOLANA_ERROR__TRANSACTION_ERROR__INSUFFICIENT_FUNDS_FOR_RENT]: "Transaction results in an account ($accountIndex) with insufficient funds for rent",
  [SOLANA_ERROR__TRANSACTION_ERROR__INVALID_ACCOUNT_FOR_FEE]: "This account may not be used to pay transaction fees",
  [SOLANA_ERROR__TRANSACTION_ERROR__INVALID_ACCOUNT_INDEX]: "Transaction contains an invalid account reference",
  [SOLANA_ERROR__TRANSACTION_ERROR__INVALID_ADDRESS_LOOKUP_TABLE_DATA]: "Transaction loads an address table account with invalid data",
  [SOLANA_ERROR__TRANSACTION_ERROR__INVALID_ADDRESS_LOOKUP_TABLE_INDEX]: "Transaction address table lookup uses an invalid index",
  [SOLANA_ERROR__TRANSACTION_ERROR__INVALID_ADDRESS_LOOKUP_TABLE_OWNER]: "Transaction loads an address table account with an invalid owner",
  [SOLANA_ERROR__TRANSACTION_ERROR__INVALID_LOADED_ACCOUNTS_DATA_SIZE_LIMIT]: "LoadedAccountsDataSizeLimit set for transaction must be greater than 0.",
  [SOLANA_ERROR__TRANSACTION_ERROR__INVALID_PROGRAM_FOR_EXECUTION]: "This program may not be used for executing instructions",
  [SOLANA_ERROR__TRANSACTION_ERROR__INVALID_RENT_PAYING_ACCOUNT]: "Transaction leaves an account with a lower balance than rent-exempt minimum",
  [SOLANA_ERROR__TRANSACTION_ERROR__INVALID_WRITABLE_ACCOUNT]: "Transaction loads a writable account that cannot be written",
  [SOLANA_ERROR__TRANSACTION_ERROR__MAX_LOADED_ACCOUNTS_DATA_SIZE_EXCEEDED]: "Transaction exceeded max loaded accounts data size cap",
  [SOLANA_ERROR__TRANSACTION_ERROR__MISSING_SIGNATURE_FOR_FEE]: "Transaction requires a fee but has no signature present",
  [SOLANA_ERROR__TRANSACTION_ERROR__PROGRAM_ACCOUNT_NOT_FOUND]: "Attempt to load a program that does not exist",
  [SOLANA_ERROR__TRANSACTION_ERROR__PROGRAM_EXECUTION_TEMPORARILY_RESTRICTED]: "Execution of the program referenced by account at index $accountIndex is temporarily restricted.",
  [SOLANA_ERROR__TRANSACTION_ERROR__RESANITIZATION_NEEDED]: "ResanitizationNeeded",
  [SOLANA_ERROR__TRANSACTION_ERROR__SANITIZE_FAILURE]: "Transaction failed to sanitize accounts offsets correctly",
  [SOLANA_ERROR__TRANSACTION_ERROR__SIGNATURE_FAILURE]: "Transaction did not pass signature verification",
  [SOLANA_ERROR__TRANSACTION_ERROR__TOO_MANY_ACCOUNT_LOCKS]: "Transaction locked too many accounts",
  [SOLANA_ERROR__TRANSACTION_ERROR__UNBALANCED_TRANSACTION]: "Sum of account balances before and after transaction do not match",
  [SOLANA_ERROR__TRANSACTION_ERROR__UNKNOWN]: "The transaction failed with the error `$errorName`",
  [SOLANA_ERROR__TRANSACTION_ERROR__UNSUPPORTED_VERSION]: "Transaction version is unsupported",
  [SOLANA_ERROR__TRANSACTION_ERROR__WOULD_EXCEED_ACCOUNT_DATA_BLOCK_LIMIT]: "Transaction would exceed account data limit within the block",
  [SOLANA_ERROR__TRANSACTION_ERROR__WOULD_EXCEED_ACCOUNT_DATA_TOTAL_LIMIT]: "Transaction would exceed total account data limit",
  [SOLANA_ERROR__TRANSACTION_ERROR__WOULD_EXCEED_MAX_ACCOUNT_COST_LIMIT]: "Transaction would exceed max account limit within the block",
  [SOLANA_ERROR__TRANSACTION_ERROR__WOULD_EXCEED_MAX_BLOCK_COST_LIMIT]: "Transaction would exceed max Block Cost Limit",
  [SOLANA_ERROR__TRANSACTION_ERROR__WOULD_EXCEED_MAX_VOTE_COST_LIMIT]: "Transaction would exceed max Vote Cost Limit",
  [SOLANA_ERROR__TRANSACTION__ADDRESSES_CANNOT_SIGN_TRANSACTION]: "Attempted to sign a transaction with an address that is not a signer for it",
  [SOLANA_ERROR__TRANSACTION__ADDRESS_MISSING]: "Transaction is missing an address at index: $index.",
  [SOLANA_ERROR__TRANSACTION__CANNOT_ENCODE_WITH_EMPTY_SIGNATURES]: "Transaction has no expected signers therefore it cannot be encoded",
  [SOLANA_ERROR__TRANSACTION__EXPECTED_BLOCKHASH_LIFETIME]: "Transaction does not have a blockhash lifetime",
  [SOLANA_ERROR__TRANSACTION__EXPECTED_NONCE_LIFETIME]: "Transaction is not a durable nonce transaction",
  [SOLANA_ERROR__TRANSACTION__FAILED_TO_DECOMPILE_ADDRESS_LOOKUP_TABLE_CONTENTS_MISSING]: "Contents of these address lookup tables unknown: $lookupTableAddresses",
  [SOLANA_ERROR__TRANSACTION__FAILED_TO_DECOMPILE_ADDRESS_LOOKUP_TABLE_INDEX_OUT_OF_RANGE]: "Lookup of address at index $highestRequestedIndex failed for lookup table `$lookupTableAddress`. Highest known index is $highestKnownIndex. The lookup table may have been extended since its contents were retrieved",
  [SOLANA_ERROR__TRANSACTION__FAILED_TO_DECOMPILE_FEE_PAYER_MISSING]: "No fee payer set in CompiledTransaction",
  [SOLANA_ERROR__TRANSACTION__FAILED_TO_DECOMPILE_INSTRUCTION_PROGRAM_ADDRESS_NOT_FOUND]: "Could not find program address at index $index",
  [SOLANA_ERROR__TRANSACTION__FAILED_TO_ESTIMATE_COMPUTE_LIMIT]: "Failed to estimate the compute unit consumption for this transaction message. This is likely because simulating the transaction failed. Inspect the `cause` property of this error to learn more",
  [SOLANA_ERROR__TRANSACTION__FAILED_WHEN_SIMULATING_TO_ESTIMATE_COMPUTE_LIMIT]: "Transaction failed when it was simulated in order to estimate the compute unit consumption. The compute unit estimate provided is for a transaction that failed when simulated and may not be representative of the compute units this transaction would consume if successful. Inspect the `cause` property of this error to learn more",
  [SOLANA_ERROR__TRANSACTION__FEE_PAYER_MISSING]: "Transaction is missing a fee payer.",
  [SOLANA_ERROR__TRANSACTION__FEE_PAYER_SIGNATURE_MISSING]: "Could not determine this transaction's signature. Make sure that the transaction has been signed by its fee payer.",
  [SOLANA_ERROR__TRANSACTION__INVALID_NONCE_TRANSACTION_FIRST_INSTRUCTION_MUST_BE_ADVANCE_NONCE]: "Transaction first instruction is not advance nonce account instruction.",
  [SOLANA_ERROR__TRANSACTION__INVALID_NONCE_TRANSACTION_INSTRUCTIONS_MISSING]: "Transaction with no instructions cannot be durable nonce transaction.",
  [SOLANA_ERROR__TRANSACTION__INVOKED_PROGRAMS_CANNOT_PAY_FEES]: "This transaction includes an address (`$programAddress`) which is both invoked and set as the fee payer. Program addresses may not pay fees",
  [SOLANA_ERROR__TRANSACTION__INVOKED_PROGRAMS_MUST_NOT_BE_WRITABLE]: "This transaction includes an address (`$programAddress`) which is both invoked and marked writable. Program addresses may not be writable",
  [SOLANA_ERROR__TRANSACTION__MESSAGE_SIGNATURES_MISMATCH]: "The transaction message expected the transaction to have $signerAddressesLength signatures, got $signaturesLength.",
  [SOLANA_ERROR__TRANSACTION__SIGNATURES_MISSING]: "Transaction is missing signatures for addresses: $addresses.",
  [SOLANA_ERROR__TRANSACTION__VERSION_NUMBER_OUT_OF_RANGE]: "Transaction version must be in the range [0, 127]. `$actualVersion` given"
};
var START_INDEX = "i";
var TYPE = "t";
function getHumanReadableErrorMessage(code, context = {}) {
  const messageFormatString = SolanaErrorMessages[code];
  if (messageFormatString.length === 0) {
    return "";
  }
  let state;
  function commitStateUpTo(endIndex) {
    if (state[TYPE] === 2) {
      const variableName = messageFormatString.slice(state[START_INDEX] + 1, endIndex);
      fragments.push(
        variableName in context ? (
          // eslint-disable-next-line @typescript-eslint/restrict-template-expressions
          `${context[variableName]}`
        ) : `$${variableName}`
      );
    } else if (state[TYPE] === 1) {
      fragments.push(messageFormatString.slice(state[START_INDEX], endIndex));
    }
  }
  const fragments = [];
  messageFormatString.split("").forEach((char, ii2) => {
    if (ii2 === 0) {
      state = {
        [START_INDEX]: 0,
        [TYPE]: messageFormatString[0] === "\\" ? 0 : messageFormatString[0] === "$" ? 2 : 1
        /* Text */
      };
      return;
    }
    let nextState;
    switch (state[TYPE]) {
      case 0:
        nextState = {
          [START_INDEX]: ii2,
          [TYPE]: 1
          /* Text */
        };
        break;
      case 1:
        if (char === "\\") {
          nextState = {
            [START_INDEX]: ii2,
            [TYPE]: 0
            /* EscapeSequence */
          };
        } else if (char === "$") {
          nextState = {
            [START_INDEX]: ii2,
            [TYPE]: 2
            /* Variable */
          };
        }
        break;
      case 2:
        if (char === "\\") {
          nextState = {
            [START_INDEX]: ii2,
            [TYPE]: 0
            /* EscapeSequence */
          };
        } else if (char === "$") {
          nextState = {
            [START_INDEX]: ii2,
            [TYPE]: 2
            /* Variable */
          };
        } else if (!char.match(/\w/)) {
          nextState = {
            [START_INDEX]: ii2,
            [TYPE]: 1
            /* Text */
          };
        }
        break;
    }
    if (nextState) {
      if (state !== nextState) {
        commitStateUpTo(ii2);
      }
      state = nextState;
    }
  });
  commitStateUpTo();
  return fragments.join("");
}
function getErrorMessage(code, context = {}) {
  if (true) {
    return getHumanReadableErrorMessage(code, context);
  } else {
    let decodingAdviceMessage = `Solana error #${code}; Decode this error by running \`npx @solana/errors decode -- ${code}`;
    if (Object.keys(context).length) {
      decodingAdviceMessage += ` '${encodeContextObject(context)}'`;
    }
    return `${decodingAdviceMessage}\``;
  }
}
var SolanaError = class extends Error {
  constructor(...[code, contextAndErrorOptions]) {
    let context;
    let errorOptions;
    if (contextAndErrorOptions) {
      const { cause, ...contextRest } = contextAndErrorOptions;
      if (cause) {
        errorOptions = { cause };
      }
      if (Object.keys(contextRest).length > 0) {
        context = contextRest;
      }
    }
    const message = getErrorMessage(code, context);
    super(message, errorOptions);
    /**
     * Indicates the root cause of this {@link SolanaError}, if any.
     *
     * For example, a transaction error might have an instruction error as its root cause. In this
     * case, you will be able to access the instruction error on the transaction error as `cause`.
     */
    __publicField(this, "cause", this.cause);
    /**
     * Contains context that can assist in understanding or recovering from a {@link SolanaError}.
     */
    __publicField(this, "context");
    this.context = {
      __code: code,
      ...context
    };
    this.name = "SolanaError";
  }
};

// node_modules/@solana/codecs-core/dist/index.browser.mjs
function getEncodedSize(value2, encoder) {
  return "fixedSize" in encoder ? encoder.fixedSize : encoder.getSizeFromValue(value2);
}
function createEncoder(encoder) {
  return Object.freeze({
    ...encoder,
    encode: (value2) => {
      const bytes = new Uint8Array(getEncodedSize(value2, encoder));
      encoder.write(value2, bytes, 0);
      return bytes;
    }
  });
}
function createDecoder(decoder) {
  return Object.freeze({
    ...decoder,
    decode: (bytes, offset2 = 0) => decoder.read(bytes, offset2)[0]
  });
}
function isFixedSize(codec) {
  return "fixedSize" in codec && typeof codec.fixedSize === "number";
}
function combineCodec(encoder, decoder) {
  if (isFixedSize(encoder) !== isFixedSize(decoder)) {
    throw new SolanaError(SOLANA_ERROR__CODECS__ENCODER_DECODER_SIZE_COMPATIBILITY_MISMATCH);
  }
  if (isFixedSize(encoder) && isFixedSize(decoder) && encoder.fixedSize !== decoder.fixedSize) {
    throw new SolanaError(SOLANA_ERROR__CODECS__ENCODER_DECODER_FIXED_SIZE_MISMATCH, {
      decoderFixedSize: decoder.fixedSize,
      encoderFixedSize: encoder.fixedSize
    });
  }
  if (!isFixedSize(encoder) && !isFixedSize(decoder) && encoder.maxSize !== decoder.maxSize) {
    throw new SolanaError(SOLANA_ERROR__CODECS__ENCODER_DECODER_MAX_SIZE_MISMATCH, {
      decoderMaxSize: decoder.maxSize,
      encoderMaxSize: encoder.maxSize
    });
  }
  return {
    ...decoder,
    ...encoder,
    decode: decoder.decode,
    encode: encoder.encode,
    read: decoder.read,
    write: encoder.write
  };
}
function assertByteArrayIsNotEmptyForCodec(codecDescription, bytes, offset2 = 0) {
  if (bytes.length - offset2 <= 0) {
    throw new SolanaError(SOLANA_ERROR__CODECS__CANNOT_DECODE_EMPTY_BYTE_ARRAY, {
      codecDescription
    });
  }
}
function assertByteArrayHasEnoughBytesForCodec(codecDescription, expected, bytes, offset2 = 0) {
  const bytesLength = bytes.length - offset2;
  if (bytesLength < expected) {
    throw new SolanaError(SOLANA_ERROR__CODECS__INVALID_BYTE_LENGTH, {
      bytesLength,
      codecDescription,
      expected
    });
  }
}

// node_modules/@solana/codecs-numbers/dist/index.browser.mjs
function assertNumberIsBetweenForCodec(codecDescription, min, max, value2) {
  if (value2 < min || value2 > max) {
    throw new SolanaError(SOLANA_ERROR__CODECS__NUMBER_OUT_OF_RANGE, {
      codecDescription,
      max,
      min,
      value: value2
    });
  }
}
var Endian = ((Endian2) => {
  Endian2[Endian2["Little"] = 0] = "Little";
  Endian2[Endian2["Big"] = 1] = "Big";
  return Endian2;
})(Endian || {});
function isLittleEndian(config) {
  return (config == null ? void 0 : config.endian) === 1 ? false : true;
}
function numberEncoderFactory(input) {
  return createEncoder({
    fixedSize: input.size,
    write(value2, bytes, offset2) {
      if (input.range) {
        assertNumberIsBetweenForCodec(input.name, input.range[0], input.range[1], value2);
      }
      const arrayBuffer = new ArrayBuffer(input.size);
      input.set(new DataView(arrayBuffer), value2, isLittleEndian(input.config));
      bytes.set(new Uint8Array(arrayBuffer), offset2);
      return offset2 + input.size;
    }
  });
}
function numberDecoderFactory(input) {
  return createDecoder({
    fixedSize: input.size,
    read(bytes, offset2 = 0) {
      assertByteArrayIsNotEmptyForCodec(input.name, bytes, offset2);
      assertByteArrayHasEnoughBytesForCodec(input.name, input.size, bytes, offset2);
      const view = new DataView(toArrayBuffer(bytes, offset2, input.size));
      return [input.get(view, isLittleEndian(input.config)), offset2 + input.size];
    }
  });
}
function toArrayBuffer(bytes, offset2, length) {
  const bytesOffset = bytes.byteOffset + (offset2 ?? 0);
  const bytesLength = length ?? bytes.byteLength;
  return bytes.buffer.slice(bytesOffset, bytesOffset + bytesLength);
}
var getU64Encoder = (config = {}) => numberEncoderFactory({
  config,
  name: "u64",
  range: [0n, BigInt("0xffffffffffffffff")],
  set: (view, value2, le3) => view.setBigUint64(0, BigInt(value2), le3),
  size: 8
});
var getU64Decoder = (config = {}) => numberDecoderFactory({
  config,
  get: (view, le3) => view.getBigUint64(0, le3),
  name: "u64",
  size: 8
});
var getU64Codec = (config = {}) => combineCodec(getU64Encoder(config), getU64Decoder(config));

// node_modules/superstruct/dist/index.mjs
var StructError = class extends TypeError {
  constructor(failure, failures) {
    let cached;
    const { message, explanation, ...rest } = failure;
    const { path } = failure;
    const msg = path.length === 0 ? message : `At path: ${path.join(".")} -- ${message}`;
    super(explanation ?? msg);
    if (explanation != null)
      this.cause = msg;
    Object.assign(this, rest);
    this.name = this.constructor.name;
    this.failures = () => {
      return cached ?? (cached = [failure, ...failures()]);
    };
  }
};
function isIterable(x3) {
  return isObject2(x3) && typeof x3[Symbol.iterator] === "function";
}
function isObject2(x3) {
  return typeof x3 === "object" && x3 != null;
}
function isNonArrayObject(x3) {
  return isObject2(x3) && !Array.isArray(x3);
}
function print(value2) {
  if (typeof value2 === "symbol") {
    return value2.toString();
  }
  return typeof value2 === "string" ? JSON.stringify(value2) : `${value2}`;
}
function shiftIterator(input) {
  const { done, value: value2 } = input.next();
  return done ? void 0 : value2;
}
function toFailure(result, context, struct2, value2) {
  if (result === true) {
    return;
  } else if (result === false) {
    result = {};
  } else if (typeof result === "string") {
    result = { message: result };
  }
  const { path, branch } = context;
  const { type: type2 } = struct2;
  const { refinement, message = `Expected a value of type \`${type2}\`${refinement ? ` with refinement \`${refinement}\`` : ""}, but received: \`${print(value2)}\`` } = result;
  return {
    value: value2,
    type: type2,
    refinement,
    key: path[path.length - 1],
    path,
    branch,
    ...result,
    message
  };
}
function* toFailures(result, context, struct2, value2) {
  if (!isIterable(result)) {
    result = [result];
  }
  for (const r2 of result) {
    const failure = toFailure(r2, context, struct2, value2);
    if (failure) {
      yield failure;
    }
  }
}
function* run(value2, struct2, options = {}) {
  const { path = [], branch = [value2], coerce: coerce2 = false, mask: mask2 = false } = options;
  const ctx = { path, branch, mask: mask2 };
  if (coerce2) {
    value2 = struct2.coercer(value2, ctx);
  }
  let status = "valid";
  for (const failure of struct2.validator(value2, ctx)) {
    failure.explanation = options.message;
    status = "not_valid";
    yield [failure, void 0];
  }
  for (let [k3, v2, s2] of struct2.entries(value2, ctx)) {
    const ts2 = run(v2, s2, {
      path: k3 === void 0 ? path : [...path, k3],
      branch: k3 === void 0 ? branch : [...branch, v2],
      coerce: coerce2,
      mask: mask2,
      message: options.message
    });
    for (const t3 of ts2) {
      if (t3[0]) {
        status = t3[0].refinement != null ? "not_refined" : "not_valid";
        yield [t3[0], void 0];
      } else if (coerce2) {
        v2 = t3[1];
        if (k3 === void 0) {
          value2 = v2;
        } else if (value2 instanceof Map) {
          value2.set(k3, v2);
        } else if (value2 instanceof Set) {
          value2.add(v2);
        } else if (isObject2(value2)) {
          if (v2 !== void 0 || k3 in value2)
            value2[k3] = v2;
        }
      }
    }
  }
  if (status !== "not_valid") {
    for (const failure of struct2.refiner(value2, ctx)) {
      failure.explanation = options.message;
      status = "not_refined";
      yield [failure, void 0];
    }
  }
  if (status === "valid") {
    yield [void 0, value2];
  }
}
var Struct = class {
  constructor(props) {
    const { type: type2, schema, validator, refiner, coercer = (value2) => value2, entries = function* () {
    } } = props;
    this.type = type2;
    this.schema = schema;
    this.entries = entries;
    this.coercer = coercer;
    if (validator) {
      this.validator = (value2, context) => {
        const result = validator(value2, context);
        return toFailures(result, context, this, value2);
      };
    } else {
      this.validator = () => [];
    }
    if (refiner) {
      this.refiner = (value2, context) => {
        const result = refiner(value2, context);
        return toFailures(result, context, this, value2);
      };
    } else {
      this.refiner = () => [];
    }
  }
  /**
   * Assert that a value passes the struct's validation, throwing if it doesn't.
   */
  assert(value2, message) {
    return assert(value2, this, message);
  }
  /**
   * Create a value with the struct's coercion logic, then validate it.
   */
  create(value2, message) {
    return create(value2, this, message);
  }
  /**
   * Check if a value passes the struct's validation.
   */
  is(value2) {
    return is2(value2, this);
  }
  /**
   * Mask a value, coercing and validating it, but returning only the subset of
   * properties defined by the struct's schema. Masking applies recursively to
   * props of `object` structs only.
   */
  mask(value2, message) {
    return mask(value2, this, message);
  }
  /**
   * Validate a value with the struct's validation logic, returning a tuple
   * representing the result.
   *
   * You may optionally pass `true` for the `coerce` argument to coerce
   * the value before attempting to validate it. If you do, the result will
   * contain the coerced result when successful. Also, `mask` will turn on
   * masking of the unknown `object` props recursively if passed.
   */
  validate(value2, options = {}) {
    return validate2(value2, this, options);
  }
};
function assert(value2, struct2, message) {
  const result = validate2(value2, struct2, { message });
  if (result[0]) {
    throw result[0];
  }
}
function create(value2, struct2, message) {
  const result = validate2(value2, struct2, { coerce: true, message });
  if (result[0]) {
    throw result[0];
  } else {
    return result[1];
  }
}
function mask(value2, struct2, message) {
  const result = validate2(value2, struct2, { coerce: true, mask: true, message });
  if (result[0]) {
    throw result[0];
  } else {
    return result[1];
  }
}
function is2(value2, struct2) {
  const result = validate2(value2, struct2);
  return !result[0];
}
function validate2(value2, struct2, options = {}) {
  const tuples = run(value2, struct2, options);
  const tuple2 = shiftIterator(tuples);
  if (tuple2[0]) {
    const error = new StructError(tuple2[0], function* () {
      for (const t3 of tuples) {
        if (t3[0]) {
          yield t3[0];
        }
      }
    });
    return [error, void 0];
  } else {
    const v2 = tuple2[1];
    return [void 0, v2];
  }
}
function define2(name, validator) {
  return new Struct({ type: name, schema: null, validator });
}
function any() {
  return define2("any", () => true);
}
function array(Element) {
  return new Struct({
    type: "array",
    schema: Element,
    *entries(value2) {
      if (Element && Array.isArray(value2)) {
        for (const [i4, v2] of value2.entries()) {
          yield [i4, v2, Element];
        }
      }
    },
    coercer(value2) {
      return Array.isArray(value2) ? value2.slice() : value2;
    },
    validator(value2) {
      return Array.isArray(value2) || `Expected an array value, but received: ${print(value2)}`;
    }
  });
}
function boolean() {
  return define2("boolean", (value2) => {
    return typeof value2 === "boolean";
  });
}
function instance(Class) {
  return define2("instance", (value2) => {
    return value2 instanceof Class || `Expected a \`${Class.name}\` instance, but received: ${print(value2)}`;
  });
}
function literal(constant) {
  const description = print(constant);
  const t3 = typeof constant;
  return new Struct({
    type: "literal",
    schema: t3 === "string" || t3 === "number" || t3 === "boolean" ? constant : null,
    validator(value2) {
      return value2 === constant || `Expected the literal \`${description}\`, but received: ${print(value2)}`;
    }
  });
}
function never() {
  return define2("never", () => false);
}
function nullable(struct2) {
  return new Struct({
    ...struct2,
    validator: (value2, ctx) => value2 === null || struct2.validator(value2, ctx),
    refiner: (value2, ctx) => value2 === null || struct2.refiner(value2, ctx)
  });
}
function number() {
  return define2("number", (value2) => {
    return typeof value2 === "number" && !isNaN(value2) || `Expected a number, but received: ${print(value2)}`;
  });
}
function optional(struct2) {
  return new Struct({
    ...struct2,
    validator: (value2, ctx) => value2 === void 0 || struct2.validator(value2, ctx),
    refiner: (value2, ctx) => value2 === void 0 || struct2.refiner(value2, ctx)
  });
}
function record(Key, Value) {
  return new Struct({
    type: "record",
    schema: null,
    *entries(value2) {
      if (isObject2(value2)) {
        for (const k3 in value2) {
          const v2 = value2[k3];
          yield [k3, k3, Key];
          yield [k3, v2, Value];
        }
      }
    },
    validator(value2) {
      return isNonArrayObject(value2) || `Expected an object, but received: ${print(value2)}`;
    },
    coercer(value2) {
      return isNonArrayObject(value2) ? { ...value2 } : value2;
    }
  });
}
function string() {
  return define2("string", (value2) => {
    return typeof value2 === "string" || `Expected a string, but received: ${print(value2)}`;
  });
}
function tuple(Structs) {
  const Never = never();
  return new Struct({
    type: "tuple",
    schema: null,
    *entries(value2) {
      if (Array.isArray(value2)) {
        const length = Math.max(Structs.length, value2.length);
        for (let i4 = 0; i4 < length; i4++) {
          yield [i4, value2[i4], Structs[i4] || Never];
        }
      }
    },
    validator(value2) {
      return Array.isArray(value2) || `Expected an array, but received: ${print(value2)}`;
    },
    coercer(value2) {
      return Array.isArray(value2) ? value2.slice() : value2;
    }
  });
}
function type(schema) {
  const keys = Object.keys(schema);
  return new Struct({
    type: "type",
    schema,
    *entries(value2) {
      if (isObject2(value2)) {
        for (const k3 of keys) {
          yield [k3, value2[k3], schema[k3]];
        }
      }
    },
    validator(value2) {
      return isNonArrayObject(value2) || `Expected an object, but received: ${print(value2)}`;
    },
    coercer(value2) {
      return isNonArrayObject(value2) ? { ...value2 } : value2;
    }
  });
}
function union(Structs) {
  const description = Structs.map((s2) => s2.type).join(" | ");
  return new Struct({
    type: "union",
    schema: null,
    coercer(value2, ctx) {
      for (const S5 of Structs) {
        const [error, coerced] = S5.validate(value2, {
          coerce: true,
          mask: ctx.mask
        });
        if (!error) {
          return coerced;
        }
      }
      return value2;
    },
    validator(value2, ctx) {
      const failures = [];
      for (const S5 of Structs) {
        const [...tuples] = run(value2, S5, ctx);
        const [first] = tuples;
        if (!first[0]) {
          return [];
        } else {
          for (const [failure] of tuples) {
            if (failure) {
              failures.push(failure);
            }
          }
        }
      }
      return [
        `Expected the value to satisfy a union of \`${description}\`, but received: ${print(value2)}`,
        ...failures
      ];
    }
  });
}
function unknown() {
  return define2("unknown", () => true);
}
function coerce(struct2, condition, coercer) {
  return new Struct({
    ...struct2,
    coercer: (value2, ctx) => {
      return is2(value2, condition) ? struct2.coercer(coercer(value2, ctx), ctx) : struct2.coercer(value2, ctx);
    }
  });
}

// node_modules/@solana/web3.js/lib/index.browser.esm.js
var import_browser = __toESM(require_browser2());

// node_modules/rpc-websockets/dist/index.browser.mjs
var import_buffer = __toESM(require_buffer(), 1);

// node_modules/rpc-websockets/node_modules/eventemitter3/index.mjs
var import_index = __toESM(require_eventemitter3(), 1);

// node_modules/@solana/web3.js/lib/index.browser.esm.js
var generatePrivateKey = ed25519.utils.randomPrivateKey;
var generateKeypair = () => {
  const privateScalar = ed25519.utils.randomPrivateKey();
  const publicKey2 = getPublicKey(privateScalar);
  const secretKey = new Uint8Array(64);
  secretKey.set(privateScalar);
  secretKey.set(publicKey2, 32);
  return {
    publicKey: publicKey2,
    secretKey
  };
};
var getPublicKey = ed25519.getPublicKey;
function isOnCurve(publicKey2) {
  try {
    ed25519.ExtendedPoint.fromHex(publicKey2);
    return true;
  } catch {
    return false;
  }
}
var sign = (message, secretKey) => ed25519.sign(message, secretKey.slice(0, 32));
var verify = ed25519.verify;
var toBuffer = (arr) => {
  if (import_buffer2.Buffer.isBuffer(arr)) {
    return arr;
  } else if (arr instanceof Uint8Array) {
    return import_buffer2.Buffer.from(arr.buffer, arr.byteOffset, arr.byteLength);
  } else {
    return import_buffer2.Buffer.from(arr);
  }
};
var Struct2 = class {
  constructor(properties) {
    Object.assign(this, properties);
  }
  encode() {
    return import_buffer2.Buffer.from((0, import_borsh.serialize)(SOLANA_SCHEMA, this));
  }
  static decode(data) {
    return (0, import_borsh.deserialize)(SOLANA_SCHEMA, this, data);
  }
  static decodeUnchecked(data) {
    return (0, import_borsh.deserializeUnchecked)(SOLANA_SCHEMA, this, data);
  }
};
var SOLANA_SCHEMA = /* @__PURE__ */ new Map();
var _PublicKey;
var MAX_SEED_LENGTH = 32;
var PUBLIC_KEY_LENGTH = 32;
function isPublicKeyData(value2) {
  return value2._bn !== void 0;
}
var uniquePublicKeyCounter = 1;
var PublicKey = class _PublicKey2 extends Struct2 {
  /**
   * Create a new PublicKey object
   * @param value ed25519 public key as buffer or base-58 encoded string
   */
  constructor(value2) {
    super({});
    this._bn = void 0;
    if (isPublicKeyData(value2)) {
      this._bn = value2._bn;
    } else {
      if (typeof value2 === "string") {
        const decoded = import_bs58.default.decode(value2);
        if (decoded.length != PUBLIC_KEY_LENGTH) {
          throw new Error(`Invalid public key input`);
        }
        this._bn = new import_bn.default(decoded);
      } else {
        this._bn = new import_bn.default(value2);
      }
      if (this._bn.byteLength() > PUBLIC_KEY_LENGTH) {
        throw new Error(`Invalid public key input`);
      }
    }
  }
  /**
   * Returns a unique PublicKey for tests and benchmarks using a counter
   */
  static unique() {
    const key = new _PublicKey2(uniquePublicKeyCounter);
    uniquePublicKeyCounter += 1;
    return new _PublicKey2(key.toBuffer());
  }
  /**
   * Default public key value. The base58-encoded string representation is all ones (as seen below)
   * The underlying BN number is 32 bytes that are all zeros
   */
  /**
   * Checks if two publicKeys are equal
   */
  equals(publicKey2) {
    return this._bn.eq(publicKey2._bn);
  }
  /**
   * Return the base-58 representation of the public key
   */
  toBase58() {
    return import_bs58.default.encode(this.toBytes());
  }
  toJSON() {
    return this.toBase58();
  }
  /**
   * Return the byte array representation of the public key in big endian
   */
  toBytes() {
    const buf = this.toBuffer();
    return new Uint8Array(buf.buffer, buf.byteOffset, buf.byteLength);
  }
  /**
   * Return the Buffer representation of the public key in big endian
   */
  toBuffer() {
    const b3 = this._bn.toArrayLike(import_buffer2.Buffer);
    if (b3.length === PUBLIC_KEY_LENGTH) {
      return b3;
    }
    const zeroPad = import_buffer2.Buffer.alloc(32);
    b3.copy(zeroPad, 32 - b3.length);
    return zeroPad;
  }
  get [Symbol.toStringTag]() {
    return `PublicKey(${this.toString()})`;
  }
  /**
   * Return the base-58 representation of the public key
   */
  toString() {
    return this.toBase58();
  }
  /**
   * Derive a public key from another key, a seed, and a program ID.
   * The program ID will also serve as the owner of the public key, giving
   * it permission to write data to the account.
   */
  /* eslint-disable require-await */
  static async createWithSeed(fromPublicKey, seed, programId) {
    const buffer = import_buffer2.Buffer.concat([fromPublicKey.toBuffer(), import_buffer2.Buffer.from(seed), programId.toBuffer()]);
    const publicKeyBytes = sha256(buffer);
    return new _PublicKey2(publicKeyBytes);
  }
  /**
   * Derive a program address from seeds and a program ID.
   */
  /* eslint-disable require-await */
  static createProgramAddressSync(seeds, programId) {
    let buffer = import_buffer2.Buffer.alloc(0);
    seeds.forEach(function(seed) {
      if (seed.length > MAX_SEED_LENGTH) {
        throw new TypeError(`Max seed length exceeded`);
      }
      buffer = import_buffer2.Buffer.concat([buffer, toBuffer(seed)]);
    });
    buffer = import_buffer2.Buffer.concat([buffer, programId.toBuffer(), import_buffer2.Buffer.from("ProgramDerivedAddress")]);
    const publicKeyBytes = sha256(buffer);
    if (isOnCurve(publicKeyBytes)) {
      throw new Error(`Invalid seeds, address must fall off the curve`);
    }
    return new _PublicKey2(publicKeyBytes);
  }
  /**
   * Async version of createProgramAddressSync
   * For backwards compatibility
   *
   * @deprecated Use {@link createProgramAddressSync} instead
   */
  /* eslint-disable require-await */
  static async createProgramAddress(seeds, programId) {
    return this.createProgramAddressSync(seeds, programId);
  }
  /**
   * Find a valid program address
   *
   * Valid program addresses must fall off the ed25519 curve.  This function
   * iterates a nonce until it finds one that when combined with the seeds
   * results in a valid program address.
   */
  static findProgramAddressSync(seeds, programId) {
    let nonce = 255;
    let address;
    while (nonce != 0) {
      try {
        const seedsWithNonce = seeds.concat(import_buffer2.Buffer.from([nonce]));
        address = this.createProgramAddressSync(seedsWithNonce, programId);
      } catch (err) {
        if (err instanceof TypeError) {
          throw err;
        }
        nonce--;
        continue;
      }
      return [address, nonce];
    }
    throw new Error(`Unable to find a viable program address nonce`);
  }
  /**
   * Async version of findProgramAddressSync
   * For backwards compatibility
   *
   * @deprecated Use {@link findProgramAddressSync} instead
   */
  static async findProgramAddress(seeds, programId) {
    return this.findProgramAddressSync(seeds, programId);
  }
  /**
   * Check that a pubkey is on the ed25519 curve.
   */
  static isOnCurve(pubkeyData) {
    const pubkey = new _PublicKey2(pubkeyData);
    return isOnCurve(pubkey.toBytes());
  }
};
_PublicKey = PublicKey;
PublicKey.default = new _PublicKey("11111111111111111111111111111111");
SOLANA_SCHEMA.set(PublicKey, {
  kind: "struct",
  fields: [["_bn", "u256"]]
});
var BPF_LOADER_DEPRECATED_PROGRAM_ID = new PublicKey("BPFLoader1111111111111111111111111111111111");
var PACKET_DATA_SIZE = 1280 - 40 - 8;
var VERSION_PREFIX_MASK = 127;
var SIGNATURE_LENGTH_IN_BYTES = 64;
var TransactionExpiredBlockheightExceededError = class extends Error {
  constructor(signature) {
    super(`Signature ${signature} has expired: block height exceeded.`);
    this.signature = void 0;
    this.signature = signature;
  }
};
Object.defineProperty(TransactionExpiredBlockheightExceededError.prototype, "name", {
  value: "TransactionExpiredBlockheightExceededError"
});
var TransactionExpiredTimeoutError = class extends Error {
  constructor(signature, timeoutSeconds) {
    super(`Transaction was not confirmed in ${timeoutSeconds.toFixed(2)} seconds. It is unknown if it succeeded or failed. Check signature ${signature} using the Solana Explorer or CLI tools.`);
    this.signature = void 0;
    this.signature = signature;
  }
};
Object.defineProperty(TransactionExpiredTimeoutError.prototype, "name", {
  value: "TransactionExpiredTimeoutError"
});
var TransactionExpiredNonceInvalidError = class extends Error {
  constructor(signature) {
    super(`Signature ${signature} has expired: the nonce is no longer valid.`);
    this.signature = void 0;
    this.signature = signature;
  }
};
Object.defineProperty(TransactionExpiredNonceInvalidError.prototype, "name", {
  value: "TransactionExpiredNonceInvalidError"
});
var MessageAccountKeys = class {
  constructor(staticAccountKeys, accountKeysFromLookups) {
    this.staticAccountKeys = void 0;
    this.accountKeysFromLookups = void 0;
    this.staticAccountKeys = staticAccountKeys;
    this.accountKeysFromLookups = accountKeysFromLookups;
  }
  keySegments() {
    const keySegments = [this.staticAccountKeys];
    if (this.accountKeysFromLookups) {
      keySegments.push(this.accountKeysFromLookups.writable);
      keySegments.push(this.accountKeysFromLookups.readonly);
    }
    return keySegments;
  }
  get(index) {
    for (const keySegment of this.keySegments()) {
      if (index < keySegment.length) {
        return keySegment[index];
      } else {
        index -= keySegment.length;
      }
    }
    return;
  }
  get length() {
    return this.keySegments().flat().length;
  }
  compileInstructions(instructions) {
    const U8_MAX = 255;
    if (this.length > U8_MAX + 1) {
      throw new Error("Account index overflow encountered during compilation");
    }
    const keyIndexMap = /* @__PURE__ */ new Map();
    this.keySegments().flat().forEach((key, index) => {
      keyIndexMap.set(key.toBase58(), index);
    });
    const findKeyIndex = (key) => {
      const keyIndex = keyIndexMap.get(key.toBase58());
      if (keyIndex === void 0) throw new Error("Encountered an unknown instruction account key during compilation");
      return keyIndex;
    };
    return instructions.map((instruction) => {
      return {
        programIdIndex: findKeyIndex(instruction.programId),
        accountKeyIndexes: instruction.keys.map((meta) => findKeyIndex(meta.pubkey)),
        data: instruction.data
      };
    });
  }
};
var publicKey = (property = "publicKey") => {
  return BufferLayout.blob(32, property);
};
var rustString = (property = "string") => {
  const rsl = BufferLayout.struct([BufferLayout.u32("length"), BufferLayout.u32("lengthPadding"), BufferLayout.blob(BufferLayout.offset(BufferLayout.u32(), -8), "chars")], property);
  const _decode = rsl.decode.bind(rsl);
  const _encode = rsl.encode.bind(rsl);
  const rslShim = rsl;
  rslShim.decode = (b3, offset2) => {
    const data = _decode(b3, offset2);
    return data["chars"].toString();
  };
  rslShim.encode = (str, b3, offset2) => {
    const data = {
      chars: import_buffer2.Buffer.from(str, "utf8")
    };
    return _encode(data, b3, offset2);
  };
  rslShim.alloc = (str) => {
    return BufferLayout.u32().span + BufferLayout.u32().span + import_buffer2.Buffer.from(str, "utf8").length;
  };
  return rslShim;
};
var authorized = (property = "authorized") => {
  return BufferLayout.struct([publicKey("staker"), publicKey("withdrawer")], property);
};
var lockup = (property = "lockup") => {
  return BufferLayout.struct([BufferLayout.ns64("unixTimestamp"), BufferLayout.ns64("epoch"), publicKey("custodian")], property);
};
var voteInit = (property = "voteInit") => {
  return BufferLayout.struct([publicKey("nodePubkey"), publicKey("authorizedVoter"), publicKey("authorizedWithdrawer"), BufferLayout.u8("commission")], property);
};
var voteAuthorizeWithSeedArgs = (property = "voteAuthorizeWithSeedArgs") => {
  return BufferLayout.struct([BufferLayout.u32("voteAuthorizationType"), publicKey("currentAuthorityDerivedKeyOwnerPubkey"), rustString("currentAuthorityDerivedKeySeed"), publicKey("newAuthorized")], property);
};
function getAlloc(type2, fields) {
  const getItemAlloc = (item) => {
    if (item.span >= 0) {
      return item.span;
    } else if (typeof item.alloc === "function") {
      return item.alloc(fields[item.property]);
    } else if ("count" in item && "elementLayout" in item) {
      const field = fields[item.property];
      if (Array.isArray(field)) {
        return field.length * getItemAlloc(item.elementLayout);
      }
    } else if ("fields" in item) {
      return getAlloc({
        layout: item
      }, fields[item.property]);
    }
    return 0;
  };
  let alloc = 0;
  type2.layout.fields.forEach((item) => {
    alloc += getItemAlloc(item);
  });
  return alloc;
}
function decodeLength(bytes) {
  let len = 0;
  let size = 0;
  for (; ; ) {
    let elem = bytes.shift();
    len |= (elem & 127) << size * 7;
    size += 1;
    if ((elem & 128) === 0) {
      break;
    }
  }
  return len;
}
function encodeLength(bytes, len) {
  let rem_len = len;
  for (; ; ) {
    let elem = rem_len & 127;
    rem_len >>= 7;
    if (rem_len == 0) {
      bytes.push(elem);
      break;
    } else {
      elem |= 128;
      bytes.push(elem);
    }
  }
}
function assert2(condition, message) {
  if (!condition) {
    throw new Error(message || "Assertion failed");
  }
}
var CompiledKeys = class _CompiledKeys {
  constructor(payer, keyMetaMap) {
    this.payer = void 0;
    this.keyMetaMap = void 0;
    this.payer = payer;
    this.keyMetaMap = keyMetaMap;
  }
  static compile(instructions, payer) {
    const keyMetaMap = /* @__PURE__ */ new Map();
    const getOrInsertDefault = (pubkey) => {
      const address = pubkey.toBase58();
      let keyMeta = keyMetaMap.get(address);
      if (keyMeta === void 0) {
        keyMeta = {
          isSigner: false,
          isWritable: false,
          isInvoked: false
        };
        keyMetaMap.set(address, keyMeta);
      }
      return keyMeta;
    };
    const payerKeyMeta = getOrInsertDefault(payer);
    payerKeyMeta.isSigner = true;
    payerKeyMeta.isWritable = true;
    for (const ix of instructions) {
      getOrInsertDefault(ix.programId).isInvoked = true;
      for (const accountMeta of ix.keys) {
        const keyMeta = getOrInsertDefault(accountMeta.pubkey);
        keyMeta.isSigner || (keyMeta.isSigner = accountMeta.isSigner);
        keyMeta.isWritable || (keyMeta.isWritable = accountMeta.isWritable);
      }
    }
    return new _CompiledKeys(payer, keyMetaMap);
  }
  getMessageComponents() {
    const mapEntries = [...this.keyMetaMap.entries()];
    assert2(mapEntries.length <= 256, "Max static account keys length exceeded");
    const writableSigners = mapEntries.filter(([, meta]) => meta.isSigner && meta.isWritable);
    const readonlySigners = mapEntries.filter(([, meta]) => meta.isSigner && !meta.isWritable);
    const writableNonSigners = mapEntries.filter(([, meta]) => !meta.isSigner && meta.isWritable);
    const readonlyNonSigners = mapEntries.filter(([, meta]) => !meta.isSigner && !meta.isWritable);
    const header = {
      numRequiredSignatures: writableSigners.length + readonlySigners.length,
      numReadonlySignedAccounts: readonlySigners.length,
      numReadonlyUnsignedAccounts: readonlyNonSigners.length
    };
    {
      assert2(writableSigners.length > 0, "Expected at least one writable signer key");
      const [payerAddress] = writableSigners[0];
      assert2(payerAddress === this.payer.toBase58(), "Expected first writable signer key to be the fee payer");
    }
    const staticAccountKeys = [...writableSigners.map(([address]) => new PublicKey(address)), ...readonlySigners.map(([address]) => new PublicKey(address)), ...writableNonSigners.map(([address]) => new PublicKey(address)), ...readonlyNonSigners.map(([address]) => new PublicKey(address))];
    return [header, staticAccountKeys];
  }
  extractTableLookup(lookupTable) {
    const [writableIndexes, drainedWritableKeys] = this.drainKeysFoundInLookupTable(lookupTable.state.addresses, (keyMeta) => !keyMeta.isSigner && !keyMeta.isInvoked && keyMeta.isWritable);
    const [readonlyIndexes, drainedReadonlyKeys] = this.drainKeysFoundInLookupTable(lookupTable.state.addresses, (keyMeta) => !keyMeta.isSigner && !keyMeta.isInvoked && !keyMeta.isWritable);
    if (writableIndexes.length === 0 && readonlyIndexes.length === 0) {
      return;
    }
    return [{
      accountKey: lookupTable.key,
      writableIndexes,
      readonlyIndexes
    }, {
      writable: drainedWritableKeys,
      readonly: drainedReadonlyKeys
    }];
  }
  /** @internal */
  drainKeysFoundInLookupTable(lookupTableEntries, keyMetaFilter) {
    const lookupTableIndexes = new Array();
    const drainedKeys = new Array();
    for (const [address, keyMeta] of this.keyMetaMap.entries()) {
      if (keyMetaFilter(keyMeta)) {
        const key = new PublicKey(address);
        const lookupTableIndex = lookupTableEntries.findIndex((entry) => entry.equals(key));
        if (lookupTableIndex >= 0) {
          assert2(lookupTableIndex < 256, "Max lookup table index exceeded");
          lookupTableIndexes.push(lookupTableIndex);
          drainedKeys.push(key);
          this.keyMetaMap.delete(address);
        }
      }
    }
    return [lookupTableIndexes, drainedKeys];
  }
};
var END_OF_BUFFER_ERROR_MESSAGE = "Reached end of buffer unexpectedly";
function guardedShift(byteArray) {
  if (byteArray.length === 0) {
    throw new Error(END_OF_BUFFER_ERROR_MESSAGE);
  }
  return byteArray.shift();
}
function guardedSplice(byteArray, ...args) {
  const [start] = args;
  if (args.length === 2 ? start + (args[1] ?? 0) > byteArray.length : start >= byteArray.length) {
    throw new Error(END_OF_BUFFER_ERROR_MESSAGE);
  }
  return byteArray.splice(...args);
}
var Message = class _Message {
  constructor(args) {
    this.header = void 0;
    this.accountKeys = void 0;
    this.recentBlockhash = void 0;
    this.instructions = void 0;
    this.indexToProgramIds = /* @__PURE__ */ new Map();
    this.header = args.header;
    this.accountKeys = args.accountKeys.map((account) => new PublicKey(account));
    this.recentBlockhash = args.recentBlockhash;
    this.instructions = args.instructions;
    this.instructions.forEach((ix) => this.indexToProgramIds.set(ix.programIdIndex, this.accountKeys[ix.programIdIndex]));
  }
  get version() {
    return "legacy";
  }
  get staticAccountKeys() {
    return this.accountKeys;
  }
  get compiledInstructions() {
    return this.instructions.map((ix) => ({
      programIdIndex: ix.programIdIndex,
      accountKeyIndexes: ix.accounts,
      data: import_bs58.default.decode(ix.data)
    }));
  }
  get addressTableLookups() {
    return [];
  }
  getAccountKeys() {
    return new MessageAccountKeys(this.staticAccountKeys);
  }
  static compile(args) {
    const compiledKeys = CompiledKeys.compile(args.instructions, args.payerKey);
    const [header, staticAccountKeys] = compiledKeys.getMessageComponents();
    const accountKeys = new MessageAccountKeys(staticAccountKeys);
    const instructions = accountKeys.compileInstructions(args.instructions).map((ix) => ({
      programIdIndex: ix.programIdIndex,
      accounts: ix.accountKeyIndexes,
      data: import_bs58.default.encode(ix.data)
    }));
    return new _Message({
      header,
      accountKeys: staticAccountKeys,
      recentBlockhash: args.recentBlockhash,
      instructions
    });
  }
  isAccountSigner(index) {
    return index < this.header.numRequiredSignatures;
  }
  isAccountWritable(index) {
    const numSignedAccounts = this.header.numRequiredSignatures;
    if (index >= this.header.numRequiredSignatures) {
      const unsignedAccountIndex = index - numSignedAccounts;
      const numUnsignedAccounts = this.accountKeys.length - numSignedAccounts;
      const numWritableUnsignedAccounts = numUnsignedAccounts - this.header.numReadonlyUnsignedAccounts;
      return unsignedAccountIndex < numWritableUnsignedAccounts;
    } else {
      const numWritableSignedAccounts = numSignedAccounts - this.header.numReadonlySignedAccounts;
      return index < numWritableSignedAccounts;
    }
  }
  isProgramId(index) {
    return this.indexToProgramIds.has(index);
  }
  programIds() {
    return [...this.indexToProgramIds.values()];
  }
  nonProgramIds() {
    return this.accountKeys.filter((_2, index) => !this.isProgramId(index));
  }
  serialize() {
    const numKeys = this.accountKeys.length;
    let keyCount = [];
    encodeLength(keyCount, numKeys);
    const instructions = this.instructions.map((instruction) => {
      const {
        accounts,
        programIdIndex
      } = instruction;
      const data = Array.from(import_bs58.default.decode(instruction.data));
      let keyIndicesCount = [];
      encodeLength(keyIndicesCount, accounts.length);
      let dataCount = [];
      encodeLength(dataCount, data.length);
      return {
        programIdIndex,
        keyIndicesCount: import_buffer2.Buffer.from(keyIndicesCount),
        keyIndices: accounts,
        dataLength: import_buffer2.Buffer.from(dataCount),
        data
      };
    });
    let instructionCount = [];
    encodeLength(instructionCount, instructions.length);
    let instructionBuffer = import_buffer2.Buffer.alloc(PACKET_DATA_SIZE);
    import_buffer2.Buffer.from(instructionCount).copy(instructionBuffer);
    let instructionBufferLength = instructionCount.length;
    instructions.forEach((instruction) => {
      const instructionLayout = BufferLayout.struct([BufferLayout.u8("programIdIndex"), BufferLayout.blob(instruction.keyIndicesCount.length, "keyIndicesCount"), BufferLayout.seq(BufferLayout.u8("keyIndex"), instruction.keyIndices.length, "keyIndices"), BufferLayout.blob(instruction.dataLength.length, "dataLength"), BufferLayout.seq(BufferLayout.u8("userdatum"), instruction.data.length, "data")]);
      const length2 = instructionLayout.encode(instruction, instructionBuffer, instructionBufferLength);
      instructionBufferLength += length2;
    });
    instructionBuffer = instructionBuffer.slice(0, instructionBufferLength);
    const signDataLayout = BufferLayout.struct([BufferLayout.blob(1, "numRequiredSignatures"), BufferLayout.blob(1, "numReadonlySignedAccounts"), BufferLayout.blob(1, "numReadonlyUnsignedAccounts"), BufferLayout.blob(keyCount.length, "keyCount"), BufferLayout.seq(publicKey("key"), numKeys, "keys"), publicKey("recentBlockhash")]);
    const transaction = {
      numRequiredSignatures: import_buffer2.Buffer.from([this.header.numRequiredSignatures]),
      numReadonlySignedAccounts: import_buffer2.Buffer.from([this.header.numReadonlySignedAccounts]),
      numReadonlyUnsignedAccounts: import_buffer2.Buffer.from([this.header.numReadonlyUnsignedAccounts]),
      keyCount: import_buffer2.Buffer.from(keyCount),
      keys: this.accountKeys.map((key) => toBuffer(key.toBytes())),
      recentBlockhash: import_bs58.default.decode(this.recentBlockhash)
    };
    let signData = import_buffer2.Buffer.alloc(2048);
    const length = signDataLayout.encode(transaction, signData);
    instructionBuffer.copy(signData, length);
    return signData.slice(0, length + instructionBuffer.length);
  }
  /**
   * Decode a compiled message into a Message object.
   */
  static from(buffer) {
    let byteArray = [...buffer];
    const numRequiredSignatures = guardedShift(byteArray);
    if (numRequiredSignatures !== (numRequiredSignatures & VERSION_PREFIX_MASK)) {
      throw new Error("Versioned messages must be deserialized with VersionedMessage.deserialize()");
    }
    const numReadonlySignedAccounts = guardedShift(byteArray);
    const numReadonlyUnsignedAccounts = guardedShift(byteArray);
    const accountCount = decodeLength(byteArray);
    let accountKeys = [];
    for (let i4 = 0; i4 < accountCount; i4++) {
      const account = guardedSplice(byteArray, 0, PUBLIC_KEY_LENGTH);
      accountKeys.push(new PublicKey(import_buffer2.Buffer.from(account)));
    }
    const recentBlockhash = guardedSplice(byteArray, 0, PUBLIC_KEY_LENGTH);
    const instructionCount = decodeLength(byteArray);
    let instructions = [];
    for (let i4 = 0; i4 < instructionCount; i4++) {
      const programIdIndex = guardedShift(byteArray);
      const accountCount2 = decodeLength(byteArray);
      const accounts = guardedSplice(byteArray, 0, accountCount2);
      const dataLength = decodeLength(byteArray);
      const dataSlice = guardedSplice(byteArray, 0, dataLength);
      const data = import_bs58.default.encode(import_buffer2.Buffer.from(dataSlice));
      instructions.push({
        programIdIndex,
        accounts,
        data
      });
    }
    const messageArgs = {
      header: {
        numRequiredSignatures,
        numReadonlySignedAccounts,
        numReadonlyUnsignedAccounts
      },
      recentBlockhash: import_bs58.default.encode(import_buffer2.Buffer.from(recentBlockhash)),
      accountKeys,
      instructions
    };
    return new _Message(messageArgs);
  }
};
var TransactionStatus = function(TransactionStatus2) {
  TransactionStatus2[TransactionStatus2["BLOCKHEIGHT_EXCEEDED"] = 0] = "BLOCKHEIGHT_EXCEEDED";
  TransactionStatus2[TransactionStatus2["PROCESSED"] = 1] = "PROCESSED";
  TransactionStatus2[TransactionStatus2["TIMED_OUT"] = 2] = "TIMED_OUT";
  TransactionStatus2[TransactionStatus2["NONCE_INVALID"] = 3] = "NONCE_INVALID";
  return TransactionStatus2;
}({});
var DEFAULT_SIGNATURE = import_buffer2.Buffer.alloc(SIGNATURE_LENGTH_IN_BYTES).fill(0);
var TransactionInstruction = class {
  constructor(opts) {
    this.keys = void 0;
    this.programId = void 0;
    this.data = import_buffer2.Buffer.alloc(0);
    this.programId = opts.programId;
    this.keys = opts.keys;
    if (opts.data) {
      this.data = opts.data;
    }
  }
  /**
   * @internal
   */
  toJSON() {
    return {
      keys: this.keys.map(({
        pubkey,
        isSigner,
        isWritable
      }) => ({
        pubkey: pubkey.toJSON(),
        isSigner,
        isWritable
      })),
      programId: this.programId.toJSON(),
      data: [...this.data]
    };
  }
};
var Transaction = class _Transaction {
  /**
   * The first (payer) Transaction signature
   *
   * @returns {Buffer | null} Buffer of payer's signature
   */
  get signature() {
    if (this.signatures.length > 0) {
      return this.signatures[0].signature;
    }
    return null;
  }
  /**
   * The transaction fee payer
   */
  // Construct a transaction with a blockhash and lastValidBlockHeight
  // Construct a transaction using a durable nonce
  /**
   * @deprecated `TransactionCtorFields` has been deprecated and will be removed in a future version.
   * Please supply a `TransactionBlockhashCtor` instead.
   */
  /**
   * Construct an empty Transaction
   */
  constructor(opts) {
    this.signatures = [];
    this.feePayer = void 0;
    this.instructions = [];
    this.recentBlockhash = void 0;
    this.lastValidBlockHeight = void 0;
    this.nonceInfo = void 0;
    this.minNonceContextSlot = void 0;
    this._message = void 0;
    this._json = void 0;
    if (!opts) {
      return;
    }
    if (opts.feePayer) {
      this.feePayer = opts.feePayer;
    }
    if (opts.signatures) {
      this.signatures = opts.signatures;
    }
    if (Object.prototype.hasOwnProperty.call(opts, "nonceInfo")) {
      const {
        minContextSlot,
        nonceInfo
      } = opts;
      this.minNonceContextSlot = minContextSlot;
      this.nonceInfo = nonceInfo;
    } else if (Object.prototype.hasOwnProperty.call(opts, "lastValidBlockHeight")) {
      const {
        blockhash,
        lastValidBlockHeight
      } = opts;
      this.recentBlockhash = blockhash;
      this.lastValidBlockHeight = lastValidBlockHeight;
    } else {
      const {
        recentBlockhash,
        nonceInfo
      } = opts;
      if (nonceInfo) {
        this.nonceInfo = nonceInfo;
      }
      this.recentBlockhash = recentBlockhash;
    }
  }
  /**
   * @internal
   */
  toJSON() {
    return {
      recentBlockhash: this.recentBlockhash || null,
      feePayer: this.feePayer ? this.feePayer.toJSON() : null,
      nonceInfo: this.nonceInfo ? {
        nonce: this.nonceInfo.nonce,
        nonceInstruction: this.nonceInfo.nonceInstruction.toJSON()
      } : null,
      instructions: this.instructions.map((instruction) => instruction.toJSON()),
      signers: this.signatures.map(({
        publicKey: publicKey2
      }) => {
        return publicKey2.toJSON();
      })
    };
  }
  /**
   * Add one or more instructions to this Transaction
   *
   * @param {Array< Transaction | TransactionInstruction | TransactionInstructionCtorFields >} items - Instructions to add to the Transaction
   */
  add(...items) {
    if (items.length === 0) {
      throw new Error("No instructions");
    }
    items.forEach((item) => {
      if ("instructions" in item) {
        this.instructions = this.instructions.concat(item.instructions);
      } else if ("data" in item && "programId" in item && "keys" in item) {
        this.instructions.push(item);
      } else {
        this.instructions.push(new TransactionInstruction(item));
      }
    });
    return this;
  }
  /**
   * Compile transaction data
   */
  compileMessage() {
    if (this._message && JSON.stringify(this.toJSON()) === JSON.stringify(this._json)) {
      return this._message;
    }
    let recentBlockhash;
    let instructions;
    if (this.nonceInfo) {
      recentBlockhash = this.nonceInfo.nonce;
      if (this.instructions[0] != this.nonceInfo.nonceInstruction) {
        instructions = [this.nonceInfo.nonceInstruction, ...this.instructions];
      } else {
        instructions = this.instructions;
      }
    } else {
      recentBlockhash = this.recentBlockhash;
      instructions = this.instructions;
    }
    if (!recentBlockhash) {
      throw new Error("Transaction recentBlockhash required");
    }
    if (instructions.length < 1) {
      console.warn("No instructions provided");
    }
    let feePayer;
    if (this.feePayer) {
      feePayer = this.feePayer;
    } else if (this.signatures.length > 0 && this.signatures[0].publicKey) {
      feePayer = this.signatures[0].publicKey;
    } else {
      throw new Error("Transaction fee payer required");
    }
    for (let i4 = 0; i4 < instructions.length; i4++) {
      if (instructions[i4].programId === void 0) {
        throw new Error(`Transaction instruction index ${i4} has undefined program id`);
      }
    }
    const programIds = [];
    const accountMetas = [];
    instructions.forEach((instruction) => {
      instruction.keys.forEach((accountMeta) => {
        accountMetas.push({
          ...accountMeta
        });
      });
      const programId = instruction.programId.toString();
      if (!programIds.includes(programId)) {
        programIds.push(programId);
      }
    });
    programIds.forEach((programId) => {
      accountMetas.push({
        pubkey: new PublicKey(programId),
        isSigner: false,
        isWritable: false
      });
    });
    const uniqueMetas = [];
    accountMetas.forEach((accountMeta) => {
      const pubkeyString = accountMeta.pubkey.toString();
      const uniqueIndex = uniqueMetas.findIndex((x3) => {
        return x3.pubkey.toString() === pubkeyString;
      });
      if (uniqueIndex > -1) {
        uniqueMetas[uniqueIndex].isWritable = uniqueMetas[uniqueIndex].isWritable || accountMeta.isWritable;
        uniqueMetas[uniqueIndex].isSigner = uniqueMetas[uniqueIndex].isSigner || accountMeta.isSigner;
      } else {
        uniqueMetas.push(accountMeta);
      }
    });
    uniqueMetas.sort(function(x3, y2) {
      if (x3.isSigner !== y2.isSigner) {
        return x3.isSigner ? -1 : 1;
      }
      if (x3.isWritable !== y2.isWritable) {
        return x3.isWritable ? -1 : 1;
      }
      const options = {
        localeMatcher: "best fit",
        usage: "sort",
        sensitivity: "variant",
        ignorePunctuation: false,
        numeric: false,
        caseFirst: "lower"
      };
      return x3.pubkey.toBase58().localeCompare(y2.pubkey.toBase58(), "en", options);
    });
    const feePayerIndex = uniqueMetas.findIndex((x3) => {
      return x3.pubkey.equals(feePayer);
    });
    if (feePayerIndex > -1) {
      const [payerMeta] = uniqueMetas.splice(feePayerIndex, 1);
      payerMeta.isSigner = true;
      payerMeta.isWritable = true;
      uniqueMetas.unshift(payerMeta);
    } else {
      uniqueMetas.unshift({
        pubkey: feePayer,
        isSigner: true,
        isWritable: true
      });
    }
    for (const signature of this.signatures) {
      const uniqueIndex = uniqueMetas.findIndex((x3) => {
        return x3.pubkey.equals(signature.publicKey);
      });
      if (uniqueIndex > -1) {
        if (!uniqueMetas[uniqueIndex].isSigner) {
          uniqueMetas[uniqueIndex].isSigner = true;
          console.warn("Transaction references a signature that is unnecessary, only the fee payer and instruction signer accounts should sign a transaction. This behavior is deprecated and will throw an error in the next major version release.");
        }
      } else {
        throw new Error(`unknown signer: ${signature.publicKey.toString()}`);
      }
    }
    let numRequiredSignatures = 0;
    let numReadonlySignedAccounts = 0;
    let numReadonlyUnsignedAccounts = 0;
    const signedKeys = [];
    const unsignedKeys = [];
    uniqueMetas.forEach(({
      pubkey,
      isSigner,
      isWritable
    }) => {
      if (isSigner) {
        signedKeys.push(pubkey.toString());
        numRequiredSignatures += 1;
        if (!isWritable) {
          numReadonlySignedAccounts += 1;
        }
      } else {
        unsignedKeys.push(pubkey.toString());
        if (!isWritable) {
          numReadonlyUnsignedAccounts += 1;
        }
      }
    });
    const accountKeys = signedKeys.concat(unsignedKeys);
    const compiledInstructions = instructions.map((instruction) => {
      const {
        data,
        programId
      } = instruction;
      return {
        programIdIndex: accountKeys.indexOf(programId.toString()),
        accounts: instruction.keys.map((meta) => accountKeys.indexOf(meta.pubkey.toString())),
        data: import_bs58.default.encode(data)
      };
    });
    compiledInstructions.forEach((instruction) => {
      assert2(instruction.programIdIndex >= 0);
      instruction.accounts.forEach((keyIndex) => assert2(keyIndex >= 0));
    });
    return new Message({
      header: {
        numRequiredSignatures,
        numReadonlySignedAccounts,
        numReadonlyUnsignedAccounts
      },
      accountKeys,
      recentBlockhash,
      instructions: compiledInstructions
    });
  }
  /**
   * @internal
   */
  _compile() {
    const message = this.compileMessage();
    const signedKeys = message.accountKeys.slice(0, message.header.numRequiredSignatures);
    if (this.signatures.length === signedKeys.length) {
      const valid = this.signatures.every((pair, index) => {
        return signedKeys[index].equals(pair.publicKey);
      });
      if (valid) return message;
    }
    this.signatures = signedKeys.map((publicKey2) => ({
      signature: null,
      publicKey: publicKey2
    }));
    return message;
  }
  /**
   * Get a buffer of the Transaction data that need to be covered by signatures
   */
  serializeMessage() {
    return this._compile().serialize();
  }
  /**
   * Get the estimated fee associated with a transaction
   *
   * @param {Connection} connection Connection to RPC Endpoint.
   *
   * @returns {Promise<number | null>} The estimated fee for the transaction
   */
  async getEstimatedFee(connection) {
    return (await connection.getFeeForMessage(this.compileMessage())).value;
  }
  /**
   * Specify the public keys which will be used to sign the Transaction.
   * The first signer will be used as the transaction fee payer account.
   *
   * Signatures can be added with either `partialSign` or `addSignature`
   *
   * @deprecated Deprecated since v0.84.0. Only the fee payer needs to be
   * specified and it can be set in the Transaction constructor or with the
   * `feePayer` property.
   */
  setSigners(...signers) {
    if (signers.length === 0) {
      throw new Error("No signers");
    }
    const seen = /* @__PURE__ */ new Set();
    this.signatures = signers.filter((publicKey2) => {
      const key = publicKey2.toString();
      if (seen.has(key)) {
        return false;
      } else {
        seen.add(key);
        return true;
      }
    }).map((publicKey2) => ({
      signature: null,
      publicKey: publicKey2
    }));
  }
  /**
   * Sign the Transaction with the specified signers. Multiple signatures may
   * be applied to a Transaction. The first signature is considered "primary"
   * and is used identify and confirm transactions.
   *
   * If the Transaction `feePayer` is not set, the first signer will be used
   * as the transaction fee payer account.
   *
   * Transaction fields should not be modified after the first call to `sign`,
   * as doing so may invalidate the signature and cause the Transaction to be
   * rejected.
   *
   * The Transaction must be assigned a valid `recentBlockhash` before invoking this method
   *
   * @param {Array<Signer>} signers Array of signers that will sign the transaction
   */
  sign(...signers) {
    if (signers.length === 0) {
      throw new Error("No signers");
    }
    const seen = /* @__PURE__ */ new Set();
    const uniqueSigners = [];
    for (const signer of signers) {
      const key = signer.publicKey.toString();
      if (seen.has(key)) {
        continue;
      } else {
        seen.add(key);
        uniqueSigners.push(signer);
      }
    }
    this.signatures = uniqueSigners.map((signer) => ({
      signature: null,
      publicKey: signer.publicKey
    }));
    const message = this._compile();
    this._partialSign(message, ...uniqueSigners);
  }
  /**
   * Partially sign a transaction with the specified accounts. All accounts must
   * correspond to either the fee payer or a signer account in the transaction
   * instructions.
   *
   * All the caveats from the `sign` method apply to `partialSign`
   *
   * @param {Array<Signer>} signers Array of signers that will sign the transaction
   */
  partialSign(...signers) {
    if (signers.length === 0) {
      throw new Error("No signers");
    }
    const seen = /* @__PURE__ */ new Set();
    const uniqueSigners = [];
    for (const signer of signers) {
      const key = signer.publicKey.toString();
      if (seen.has(key)) {
        continue;
      } else {
        seen.add(key);
        uniqueSigners.push(signer);
      }
    }
    const message = this._compile();
    this._partialSign(message, ...uniqueSigners);
  }
  /**
   * @internal
   */
  _partialSign(message, ...signers) {
    const signData = message.serialize();
    signers.forEach((signer) => {
      const signature = sign(signData, signer.secretKey);
      this._addSignature(signer.publicKey, toBuffer(signature));
    });
  }
  /**
   * Add an externally created signature to a transaction. The public key
   * must correspond to either the fee payer or a signer account in the transaction
   * instructions.
   *
   * @param {PublicKey} pubkey Public key that will be added to the transaction.
   * @param {Buffer} signature An externally created signature to add to the transaction.
   */
  addSignature(pubkey, signature) {
    this._compile();
    this._addSignature(pubkey, signature);
  }
  /**
   * @internal
   */
  _addSignature(pubkey, signature) {
    assert2(signature.length === 64);
    const index = this.signatures.findIndex((sigpair) => pubkey.equals(sigpair.publicKey));
    if (index < 0) {
      throw new Error(`unknown signer: ${pubkey.toString()}`);
    }
    this.signatures[index].signature = import_buffer2.Buffer.from(signature);
  }
  /**
   * Verify signatures of a Transaction
   * Optional parameter specifies if we're expecting a fully signed Transaction or a partially signed one.
   * If no boolean is provided, we expect a fully signed Transaction by default.
   *
   * @param {boolean} [requireAllSignatures=true] Require a fully signed Transaction
   */
  verifySignatures(requireAllSignatures = true) {
    const signatureErrors = this._getMessageSignednessErrors(this.serializeMessage(), requireAllSignatures);
    return !signatureErrors;
  }
  /**
   * @internal
   */
  _getMessageSignednessErrors(message, requireAllSignatures) {
    const errors = {};
    for (const {
      signature,
      publicKey: publicKey2
    } of this.signatures) {
      if (signature === null) {
        if (requireAllSignatures) {
          (errors.missing || (errors.missing = [])).push(publicKey2);
        }
      } else {
        if (!verify(signature, message, publicKey2.toBytes())) {
          (errors.invalid || (errors.invalid = [])).push(publicKey2);
        }
      }
    }
    return errors.invalid || errors.missing ? errors : void 0;
  }
  /**
   * Serialize the Transaction in the wire format.
   *
   * @param {Buffer} [config] Config of transaction.
   *
   * @returns {Buffer} Signature of transaction in wire format.
   */
  serialize(config) {
    const {
      requireAllSignatures,
      verifySignatures
    } = Object.assign({
      requireAllSignatures: true,
      verifySignatures: true
    }, config);
    const signData = this.serializeMessage();
    if (verifySignatures) {
      const sigErrors = this._getMessageSignednessErrors(signData, requireAllSignatures);
      if (sigErrors) {
        let errorMessage = "Signature verification failed.";
        if (sigErrors.invalid) {
          errorMessage += `
Invalid signature for public key${sigErrors.invalid.length === 1 ? "" : "(s)"} [\`${sigErrors.invalid.map((p4) => p4.toBase58()).join("`, `")}\`].`;
        }
        if (sigErrors.missing) {
          errorMessage += `
Missing signature for public key${sigErrors.missing.length === 1 ? "" : "(s)"} [\`${sigErrors.missing.map((p4) => p4.toBase58()).join("`, `")}\`].`;
        }
        throw new Error(errorMessage);
      }
    }
    return this._serialize(signData);
  }
  /**
   * @internal
   */
  _serialize(signData) {
    const {
      signatures
    } = this;
    const signatureCount = [];
    encodeLength(signatureCount, signatures.length);
    const transactionLength = signatureCount.length + signatures.length * 64 + signData.length;
    const wireTransaction = import_buffer2.Buffer.alloc(transactionLength);
    assert2(signatures.length < 256);
    import_buffer2.Buffer.from(signatureCount).copy(wireTransaction, 0);
    signatures.forEach(({
      signature
    }, index) => {
      if (signature !== null) {
        assert2(signature.length === 64, `signature has invalid length`);
        import_buffer2.Buffer.from(signature).copy(wireTransaction, signatureCount.length + index * 64);
      }
    });
    signData.copy(wireTransaction, signatureCount.length + signatures.length * 64);
    assert2(wireTransaction.length <= PACKET_DATA_SIZE, `Transaction too large: ${wireTransaction.length} > ${PACKET_DATA_SIZE}`);
    return wireTransaction;
  }
  /**
   * Deprecated method
   * @internal
   */
  get keys() {
    assert2(this.instructions.length === 1);
    return this.instructions[0].keys.map((keyObj) => keyObj.pubkey);
  }
  /**
   * Deprecated method
   * @internal
   */
  get programId() {
    assert2(this.instructions.length === 1);
    return this.instructions[0].programId;
  }
  /**
   * Deprecated method
   * @internal
   */
  get data() {
    assert2(this.instructions.length === 1);
    return this.instructions[0].data;
  }
  /**
   * Parse a wire transaction into a Transaction object.
   *
   * @param {Buffer | Uint8Array | Array<number>} buffer Signature of wire Transaction
   *
   * @returns {Transaction} Transaction associated with the signature
   */
  static from(buffer) {
    let byteArray = [...buffer];
    const signatureCount = decodeLength(byteArray);
    let signatures = [];
    for (let i4 = 0; i4 < signatureCount; i4++) {
      const signature = guardedSplice(byteArray, 0, SIGNATURE_LENGTH_IN_BYTES);
      signatures.push(import_bs58.default.encode(import_buffer2.Buffer.from(signature)));
    }
    return _Transaction.populate(Message.from(byteArray), signatures);
  }
  /**
   * Populate Transaction object from message and signatures
   *
   * @param {Message} message Message of transaction
   * @param {Array<string>} signatures List of signatures to assign to the transaction
   *
   * @returns {Transaction} The populated Transaction
   */
  static populate(message, signatures = []) {
    const transaction = new _Transaction();
    transaction.recentBlockhash = message.recentBlockhash;
    if (message.header.numRequiredSignatures > 0) {
      transaction.feePayer = message.accountKeys[0];
    }
    signatures.forEach((signature, index) => {
      const sigPubkeyPair = {
        signature: signature == import_bs58.default.encode(DEFAULT_SIGNATURE) ? null : import_bs58.default.decode(signature),
        publicKey: message.accountKeys[index]
      };
      transaction.signatures.push(sigPubkeyPair);
    });
    message.instructions.forEach((instruction) => {
      const keys = instruction.accounts.map((account) => {
        const pubkey = message.accountKeys[account];
        return {
          pubkey,
          isSigner: transaction.signatures.some((keyObj) => keyObj.publicKey.toString() === pubkey.toString()) || message.isAccountSigner(account),
          isWritable: message.isAccountWritable(account)
        };
      });
      transaction.instructions.push(new TransactionInstruction({
        keys,
        programId: message.accountKeys[instruction.programIdIndex],
        data: import_bs58.default.decode(instruction.data)
      }));
    });
    transaction._message = message;
    transaction._json = transaction.toJSON();
    return transaction;
  }
};
var NUM_TICKS_PER_SECOND = 160;
var DEFAULT_TICKS_PER_SLOT = 64;
var NUM_SLOTS_PER_SECOND = NUM_TICKS_PER_SECOND / DEFAULT_TICKS_PER_SLOT;
var MS_PER_SLOT = 1e3 / NUM_SLOTS_PER_SECOND;
var SYSVAR_CLOCK_PUBKEY = new PublicKey("SysvarC1ock11111111111111111111111111111111");
var SYSVAR_EPOCH_SCHEDULE_PUBKEY = new PublicKey("SysvarEpochSchedu1e111111111111111111111111");
var SYSVAR_INSTRUCTIONS_PUBKEY = new PublicKey("Sysvar1nstructions1111111111111111111111111");
var SYSVAR_RECENT_BLOCKHASHES_PUBKEY = new PublicKey("SysvarRecentB1ockHashes11111111111111111111");
var SYSVAR_RENT_PUBKEY = new PublicKey("SysvarRent111111111111111111111111111111111");
var SYSVAR_REWARDS_PUBKEY = new PublicKey("SysvarRewards111111111111111111111111111111");
var SYSVAR_SLOT_HASHES_PUBKEY = new PublicKey("SysvarS1otHashes111111111111111111111111111");
var SYSVAR_SLOT_HISTORY_PUBKEY = new PublicKey("SysvarS1otHistory11111111111111111111111111");
var SYSVAR_STAKE_HISTORY_PUBKEY = new PublicKey("SysvarStakeHistory1111111111111111111111111");
var SendTransactionError = class extends Error {
  constructor({
    action,
    signature,
    transactionMessage,
    logs
  }) {
    const maybeLogsOutput = logs ? `Logs: 
${JSON.stringify(logs.slice(-10), null, 2)}. ` : "";
    const guideText = "\nCatch the `SendTransactionError` and call `getLogs()` on it for full details.";
    let message;
    switch (action) {
      case "send":
        message = `Transaction ${signature} resulted in an error. 
${transactionMessage}. ` + maybeLogsOutput + guideText;
        break;
      case "simulate":
        message = `Simulation failed. 
Message: ${transactionMessage}. 
` + maybeLogsOutput + guideText;
        break;
      default: {
        message = `Unknown action '${/* @__PURE__ */ ((a) => a)(action)}'`;
      }
    }
    super(message);
    this.signature = void 0;
    this.transactionMessage = void 0;
    this.transactionLogs = void 0;
    this.signature = signature;
    this.transactionMessage = transactionMessage;
    this.transactionLogs = logs ? logs : void 0;
  }
  get transactionError() {
    return {
      message: this.transactionMessage,
      logs: Array.isArray(this.transactionLogs) ? this.transactionLogs : void 0
    };
  }
  /* @deprecated Use `await getLogs()` instead */
  get logs() {
    const cachedLogs = this.transactionLogs;
    if (cachedLogs != null && typeof cachedLogs === "object" && "then" in cachedLogs) {
      return void 0;
    }
    return cachedLogs;
  }
  async getLogs(connection) {
    if (!Array.isArray(this.transactionLogs)) {
      this.transactionLogs = new Promise((resolve, reject) => {
        connection.getTransaction(this.signature).then((tx) => {
          if (tx && tx.meta && tx.meta.logMessages) {
            const logs = tx.meta.logMessages;
            this.transactionLogs = logs;
            resolve(logs);
          } else {
            reject(new Error("Log messages not found"));
          }
        }).catch(reject);
      });
    }
    return await this.transactionLogs;
  }
};
async function sendAndConfirmTransaction(connection, transaction, signers, options) {
  const sendOptions = options && {
    skipPreflight: options.skipPreflight,
    preflightCommitment: options.preflightCommitment || options.commitment,
    maxRetries: options.maxRetries,
    minContextSlot: options.minContextSlot
  };
  const signature = await connection.sendTransaction(transaction, signers, sendOptions);
  let status;
  if (transaction.recentBlockhash != null && transaction.lastValidBlockHeight != null) {
    status = (await connection.confirmTransaction({
      abortSignal: options == null ? void 0 : options.abortSignal,
      signature,
      blockhash: transaction.recentBlockhash,
      lastValidBlockHeight: transaction.lastValidBlockHeight
    }, options && options.commitment)).value;
  } else if (transaction.minNonceContextSlot != null && transaction.nonceInfo != null) {
    const {
      nonceInstruction
    } = transaction.nonceInfo;
    const nonceAccountPubkey = nonceInstruction.keys[0].pubkey;
    status = (await connection.confirmTransaction({
      abortSignal: options == null ? void 0 : options.abortSignal,
      minContextSlot: transaction.minNonceContextSlot,
      nonceAccountPubkey,
      nonceValue: transaction.nonceInfo.nonce,
      signature
    }, options && options.commitment)).value;
  } else {
    if ((options == null ? void 0 : options.abortSignal) != null) {
      console.warn("sendAndConfirmTransaction(): A transaction with a deprecated confirmation strategy was supplied along with an `abortSignal`. Only transactions having `lastValidBlockHeight` or a combination of `nonceInfo` and `minNonceContextSlot` are abortable.");
    }
    status = (await connection.confirmTransaction(signature, options && options.commitment)).value;
  }
  if (status.err) {
    if (signature != null) {
      throw new SendTransactionError({
        action: "send",
        signature,
        transactionMessage: `Status: (${JSON.stringify(status)})`
      });
    }
    throw new Error(`Transaction ${signature} failed (${JSON.stringify(status)})`);
  }
  return signature;
}
function sleep(ms2) {
  return new Promise((resolve) => setTimeout(resolve, ms2));
}
function encodeData(type2, fields) {
  const allocLength = type2.layout.span >= 0 ? type2.layout.span : getAlloc(type2, fields);
  const data = import_buffer2.Buffer.alloc(allocLength);
  const layoutFields = Object.assign({
    instruction: type2.index
  }, fields);
  type2.layout.encode(layoutFields, data);
  return data;
}
var FeeCalculatorLayout = BufferLayout.nu64("lamportsPerSignature");
var NonceAccountLayout = BufferLayout.struct([BufferLayout.u32("version"), BufferLayout.u32("state"), publicKey("authorizedPubkey"), publicKey("nonce"), BufferLayout.struct([FeeCalculatorLayout], "feeCalculator")]);
var NONCE_ACCOUNT_LENGTH = NonceAccountLayout.span;
function u64(property) {
  const layout = (0, import_buffer_layout.blob)(8, property);
  const decode4 = layout.decode.bind(layout);
  const encode3 = layout.encode.bind(layout);
  const bigIntLayout = layout;
  const codec = getU64Codec();
  bigIntLayout.decode = (buffer, offset2) => {
    const src = decode4(buffer, offset2);
    return codec.decode(src);
  };
  bigIntLayout.encode = (bigInt, buffer, offset2) => {
    const src = codec.encode(bigInt);
    return encode3(src, buffer, offset2);
  };
  return bigIntLayout;
}
var SYSTEM_INSTRUCTION_LAYOUTS = Object.freeze({
  Create: {
    index: 0,
    layout: BufferLayout.struct([BufferLayout.u32("instruction"), BufferLayout.ns64("lamports"), BufferLayout.ns64("space"), publicKey("programId")])
  },
  Assign: {
    index: 1,
    layout: BufferLayout.struct([BufferLayout.u32("instruction"), publicKey("programId")])
  },
  Transfer: {
    index: 2,
    layout: BufferLayout.struct([BufferLayout.u32("instruction"), u64("lamports")])
  },
  CreateWithSeed: {
    index: 3,
    layout: BufferLayout.struct([BufferLayout.u32("instruction"), publicKey("base"), rustString("seed"), BufferLayout.ns64("lamports"), BufferLayout.ns64("space"), publicKey("programId")])
  },
  AdvanceNonceAccount: {
    index: 4,
    layout: BufferLayout.struct([BufferLayout.u32("instruction")])
  },
  WithdrawNonceAccount: {
    index: 5,
    layout: BufferLayout.struct([BufferLayout.u32("instruction"), BufferLayout.ns64("lamports")])
  },
  InitializeNonceAccount: {
    index: 6,
    layout: BufferLayout.struct([BufferLayout.u32("instruction"), publicKey("authorized")])
  },
  AuthorizeNonceAccount: {
    index: 7,
    layout: BufferLayout.struct([BufferLayout.u32("instruction"), publicKey("authorized")])
  },
  Allocate: {
    index: 8,
    layout: BufferLayout.struct([BufferLayout.u32("instruction"), BufferLayout.ns64("space")])
  },
  AllocateWithSeed: {
    index: 9,
    layout: BufferLayout.struct([BufferLayout.u32("instruction"), publicKey("base"), rustString("seed"), BufferLayout.ns64("space"), publicKey("programId")])
  },
  AssignWithSeed: {
    index: 10,
    layout: BufferLayout.struct([BufferLayout.u32("instruction"), publicKey("base"), rustString("seed"), publicKey("programId")])
  },
  TransferWithSeed: {
    index: 11,
    layout: BufferLayout.struct([BufferLayout.u32("instruction"), u64("lamports"), rustString("seed"), publicKey("programId")])
  },
  UpgradeNonceAccount: {
    index: 12,
    layout: BufferLayout.struct([BufferLayout.u32("instruction")])
  }
});
var SystemProgram = class _SystemProgram {
  /**
   * @internal
   */
  constructor() {
  }
  /**
   * Public key that identifies the System program
   */
  /**
   * Generate a transaction instruction that creates a new account
   */
  static createAccount(params) {
    const type2 = SYSTEM_INSTRUCTION_LAYOUTS.Create;
    const data = encodeData(type2, {
      lamports: params.lamports,
      space: params.space,
      programId: toBuffer(params.programId.toBuffer())
    });
    return new TransactionInstruction({
      keys: [{
        pubkey: params.fromPubkey,
        isSigner: true,
        isWritable: true
      }, {
        pubkey: params.newAccountPubkey,
        isSigner: true,
        isWritable: true
      }],
      programId: this.programId,
      data
    });
  }
  /**
   * Generate a transaction instruction that transfers lamports from one account to another
   */
  static transfer(params) {
    let data;
    let keys;
    if ("basePubkey" in params) {
      const type2 = SYSTEM_INSTRUCTION_LAYOUTS.TransferWithSeed;
      data = encodeData(type2, {
        lamports: BigInt(params.lamports),
        seed: params.seed,
        programId: toBuffer(params.programId.toBuffer())
      });
      keys = [{
        pubkey: params.fromPubkey,
        isSigner: false,
        isWritable: true
      }, {
        pubkey: params.basePubkey,
        isSigner: true,
        isWritable: false
      }, {
        pubkey: params.toPubkey,
        isSigner: false,
        isWritable: true
      }];
    } else {
      const type2 = SYSTEM_INSTRUCTION_LAYOUTS.Transfer;
      data = encodeData(type2, {
        lamports: BigInt(params.lamports)
      });
      keys = [{
        pubkey: params.fromPubkey,
        isSigner: true,
        isWritable: true
      }, {
        pubkey: params.toPubkey,
        isSigner: false,
        isWritable: true
      }];
    }
    return new TransactionInstruction({
      keys,
      programId: this.programId,
      data
    });
  }
  /**
   * Generate a transaction instruction that assigns an account to a program
   */
  static assign(params) {
    let data;
    let keys;
    if ("basePubkey" in params) {
      const type2 = SYSTEM_INSTRUCTION_LAYOUTS.AssignWithSeed;
      data = encodeData(type2, {
        base: toBuffer(params.basePubkey.toBuffer()),
        seed: params.seed,
        programId: toBuffer(params.programId.toBuffer())
      });
      keys = [{
        pubkey: params.accountPubkey,
        isSigner: false,
        isWritable: true
      }, {
        pubkey: params.basePubkey,
        isSigner: true,
        isWritable: false
      }];
    } else {
      const type2 = SYSTEM_INSTRUCTION_LAYOUTS.Assign;
      data = encodeData(type2, {
        programId: toBuffer(params.programId.toBuffer())
      });
      keys = [{
        pubkey: params.accountPubkey,
        isSigner: true,
        isWritable: true
      }];
    }
    return new TransactionInstruction({
      keys,
      programId: this.programId,
      data
    });
  }
  /**
   * Generate a transaction instruction that creates a new account at
   *   an address generated with `from`, a seed, and programId
   */
  static createAccountWithSeed(params) {
    const type2 = SYSTEM_INSTRUCTION_LAYOUTS.CreateWithSeed;
    const data = encodeData(type2, {
      base: toBuffer(params.basePubkey.toBuffer()),
      seed: params.seed,
      lamports: params.lamports,
      space: params.space,
      programId: toBuffer(params.programId.toBuffer())
    });
    let keys = [{
      pubkey: params.fromPubkey,
      isSigner: true,
      isWritable: true
    }, {
      pubkey: params.newAccountPubkey,
      isSigner: false,
      isWritable: true
    }];
    if (!params.basePubkey.equals(params.fromPubkey)) {
      keys.push({
        pubkey: params.basePubkey,
        isSigner: true,
        isWritable: false
      });
    }
    return new TransactionInstruction({
      keys,
      programId: this.programId,
      data
    });
  }
  /**
   * Generate a transaction that creates a new Nonce account
   */
  static createNonceAccount(params) {
    const transaction = new Transaction();
    if ("basePubkey" in params && "seed" in params) {
      transaction.add(_SystemProgram.createAccountWithSeed({
        fromPubkey: params.fromPubkey,
        newAccountPubkey: params.noncePubkey,
        basePubkey: params.basePubkey,
        seed: params.seed,
        lamports: params.lamports,
        space: NONCE_ACCOUNT_LENGTH,
        programId: this.programId
      }));
    } else {
      transaction.add(_SystemProgram.createAccount({
        fromPubkey: params.fromPubkey,
        newAccountPubkey: params.noncePubkey,
        lamports: params.lamports,
        space: NONCE_ACCOUNT_LENGTH,
        programId: this.programId
      }));
    }
    const initParams = {
      noncePubkey: params.noncePubkey,
      authorizedPubkey: params.authorizedPubkey
    };
    transaction.add(this.nonceInitialize(initParams));
    return transaction;
  }
  /**
   * Generate an instruction to initialize a Nonce account
   */
  static nonceInitialize(params) {
    const type2 = SYSTEM_INSTRUCTION_LAYOUTS.InitializeNonceAccount;
    const data = encodeData(type2, {
      authorized: toBuffer(params.authorizedPubkey.toBuffer())
    });
    const instructionData = {
      keys: [{
        pubkey: params.noncePubkey,
        isSigner: false,
        isWritable: true
      }, {
        pubkey: SYSVAR_RECENT_BLOCKHASHES_PUBKEY,
        isSigner: false,
        isWritable: false
      }, {
        pubkey: SYSVAR_RENT_PUBKEY,
        isSigner: false,
        isWritable: false
      }],
      programId: this.programId,
      data
    };
    return new TransactionInstruction(instructionData);
  }
  /**
   * Generate an instruction to advance the nonce in a Nonce account
   */
  static nonceAdvance(params) {
    const type2 = SYSTEM_INSTRUCTION_LAYOUTS.AdvanceNonceAccount;
    const data = encodeData(type2);
    const instructionData = {
      keys: [{
        pubkey: params.noncePubkey,
        isSigner: false,
        isWritable: true
      }, {
        pubkey: SYSVAR_RECENT_BLOCKHASHES_PUBKEY,
        isSigner: false,
        isWritable: false
      }, {
        pubkey: params.authorizedPubkey,
        isSigner: true,
        isWritable: false
      }],
      programId: this.programId,
      data
    };
    return new TransactionInstruction(instructionData);
  }
  /**
   * Generate a transaction instruction that withdraws lamports from a Nonce account
   */
  static nonceWithdraw(params) {
    const type2 = SYSTEM_INSTRUCTION_LAYOUTS.WithdrawNonceAccount;
    const data = encodeData(type2, {
      lamports: params.lamports
    });
    return new TransactionInstruction({
      keys: [{
        pubkey: params.noncePubkey,
        isSigner: false,
        isWritable: true
      }, {
        pubkey: params.toPubkey,
        isSigner: false,
        isWritable: true
      }, {
        pubkey: SYSVAR_RECENT_BLOCKHASHES_PUBKEY,
        isSigner: false,
        isWritable: false
      }, {
        pubkey: SYSVAR_RENT_PUBKEY,
        isSigner: false,
        isWritable: false
      }, {
        pubkey: params.authorizedPubkey,
        isSigner: true,
        isWritable: false
      }],
      programId: this.programId,
      data
    });
  }
  /**
   * Generate a transaction instruction that authorizes a new PublicKey as the authority
   * on a Nonce account.
   */
  static nonceAuthorize(params) {
    const type2 = SYSTEM_INSTRUCTION_LAYOUTS.AuthorizeNonceAccount;
    const data = encodeData(type2, {
      authorized: toBuffer(params.newAuthorizedPubkey.toBuffer())
    });
    return new TransactionInstruction({
      keys: [{
        pubkey: params.noncePubkey,
        isSigner: false,
        isWritable: true
      }, {
        pubkey: params.authorizedPubkey,
        isSigner: true,
        isWritable: false
      }],
      programId: this.programId,
      data
    });
  }
  /**
   * Generate a transaction instruction that allocates space in an account without funding
   */
  static allocate(params) {
    let data;
    let keys;
    if ("basePubkey" in params) {
      const type2 = SYSTEM_INSTRUCTION_LAYOUTS.AllocateWithSeed;
      data = encodeData(type2, {
        base: toBuffer(params.basePubkey.toBuffer()),
        seed: params.seed,
        space: params.space,
        programId: toBuffer(params.programId.toBuffer())
      });
      keys = [{
        pubkey: params.accountPubkey,
        isSigner: false,
        isWritable: true
      }, {
        pubkey: params.basePubkey,
        isSigner: true,
        isWritable: false
      }];
    } else {
      const type2 = SYSTEM_INSTRUCTION_LAYOUTS.Allocate;
      data = encodeData(type2, {
        space: params.space
      });
      keys = [{
        pubkey: params.accountPubkey,
        isSigner: true,
        isWritable: true
      }];
    }
    return new TransactionInstruction({
      keys,
      programId: this.programId,
      data
    });
  }
};
SystemProgram.programId = new PublicKey("11111111111111111111111111111111");
var CHUNK_SIZE = PACKET_DATA_SIZE - 300;
var Loader = class _Loader {
  /**
   * @internal
   */
  constructor() {
  }
  /**
   * Amount of program data placed in each load Transaction
   */
  /**
   * Minimum number of signatures required to load a program not including
   * retries
   *
   * Can be used to calculate transaction fees
   */
  static getMinNumSignatures(dataLength) {
    return 2 * // Every transaction requires two signatures (payer + program)
    (Math.ceil(dataLength / _Loader.chunkSize) + 1 + // Add one for Create transaction
    1);
  }
  /**
   * Loads a generic program
   *
   * @param connection The connection to use
   * @param payer System account that pays to load the program
   * @param program Account to load the program into
   * @param programId Public key that identifies the loader
   * @param data Program octets
   * @return true if program was loaded successfully, false if program was already loaded
   */
  static async load(connection, payer, program, programId, data) {
    {
      const balanceNeeded = await connection.getMinimumBalanceForRentExemption(data.length);
      const programInfo = await connection.getAccountInfo(program.publicKey, "confirmed");
      let transaction = null;
      if (programInfo !== null) {
        if (programInfo.executable) {
          console.error("Program load failed, account is already executable");
          return false;
        }
        if (programInfo.data.length !== data.length) {
          transaction = transaction || new Transaction();
          transaction.add(SystemProgram.allocate({
            accountPubkey: program.publicKey,
            space: data.length
          }));
        }
        if (!programInfo.owner.equals(programId)) {
          transaction = transaction || new Transaction();
          transaction.add(SystemProgram.assign({
            accountPubkey: program.publicKey,
            programId
          }));
        }
        if (programInfo.lamports < balanceNeeded) {
          transaction = transaction || new Transaction();
          transaction.add(SystemProgram.transfer({
            fromPubkey: payer.publicKey,
            toPubkey: program.publicKey,
            lamports: balanceNeeded - programInfo.lamports
          }));
        }
      } else {
        transaction = new Transaction().add(SystemProgram.createAccount({
          fromPubkey: payer.publicKey,
          newAccountPubkey: program.publicKey,
          lamports: balanceNeeded > 0 ? balanceNeeded : 1,
          space: data.length,
          programId
        }));
      }
      if (transaction !== null) {
        await sendAndConfirmTransaction(connection, transaction, [payer, program], {
          commitment: "confirmed"
        });
      }
    }
    const dataLayout = BufferLayout.struct([BufferLayout.u32("instruction"), BufferLayout.u32("offset"), BufferLayout.u32("bytesLength"), BufferLayout.u32("bytesLengthPadding"), BufferLayout.seq(BufferLayout.u8("byte"), BufferLayout.offset(BufferLayout.u32(), -8), "bytes")]);
    const chunkSize = _Loader.chunkSize;
    let offset2 = 0;
    let array2 = data;
    let transactions = [];
    while (array2.length > 0) {
      const bytes = array2.slice(0, chunkSize);
      const data2 = import_buffer2.Buffer.alloc(chunkSize + 16);
      dataLayout.encode({
        instruction: 0,
        // Load instruction
        offset: offset2,
        bytes,
        bytesLength: 0,
        bytesLengthPadding: 0
      }, data2);
      const transaction = new Transaction().add({
        keys: [{
          pubkey: program.publicKey,
          isSigner: true,
          isWritable: true
        }],
        programId,
        data: data2
      });
      transactions.push(sendAndConfirmTransaction(connection, transaction, [payer, program], {
        commitment: "confirmed"
      }));
      if (connection._rpcEndpoint.includes("solana.com")) {
        const REQUESTS_PER_SECOND = 4;
        await sleep(1e3 / REQUESTS_PER_SECOND);
      }
      offset2 += chunkSize;
      array2 = array2.slice(chunkSize);
    }
    await Promise.all(transactions);
    {
      const dataLayout2 = BufferLayout.struct([BufferLayout.u32("instruction")]);
      const data2 = import_buffer2.Buffer.alloc(dataLayout2.span);
      dataLayout2.encode({
        instruction: 1
        // Finalize instruction
      }, data2);
      const transaction = new Transaction().add({
        keys: [{
          pubkey: program.publicKey,
          isSigner: true,
          isWritable: true
        }, {
          pubkey: SYSVAR_RENT_PUBKEY,
          isSigner: false,
          isWritable: false
        }],
        programId,
        data: data2
      });
      const deployCommitment = "processed";
      const finalizeSignature = await connection.sendTransaction(transaction, [payer, program], {
        preflightCommitment: deployCommitment
      });
      const {
        context,
        value: value2
      } = await connection.confirmTransaction({
        signature: finalizeSignature,
        lastValidBlockHeight: transaction.lastValidBlockHeight,
        blockhash: transaction.recentBlockhash
      }, deployCommitment);
      if (value2.err) {
        throw new Error(`Transaction ${finalizeSignature} failed (${JSON.stringify(value2)})`);
      }
      while (true) {
        try {
          const currentSlot = await connection.getSlot({
            commitment: deployCommitment
          });
          if (currentSlot > context.slot) {
            break;
          }
        } catch {
        }
        await new Promise((resolve) => setTimeout(resolve, Math.round(MS_PER_SLOT / 2)));
      }
    }
    return true;
  }
};
Loader.chunkSize = CHUNK_SIZE;
var BPF_LOADER_PROGRAM_ID = new PublicKey("BPFLoader2111111111111111111111111111111111");
function getDefaultExportFromCjs(x3) {
  return x3 && x3.__esModule && Object.prototype.hasOwnProperty.call(x3, "default") ? x3["default"] : x3;
}
var fastStableStringify$1;
var hasRequiredFastStableStringify;
function requireFastStableStringify() {
  if (hasRequiredFastStableStringify) return fastStableStringify$1;
  hasRequiredFastStableStringify = 1;
  var objToString = Object.prototype.toString;
  var objKeys = Object.keys || function(obj) {
    var keys = [];
    for (var name in obj) {
      keys.push(name);
    }
    return keys;
  };
  function stringify2(val, isArrayProp) {
    var i4, max, str, keys, key, propVal, toStr;
    if (val === true) {
      return "true";
    }
    if (val === false) {
      return "false";
    }
    switch (typeof val) {
      case "object":
        if (val === null) {
          return null;
        } else if (val.toJSON && typeof val.toJSON === "function") {
          return stringify2(val.toJSON(), isArrayProp);
        } else {
          toStr = objToString.call(val);
          if (toStr === "[object Array]") {
            str = "[";
            max = val.length - 1;
            for (i4 = 0; i4 < max; i4++) {
              str += stringify2(val[i4], true) + ",";
            }
            if (max > -1) {
              str += stringify2(val[i4], true);
            }
            return str + "]";
          } else if (toStr === "[object Object]") {
            keys = objKeys(val).sort();
            max = keys.length;
            str = "";
            i4 = 0;
            while (i4 < max) {
              key = keys[i4];
              propVal = stringify2(val[key], false);
              if (propVal !== void 0) {
                if (str) {
                  str += ",";
                }
                str += JSON.stringify(key) + ":" + propVal;
              }
              i4++;
            }
            return "{" + str + "}";
          } else {
            return JSON.stringify(val);
          }
        }
      case "function":
      case "undefined":
        return isArrayProp ? null : void 0;
      case "string":
        return JSON.stringify(val);
      default:
        return isFinite(val) ? val : null;
    }
  }
  fastStableStringify$1 = function(val) {
    var returnVal = stringify2(val, false);
    if (returnVal !== void 0) {
      return "" + returnVal;
    }
  };
  return fastStableStringify$1;
}
var fastStableStringifyExports = requireFastStableStringify();
var fastStableStringify = getDefaultExportFromCjs(fastStableStringifyExports);
var fetchImpl = globalThis.fetch;
var LookupTableMetaLayout = {
  index: 1,
  layout: BufferLayout.struct([
    BufferLayout.u32("typeIndex"),
    u64("deactivationSlot"),
    BufferLayout.nu64("lastExtendedSlot"),
    BufferLayout.u8("lastExtendedStartIndex"),
    BufferLayout.u8(),
    // option
    BufferLayout.seq(publicKey(), BufferLayout.offset(BufferLayout.u8(), -1), "authority")
  ])
};
var PublicKeyFromString = coerce(instance(PublicKey), string(), (value2) => new PublicKey(value2));
var RawAccountDataResult = tuple([string(), literal("base64")]);
var BufferFromRawAccountData = coerce(instance(import_buffer2.Buffer), RawAccountDataResult, (value2) => import_buffer2.Buffer.from(value2[0], "base64"));
var BLOCKHASH_CACHE_TIMEOUT_MS = 30 * 1e3;
function createRpcResult(result) {
  return union([type({
    jsonrpc: literal("2.0"),
    id: string(),
    result
  }), type({
    jsonrpc: literal("2.0"),
    id: string(),
    error: type({
      code: unknown(),
      message: string(),
      data: optional(any())
    })
  })]);
}
var UnknownRpcResult = createRpcResult(unknown());
function jsonRpcResult(schema) {
  return coerce(createRpcResult(schema), UnknownRpcResult, (value2) => {
    if ("error" in value2) {
      return value2;
    } else {
      return {
        ...value2,
        result: create(value2.result, schema)
      };
    }
  });
}
function jsonRpcResultAndContext(value2) {
  return jsonRpcResult(type({
    context: type({
      slot: number()
    }),
    value: value2
  }));
}
function notificationResultAndContext(value2) {
  return type({
    context: type({
      slot: number()
    }),
    value: value2
  });
}
var GetInflationGovernorResult = type({
  foundation: number(),
  foundationTerm: number(),
  initial: number(),
  taper: number(),
  terminal: number()
});
var GetInflationRewardResult = jsonRpcResult(array(nullable(type({
  epoch: number(),
  effectiveSlot: number(),
  amount: number(),
  postBalance: number(),
  commission: optional(nullable(number()))
}))));
var GetRecentPrioritizationFeesResult = array(type({
  slot: number(),
  prioritizationFee: number()
}));
var GetInflationRateResult = type({
  total: number(),
  validator: number(),
  foundation: number(),
  epoch: number()
});
var GetEpochInfoResult = type({
  epoch: number(),
  slotIndex: number(),
  slotsInEpoch: number(),
  absoluteSlot: number(),
  blockHeight: optional(number()),
  transactionCount: optional(number())
});
var GetEpochScheduleResult = type({
  slotsPerEpoch: number(),
  leaderScheduleSlotOffset: number(),
  warmup: boolean(),
  firstNormalEpoch: number(),
  firstNormalSlot: number()
});
var GetLeaderScheduleResult = record(string(), array(number()));
var TransactionErrorResult = nullable(union([type({}), string()]));
var SignatureStatusResult = type({
  err: TransactionErrorResult
});
var SignatureReceivedResult = literal("receivedSignature");
var VersionResult = type({
  "solana-core": string(),
  "feature-set": optional(number())
});
var ParsedInstructionStruct = type({
  program: string(),
  programId: PublicKeyFromString,
  parsed: unknown()
});
var PartiallyDecodedInstructionStruct = type({
  programId: PublicKeyFromString,
  accounts: array(PublicKeyFromString),
  data: string()
});
var SimulatedTransactionResponseStruct = jsonRpcResultAndContext(type({
  err: nullable(union([type({}), string()])),
  logs: nullable(array(string())),
  accounts: optional(nullable(array(nullable(type({
    executable: boolean(),
    owner: string(),
    lamports: number(),
    data: array(string()),
    rentEpoch: optional(number())
  }))))),
  unitsConsumed: optional(number()),
  returnData: optional(nullable(type({
    programId: string(),
    data: tuple([string(), literal("base64")])
  }))),
  innerInstructions: optional(nullable(array(type({
    index: number(),
    instructions: array(union([ParsedInstructionStruct, PartiallyDecodedInstructionStruct]))
  }))))
}));
var BlockProductionResponseStruct = jsonRpcResultAndContext(type({
  byIdentity: record(string(), array(number())),
  range: type({
    firstSlot: number(),
    lastSlot: number()
  })
}));
var GetInflationGovernorRpcResult = jsonRpcResult(GetInflationGovernorResult);
var GetInflationRateRpcResult = jsonRpcResult(GetInflationRateResult);
var GetRecentPrioritizationFeesRpcResult = jsonRpcResult(GetRecentPrioritizationFeesResult);
var GetEpochInfoRpcResult = jsonRpcResult(GetEpochInfoResult);
var GetEpochScheduleRpcResult = jsonRpcResult(GetEpochScheduleResult);
var GetLeaderScheduleRpcResult = jsonRpcResult(GetLeaderScheduleResult);
var SlotRpcResult = jsonRpcResult(number());
var GetSupplyRpcResult = jsonRpcResultAndContext(type({
  total: number(),
  circulating: number(),
  nonCirculating: number(),
  nonCirculatingAccounts: array(PublicKeyFromString)
}));
var TokenAmountResult = type({
  amount: string(),
  uiAmount: nullable(number()),
  decimals: number(),
  uiAmountString: optional(string())
});
var GetTokenLargestAccountsResult = jsonRpcResultAndContext(array(type({
  address: PublicKeyFromString,
  amount: string(),
  uiAmount: nullable(number()),
  decimals: number(),
  uiAmountString: optional(string())
})));
var GetTokenAccountsByOwner = jsonRpcResultAndContext(array(type({
  pubkey: PublicKeyFromString,
  account: type({
    executable: boolean(),
    owner: PublicKeyFromString,
    lamports: number(),
    data: BufferFromRawAccountData,
    rentEpoch: number()
  })
})));
var ParsedAccountDataResult = type({
  program: string(),
  parsed: unknown(),
  space: number()
});
var GetParsedTokenAccountsByOwner = jsonRpcResultAndContext(array(type({
  pubkey: PublicKeyFromString,
  account: type({
    executable: boolean(),
    owner: PublicKeyFromString,
    lamports: number(),
    data: ParsedAccountDataResult,
    rentEpoch: number()
  })
})));
var GetLargestAccountsRpcResult = jsonRpcResultAndContext(array(type({
  lamports: number(),
  address: PublicKeyFromString
})));
var AccountInfoResult = type({
  executable: boolean(),
  owner: PublicKeyFromString,
  lamports: number(),
  data: BufferFromRawAccountData,
  rentEpoch: number()
});
var KeyedAccountInfoResult = type({
  pubkey: PublicKeyFromString,
  account: AccountInfoResult
});
var ParsedOrRawAccountData = coerce(union([instance(import_buffer2.Buffer), ParsedAccountDataResult]), union([RawAccountDataResult, ParsedAccountDataResult]), (value2) => {
  if (Array.isArray(value2)) {
    return create(value2, BufferFromRawAccountData);
  } else {
    return value2;
  }
});
var ParsedAccountInfoResult = type({
  executable: boolean(),
  owner: PublicKeyFromString,
  lamports: number(),
  data: ParsedOrRawAccountData,
  rentEpoch: number()
});
var KeyedParsedAccountInfoResult = type({
  pubkey: PublicKeyFromString,
  account: ParsedAccountInfoResult
});
var StakeActivationResult = type({
  state: union([literal("active"), literal("inactive"), literal("activating"), literal("deactivating")]),
  active: number(),
  inactive: number()
});
var GetConfirmedSignaturesForAddress2RpcResult = jsonRpcResult(array(type({
  signature: string(),
  slot: number(),
  err: TransactionErrorResult,
  memo: nullable(string()),
  blockTime: optional(nullable(number()))
})));
var GetSignaturesForAddressRpcResult = jsonRpcResult(array(type({
  signature: string(),
  slot: number(),
  err: TransactionErrorResult,
  memo: nullable(string()),
  blockTime: optional(nullable(number()))
})));
var AccountNotificationResult = type({
  subscription: number(),
  result: notificationResultAndContext(AccountInfoResult)
});
var ProgramAccountInfoResult = type({
  pubkey: PublicKeyFromString,
  account: AccountInfoResult
});
var ProgramAccountNotificationResult = type({
  subscription: number(),
  result: notificationResultAndContext(ProgramAccountInfoResult)
});
var SlotInfoResult = type({
  parent: number(),
  slot: number(),
  root: number()
});
var SlotNotificationResult = type({
  subscription: number(),
  result: SlotInfoResult
});
var SlotUpdateResult = union([type({
  type: union([literal("firstShredReceived"), literal("completed"), literal("optimisticConfirmation"), literal("root")]),
  slot: number(),
  timestamp: number()
}), type({
  type: literal("createdBank"),
  parent: number(),
  slot: number(),
  timestamp: number()
}), type({
  type: literal("frozen"),
  slot: number(),
  timestamp: number(),
  stats: type({
    numTransactionEntries: number(),
    numSuccessfulTransactions: number(),
    numFailedTransactions: number(),
    maxTransactionsPerEntry: number()
  })
}), type({
  type: literal("dead"),
  slot: number(),
  timestamp: number(),
  err: string()
})]);
var SlotUpdateNotificationResult = type({
  subscription: number(),
  result: SlotUpdateResult
});
var SignatureNotificationResult = type({
  subscription: number(),
  result: notificationResultAndContext(union([SignatureStatusResult, SignatureReceivedResult]))
});
var RootNotificationResult = type({
  subscription: number(),
  result: number()
});
var ContactInfoResult = type({
  pubkey: string(),
  gossip: nullable(string()),
  tpu: nullable(string()),
  rpc: nullable(string()),
  version: nullable(string())
});
var VoteAccountInfoResult = type({
  votePubkey: string(),
  nodePubkey: string(),
  activatedStake: number(),
  epochVoteAccount: boolean(),
  epochCredits: array(tuple([number(), number(), number()])),
  commission: number(),
  lastVote: number(),
  rootSlot: nullable(number())
});
var GetVoteAccounts = jsonRpcResult(type({
  current: array(VoteAccountInfoResult),
  delinquent: array(VoteAccountInfoResult)
}));
var ConfirmationStatus = union([literal("processed"), literal("confirmed"), literal("finalized")]);
var SignatureStatusResponse = type({
  slot: number(),
  confirmations: nullable(number()),
  err: TransactionErrorResult,
  confirmationStatus: optional(ConfirmationStatus)
});
var GetSignatureStatusesRpcResult = jsonRpcResultAndContext(array(nullable(SignatureStatusResponse)));
var GetMinimumBalanceForRentExemptionRpcResult = jsonRpcResult(number());
var AddressTableLookupStruct = type({
  accountKey: PublicKeyFromString,
  writableIndexes: array(number()),
  readonlyIndexes: array(number())
});
var ConfirmedTransactionResult = type({
  signatures: array(string()),
  message: type({
    accountKeys: array(string()),
    header: type({
      numRequiredSignatures: number(),
      numReadonlySignedAccounts: number(),
      numReadonlyUnsignedAccounts: number()
    }),
    instructions: array(type({
      accounts: array(number()),
      data: string(),
      programIdIndex: number()
    })),
    recentBlockhash: string(),
    addressTableLookups: optional(array(AddressTableLookupStruct))
  })
});
var AnnotatedAccountKey = type({
  pubkey: PublicKeyFromString,
  signer: boolean(),
  writable: boolean(),
  source: optional(union([literal("transaction"), literal("lookupTable")]))
});
var ConfirmedTransactionAccountsModeResult = type({
  accountKeys: array(AnnotatedAccountKey),
  signatures: array(string())
});
var ParsedInstructionResult = type({
  parsed: unknown(),
  program: string(),
  programId: PublicKeyFromString
});
var RawInstructionResult = type({
  accounts: array(PublicKeyFromString),
  data: string(),
  programId: PublicKeyFromString
});
var InstructionResult = union([RawInstructionResult, ParsedInstructionResult]);
var UnknownInstructionResult = union([type({
  parsed: unknown(),
  program: string(),
  programId: string()
}), type({
  accounts: array(string()),
  data: string(),
  programId: string()
})]);
var ParsedOrRawInstruction = coerce(InstructionResult, UnknownInstructionResult, (value2) => {
  if ("accounts" in value2) {
    return create(value2, RawInstructionResult);
  } else {
    return create(value2, ParsedInstructionResult);
  }
});
var ParsedConfirmedTransactionResult = type({
  signatures: array(string()),
  message: type({
    accountKeys: array(AnnotatedAccountKey),
    instructions: array(ParsedOrRawInstruction),
    recentBlockhash: string(),
    addressTableLookups: optional(nullable(array(AddressTableLookupStruct)))
  })
});
var TokenBalanceResult = type({
  accountIndex: number(),
  mint: string(),
  owner: optional(string()),
  programId: optional(string()),
  uiTokenAmount: TokenAmountResult
});
var LoadedAddressesResult = type({
  writable: array(PublicKeyFromString),
  readonly: array(PublicKeyFromString)
});
var ConfirmedTransactionMetaResult = type({
  err: TransactionErrorResult,
  fee: number(),
  innerInstructions: optional(nullable(array(type({
    index: number(),
    instructions: array(type({
      accounts: array(number()),
      data: string(),
      programIdIndex: number()
    }))
  })))),
  preBalances: array(number()),
  postBalances: array(number()),
  logMessages: optional(nullable(array(string()))),
  preTokenBalances: optional(nullable(array(TokenBalanceResult))),
  postTokenBalances: optional(nullable(array(TokenBalanceResult))),
  loadedAddresses: optional(LoadedAddressesResult),
  computeUnitsConsumed: optional(number())
});
var ParsedConfirmedTransactionMetaResult = type({
  err: TransactionErrorResult,
  fee: number(),
  innerInstructions: optional(nullable(array(type({
    index: number(),
    instructions: array(ParsedOrRawInstruction)
  })))),
  preBalances: array(number()),
  postBalances: array(number()),
  logMessages: optional(nullable(array(string()))),
  preTokenBalances: optional(nullable(array(TokenBalanceResult))),
  postTokenBalances: optional(nullable(array(TokenBalanceResult))),
  loadedAddresses: optional(LoadedAddressesResult),
  computeUnitsConsumed: optional(number())
});
var TransactionVersionStruct = union([literal(0), literal("legacy")]);
var RewardsResult = type({
  pubkey: string(),
  lamports: number(),
  postBalance: nullable(number()),
  rewardType: nullable(string()),
  commission: optional(nullable(number()))
});
var GetBlockRpcResult = jsonRpcResult(nullable(type({
  blockhash: string(),
  previousBlockhash: string(),
  parentSlot: number(),
  transactions: array(type({
    transaction: ConfirmedTransactionResult,
    meta: nullable(ConfirmedTransactionMetaResult),
    version: optional(TransactionVersionStruct)
  })),
  rewards: optional(array(RewardsResult)),
  blockTime: nullable(number()),
  blockHeight: nullable(number())
})));
var GetNoneModeBlockRpcResult = jsonRpcResult(nullable(type({
  blockhash: string(),
  previousBlockhash: string(),
  parentSlot: number(),
  rewards: optional(array(RewardsResult)),
  blockTime: nullable(number()),
  blockHeight: nullable(number())
})));
var GetAccountsModeBlockRpcResult = jsonRpcResult(nullable(type({
  blockhash: string(),
  previousBlockhash: string(),
  parentSlot: number(),
  transactions: array(type({
    transaction: ConfirmedTransactionAccountsModeResult,
    meta: nullable(ConfirmedTransactionMetaResult),
    version: optional(TransactionVersionStruct)
  })),
  rewards: optional(array(RewardsResult)),
  blockTime: nullable(number()),
  blockHeight: nullable(number())
})));
var GetParsedBlockRpcResult = jsonRpcResult(nullable(type({
  blockhash: string(),
  previousBlockhash: string(),
  parentSlot: number(),
  transactions: array(type({
    transaction: ParsedConfirmedTransactionResult,
    meta: nullable(ParsedConfirmedTransactionMetaResult),
    version: optional(TransactionVersionStruct)
  })),
  rewards: optional(array(RewardsResult)),
  blockTime: nullable(number()),
  blockHeight: nullable(number())
})));
var GetParsedAccountsModeBlockRpcResult = jsonRpcResult(nullable(type({
  blockhash: string(),
  previousBlockhash: string(),
  parentSlot: number(),
  transactions: array(type({
    transaction: ConfirmedTransactionAccountsModeResult,
    meta: nullable(ParsedConfirmedTransactionMetaResult),
    version: optional(TransactionVersionStruct)
  })),
  rewards: optional(array(RewardsResult)),
  blockTime: nullable(number()),
  blockHeight: nullable(number())
})));
var GetParsedNoneModeBlockRpcResult = jsonRpcResult(nullable(type({
  blockhash: string(),
  previousBlockhash: string(),
  parentSlot: number(),
  rewards: optional(array(RewardsResult)),
  blockTime: nullable(number()),
  blockHeight: nullable(number())
})));
var GetConfirmedBlockRpcResult = jsonRpcResult(nullable(type({
  blockhash: string(),
  previousBlockhash: string(),
  parentSlot: number(),
  transactions: array(type({
    transaction: ConfirmedTransactionResult,
    meta: nullable(ConfirmedTransactionMetaResult)
  })),
  rewards: optional(array(RewardsResult)),
  blockTime: nullable(number())
})));
var GetBlockSignaturesRpcResult = jsonRpcResult(nullable(type({
  blockhash: string(),
  previousBlockhash: string(),
  parentSlot: number(),
  signatures: array(string()),
  blockTime: nullable(number())
})));
var GetTransactionRpcResult = jsonRpcResult(nullable(type({
  slot: number(),
  meta: nullable(ConfirmedTransactionMetaResult),
  blockTime: optional(nullable(number())),
  transaction: ConfirmedTransactionResult,
  version: optional(TransactionVersionStruct)
})));
var GetParsedTransactionRpcResult = jsonRpcResult(nullable(type({
  slot: number(),
  transaction: ParsedConfirmedTransactionResult,
  meta: nullable(ParsedConfirmedTransactionMetaResult),
  blockTime: optional(nullable(number())),
  version: optional(TransactionVersionStruct)
})));
var GetLatestBlockhashRpcResult = jsonRpcResultAndContext(type({
  blockhash: string(),
  lastValidBlockHeight: number()
}));
var IsBlockhashValidRpcResult = jsonRpcResultAndContext(boolean());
var PerfSampleResult = type({
  slot: number(),
  numTransactions: number(),
  numSlots: number(),
  samplePeriodSecs: number()
});
var GetRecentPerformanceSamplesRpcResult = jsonRpcResult(array(PerfSampleResult));
var GetFeeCalculatorRpcResult = jsonRpcResultAndContext(nullable(type({
  feeCalculator: type({
    lamportsPerSignature: number()
  })
})));
var RequestAirdropRpcResult = jsonRpcResult(string());
var SendTransactionRpcResult = jsonRpcResult(string());
var LogsResult = type({
  err: TransactionErrorResult,
  logs: array(string()),
  signature: string()
});
var LogsNotificationResult = type({
  result: notificationResultAndContext(LogsResult),
  subscription: number()
});
var Keypair = class _Keypair {
  /**
   * Create a new keypair instance.
   * Generate random keypair if no {@link Ed25519Keypair} is provided.
   *
   * @param {Ed25519Keypair} keypair ed25519 keypair
   */
  constructor(keypair) {
    this._keypair = void 0;
    this._keypair = keypair ?? generateKeypair();
  }
  /**
   * Generate a new random keypair
   *
   * @returns {Keypair} Keypair
   */
  static generate() {
    return new _Keypair(generateKeypair());
  }
  /**
   * Create a keypair from a raw secret key byte array.
   *
   * This method should only be used to recreate a keypair from a previously
   * generated secret key. Generating keypairs from a random seed should be done
   * with the {@link Keypair.fromSeed} method.
   *
   * @throws error if the provided secret key is invalid and validation is not skipped.
   *
   * @param secretKey secret key byte array
   * @param options skip secret key validation
   *
   * @returns {Keypair} Keypair
   */
  static fromSecretKey(secretKey, options) {
    if (secretKey.byteLength !== 64) {
      throw new Error("bad secret key size");
    }
    const publicKey2 = secretKey.slice(32, 64);
    if (!options || !options.skipValidation) {
      const privateScalar = secretKey.slice(0, 32);
      const computedPublicKey = getPublicKey(privateScalar);
      for (let ii2 = 0; ii2 < 32; ii2++) {
        if (publicKey2[ii2] !== computedPublicKey[ii2]) {
          throw new Error("provided secretKey is invalid");
        }
      }
    }
    return new _Keypair({
      publicKey: publicKey2,
      secretKey
    });
  }
  /**
   * Generate a keypair from a 32 byte seed.
   *
   * @param seed seed byte array
   *
   * @returns {Keypair} Keypair
   */
  static fromSeed(seed) {
    const publicKey2 = getPublicKey(seed);
    const secretKey = new Uint8Array(64);
    secretKey.set(seed);
    secretKey.set(publicKey2, 32);
    return new _Keypair({
      publicKey: publicKey2,
      secretKey
    });
  }
  /**
   * The public key for this keypair
   *
   * @returns {PublicKey} PublicKey
   */
  get publicKey() {
    return new PublicKey(this._keypair.publicKey);
  }
  /**
   * The raw secret key for this keypair
   * @returns {Uint8Array} Secret key in an array of Uint8 bytes
   */
  get secretKey() {
    return new Uint8Array(this._keypair.secretKey);
  }
};
var LOOKUP_TABLE_INSTRUCTION_LAYOUTS = Object.freeze({
  CreateLookupTable: {
    index: 0,
    layout: BufferLayout.struct([BufferLayout.u32("instruction"), u64("recentSlot"), BufferLayout.u8("bumpSeed")])
  },
  FreezeLookupTable: {
    index: 1,
    layout: BufferLayout.struct([BufferLayout.u32("instruction")])
  },
  ExtendLookupTable: {
    index: 2,
    layout: BufferLayout.struct([BufferLayout.u32("instruction"), u64(), BufferLayout.seq(publicKey(), BufferLayout.offset(BufferLayout.u32(), -8), "addresses")])
  },
  DeactivateLookupTable: {
    index: 3,
    layout: BufferLayout.struct([BufferLayout.u32("instruction")])
  },
  CloseLookupTable: {
    index: 4,
    layout: BufferLayout.struct([BufferLayout.u32("instruction")])
  }
});
var AddressLookupTableProgram = class {
  /**
   * @internal
   */
  constructor() {
  }
  static createLookupTable(params) {
    const [lookupTableAddress, bumpSeed] = PublicKey.findProgramAddressSync([params.authority.toBuffer(), getU64Encoder().encode(params.recentSlot)], this.programId);
    const type2 = LOOKUP_TABLE_INSTRUCTION_LAYOUTS.CreateLookupTable;
    const data = encodeData(type2, {
      recentSlot: BigInt(params.recentSlot),
      bumpSeed
    });
    const keys = [{
      pubkey: lookupTableAddress,
      isSigner: false,
      isWritable: true
    }, {
      pubkey: params.authority,
      isSigner: true,
      isWritable: false
    }, {
      pubkey: params.payer,
      isSigner: true,
      isWritable: true
    }, {
      pubkey: SystemProgram.programId,
      isSigner: false,
      isWritable: false
    }];
    return [new TransactionInstruction({
      programId: this.programId,
      keys,
      data
    }), lookupTableAddress];
  }
  static freezeLookupTable(params) {
    const type2 = LOOKUP_TABLE_INSTRUCTION_LAYOUTS.FreezeLookupTable;
    const data = encodeData(type2);
    const keys = [{
      pubkey: params.lookupTable,
      isSigner: false,
      isWritable: true
    }, {
      pubkey: params.authority,
      isSigner: true,
      isWritable: false
    }];
    return new TransactionInstruction({
      programId: this.programId,
      keys,
      data
    });
  }
  static extendLookupTable(params) {
    const type2 = LOOKUP_TABLE_INSTRUCTION_LAYOUTS.ExtendLookupTable;
    const data = encodeData(type2, {
      addresses: params.addresses.map((addr) => addr.toBytes())
    });
    const keys = [{
      pubkey: params.lookupTable,
      isSigner: false,
      isWritable: true
    }, {
      pubkey: params.authority,
      isSigner: true,
      isWritable: false
    }];
    if (params.payer) {
      keys.push({
        pubkey: params.payer,
        isSigner: true,
        isWritable: true
      }, {
        pubkey: SystemProgram.programId,
        isSigner: false,
        isWritable: false
      });
    }
    return new TransactionInstruction({
      programId: this.programId,
      keys,
      data
    });
  }
  static deactivateLookupTable(params) {
    const type2 = LOOKUP_TABLE_INSTRUCTION_LAYOUTS.DeactivateLookupTable;
    const data = encodeData(type2);
    const keys = [{
      pubkey: params.lookupTable,
      isSigner: false,
      isWritable: true
    }, {
      pubkey: params.authority,
      isSigner: true,
      isWritable: false
    }];
    return new TransactionInstruction({
      programId: this.programId,
      keys,
      data
    });
  }
  static closeLookupTable(params) {
    const type2 = LOOKUP_TABLE_INSTRUCTION_LAYOUTS.CloseLookupTable;
    const data = encodeData(type2);
    const keys = [{
      pubkey: params.lookupTable,
      isSigner: false,
      isWritable: true
    }, {
      pubkey: params.authority,
      isSigner: true,
      isWritable: false
    }, {
      pubkey: params.recipient,
      isSigner: false,
      isWritable: true
    }];
    return new TransactionInstruction({
      programId: this.programId,
      keys,
      data
    });
  }
};
AddressLookupTableProgram.programId = new PublicKey("AddressLookupTab1e1111111111111111111111111");
var COMPUTE_BUDGET_INSTRUCTION_LAYOUTS = Object.freeze({
  RequestUnits: {
    index: 0,
    layout: BufferLayout.struct([BufferLayout.u8("instruction"), BufferLayout.u32("units"), BufferLayout.u32("additionalFee")])
  },
  RequestHeapFrame: {
    index: 1,
    layout: BufferLayout.struct([BufferLayout.u8("instruction"), BufferLayout.u32("bytes")])
  },
  SetComputeUnitLimit: {
    index: 2,
    layout: BufferLayout.struct([BufferLayout.u8("instruction"), BufferLayout.u32("units")])
  },
  SetComputeUnitPrice: {
    index: 3,
    layout: BufferLayout.struct([BufferLayout.u8("instruction"), u64("microLamports")])
  }
});
var ComputeBudgetProgram = class {
  /**
   * @internal
   */
  constructor() {
  }
  /**
   * Public key that identifies the Compute Budget program
   */
  /**
   * @deprecated Instead, call {@link setComputeUnitLimit} and/or {@link setComputeUnitPrice}
   */
  static requestUnits(params) {
    const type2 = COMPUTE_BUDGET_INSTRUCTION_LAYOUTS.RequestUnits;
    const data = encodeData(type2, params);
    return new TransactionInstruction({
      keys: [],
      programId: this.programId,
      data
    });
  }
  static requestHeapFrame(params) {
    const type2 = COMPUTE_BUDGET_INSTRUCTION_LAYOUTS.RequestHeapFrame;
    const data = encodeData(type2, params);
    return new TransactionInstruction({
      keys: [],
      programId: this.programId,
      data
    });
  }
  static setComputeUnitLimit(params) {
    const type2 = COMPUTE_BUDGET_INSTRUCTION_LAYOUTS.SetComputeUnitLimit;
    const data = encodeData(type2, params);
    return new TransactionInstruction({
      keys: [],
      programId: this.programId,
      data
    });
  }
  static setComputeUnitPrice(params) {
    const type2 = COMPUTE_BUDGET_INSTRUCTION_LAYOUTS.SetComputeUnitPrice;
    const data = encodeData(type2, {
      microLamports: BigInt(params.microLamports)
    });
    return new TransactionInstruction({
      keys: [],
      programId: this.programId,
      data
    });
  }
};
ComputeBudgetProgram.programId = new PublicKey("ComputeBudget111111111111111111111111111111");
var PRIVATE_KEY_BYTES$1 = 64;
var PUBLIC_KEY_BYTES$1 = 32;
var SIGNATURE_BYTES = 64;
var ED25519_INSTRUCTION_LAYOUT = BufferLayout.struct([BufferLayout.u8("numSignatures"), BufferLayout.u8("padding"), BufferLayout.u16("signatureOffset"), BufferLayout.u16("signatureInstructionIndex"), BufferLayout.u16("publicKeyOffset"), BufferLayout.u16("publicKeyInstructionIndex"), BufferLayout.u16("messageDataOffset"), BufferLayout.u16("messageDataSize"), BufferLayout.u16("messageInstructionIndex")]);
var Ed25519Program = class _Ed25519Program {
  /**
   * @internal
   */
  constructor() {
  }
  /**
   * Public key that identifies the ed25519 program
   */
  /**
   * Create an ed25519 instruction with a public key and signature. The
   * public key must be a buffer that is 32 bytes long, and the signature
   * must be a buffer of 64 bytes.
   */
  static createInstructionWithPublicKey(params) {
    const {
      publicKey: publicKey2,
      message,
      signature,
      instructionIndex
    } = params;
    assert2(publicKey2.length === PUBLIC_KEY_BYTES$1, `Public Key must be ${PUBLIC_KEY_BYTES$1} bytes but received ${publicKey2.length} bytes`);
    assert2(signature.length === SIGNATURE_BYTES, `Signature must be ${SIGNATURE_BYTES} bytes but received ${signature.length} bytes`);
    const publicKeyOffset = ED25519_INSTRUCTION_LAYOUT.span;
    const signatureOffset = publicKeyOffset + publicKey2.length;
    const messageDataOffset = signatureOffset + signature.length;
    const numSignatures = 1;
    const instructionData = import_buffer2.Buffer.alloc(messageDataOffset + message.length);
    const index = instructionIndex == null ? 65535 : instructionIndex;
    ED25519_INSTRUCTION_LAYOUT.encode({
      numSignatures,
      padding: 0,
      signatureOffset,
      signatureInstructionIndex: index,
      publicKeyOffset,
      publicKeyInstructionIndex: index,
      messageDataOffset,
      messageDataSize: message.length,
      messageInstructionIndex: index
    }, instructionData);
    instructionData.fill(publicKey2, publicKeyOffset);
    instructionData.fill(signature, signatureOffset);
    instructionData.fill(message, messageDataOffset);
    return new TransactionInstruction({
      keys: [],
      programId: _Ed25519Program.programId,
      data: instructionData
    });
  }
  /**
   * Create an ed25519 instruction with a private key. The private key
   * must be a buffer that is 64 bytes long.
   */
  static createInstructionWithPrivateKey(params) {
    const {
      privateKey,
      message,
      instructionIndex
    } = params;
    assert2(privateKey.length === PRIVATE_KEY_BYTES$1, `Private key must be ${PRIVATE_KEY_BYTES$1} bytes but received ${privateKey.length} bytes`);
    try {
      const keypair = Keypair.fromSecretKey(privateKey);
      const publicKey2 = keypair.publicKey.toBytes();
      const signature = sign(message, keypair.secretKey);
      return this.createInstructionWithPublicKey({
        publicKey: publicKey2,
        message,
        signature,
        instructionIndex
      });
    } catch (error) {
      throw new Error(`Error creating instruction; ${error}`);
    }
  }
};
Ed25519Program.programId = new PublicKey("Ed25519SigVerify111111111111111111111111111");
var ecdsaSign = (msgHash, privKey) => {
  const signature = secp256k1.sign(msgHash, privKey);
  return [signature.toCompactRawBytes(), signature.recovery];
};
secp256k1.utils.isValidPrivateKey;
var publicKeyCreate = secp256k1.getPublicKey;
var PRIVATE_KEY_BYTES = 32;
var ETHEREUM_ADDRESS_BYTES = 20;
var PUBLIC_KEY_BYTES = 64;
var SIGNATURE_OFFSETS_SERIALIZED_SIZE = 11;
var SECP256K1_INSTRUCTION_LAYOUT = BufferLayout.struct([BufferLayout.u8("numSignatures"), BufferLayout.u16("signatureOffset"), BufferLayout.u8("signatureInstructionIndex"), BufferLayout.u16("ethAddressOffset"), BufferLayout.u8("ethAddressInstructionIndex"), BufferLayout.u16("messageDataOffset"), BufferLayout.u16("messageDataSize"), BufferLayout.u8("messageInstructionIndex"), BufferLayout.blob(20, "ethAddress"), BufferLayout.blob(64, "signature"), BufferLayout.u8("recoveryId")]);
var Secp256k1Program = class _Secp256k1Program {
  /**
   * @internal
   */
  constructor() {
  }
  /**
   * Public key that identifies the secp256k1 program
   */
  /**
   * Construct an Ethereum address from a secp256k1 public key buffer.
   * @param {Buffer} publicKey a 64 byte secp256k1 public key buffer
   */
  static publicKeyToEthAddress(publicKey2) {
    assert2(publicKey2.length === PUBLIC_KEY_BYTES, `Public key must be ${PUBLIC_KEY_BYTES} bytes but received ${publicKey2.length} bytes`);
    try {
      return import_buffer2.Buffer.from(keccak_256(toBuffer(publicKey2))).slice(-ETHEREUM_ADDRESS_BYTES);
    } catch (error) {
      throw new Error(`Error constructing Ethereum address: ${error}`);
    }
  }
  /**
   * Create an secp256k1 instruction with a public key. The public key
   * must be a buffer that is 64 bytes long.
   */
  static createInstructionWithPublicKey(params) {
    const {
      publicKey: publicKey2,
      message,
      signature,
      recoveryId,
      instructionIndex
    } = params;
    return _Secp256k1Program.createInstructionWithEthAddress({
      ethAddress: _Secp256k1Program.publicKeyToEthAddress(publicKey2),
      message,
      signature,
      recoveryId,
      instructionIndex
    });
  }
  /**
   * Create an secp256k1 instruction with an Ethereum address. The address
   * must be a hex string or a buffer that is 20 bytes long.
   */
  static createInstructionWithEthAddress(params) {
    const {
      ethAddress: rawAddress,
      message,
      signature,
      recoveryId,
      instructionIndex = 0
    } = params;
    let ethAddress;
    if (typeof rawAddress === "string") {
      if (rawAddress.startsWith("0x")) {
        ethAddress = import_buffer2.Buffer.from(rawAddress.substr(2), "hex");
      } else {
        ethAddress = import_buffer2.Buffer.from(rawAddress, "hex");
      }
    } else {
      ethAddress = rawAddress;
    }
    assert2(ethAddress.length === ETHEREUM_ADDRESS_BYTES, `Address must be ${ETHEREUM_ADDRESS_BYTES} bytes but received ${ethAddress.length} bytes`);
    const dataStart = 1 + SIGNATURE_OFFSETS_SERIALIZED_SIZE;
    const ethAddressOffset = dataStart;
    const signatureOffset = dataStart + ethAddress.length;
    const messageDataOffset = signatureOffset + signature.length + 1;
    const numSignatures = 1;
    const instructionData = import_buffer2.Buffer.alloc(SECP256K1_INSTRUCTION_LAYOUT.span + message.length);
    SECP256K1_INSTRUCTION_LAYOUT.encode({
      numSignatures,
      signatureOffset,
      signatureInstructionIndex: instructionIndex,
      ethAddressOffset,
      ethAddressInstructionIndex: instructionIndex,
      messageDataOffset,
      messageDataSize: message.length,
      messageInstructionIndex: instructionIndex,
      signature: toBuffer(signature),
      ethAddress: toBuffer(ethAddress),
      recoveryId
    }, instructionData);
    instructionData.fill(toBuffer(message), SECP256K1_INSTRUCTION_LAYOUT.span);
    return new TransactionInstruction({
      keys: [],
      programId: _Secp256k1Program.programId,
      data: instructionData
    });
  }
  /**
   * Create an secp256k1 instruction with a private key. The private key
   * must be a buffer that is 32 bytes long.
   */
  static createInstructionWithPrivateKey(params) {
    const {
      privateKey: pkey,
      message,
      instructionIndex
    } = params;
    assert2(pkey.length === PRIVATE_KEY_BYTES, `Private key must be ${PRIVATE_KEY_BYTES} bytes but received ${pkey.length} bytes`);
    try {
      const privateKey = toBuffer(pkey);
      const publicKey2 = publicKeyCreate(
        privateKey,
        false
        /* isCompressed */
      ).slice(1);
      const messageHash = import_buffer2.Buffer.from(keccak_256(toBuffer(message)));
      const [signature, recoveryId] = ecdsaSign(messageHash, privateKey);
      return this.createInstructionWithPublicKey({
        publicKey: publicKey2,
        message,
        signature,
        recoveryId,
        instructionIndex
      });
    } catch (error) {
      throw new Error(`Error creating instruction; ${error}`);
    }
  }
};
Secp256k1Program.programId = new PublicKey("KeccakSecp256k11111111111111111111111111111");
var _Lockup;
var STAKE_CONFIG_ID = new PublicKey("StakeConfig11111111111111111111111111111111");
var Lockup = class {
  /**
   * Create a new Lockup object
   */
  constructor(unixTimestamp, epoch, custodian) {
    this.unixTimestamp = void 0;
    this.epoch = void 0;
    this.custodian = void 0;
    this.unixTimestamp = unixTimestamp;
    this.epoch = epoch;
    this.custodian = custodian;
  }
  /**
   * Default, inactive Lockup value
   */
};
_Lockup = Lockup;
Lockup.default = new _Lockup(0, 0, PublicKey.default);
var STAKE_INSTRUCTION_LAYOUTS = Object.freeze({
  Initialize: {
    index: 0,
    layout: BufferLayout.struct([BufferLayout.u32("instruction"), authorized(), lockup()])
  },
  Authorize: {
    index: 1,
    layout: BufferLayout.struct([BufferLayout.u32("instruction"), publicKey("newAuthorized"), BufferLayout.u32("stakeAuthorizationType")])
  },
  Delegate: {
    index: 2,
    layout: BufferLayout.struct([BufferLayout.u32("instruction")])
  },
  Split: {
    index: 3,
    layout: BufferLayout.struct([BufferLayout.u32("instruction"), BufferLayout.ns64("lamports")])
  },
  Withdraw: {
    index: 4,
    layout: BufferLayout.struct([BufferLayout.u32("instruction"), BufferLayout.ns64("lamports")])
  },
  Deactivate: {
    index: 5,
    layout: BufferLayout.struct([BufferLayout.u32("instruction")])
  },
  Merge: {
    index: 7,
    layout: BufferLayout.struct([BufferLayout.u32("instruction")])
  },
  AuthorizeWithSeed: {
    index: 8,
    layout: BufferLayout.struct([BufferLayout.u32("instruction"), publicKey("newAuthorized"), BufferLayout.u32("stakeAuthorizationType"), rustString("authoritySeed"), publicKey("authorityOwner")])
  }
});
var StakeAuthorizationLayout = Object.freeze({
  Staker: {
    index: 0
  },
  Withdrawer: {
    index: 1
  }
});
var StakeProgram = class {
  /**
   * @internal
   */
  constructor() {
  }
  /**
   * Public key that identifies the Stake program
   */
  /**
   * Generate an Initialize instruction to add to a Stake Create transaction
   */
  static initialize(params) {
    const {
      stakePubkey,
      authorized: authorized2,
      lockup: maybeLockup
    } = params;
    const lockup2 = maybeLockup || Lockup.default;
    const type2 = STAKE_INSTRUCTION_LAYOUTS.Initialize;
    const data = encodeData(type2, {
      authorized: {
        staker: toBuffer(authorized2.staker.toBuffer()),
        withdrawer: toBuffer(authorized2.withdrawer.toBuffer())
      },
      lockup: {
        unixTimestamp: lockup2.unixTimestamp,
        epoch: lockup2.epoch,
        custodian: toBuffer(lockup2.custodian.toBuffer())
      }
    });
    const instructionData = {
      keys: [{
        pubkey: stakePubkey,
        isSigner: false,
        isWritable: true
      }, {
        pubkey: SYSVAR_RENT_PUBKEY,
        isSigner: false,
        isWritable: false
      }],
      programId: this.programId,
      data
    };
    return new TransactionInstruction(instructionData);
  }
  /**
   * Generate a Transaction that creates a new Stake account at
   *   an address generated with `from`, a seed, and the Stake programId
   */
  static createAccountWithSeed(params) {
    const transaction = new Transaction();
    transaction.add(SystemProgram.createAccountWithSeed({
      fromPubkey: params.fromPubkey,
      newAccountPubkey: params.stakePubkey,
      basePubkey: params.basePubkey,
      seed: params.seed,
      lamports: params.lamports,
      space: this.space,
      programId: this.programId
    }));
    const {
      stakePubkey,
      authorized: authorized2,
      lockup: lockup2
    } = params;
    return transaction.add(this.initialize({
      stakePubkey,
      authorized: authorized2,
      lockup: lockup2
    }));
  }
  /**
   * Generate a Transaction that creates a new Stake account
   */
  static createAccount(params) {
    const transaction = new Transaction();
    transaction.add(SystemProgram.createAccount({
      fromPubkey: params.fromPubkey,
      newAccountPubkey: params.stakePubkey,
      lamports: params.lamports,
      space: this.space,
      programId: this.programId
    }));
    const {
      stakePubkey,
      authorized: authorized2,
      lockup: lockup2
    } = params;
    return transaction.add(this.initialize({
      stakePubkey,
      authorized: authorized2,
      lockup: lockup2
    }));
  }
  /**
   * Generate a Transaction that delegates Stake tokens to a validator
   * Vote PublicKey. This transaction can also be used to redelegate Stake
   * to a new validator Vote PublicKey.
   */
  static delegate(params) {
    const {
      stakePubkey,
      authorizedPubkey,
      votePubkey
    } = params;
    const type2 = STAKE_INSTRUCTION_LAYOUTS.Delegate;
    const data = encodeData(type2);
    return new Transaction().add({
      keys: [{
        pubkey: stakePubkey,
        isSigner: false,
        isWritable: true
      }, {
        pubkey: votePubkey,
        isSigner: false,
        isWritable: false
      }, {
        pubkey: SYSVAR_CLOCK_PUBKEY,
        isSigner: false,
        isWritable: false
      }, {
        pubkey: SYSVAR_STAKE_HISTORY_PUBKEY,
        isSigner: false,
        isWritable: false
      }, {
        pubkey: STAKE_CONFIG_ID,
        isSigner: false,
        isWritable: false
      }, {
        pubkey: authorizedPubkey,
        isSigner: true,
        isWritable: false
      }],
      programId: this.programId,
      data
    });
  }
  /**
   * Generate a Transaction that authorizes a new PublicKey as Staker
   * or Withdrawer on the Stake account.
   */
  static authorize(params) {
    const {
      stakePubkey,
      authorizedPubkey,
      newAuthorizedPubkey,
      stakeAuthorizationType,
      custodianPubkey
    } = params;
    const type2 = STAKE_INSTRUCTION_LAYOUTS.Authorize;
    const data = encodeData(type2, {
      newAuthorized: toBuffer(newAuthorizedPubkey.toBuffer()),
      stakeAuthorizationType: stakeAuthorizationType.index
    });
    const keys = [{
      pubkey: stakePubkey,
      isSigner: false,
      isWritable: true
    }, {
      pubkey: SYSVAR_CLOCK_PUBKEY,
      isSigner: false,
      isWritable: true
    }, {
      pubkey: authorizedPubkey,
      isSigner: true,
      isWritable: false
    }];
    if (custodianPubkey) {
      keys.push({
        pubkey: custodianPubkey,
        isSigner: true,
        isWritable: false
      });
    }
    return new Transaction().add({
      keys,
      programId: this.programId,
      data
    });
  }
  /**
   * Generate a Transaction that authorizes a new PublicKey as Staker
   * or Withdrawer on the Stake account.
   */
  static authorizeWithSeed(params) {
    const {
      stakePubkey,
      authorityBase,
      authoritySeed,
      authorityOwner,
      newAuthorizedPubkey,
      stakeAuthorizationType,
      custodianPubkey
    } = params;
    const type2 = STAKE_INSTRUCTION_LAYOUTS.AuthorizeWithSeed;
    const data = encodeData(type2, {
      newAuthorized: toBuffer(newAuthorizedPubkey.toBuffer()),
      stakeAuthorizationType: stakeAuthorizationType.index,
      authoritySeed,
      authorityOwner: toBuffer(authorityOwner.toBuffer())
    });
    const keys = [{
      pubkey: stakePubkey,
      isSigner: false,
      isWritable: true
    }, {
      pubkey: authorityBase,
      isSigner: true,
      isWritable: false
    }, {
      pubkey: SYSVAR_CLOCK_PUBKEY,
      isSigner: false,
      isWritable: false
    }];
    if (custodianPubkey) {
      keys.push({
        pubkey: custodianPubkey,
        isSigner: true,
        isWritable: false
      });
    }
    return new Transaction().add({
      keys,
      programId: this.programId,
      data
    });
  }
  /**
   * @internal
   */
  static splitInstruction(params) {
    const {
      stakePubkey,
      authorizedPubkey,
      splitStakePubkey,
      lamports
    } = params;
    const type2 = STAKE_INSTRUCTION_LAYOUTS.Split;
    const data = encodeData(type2, {
      lamports
    });
    return new TransactionInstruction({
      keys: [{
        pubkey: stakePubkey,
        isSigner: false,
        isWritable: true
      }, {
        pubkey: splitStakePubkey,
        isSigner: false,
        isWritable: true
      }, {
        pubkey: authorizedPubkey,
        isSigner: true,
        isWritable: false
      }],
      programId: this.programId,
      data
    });
  }
  /**
   * Generate a Transaction that splits Stake tokens into another stake account
   */
  static split(params, rentExemptReserve) {
    const transaction = new Transaction();
    transaction.add(SystemProgram.createAccount({
      fromPubkey: params.authorizedPubkey,
      newAccountPubkey: params.splitStakePubkey,
      lamports: rentExemptReserve,
      space: this.space,
      programId: this.programId
    }));
    return transaction.add(this.splitInstruction(params));
  }
  /**
   * Generate a Transaction that splits Stake tokens into another account
   * derived from a base public key and seed
   */
  static splitWithSeed(params, rentExemptReserve) {
    const {
      stakePubkey,
      authorizedPubkey,
      splitStakePubkey,
      basePubkey,
      seed,
      lamports
    } = params;
    const transaction = new Transaction();
    transaction.add(SystemProgram.allocate({
      accountPubkey: splitStakePubkey,
      basePubkey,
      seed,
      space: this.space,
      programId: this.programId
    }));
    if (rentExemptReserve && rentExemptReserve > 0) {
      transaction.add(SystemProgram.transfer({
        fromPubkey: params.authorizedPubkey,
        toPubkey: splitStakePubkey,
        lamports: rentExemptReserve
      }));
    }
    return transaction.add(this.splitInstruction({
      stakePubkey,
      authorizedPubkey,
      splitStakePubkey,
      lamports
    }));
  }
  /**
   * Generate a Transaction that merges Stake accounts.
   */
  static merge(params) {
    const {
      stakePubkey,
      sourceStakePubKey,
      authorizedPubkey
    } = params;
    const type2 = STAKE_INSTRUCTION_LAYOUTS.Merge;
    const data = encodeData(type2);
    return new Transaction().add({
      keys: [{
        pubkey: stakePubkey,
        isSigner: false,
        isWritable: true
      }, {
        pubkey: sourceStakePubKey,
        isSigner: false,
        isWritable: true
      }, {
        pubkey: SYSVAR_CLOCK_PUBKEY,
        isSigner: false,
        isWritable: false
      }, {
        pubkey: SYSVAR_STAKE_HISTORY_PUBKEY,
        isSigner: false,
        isWritable: false
      }, {
        pubkey: authorizedPubkey,
        isSigner: true,
        isWritable: false
      }],
      programId: this.programId,
      data
    });
  }
  /**
   * Generate a Transaction that withdraws deactivated Stake tokens.
   */
  static withdraw(params) {
    const {
      stakePubkey,
      authorizedPubkey,
      toPubkey,
      lamports,
      custodianPubkey
    } = params;
    const type2 = STAKE_INSTRUCTION_LAYOUTS.Withdraw;
    const data = encodeData(type2, {
      lamports
    });
    const keys = [{
      pubkey: stakePubkey,
      isSigner: false,
      isWritable: true
    }, {
      pubkey: toPubkey,
      isSigner: false,
      isWritable: true
    }, {
      pubkey: SYSVAR_CLOCK_PUBKEY,
      isSigner: false,
      isWritable: false
    }, {
      pubkey: SYSVAR_STAKE_HISTORY_PUBKEY,
      isSigner: false,
      isWritable: false
    }, {
      pubkey: authorizedPubkey,
      isSigner: true,
      isWritable: false
    }];
    if (custodianPubkey) {
      keys.push({
        pubkey: custodianPubkey,
        isSigner: true,
        isWritable: false
      });
    }
    return new Transaction().add({
      keys,
      programId: this.programId,
      data
    });
  }
  /**
   * Generate a Transaction that deactivates Stake tokens.
   */
  static deactivate(params) {
    const {
      stakePubkey,
      authorizedPubkey
    } = params;
    const type2 = STAKE_INSTRUCTION_LAYOUTS.Deactivate;
    const data = encodeData(type2);
    return new Transaction().add({
      keys: [{
        pubkey: stakePubkey,
        isSigner: false,
        isWritable: true
      }, {
        pubkey: SYSVAR_CLOCK_PUBKEY,
        isSigner: false,
        isWritable: false
      }, {
        pubkey: authorizedPubkey,
        isSigner: true,
        isWritable: false
      }],
      programId: this.programId,
      data
    });
  }
};
StakeProgram.programId = new PublicKey("Stake11111111111111111111111111111111111111");
StakeProgram.space = 200;
var VOTE_INSTRUCTION_LAYOUTS = Object.freeze({
  InitializeAccount: {
    index: 0,
    layout: BufferLayout.struct([BufferLayout.u32("instruction"), voteInit()])
  },
  Authorize: {
    index: 1,
    layout: BufferLayout.struct([BufferLayout.u32("instruction"), publicKey("newAuthorized"), BufferLayout.u32("voteAuthorizationType")])
  },
  Withdraw: {
    index: 3,
    layout: BufferLayout.struct([BufferLayout.u32("instruction"), BufferLayout.ns64("lamports")])
  },
  UpdateValidatorIdentity: {
    index: 4,
    layout: BufferLayout.struct([BufferLayout.u32("instruction")])
  },
  AuthorizeWithSeed: {
    index: 10,
    layout: BufferLayout.struct([BufferLayout.u32("instruction"), voteAuthorizeWithSeedArgs()])
  }
});
var VoteAuthorizationLayout = Object.freeze({
  Voter: {
    index: 0
  },
  Withdrawer: {
    index: 1
  }
});
var VoteProgram = class _VoteProgram {
  /**
   * @internal
   */
  constructor() {
  }
  /**
   * Public key that identifies the Vote program
   */
  /**
   * Generate an Initialize instruction.
   */
  static initializeAccount(params) {
    const {
      votePubkey,
      nodePubkey,
      voteInit: voteInit2
    } = params;
    const type2 = VOTE_INSTRUCTION_LAYOUTS.InitializeAccount;
    const data = encodeData(type2, {
      voteInit: {
        nodePubkey: toBuffer(voteInit2.nodePubkey.toBuffer()),
        authorizedVoter: toBuffer(voteInit2.authorizedVoter.toBuffer()),
        authorizedWithdrawer: toBuffer(voteInit2.authorizedWithdrawer.toBuffer()),
        commission: voteInit2.commission
      }
    });
    const instructionData = {
      keys: [{
        pubkey: votePubkey,
        isSigner: false,
        isWritable: true
      }, {
        pubkey: SYSVAR_RENT_PUBKEY,
        isSigner: false,
        isWritable: false
      }, {
        pubkey: SYSVAR_CLOCK_PUBKEY,
        isSigner: false,
        isWritable: false
      }, {
        pubkey: nodePubkey,
        isSigner: true,
        isWritable: false
      }],
      programId: this.programId,
      data
    };
    return new TransactionInstruction(instructionData);
  }
  /**
   * Generate a transaction that creates a new Vote account.
   */
  static createAccount(params) {
    const transaction = new Transaction();
    transaction.add(SystemProgram.createAccount({
      fromPubkey: params.fromPubkey,
      newAccountPubkey: params.votePubkey,
      lamports: params.lamports,
      space: this.space,
      programId: this.programId
    }));
    return transaction.add(this.initializeAccount({
      votePubkey: params.votePubkey,
      nodePubkey: params.voteInit.nodePubkey,
      voteInit: params.voteInit
    }));
  }
  /**
   * Generate a transaction that authorizes a new Voter or Withdrawer on the Vote account.
   */
  static authorize(params) {
    const {
      votePubkey,
      authorizedPubkey,
      newAuthorizedPubkey,
      voteAuthorizationType
    } = params;
    const type2 = VOTE_INSTRUCTION_LAYOUTS.Authorize;
    const data = encodeData(type2, {
      newAuthorized: toBuffer(newAuthorizedPubkey.toBuffer()),
      voteAuthorizationType: voteAuthorizationType.index
    });
    const keys = [{
      pubkey: votePubkey,
      isSigner: false,
      isWritable: true
    }, {
      pubkey: SYSVAR_CLOCK_PUBKEY,
      isSigner: false,
      isWritable: false
    }, {
      pubkey: authorizedPubkey,
      isSigner: true,
      isWritable: false
    }];
    return new Transaction().add({
      keys,
      programId: this.programId,
      data
    });
  }
  /**
   * Generate a transaction that authorizes a new Voter or Withdrawer on the Vote account
   * where the current Voter or Withdrawer authority is a derived key.
   */
  static authorizeWithSeed(params) {
    const {
      currentAuthorityDerivedKeyBasePubkey,
      currentAuthorityDerivedKeyOwnerPubkey,
      currentAuthorityDerivedKeySeed,
      newAuthorizedPubkey,
      voteAuthorizationType,
      votePubkey
    } = params;
    const type2 = VOTE_INSTRUCTION_LAYOUTS.AuthorizeWithSeed;
    const data = encodeData(type2, {
      voteAuthorizeWithSeedArgs: {
        currentAuthorityDerivedKeyOwnerPubkey: toBuffer(currentAuthorityDerivedKeyOwnerPubkey.toBuffer()),
        currentAuthorityDerivedKeySeed,
        newAuthorized: toBuffer(newAuthorizedPubkey.toBuffer()),
        voteAuthorizationType: voteAuthorizationType.index
      }
    });
    const keys = [{
      pubkey: votePubkey,
      isSigner: false,
      isWritable: true
    }, {
      pubkey: SYSVAR_CLOCK_PUBKEY,
      isSigner: false,
      isWritable: false
    }, {
      pubkey: currentAuthorityDerivedKeyBasePubkey,
      isSigner: true,
      isWritable: false
    }];
    return new Transaction().add({
      keys,
      programId: this.programId,
      data
    });
  }
  /**
   * Generate a transaction to withdraw from a Vote account.
   */
  static withdraw(params) {
    const {
      votePubkey,
      authorizedWithdrawerPubkey,
      lamports,
      toPubkey
    } = params;
    const type2 = VOTE_INSTRUCTION_LAYOUTS.Withdraw;
    const data = encodeData(type2, {
      lamports
    });
    const keys = [{
      pubkey: votePubkey,
      isSigner: false,
      isWritable: true
    }, {
      pubkey: toPubkey,
      isSigner: false,
      isWritable: true
    }, {
      pubkey: authorizedWithdrawerPubkey,
      isSigner: true,
      isWritable: false
    }];
    return new Transaction().add({
      keys,
      programId: this.programId,
      data
    });
  }
  /**
   * Generate a transaction to withdraw safely from a Vote account.
   *
   * This function was created as a safeguard for vote accounts running validators, `safeWithdraw`
   * checks that the withdraw amount will not exceed the specified balance while leaving enough left
   * to cover rent. If you wish to close the vote account by withdrawing the full amount, call the
   * `withdraw` method directly.
   */
  static safeWithdraw(params, currentVoteAccountBalance, rentExemptMinimum) {
    if (params.lamports > currentVoteAccountBalance - rentExemptMinimum) {
      throw new Error("Withdraw will leave vote account with insufficient funds.");
    }
    return _VoteProgram.withdraw(params);
  }
  /**
   * Generate a transaction to update the validator identity (node pubkey) of a Vote account.
   */
  static updateValidatorIdentity(params) {
    const {
      votePubkey,
      authorizedWithdrawerPubkey,
      nodePubkey
    } = params;
    const type2 = VOTE_INSTRUCTION_LAYOUTS.UpdateValidatorIdentity;
    const data = encodeData(type2);
    const keys = [{
      pubkey: votePubkey,
      isSigner: false,
      isWritable: true
    }, {
      pubkey: nodePubkey,
      isSigner: true,
      isWritable: false
    }, {
      pubkey: authorizedWithdrawerPubkey,
      isSigner: true,
      isWritable: false
    }];
    return new Transaction().add({
      keys,
      programId: this.programId,
      data
    });
  }
};
VoteProgram.programId = new PublicKey("Vote111111111111111111111111111111111111111");
VoteProgram.space = 3762;
var VALIDATOR_INFO_KEY = new PublicKey("Va1idator1nfo111111111111111111111111111111");
var InfoString = type({
  name: string(),
  website: optional(string()),
  details: optional(string()),
  iconUrl: optional(string()),
  keybaseUsername: optional(string())
});
var VOTE_PROGRAM_ID = new PublicKey("Vote111111111111111111111111111111111111111");
var VoteAccountLayout = BufferLayout.struct([
  publicKey("nodePubkey"),
  publicKey("authorizedWithdrawer"),
  BufferLayout.u8("commission"),
  BufferLayout.nu64(),
  // votes.length
  BufferLayout.seq(BufferLayout.struct([BufferLayout.nu64("slot"), BufferLayout.u32("confirmationCount")]), BufferLayout.offset(BufferLayout.u32(), -8), "votes"),
  BufferLayout.u8("rootSlotValid"),
  BufferLayout.nu64("rootSlot"),
  BufferLayout.nu64(),
  // authorizedVoters.length
  BufferLayout.seq(BufferLayout.struct([BufferLayout.nu64("epoch"), publicKey("authorizedVoter")]), BufferLayout.offset(BufferLayout.u32(), -8), "authorizedVoters"),
  BufferLayout.struct([BufferLayout.seq(BufferLayout.struct([publicKey("authorizedPubkey"), BufferLayout.nu64("epochOfLastAuthorizedSwitch"), BufferLayout.nu64("targetEpoch")]), 32, "buf"), BufferLayout.nu64("idx"), BufferLayout.u8("isEmpty")], "priorVoters"),
  BufferLayout.nu64(),
  // epochCredits.length
  BufferLayout.seq(BufferLayout.struct([BufferLayout.nu64("epoch"), BufferLayout.nu64("credits"), BufferLayout.nu64("prevCredits")]), BufferLayout.offset(BufferLayout.u32(), -8), "epochCredits"),
  BufferLayout.struct([BufferLayout.nu64("slot"), BufferLayout.nu64("timestamp")], "lastTimestamp")
]);

// node_modules/@cartridge/controller/dist/index.js
var H2 = class extends WalletAccount {
  constructor(e9, t3, n6, o3, s2, a) {
    super({ nodeUrl: t3 }, e9);
    __publicField(this, "address");
    __publicField(this, "keychain");
    __publicField(this, "modal");
    __publicField(this, "options");
    this.address = n6, this.keychain = o3, this.options = s2, this.modal = a;
  }
  /**
   * Invoke execute function in account contract
   *
   * @param calls the invocation object or an array of them, containing:
   * - contractAddress - the address of the contract
   * - entrypoint - the entrypoint of the contract
   * - calldata - (defaults to []) the calldata
   * - signature - (defaults to []) the signature
   * @param abis (optional) the abi of the contract for better displaying
   *
   * @returns response from addTransaction
   */
  async execute(e9) {
    return e9 = n2(e9), new Promise(async (t3, n6) => {
      var _a2, _b;
      const o3 = await this.keychain.execute(
        e9,
        void 0,
        void 0,
        false,
        (_a2 = this.options) == null ? void 0 : _a2.feeSource
      );
      if (o3.code === w.SUCCESS) {
        t3(o3);
        return;
      }
      if (((_b = this.options) == null ? void 0 : _b.propagateSessionErrors) && o3.code !== w.USER_INTERACTION_REQUIRED) {
        n6(o3.error);
        return;
      }
      this.modal.open();
      const s2 = await this.keychain.execute(
        e9,
        void 0,
        void 0,
        true,
        o3.error
      );
      if (s2.code === w.SUCCESS) {
        t3(s2), this.modal.close();
        return;
      }
      n6(s2.error);
    });
  }
  /**
   * Sign an JSON object for off-chain usage with the starknet private key and return the signature
   * This adds a message prefix so it cant be interchanged with transactions
   *
   * @param json - JSON object to be signed
   * @returns the signature of the JSON object
   * @throws {Error} if the JSON object is not a valid JSON
   */
  async signMessage(e9) {
    return new Promise(async (t3, n6) => {
      const o3 = await this.keychain.signMessage(e9, "", true);
      if (!("code" in o3)) {
        t3(o3);
        return;
      }
      this.modal.open();
      const s2 = await this.keychain.signMessage(e9, "", false);
      "code" in s2 ? n6(s2.error) : t3(s2), this.modal.close();
    });
  }
};
var w4;
(function(r2) {
  r2.Call = "call", r2.Reply = "reply", r2.Syn = "syn", r2.SynAck = "synAck", r2.Ack = "ack";
})(w4 || (w4 = {}));
var E3;
(function(r2) {
  r2.Fulfilled = "fulfilled", r2.Rejected = "rejected";
})(E3 || (E3 = {}));
var D2;
(function(r2) {
  r2.ConnectionDestroyed = "ConnectionDestroyed", r2.ConnectionTimeout = "ConnectionTimeout", r2.NoIframeSrc = "NoIframeSrc";
})(D2 || (D2 = {}));
var z2;
(function(r2) {
  r2.DataCloneError = "DataCloneError";
})(z2 || (z2 = {}));
var A2;
(function(r2) {
  r2.Message = "message";
})(A2 || (A2 = {}));
var Re3 = (r2, e9) => {
  const t3 = [];
  let n6 = false;
  return {
    destroy(o3) {
      n6 || (n6 = true, e9(`${r2}: Destroying connection`), t3.forEach((s2) => {
        s2(o3);
      }));
    },
    onDestroy(o3) {
      n6 ? o3() : t3.push(o3);
    }
  };
};
var Se2 = (r2) => (...e9) => {
  r2 && console.log("[Penpal]", ...e9);
};
var Ne2 = {
  "http:": "80",
  "https:": "443"
};
var De2 = /^(https?:)?\/\/([^/:]+)?(:(\d+))?/;
var Me2 = ["file:", "data:"];
var Be2 = (r2) => {
  if (r2 && Me2.find((i4) => r2.startsWith(i4)))
    return "null";
  const e9 = document.location, t3 = De2.exec(r2);
  let n6, o3, s2;
  t3 ? (n6 = t3[1] ? t3[1] : e9.protocol, o3 = t3[2], s2 = t3[4]) : (n6 = e9.protocol, o3 = e9.hostname, s2 = e9.port);
  const a = s2 && s2 !== Ne2[n6] ? `:${s2}` : "";
  return `${n6}//${o3}${a}`;
};
var K3 = ({ name: r2, message: e9, stack: t3 }) => ({
  name: r2,
  message: e9,
  stack: t3
});
var Ue2 = (r2) => {
  const e9 = new Error();
  return Object.keys(r2).forEach((t3) => e9[t3] = r2[t3]), e9;
};
var Qe2 = (r2, e9, t3) => {
  const { localName: n6, local: o3, remote: s2, originForSending: a, originForReceiving: i4 } = r2;
  let c3 = false;
  const d3 = (l5) => {
    if (l5.source !== s2 || l5.data.penpal !== w4.Call)
      return;
    if (i4 !== "*" && l5.origin !== i4) {
      t3(`${n6} received message from origin ${l5.origin} which did not match expected origin ${i4}`);
      return;
    }
    const h3 = l5.data, { methodName: p4, args: f4, id: g2 } = h3;
    t3(`${n6}: Received ${p4}() call`);
    const k3 = (y2) => (I2) => {
      if (t3(`${n6}: Sending ${p4}() reply`), c3) {
        t3(`${n6}: Unable to send ${p4}() reply due to destroyed connection`);
        return;
      }
      const _2 = {
        penpal: w4.Reply,
        id: g2,
        resolution: y2,
        returnValue: I2
      };
      y2 === E3.Rejected && I2 instanceof Error && (_2.returnValue = K3(I2), _2.returnValueIsError = true);
      try {
        s2.postMessage(_2, a);
      } catch (u2) {
        if (u2.name === z2.DataCloneError) {
          const x3 = {
            penpal: w4.Reply,
            id: g2,
            resolution: E3.Rejected,
            returnValue: K3(u2),
            returnValueIsError: true
          };
          s2.postMessage(x3, a);
        }
        throw u2;
      }
    };
    new Promise((y2) => y2(e9[p4].call(e9, l5.origin).apply(e9, f4))).then(k3(E3.Fulfilled), k3(E3.Rejected));
  };
  return o3.addEventListener(A2.Message, d3), () => {
    c3 = true, o3.removeEventListener(A2.Message, d3);
  };
};
var Te2 = 0;
var $e2 = () => ++Te2;
var re3 = ".";
var ne2 = (r2) => r2 ? r2.split(re3) : [];
var ze2 = (r2) => r2.join(re3);
var Oe2 = (r2, e9) => {
  const t3 = ne2(e9 || "");
  return t3.push(r2), ze2(t3);
};
var Le2 = (r2, e9, t3) => {
  const n6 = ne2(e9);
  return n6.reduce((o3, s2, a) => (typeof o3[s2] > "u" && (o3[s2] = {}), a === n6.length - 1 && (o3[s2] = t3), o3[s2]), r2), r2;
};
var oe2 = (r2, e9) => {
  const t3 = {};
  return Object.keys(r2).forEach((n6) => {
    const o3 = r2[n6], s2 = Oe2(n6, e9);
    typeof o3 == "object" && Object.assign(t3, oe2(o3, s2)), typeof o3 == "function" && (t3[s2] = o3);
  }), t3;
};
var Ye2 = (r2) => {
  const e9 = {};
  for (const t3 in r2)
    Le2(e9, t3, r2[t3]);
  return e9;
};
var Fe3 = (r2, e9, t3, n6, o3) => {
  const { localName: s2, local: a, remote: i4, originForSending: c3, originForReceiving: d3 } = e9;
  let l5 = false;
  o3(`${s2}: Connecting call sender`);
  const h3 = (f4) => (...g2) => {
    o3(`${s2}: Sending ${f4}() call`);
    let k3;
    try {
      i4.closed && (k3 = true);
    } catch {
      k3 = true;
    }
    if (k3 && n6(), l5) {
      const y2 = new Error(`Unable to send ${f4}() call due to destroyed connection`);
      throw y2.code = D2.ConnectionDestroyed, y2;
    }
    return new Promise((y2, I2) => {
      const _2 = $e2(), u2 = (C4) => {
        if (C4.source !== i4 || C4.data.penpal !== w4.Reply || C4.data.id !== _2)
          return;
        if (d3 !== "*" && C4.origin !== d3) {
          o3(`${s2} received message from origin ${C4.origin} which did not match expected origin ${d3}`);
          return;
        }
        const Q5 = C4.data;
        o3(`${s2}: Received ${f4}() reply`), a.removeEventListener(A2.Message, u2);
        let T3 = Q5.returnValue;
        Q5.returnValueIsError && (T3 = Ue2(T3)), (Q5.resolution === E3.Fulfilled ? y2 : I2)(T3);
      };
      a.addEventListener(A2.Message, u2);
      const x3 = {
        penpal: w4.Call,
        id: _2,
        methodName: f4,
        args: g2
      };
      i4.postMessage(x3, c3);
    });
  }, p4 = t3.reduce((f4, g2) => (f4[g2] = h3(g2), f4), {});
  return Object.assign(r2, Ye2(p4)), () => {
    l5 = true;
  };
};
var We2 = (r2, e9, t3, n6, o3) => {
  const { destroy: s2, onDestroy: a } = n6;
  let i4, c3;
  const d3 = {};
  return (l5) => {
    if (e9 !== "*" && l5.origin !== e9) {
      o3(`Parent: Handshake - Received ACK message from origin ${l5.origin} which did not match expected origin ${e9}`);
      return;
    }
    o3("Parent: Handshake - Received ACK");
    const h3 = {
      localName: "Parent",
      local: window,
      remote: l5.source,
      originForSending: t3,
      originForReceiving: e9
    };
    i4 && i4(), i4 = Qe2(h3, r2, o3), a(i4), c3 && c3.forEach((f4) => {
      delete d3[f4];
    }), c3 = l5.data.methodNames;
    const p4 = Fe3(d3, h3, c3, s2, o3);
    return a(p4), d3;
  };
};
var He2 = (r2, e9, t3, n6) => (o3) => {
  if (!o3.source)
    return;
  if (t3 !== "*" && o3.origin !== t3) {
    r2(`Parent: Handshake - Received SYN message from origin ${o3.origin} which did not match expected origin ${t3}`);
    return;
  }
  r2("Parent: Handshake - Received SYN, responding with SYN-ACK");
  const s2 = {
    penpal: w4.SynAck,
    methodNames: Object.keys(e9)
  };
  o3.source.postMessage(s2, n6);
};
var Ke2 = 6e4;
var je2 = (r2, e9) => {
  const { destroy: t3, onDestroy: n6 } = e9, o3 = setInterval(() => {
    r2.isConnected || (clearInterval(o3), t3());
  }, Ke2);
  n6(() => {
    clearInterval(o3);
  });
};
var qe2 = (r2, e9) => {
  let t3;
  return r2 !== void 0 && (t3 = window.setTimeout(() => {
    const n6 = new Error(`Connection timed out after ${r2}ms`);
    n6.code = D2.ConnectionTimeout, e9(n6);
  }, r2)), () => {
    clearTimeout(t3);
  };
};
var Xe2 = (r2) => {
  if (!r2.src && !r2.srcdoc) {
    const e9 = new Error("Iframe must have src or srcdoc property defined.");
    throw e9.code = D2.NoIframeSrc, e9;
  }
};
var Ge2 = (r2) => {
  let { iframe: e9, methods: t3 = {}, childOrigin: n6, timeout: o3, debug: s2 = false } = r2;
  const a = Se2(s2), i4 = Re3("Parent", a), { onDestroy: c3, destroy: d3 } = i4;
  n6 || (Xe2(e9), n6 = Be2(e9.src));
  const l5 = n6 === "null" ? "*" : n6, h3 = oe2(t3), p4 = He2(a, h3, n6, l5), f4 = We2(h3, n6, l5, i4, a);
  return {
    promise: new Promise((k3, y2) => {
      const I2 = qe2(o3, d3), _2 = (u2) => {
        if (!(u2.source !== e9.contentWindow || !u2.data)) {
          if (u2.data.penpal === w4.Syn) {
            p4(u2);
            return;
          }
          if (u2.data.penpal === w4.Ack) {
            const x3 = f4(u2);
            x3 && (I2(), k3(x3));
            return;
          }
        }
      };
      window.addEventListener(A2.Message, _2), a("Parent: Awaiting handshake"), je2(e9, i4), c3((u2) => {
        window.removeEventListener(A2.Message, _2), u2 && y2(u2);
      });
    }),
    destroy() {
      d3();
    }
  };
};
var se2 = class {
  constructor({
    id: e9,
    url: t3,
    preset: n6,
    onClose: o3,
    onConnect: s2,
    methods: a = {}
  }) {
    __publicField(this, "url");
    __publicField(this, "iframe");
    __publicField(this, "container");
    __publicField(this, "onClose");
    __publicField(this, "child");
    if (typeof document > "u" || typeof window > "u")
      return;
    n6 && t3.searchParams.set("preset", n6), this.url = t3;
    const i4 = document.createElement("iframe");
    i4.src = t3.toString(), i4.id = e9, i4.style.border = "none", i4.sandbox.add("allow-forms"), i4.sandbox.add("allow-popups"), i4.sandbox.add("allow-popups-to-escape-sandbox"), i4.sandbox.add("allow-scripts"), i4.sandbox.add("allow-same-origin"), i4.allow = "publickey-credentials-create *; publickey-credentials-get *; clipboard-write", document.hasStorageAccess && i4.sandbox.add("allow-storage-access-by-user-activation");
    const c3 = document.createElement("div");
    c3.id = "controller", c3.style.position = "fixed", c3.style.height = "100%", c3.style.width = "100%", c3.style.top = "0", c3.style.left = "0", c3.style.zIndex = "10000", c3.style.backgroundColor = "rgba(0,0,0,0.6)", c3.style.display = "flex", c3.style.alignItems = "center", c3.style.justifyContent = "center", c3.style.visibility = "hidden", c3.style.opacity = "0", c3.style.transition = "opacity 0.2s ease", c3.style.pointerEvents = "auto", c3.appendChild(i4), c3.addEventListener("click", (h3) => {
      var _a2, _b;
      h3.target === c3 && (e9 === "controller-keychain" && this.child && ((_b = (_a2 = this.child).reset) == null ? void 0 : _b.call(_a2).catch((p4) => console.error("Error resetting context:", p4))), this.close());
    }), this.iframe = i4, this.container = c3, Ge2({
      iframe: this.iframe,
      methods: {
        close: (h3) => () => this.close(),
        closeAll: (h3) => () => {
          document.querySelectorAll(
            'iframe[id^="controller-"]'
          ).forEach((f4) => {
            const g2 = f4.parentElement;
            g2 && (g2.style.visibility = "hidden", g2.style.opacity = "0");
          }), document.body && (document.body.style.overflow = "auto");
        },
        reload: (h3) => () => window.location.reload(),
        ...a
      }
    }).promise.then((h3) => {
      this.child = h3, s2(h3);
    }), this.resize(), window.addEventListener("resize", () => this.resize());
    const d3 = new MutationObserver(() => {
      if (typeof document > "u") return;
      const h3 = document.getElementById("controller");
      document.body && (e9 === "controller-keychain" && !h3 || e9 === "controller-profile") && (document.body.appendChild(c3), d3.disconnect());
    });
    d3.observe(document.documentElement, {
      childList: true,
      subtree: true
    });
    const l5 = document.getElementById("controller");
    document.body && (e9 === "controller-keychain" && !l5 || e9 === "controller-profile") && document.body.appendChild(c3), this.onClose = o3;
  }
  open() {
    !this.container || typeof document > "u" || !document.body || (document.body.style.overflow = "hidden", this.container.style.visibility = "visible", this.container.style.opacity = "1");
  }
  close() {
    var _a2;
    !this.container || typeof document > "u" || !document.body || ((_a2 = this.onClose) == null ? void 0 : _a2.call(this), document.body.style.overflow = "auto", this.container.style.visibility = "hidden", this.container.style.opacity = "0");
  }
  sendBackward() {
    this.container && (this.container.style.zIndex = "9999");
  }
  sendForward() {
    this.container && (this.container.style.zIndex = "10000");
  }
  resize() {
    if (!(!this.iframe || typeof window > "u")) {
      if (this.iframe.style.userSelect = "none", window.innerWidth < 768) {
        this.iframe.style.height = "100%", this.iframe.style.width = "100%", this.iframe.style.borderRadius = "0";
        return;
      }
      this.iframe.style.height = "600px", this.iframe.style.width = "432px", this.iframe.style.borderRadius = "8px";
    }
  }
};
var Ve3 = "6.13.7";
function j3(r2, e9, t3) {
  for (let n6 in e9) {
    let o3 = e9[n6];
    Object.defineProperty(r2, n6, { enumerable: true, value: o3, writable: false });
  }
}
function P4(r2) {
  if (r2 == null)
    return "null";
  if (Array.isArray(r2))
    return "[ " + r2.map(P4).join(", ") + " ]";
  if (r2 instanceof Uint8Array) {
    const e9 = "0123456789abcdef";
    let t3 = "0x";
    for (let n6 = 0; n6 < r2.length; n6++)
      t3 += e9[r2[n6] >> 4], t3 += e9[r2[n6] & 15];
    return t3;
  }
  if (typeof r2 == "object" && typeof r2.toJSON == "function")
    return P4(r2.toJSON());
  switch (typeof r2) {
    case "boolean":
    case "symbol":
      return r2.toString();
    case "bigint":
      return BigInt(r2).toString();
    case "number":
      return r2.toString();
    case "string":
      return JSON.stringify(r2);
    case "object": {
      const e9 = Object.keys(r2);
      return e9.sort(), "{ " + e9.map((t3) => `${P4(t3)}: ${P4(r2[t3])}`).join(", ") + " }";
    }
  }
  return "[ COULD NOT SERIALIZE ]";
}
function Je2(r2, e9, t3) {
  let n6 = r2;
  {
    const s2 = [];
    if (t3) {
      if ("message" in t3 || "code" in t3 || "name" in t3)
        throw new Error(`value will overwrite populated values: ${P4(t3)}`);
      for (const a in t3) {
        if (a === "shortMessage")
          continue;
        const i4 = t3[a];
        s2.push(a + "=" + P4(i4));
      }
    }
    s2.push(`code=${e9}`), s2.push(`version=${Ve3}`), s2.length && (r2 += " (" + s2.join(", ") + ")");
  }
  let o3;
  switch (e9) {
    case "INVALID_ARGUMENT":
      o3 = new TypeError(r2);
      break;
    case "NUMERIC_FAULT":
    case "BUFFER_OVERRUN":
      o3 = new RangeError(r2);
      break;
    default:
      o3 = new Error(r2);
  }
  return j3(o3, { code: e9 }), t3 && Object.assign(o3, t3), o3.shortMessage == null && j3(o3, { shortMessage: n6 }), o3;
}
function Ze2(r2, e9, t3, n6) {
  if (!r2)
    throw Je2(e9, t3, n6);
}
function N2(r2, e9, t3, n6) {
  Ze2(r2, e9, "INVALID_ARGUMENT", { argument: t3, value: n6 });
}
["NFD", "NFC", "NFKD", "NFKC"].reduce((r2, e9) => {
  try {
    if ("test".normalize(e9) !== "test")
      throw new Error("bad");
    if (e9 === "NFD" && "é".normalize("NFD") !== "é")
      throw new Error("broken");
    r2.push(e9);
  } catch {
  }
  return r2;
}, []);
function et2(r2, e9, t3) {
  if (r2 instanceof Uint8Array)
    return r2;
  if (typeof r2 == "string" && r2.match(/^0x(?:[0-9a-f][0-9a-f])*$/i)) {
    const n6 = new Uint8Array((r2.length - 2) / 2);
    let o3 = 2;
    for (let s2 = 0; s2 < n6.length; s2++)
      n6[s2] = parseInt(r2.substring(o3, o3 + 2), 16), o3 += 2;
    return n6;
  }
  N2(false, "invalid BytesLike value", e9 || "value", r2);
}
function O3(r2, e9) {
  return et2(r2, e9);
}
var q3 = "0123456789abcdef";
function tt2(r2) {
  const e9 = O3(r2);
  let t3 = "0x";
  for (let n6 = 0; n6 < e9.length; n6++) {
    const o3 = e9[n6];
    t3 += q3[(o3 & 240) >> 4] + q3[o3 & 15];
  }
  return t3;
}
function X2(r2) {
  if (!Number.isSafeInteger(r2) || r2 < 0)
    throw new Error(`Wrong positive integer: ${r2}`);
}
function ae2(r2, ...e9) {
  if (!(r2 instanceof Uint8Array))
    throw new Error("Expected Uint8Array");
  if (e9.length > 0 && !e9.includes(r2.length))
    throw new Error(`Expected Uint8Array of length ${e9}, not of length=${r2.length}`);
}
function G2(r2, e9 = true) {
  if (r2.destroyed)
    throw new Error("Hash instance has been destroyed");
  if (e9 && r2.finished)
    throw new Error("Hash#digest() has already been called");
}
function rt2(r2, e9) {
  ae2(r2);
  const t3 = e9.outputLen;
  if (r2.length < t3)
    throw new Error(`digestInto() expects output buffer of length at least ${t3}`);
}
var nt2 = (r2) => r2 instanceof Uint8Array;
var ot2 = (r2) => new Uint32Array(r2.buffer, r2.byteOffset, Math.floor(r2.byteLength / 4));
var st2 = new Uint8Array(new Uint32Array([287454020]).buffer)[0] === 68;
if (!st2)
  throw new Error("Non little-endian hardware is not supported");
function at2(r2) {
  if (typeof r2 != "string")
    throw new Error(`utf8ToBytes expected string, got ${typeof r2}`);
  return new Uint8Array(new TextEncoder().encode(r2));
}
function ie2(r2) {
  if (typeof r2 == "string" && (r2 = at2(r2)), !nt2(r2))
    throw new Error(`expected Uint8Array, got ${typeof r2}`);
  return r2;
}
var it2 = class {
  // Safe version that clones internal state
  clone() {
    return this._cloneInto();
  }
};
function ct2(r2) {
  const e9 = (n6) => r2().update(ie2(n6)).digest(), t3 = r2();
  return e9.outputLen = t3.outputLen, e9.blockLen = t3.blockLen, e9.create = () => r2(), e9;
}
var B2 = BigInt(2 ** 32 - 1);
var V2 = BigInt(32);
function lt2(r2, e9 = false) {
  return e9 ? { h: Number(r2 & B2), l: Number(r2 >> V2 & B2) } : { h: Number(r2 >> V2 & B2) | 0, l: Number(r2 & B2) | 0 };
}
function dt2(r2, e9 = false) {
  let t3 = new Uint32Array(r2.length), n6 = new Uint32Array(r2.length);
  for (let o3 = 0; o3 < r2.length; o3++) {
    const { h: s2, l: a } = lt2(r2[o3], e9);
    [t3[o3], n6[o3]] = [s2, a];
  }
  return [t3, n6];
}
var ht2 = (r2, e9, t3) => r2 << t3 | e9 >>> 32 - t3;
var ft2 = (r2, e9, t3) => e9 << t3 | r2 >>> 32 - t3;
var ut2 = (r2, e9, t3) => e9 << t3 - 32 | r2 >>> 64 - t3;
var pt2 = (r2, e9, t3) => r2 << t3 - 32 | e9 >>> 64 - t3;
var [ce2, le2, de2] = [[], [], []];
var mt2 = BigInt(0);
var S4 = BigInt(1);
var gt2 = BigInt(2);
var yt2 = BigInt(7);
var bt2 = BigInt(256);
var wt2 = BigInt(113);
for (let r2 = 0, e9 = S4, t3 = 1, n6 = 0; r2 < 24; r2++) {
  [t3, n6] = [n6, (2 * t3 + 3 * n6) % 5], ce2.push(2 * (5 * n6 + t3)), le2.push((r2 + 1) * (r2 + 2) / 2 % 64);
  let o3 = mt2;
  for (let s2 = 0; s2 < 7; s2++)
    e9 = (e9 << S4 ^ (e9 >> yt2) * wt2) % bt2, e9 & gt2 && (o3 ^= S4 << (S4 << BigInt(s2)) - S4);
  de2.push(o3);
}
var [_t2, kt2] = dt2(de2, true);
var J2 = (r2, e9, t3) => t3 > 32 ? ut2(r2, e9, t3) : ht2(r2, e9, t3);
var Z3 = (r2, e9, t3) => t3 > 32 ? pt2(r2, e9, t3) : ft2(r2, e9, t3);
function At2(r2, e9 = 24) {
  const t3 = new Uint32Array(10);
  for (let n6 = 24 - e9; n6 < 24; n6++) {
    for (let a = 0; a < 10; a++)
      t3[a] = r2[a] ^ r2[a + 10] ^ r2[a + 20] ^ r2[a + 30] ^ r2[a + 40];
    for (let a = 0; a < 10; a += 2) {
      const i4 = (a + 8) % 10, c3 = (a + 2) % 10, d3 = t3[c3], l5 = t3[c3 + 1], h3 = J2(d3, l5, 1) ^ t3[i4], p4 = Z3(d3, l5, 1) ^ t3[i4 + 1];
      for (let f4 = 0; f4 < 50; f4 += 10)
        r2[a + f4] ^= h3, r2[a + f4 + 1] ^= p4;
    }
    let o3 = r2[2], s2 = r2[3];
    for (let a = 0; a < 24; a++) {
      const i4 = le2[a], c3 = J2(o3, s2, i4), d3 = Z3(o3, s2, i4), l5 = ce2[a];
      o3 = r2[l5], s2 = r2[l5 + 1], r2[l5] = c3, r2[l5 + 1] = d3;
    }
    for (let a = 0; a < 50; a += 10) {
      for (let i4 = 0; i4 < 10; i4++)
        t3[i4] = r2[a + i4];
      for (let i4 = 0; i4 < 10; i4++)
        r2[a + i4] ^= ~t3[(i4 + 2) % 10] & t3[(i4 + 4) % 10];
    }
    r2[0] ^= _t2[n6], r2[1] ^= kt2[n6];
  }
  t3.fill(0);
}
var L4 = class _L extends it2 {
  // NOTE: we accept arguments in bytes instead of bits here.
  constructor(e9, t3, n6, o3 = false, s2 = 24) {
    if (super(), this.blockLen = e9, this.suffix = t3, this.outputLen = n6, this.enableXOF = o3, this.rounds = s2, this.pos = 0, this.posOut = 0, this.finished = false, this.destroyed = false, X2(n6), 0 >= this.blockLen || this.blockLen >= 200)
      throw new Error("Sha3 supports only keccak-f1600 function");
    this.state = new Uint8Array(200), this.state32 = ot2(this.state);
  }
  keccak() {
    At2(this.state32, this.rounds), this.posOut = 0, this.pos = 0;
  }
  update(e9) {
    G2(this);
    const { blockLen: t3, state: n6 } = this;
    e9 = ie2(e9);
    const o3 = e9.length;
    for (let s2 = 0; s2 < o3; ) {
      const a = Math.min(t3 - this.pos, o3 - s2);
      for (let i4 = 0; i4 < a; i4++)
        n6[this.pos++] ^= e9[s2++];
      this.pos === t3 && this.keccak();
    }
    return this;
  }
  finish() {
    if (this.finished)
      return;
    this.finished = true;
    const { state: e9, suffix: t3, pos: n6, blockLen: o3 } = this;
    e9[n6] ^= t3, (t3 & 128) !== 0 && n6 === o3 - 1 && this.keccak(), e9[o3 - 1] ^= 128, this.keccak();
  }
  writeInto(e9) {
    G2(this, false), ae2(e9), this.finish();
    const t3 = this.state, { blockLen: n6 } = this;
    for (let o3 = 0, s2 = e9.length; o3 < s2; ) {
      this.posOut >= n6 && this.keccak();
      const a = Math.min(n6 - this.posOut, s2 - o3);
      e9.set(t3.subarray(this.posOut, this.posOut + a), o3), this.posOut += a, o3 += a;
    }
    return e9;
  }
  xofInto(e9) {
    if (!this.enableXOF)
      throw new Error("XOF is not possible for this instance");
    return this.writeInto(e9);
  }
  xof(e9) {
    return X2(e9), this.xofInto(new Uint8Array(e9));
  }
  digestInto(e9) {
    if (rt2(e9, this), this.finished)
      throw new Error("digest() was already called");
    return this.writeInto(e9), this.destroy(), e9;
  }
  digest() {
    return this.digestInto(new Uint8Array(this.outputLen));
  }
  destroy() {
    this.destroyed = true, this.state.fill(0);
  }
  _cloneInto(e9) {
    const { blockLen: t3, suffix: n6, outputLen: o3, rounds: s2, enableXOF: a } = this;
    return e9 || (e9 = new _L(t3, n6, o3, a, s2)), e9.state32.set(this.state32), e9.pos = this.pos, e9.posOut = this.posOut, e9.finished = this.finished, e9.rounds = s2, e9.suffix = n6, e9.outputLen = o3, e9.enableXOF = a, e9.destroyed = this.destroyed, e9;
  }
};
var It2 = (r2, e9, t3) => ct2(() => new L4(e9, r2, t3));
var vt2 = It2(1, 136, 256 / 8);
var he2 = false;
var fe2 = function(r2) {
  return vt2(r2);
};
var ue2 = fe2;
function M3(r2) {
  const e9 = O3(r2, "data");
  return tt2(ue2(e9));
}
M3._ = fe2;
M3.lock = function() {
  he2 = true;
};
M3.register = function(r2) {
  if (he2)
    throw new TypeError("keccak256 is locked");
  ue2 = r2;
};
Object.freeze(M3);
var Et2 = BigInt(0);
var xt2 = BigInt(36);
function ee2(r2) {
  r2 = r2.toLowerCase();
  const e9 = r2.substring(2).split(""), t3 = new Uint8Array(40);
  for (let o3 = 0; o3 < 40; o3++)
    t3[o3] = e9[o3].charCodeAt(0);
  const n6 = O3(M3(t3));
  for (let o3 = 0; o3 < 40; o3 += 2)
    n6[o3 >> 1] >> 4 >= 8 && (e9[o3] = e9[o3].toUpperCase()), (n6[o3 >> 1] & 15) >= 8 && (e9[o3 + 1] = e9[o3 + 1].toUpperCase());
  return "0x" + e9.join("");
}
var Y2 = {};
for (let r2 = 0; r2 < 10; r2++)
  Y2[String(r2)] = String(r2);
for (let r2 = 0; r2 < 26; r2++)
  Y2[String.fromCharCode(65 + r2)] = String(10 + r2);
var te2 = 15;
function Ct2(r2) {
  r2 = r2.toUpperCase(), r2 = r2.substring(4) + r2.substring(0, 2) + "00";
  let e9 = r2.split("").map((n6) => Y2[n6]).join("");
  for (; e9.length >= te2; ) {
    let n6 = e9.substring(0, te2);
    e9 = parseInt(n6, 10) % 97 + e9.substring(n6.length);
  }
  let t3 = String(98 - parseInt(e9, 10) % 97);
  for (; t3.length < 2; )
    t3 = "0" + t3;
  return t3;
}
var Pt2 = function() {
  const r2 = {};
  for (let e9 = 0; e9 < 36; e9++) {
    const t3 = "0123456789abcdefghijklmnopqrstuvwxyz"[e9];
    r2[t3] = BigInt(e9);
  }
  return r2;
}();
function Rt2(r2) {
  r2 = r2.toLowerCase();
  let e9 = Et2;
  for (let t3 = 0; t3 < r2.length; t3++)
    e9 = e9 * xt2 + Pt2[r2[t3]];
  return e9;
}
function m3(r2) {
  if (N2(typeof r2 == "string", "invalid address", "address", r2), r2.match(/^(0x)?[0-9a-fA-F]{40}$/)) {
    r2.startsWith("0x") || (r2 = "0x" + r2);
    const e9 = ee2(r2);
    return N2(!r2.match(/([A-F].*[a-f])|([a-f].*[A-F])/) || e9 === r2, "bad address checksum", "address", r2), e9;
  }
  if (r2.match(/^XE[0-9]{2}[0-9A-Za-z]{30,31}$/)) {
    N2(r2.substring(2, 4) === Ct2(r2), "bad icap checksum", "address", r2);
    let e9 = Rt2(r2.substring(4)).toString(16);
    for (; e9.length < 40; )
      e9 = "0" + e9;
    return ee2("0x" + e9);
  }
  N2(false, "invalid address", "address", r2);
}
var St2 = class {
  constructor() {
    __publicField(this, "type", "argent");
    __publicField(this, "platform", "starknet");
    __publicField(this, "wallet");
    __publicField(this, "account");
    __publicField(this, "connectedAccounts", []);
  }
  isAvailable() {
    return typeof window < "u" && !!window.starknet_argentX;
  }
  getInfo() {
    var _a2, _b;
    const e9 = this.isAvailable();
    return {
      type: this.type,
      available: e9,
      version: e9 ? ((_a2 = window.starknet_argentX) == null ? void 0 : _a2.version) || "Unknown" : void 0,
      chainId: e9 ? (_b = window.starknet_argentX) == null ? void 0 : _b.chainId : void 0,
      name: "Argent",
      platform: this.platform
    };
  }
  async connect() {
    if (this.account)
      return { success: true, wallet: this.type, account: this.account };
    try {
      if (!this.isAvailable())
        throw new Error("Argent is not available");
      const { wallet: e9, connectorData: t3 } = await K({
        connectors: [new L({ options: { id: "argentX" } })]
      });
      if (!e9)
        throw new Error("No wallet found");
      return this.wallet = e9, this.account = t3 == null ? void 0 : t3.account, { success: true, wallet: this.type, account: this.account };
    } catch (e9) {
      return console.error("Error connecting to Argent:", e9), {
        success: false,
        wallet: this.type,
        error: e9.message || "Unknown error"
      };
    }
  }
  getConnectedAccounts() {
    return this.connectedAccounts;
  }
  async signTypedData(e9) {
    try {
      if (!this.isAvailable() || !this.wallet)
        throw new Error("Argent is not connected");
      const t3 = await this.wallet.request({
        type: "wallet_signTypedData",
        params: e9
      });
      return { success: true, wallet: this.type, result: t3 };
    } catch (t3) {
      return console.error("Error signing typed data with Argent:", t3), {
        success: false,
        wallet: this.type,
        error: t3.message || "Unknown error"
      };
    }
  }
  async sendTransaction(e9) {
    return {
      success: false,
      wallet: this.type,
      error: "Not implemented"
    };
  }
  async switchChain(e9) {
    return console.warn(
      "Chain switching for Argent may require custom implementation"
    ), false;
  }
  async getBalance(e9) {
    try {
      if (!this.isAvailable() || !this.wallet)
        throw new Error("Argent is not connected");
      return {
        success: true,
        wallet: this.type,
        result: "Implement based on Argent API"
      };
    } catch (t3) {
      return console.error("Error getting balance from Argent:", t3), {
        success: false,
        wallet: this.type,
        error: t3.message || "Unknown error"
      };
    }
  }
};
function Nt2(r2) {
  if (typeof window > "u")
    return;
  const e9 = (t3) => r2(t3.detail);
  return window.addEventListener("eip6963:announceProvider", e9), window.dispatchEvent(new CustomEvent("eip6963:requestProvider")), () => window.removeEventListener("eip6963:announceProvider", e9);
}
function pe2() {
  const r2 = /* @__PURE__ */ new Set();
  let e9 = [];
  const t3 = () => Nt2((o3) => {
    e9.some(({ info: s2 }) => s2.uuid === o3.info.uuid) || (e9 = [...e9, o3], r2.forEach((s2) => s2(e9, { added: [o3] })));
  });
  let n6 = t3();
  return {
    _listeners() {
      return r2;
    },
    clear() {
      r2.forEach((o3) => o3([], { removed: [...e9] })), e9 = [];
    },
    destroy() {
      this.clear(), r2.clear(), n6 == null ? void 0 : n6();
    },
    findProvider({ rdns: o3 }) {
      return e9.find((s2) => s2.info.rdns === o3);
    },
    getProviders() {
      return e9;
    },
    reset() {
      this.clear(), n6 == null ? void 0 : n6(), n6 = t3();
    },
    subscribe(o3, { emitImmediately: s2 } = {}) {
      return r2.add(o3), s2 && o3(e9, { added: e9 }), () => r2.delete(o3);
    }
  };
}
var Dt2 = class {
  constructor() {
    __publicField(this, "type", "metamask");
    __publicField(this, "platform", "ethereum");
    __publicField(this, "MMSDK");
    __publicField(this, "store", pe2());
    __publicField(this, "account");
    __publicField(this, "connectedAccounts", []);
    var _a2;
    this.MMSDK = new af({
      dappMetadata: {
        name: "Cartridge Controller",
        url: window.location.href
      }
    }), this.isAvailable() && ((_a2 = this.MMSDK.sdkInitPromise) == null ? void 0 : _a2.then(() => {
      var _a3, _b;
      (_a3 = this.MMSDK.getProvider()) == null ? void 0 : _a3.request({
        method: "eth_accounts"
      }).then((e9) => {
        e9 && e9.length > 0 && (this.account = m3(e9[0]), this.connectedAccounts = e9.map(
          (t3) => m3(t3)
        ));
      }), (_b = this.MMSDK.getProvider()) == null ? void 0 : _b.on("accountsChanged", (e9) => {
        Array.isArray(e9) && (e9.length > 0 && (this.account = m3(e9 == null ? void 0 : e9[0])), this.connectedAccounts = e9.map(
          (t3) => m3(t3)
        ));
      });
    }));
  }
  isAvailable() {
    return typeof window < "u" && this.store.getProviders().some((e9) => e9.info.rdns === "io.metamask");
  }
  getInfo() {
    var _a2, _b;
    const e9 = this.isAvailable();
    return {
      type: this.type,
      available: e9,
      version: e9 ? ((_a2 = window.ethereum) == null ? void 0 : _a2.version) || "Unknown" : void 0,
      chainId: e9 ? (_b = window.ethereum) == null ? void 0 : _b.chainId : void 0,
      name: "MetaMask",
      platform: this.platform,
      connectedAccounts: this.connectedAccounts
    };
  }
  async connect(e9) {
    if (e9 && this.connectedAccounts.includes(m3(e9)) && (this.account = m3(e9)), this.account)
      return { success: true, wallet: this.type, account: this.account };
    try {
      if (!this.isAvailable())
        throw new Error("MetaMask is not available");
      const t3 = await this.MMSDK.connect();
      if (t3 && t3.length > 0)
        return this.account = m3(t3[0]), this.connectedAccounts = t3.map(
          (n6) => m3(n6)
        ), { success: true, wallet: this.type, account: this.account };
      throw new Error("No accounts found");
    } catch (t3) {
      return console.error("Error connecting to MetaMask:", t3), {
        success: false,
        wallet: this.type,
        error: t3.message || "Unknown error"
      };
    }
  }
  getConnectedAccounts() {
    return this.connectedAccounts;
  }
  async signTransaction(e9) {
    try {
      if (!this.isAvailable() || !this.account)
        throw new Error("MetaMask is not connected");
      const t3 = this.MMSDK.getProvider();
      if (!t3)
        throw new Error("MetaMask is not connected");
      const n6 = await t3.request({
        method: "eth_sendTransaction",
        params: [e9]
      });
      return { success: true, wallet: this.type, result: n6 };
    } catch (t3) {
      return console.error("Error signing transaction with MetaMask:", t3), {
        success: false,
        wallet: this.type,
        error: t3.message || "Unknown error"
      };
    }
  }
  async signMessage(e9) {
    var _a2;
    try {
      if (!this.isAvailable() || !this.account)
        throw new Error("MetaMask is not connected");
      const t3 = await ((_a2 = this.MMSDK.getProvider()) == null ? void 0 : _a2.request({
        method: "personal_sign",
        params: [this.account, e9]
      }));
      return { success: true, wallet: this.type, result: t3 };
    } catch (t3) {
      return console.error("Error signing message with MetaMask:", t3), {
        success: false,
        wallet: this.type,
        error: t3.message || "Unknown error"
      };
    }
  }
  async signTypedData(e9) {
    try {
      if (!this.isAvailable() || !this.account)
        throw new Error("MetaMask is not connected");
      const t3 = this.MMSDK.getProvider();
      if (!t3)
        throw new Error("MetaMask is not connected");
      const n6 = await t3.request({
        method: "eth_signTypedData_v4",
        params: [this.account, JSON.stringify(e9)]
      });
      return { success: true, wallet: this.type, result: n6 };
    } catch (t3) {
      return console.error("Error signing typed data with MetaMask:", t3), {
        success: false,
        wallet: this.type,
        error: t3.message || "Unknown error"
      };
    }
  }
  async sendTransaction(e9) {
    return {
      success: false,
      wallet: this.type,
      error: "Not implemented"
    };
  }
  async switchChain(e9) {
    try {
      if (!this.isAvailable())
        throw new Error("MetaMask is not available");
      const t3 = this.MMSDK.getProvider();
      if (!t3)
        throw new Error("MetaMask is not connected");
      try {
        return await t3.request({
          method: "wallet_switchEthereumChain",
          params: [{ chainId: e9 }]
        }), true;
      } catch (n6) {
        throw n6.code === 4902 && console.warn("Chain not added to MetaMask"), n6;
      }
    } catch (t3) {
      return console.error("Error switching chain for MetaMask:", t3), false;
    }
  }
  async getBalance(e9) {
    try {
      if (!this.isAvailable() || !this.account)
        throw new Error("MetaMask is not connected");
      if (e9)
        return {
          success: false,
          wallet: this.type,
          error: "Not implemented for ERC20"
        };
      {
        const t3 = this.MMSDK.getProvider();
        if (!t3)
          throw new Error("MetaMask is not connected");
        const n6 = await t3.request({
          method: "eth_getBalance",
          params: [this.account, "latest"]
        });
        return { success: true, wallet: this.type, result: n6 };
      }
    } catch (t3) {
      return console.error("Error getting balance from MetaMask:", t3), {
        success: false,
        wallet: this.type,
        error: t3.message || "Unknown error"
      };
    }
  }
};
var Mt2 = class {
  constructor() {
    __publicField(this, "type", "phantom");
    __publicField(this, "platform", "solana");
    __publicField(this, "account");
    __publicField(this, "connectedAccounts", []);
  }
  getProvider() {
    if (typeof window > "u")
      throw new Error("Not ready");
    const e9 = window.solana;
    if (!(e9 == null ? void 0 : e9.isPhantom))
      throw new Error("Phantom is not available");
    return e9;
  }
  isAvailable() {
    var _a2;
    return typeof window < "u" && !!((_a2 = window.solana) == null ? void 0 : _a2.isPhantom);
  }
  getInfo() {
    const e9 = this.isAvailable();
    return {
      type: this.type,
      available: e9,
      version: "Unknown",
      name: "Phantom",
      platform: this.platform
    };
  }
  async connect() {
    if (this.account)
      return { success: true, wallet: this.type, account: this.account };
    try {
      if (!this.isAvailable())
        throw new Error("Phantom is not available");
      const e9 = await this.getProvider().connect();
      if (e9.publicKey)
        return this.account = e9.publicKey.toString(), { success: true, wallet: this.type, account: this.account };
      throw new Error("No accounts found");
    } catch (e9) {
      return console.error("Error connecting to Phantom:", e9), {
        success: false,
        wallet: this.type,
        error: e9.message || "Unknown error"
      };
    }
  }
  getConnectedAccounts() {
    return this.connectedAccounts;
  }
  async signMessage(e9) {
    try {
      if (!this.isAvailable() || !this.account)
        throw new Error("Phantom is not connected");
      const t3 = new TextEncoder().encode(e9), n6 = await this.getProvider().signMessage(
        t3,
        "utf8"
      );
      return { success: true, wallet: this.type, result: n6 };
    } catch (t3) {
      return console.error("Error signing message with Phantom:", t3), {
        success: false,
        wallet: this.type,
        error: t3.message || "Unknown error"
      };
    }
  }
  async sendTransaction(e9) {
    if (!this.isAvailable() || !this.account)
      throw new Error("Phantom is not connected");
    try {
      const t3 = Transaction.from(e9), o3 = await this.getProvider().signAndSendTransaction(t3);
      return {
        success: true,
        wallet: this.type,
        result: o3
      };
    } catch (t3) {
      return console.error("Error sending transaction with Phantom:", t3), {
        success: false,
        wallet: this.type,
        error: t3.message || "Unknown error"
      };
    }
  }
  async switchChain(e9) {
    return console.warn("Chain switching not supported for Phantom"), false;
  }
  async getBalance(e9) {
    try {
      if (!this.isAvailable() || !this.account)
        throw new Error("Phantom is not connected");
      return {
        success: true,
        wallet: this.type,
        result: "Implement based on Phantom API"
      };
    } catch (t3) {
      return console.error("Error getting balance from Phantom:", t3), {
        success: false,
        wallet: this.type,
        error: t3.message || "Unknown error"
      };
    }
  }
};
var Bt2 = "io.rabby";
var Ut2 = class {
  constructor() {
    __publicField(this, "type", "rabby");
    __publicField(this, "platform", "ethereum");
    __publicField(this, "account");
    __publicField(this, "store", pe2());
    __publicField(this, "provider");
    __publicField(this, "connectedAccounts", []);
    var _a2, _b, _c2;
    this.provider = this.store.getProviders().find((e9) => e9.info.rdns === Bt2), (_a2 = this.provider) == null ? void 0 : _a2.provider.request({
      method: "eth_accounts"
    }).then((e9) => {
      this.connectedAccounts = e9;
    }), (_c2 = (_b = this.provider) == null ? void 0 : _b.provider) == null ? void 0 : _c2.on("accountsChanged", (e9) => {
      e9 && (this.connectedAccounts = e9.map((t3) => m3(t3)), this.account = m3(e9 == null ? void 0 : e9[0]));
    });
  }
  isAvailable() {
    return typeof window < "u" && !!this.provider;
  }
  getInfo() {
    var _a2, _b;
    const e9 = this.isAvailable();
    return {
      type: this.type,
      available: e9,
      version: e9 ? ((_a2 = window.ethereum) == null ? void 0 : _a2.version) || "Unknown" : void 0,
      chainId: e9 ? (_b = window.ethereum) == null ? void 0 : _b.chainId : void 0,
      name: "Rabby",
      platform: this.platform,
      connectedAccounts: this.connectedAccounts
    };
  }
  async connect(e9) {
    var _a2;
    if (e9 && this.connectedAccounts.includes(m3(e9)) && (this.account = m3(e9)), this.account)
      return { success: true, wallet: this.type, account: this.account };
    try {
      if (!this.isAvailable())
        throw new Error("Rabby is not available");
      const t3 = await ((_a2 = this.provider) == null ? void 0 : _a2.provider.request({
        method: "eth_requestAccounts"
      }));
      if (t3 && t3.length > 0)
        return this.account = t3[0], this.connectedAccounts = t3, { success: true, wallet: this.type, account: this.account };
      throw new Error("No accounts found");
    } catch (t3) {
      return console.error("Error connecting to Rabby:", t3), {
        success: false,
        wallet: this.type,
        error: t3.message || "Unknown error"
      };
    }
  }
  getConnectedAccounts() {
    return this.connectedAccounts;
  }
  async signTransaction(e9) {
    var _a2;
    try {
      if (!this.isAvailable() || !this.account)
        throw new Error("Rabby is not connected");
      const t3 = (_a2 = this.provider) == null ? void 0 : _a2.provider;
      if (!t3)
        throw new Error("Rabby is not connected");
      const n6 = await t3.request({
        method: "eth_sendTransaction",
        params: [e9]
      });
      return { success: true, wallet: this.type, result: n6 };
    } catch (t3) {
      return console.error("Error signing transaction with Rabby:", t3), {
        success: false,
        wallet: this.type,
        error: t3.message || "Unknown error"
      };
    }
  }
  async signMessage(e9) {
    var _a2;
    try {
      if (!this.isAvailable() || !this.account)
        throw new Error("Rabby is not connected");
      const t3 = await ((_a2 = this.provider) == null ? void 0 : _a2.provider.request({
        method: "personal_sign",
        params: [this.account, e9]
      }));
      return { success: true, wallet: this.type, result: t3 };
    } catch (t3) {
      return console.error("Error signing message with Rabby:", t3), {
        success: false,
        wallet: this.type,
        error: t3.message || "Unknown error"
      };
    }
  }
  async signTypedData(e9) {
    var _a2;
    try {
      if (!this.isAvailable() || !this.account)
        throw new Error("Rabby is not connected");
      const t3 = (_a2 = this.provider) == null ? void 0 : _a2.provider;
      if (!t3)
        throw new Error("Rabby is not connected");
      const n6 = await t3.request({
        method: "eth_signTypedData_v4",
        params: [this.account, JSON.stringify(e9)]
      });
      return { success: true, wallet: this.type, result: n6 };
    } catch (t3) {
      return console.error("Error signing typed data with Rabby:", t3), {
        success: false,
        wallet: this.type,
        error: t3.message || "Unknown error"
      };
    }
  }
  async sendTransaction(e9) {
    return {
      success: false,
      wallet: this.type,
      error: "Not implemented"
    };
  }
  async switchChain(e9) {
    var _a2;
    try {
      if (!this.isAvailable())
        throw new Error("Rabby is not available");
      const t3 = (_a2 = this.provider) == null ? void 0 : _a2.provider;
      if (!t3)
        throw new Error("Rabby is not connected");
      try {
        return await t3.request({
          method: "wallet_switchEthereumChain",
          params: [{ chainId: e9 }]
        }), true;
      } catch (n6) {
        throw n6.code === 4902 && console.warn("Chain not added to Rabby"), n6;
      }
    } catch (t3) {
      return console.error("Error switching chain for Rabby:", t3), false;
    }
  }
  async getBalance(e9) {
    var _a2;
    try {
      if (!this.isAvailable() || !this.account)
        throw new Error("Rabby is not connected");
      if (e9)
        return {
          success: false,
          wallet: this.type,
          error: "Not implemented for ERC20"
        };
      {
        const t3 = (_a2 = this.provider) == null ? void 0 : _a2.provider;
        if (!t3)
          throw new Error("Rabby is not connected");
        const n6 = await t3.request({
          method: "eth_getBalance",
          params: [this.account, "latest"]
        });
        return { success: true, wallet: this.type, result: n6 };
      }
    } catch (t3) {
      return console.error("Error getting balance from Rabby:", t3), {
        success: false,
        wallet: this.type,
        error: t3.message || "Unknown error"
      };
    }
  }
};
var Qt2 = class {
  constructor() {
    __publicField(this, "walletAdapters");
    if (this.walletAdapters = /* @__PURE__ */ new Map(), typeof window > "u")
      return;
    const e9 = new Dt2();
    e9.isAvailable() && this.walletAdapters.set("metamask", e9);
    const t3 = new Mt2();
    t3.isAvailable() && this.walletAdapters.set("phantom", t3);
    const n6 = new St2();
    n6.isAvailable() && this.walletAdapters.set("argent", n6);
    const o3 = new Ut2();
    o3.isAvailable() && this.walletAdapters.set("rabby", o3), window.wallet_bridge = this;
  }
  getIFrameMethods() {
    return {
      externalDetectWallets: (e9) => () => this.detectWallets(),
      externalConnectWallet: (e9) => (t3, n6) => this.connectWallet(t3, n6),
      externalSignMessage: (e9) => (t3, n6) => this.signMessage(t3, n6),
      externalSignTypedData: (e9) => (t3, n6) => this.signTypedData(t3, n6),
      externalSendTransaction: (e9) => (t3, n6) => this.sendTransaction(t3, n6),
      externalGetBalance: (e9) => (t3, n6) => this.getBalance(t3, n6)
    };
  }
  async detectWallets() {
    return Array.from(this.walletAdapters.values()).map(
      (t3) => t3.getInfo()
    );
  }
  getWalletAdapterByType(e9) {
    const t3 = this.walletAdapters.get(e9);
    if (!t3)
      throw new Error(`Unsupported wallet type: ${e9}`);
    return t3;
  }
  handleError(e9, t3, n6, o3) {
    const s2 = t3 instanceof Error ? t3.message : "Unknown error";
    let a = "unknown";
    if (typeof e9 == "string") {
      const i4 = this.getConnectedWalletAdapter(e9);
      a = o3 ?? (i4 == null ? void 0 : i4.type) ?? e9;
    } else
      a = e9;
    return console.error(`Error ${n6} with ${e9} wallet:`, t3), {
      success: false,
      wallet: a,
      error: s2
    };
  }
  async connectWallet(e9, t3) {
    try {
      const o3 = await this.getWalletAdapterByType(e9).connect(t3);
      if (o3.success && o3.account)
        console.log(
          `Wallet ${e9} connected with address ${o3.account}`
        );
      else if (o3.success && !o3.account)
        return console.error(
          `Wallet ${e9} connected successfully but did not provide an address.`
        ), {
          ...o3,
          success: false,
          error: "Wallet connected but address not found."
        };
      return o3;
    } catch (n6) {
      return this.handleError(e9, n6, "connecting to");
    }
  }
  getConnectedWalletAdapter(e9) {
    let t3;
    if (typeof e9 == "string") {
      const n6 = m3(e9);
      t3 = this.walletAdapters.values().find((o3) => o3.getConnectedAccounts().includes(n6) || o3.type === n6);
    } else
      t3 = this.walletAdapters.get(e9);
    if (!t3 && typeof e9 == "string" && (t3 = this.walletAdapters.values().find(
      (n6) => n6.getConnectedAccounts().includes(m3(e9))
    )), !t3)
      throw new Error(
        `Wallet with identifier ${e9} is not connected or supported`
      );
    return t3;
  }
  async signMessage(e9, t3) {
    let n6;
    try {
      if (n6 = this.getConnectedWalletAdapter(e9), !n6.signMessage)
        throw new Error(
          `Wallet type ${n6.type} (identifier: ${e9}) does not support signing messages`
        );
      return await n6.signMessage(t3);
    } catch (o3) {
      return this.handleError(
        e9,
        o3,
        "signing message with",
        n6 == null ? void 0 : n6.type
      );
    }
  }
  async signTypedData(e9, t3) {
    let n6;
    try {
      if (n6 = this.getConnectedWalletAdapter(e9), !n6.signTypedData)
        throw new Error(
          `Wallet type ${n6.type} (identifier: ${e9}) does not support signing typed data`
        );
      return await n6.signTypedData(t3);
    } catch (o3) {
      return this.handleError(
        e9,
        o3,
        "signing typed data with",
        n6 == null ? void 0 : n6.type
      );
    }
  }
  async sendTransaction(e9, t3) {
    let n6;
    try {
      return n6 = this.getConnectedWalletAdapter(e9), await n6.sendTransaction(t3);
    } catch (o3) {
      return this.handleError(
        e9,
        o3,
        "sending transaction with",
        n6 == null ? void 0 : n6.type
      );
    }
  }
  async getBalance(e9, t3) {
    let n6;
    try {
      return n6 = this.getConnectedWalletAdapter(e9), await n6.getBalance(t3);
    } catch (o3) {
      return this.handleError(
        e9,
        o3,
        "getting balance from",
        n6 == null ? void 0 : n6.type
      );
    }
  }
};
var Tt2 = class extends se2 {
  constructor({ url: e9, policies: t3, ...n6 }) {
    const o3 = new URL(e9 ?? f), s2 = new Qt2();
    t3 && o3.searchParams.set(
      "policies",
      encodeURIComponent(JSON.stringify(t3))
    );
    super({
      ...n6,
      id: "controller-keychain",
      url: o3,
      methods: s2.getIFrameMethods()
    });
    __publicField(this, "walletBridge");
    this.walletBridge = s2, typeof window < "u" && (window.external_wallets = this.walletBridge);
  }
  getWalletBridge() {
    return this.walletBridge;
  }
};
var $t2 = class extends se2 {
  constructor({
    profileUrl: e9,
    rpcUrl: t3,
    version: n6,
    username: o3,
    slot: s2,
    namespace: a,
    tokens: i4,
    ...c3
  }) {
    const d3 = (e9 || P).replace(/\/$/, "");
    let l5 = new URL(
      s2 ? `${d3}/account/${o3}/slot/${s2}` : `${d3}/account/${o3}`
    );
    s2 && l5.searchParams.set("ps", encodeURIComponent(s2)), a && l5.searchParams.set("ns", encodeURIComponent(a)), n6 && l5.searchParams.set("v", encodeURIComponent(n6)), l5.searchParams.set("rpcUrl", encodeURIComponent(t3)), (i4 == null ? void 0 : i4.erc20) && l5.searchParams.set(
      "erc20",
      encodeURIComponent(i4.erc20.toString())
    ), super({
      ...c3,
      id: "controller-profile",
      url: l5
    });
  }
};
var jt2 = class extends Z {
  constructor(e9) {
    var _a2;
    super();
    __publicField(this, "keychain");
    __publicField(this, "profile");
    __publicField(this, "options");
    __publicField(this, "iframes");
    __publicField(this, "selectedChain");
    __publicField(this, "chains");
    const n6 = [...[
      { rpcUrl: "https://api.cartridge.gg/x/starknet/sepolia" },
      { rpcUrl: "https://api.cartridge.gg/x/starknet/mainnet" }
    ], ...e9.chains || []], o3 = e9.defaultChainId || constants_exports.StarknetChainId.SN_MAIN;
    this.selectedChain = o3, this.chains = /* @__PURE__ */ new Map(), this.iframes = {
      keychain: new Tt2({
        ...e9,
        onClose: (_a2 = this.keychain) == null ? void 0 : _a2.reset,
        onConnect: (s2) => {
          this.keychain = s2;
        }
      })
    }, this.options = { ...e9, chains: n6, defaultChainId: o3 }, this.initializeChains(n6), typeof window < "u" && (window.starknet_controller = this);
  }
  isReady() {
    return !!this.keychain;
  }
  async logout() {
    if (!this.keychain) {
      console.error(new j().message);
      return;
    }
    try {
      await this.disconnect(), document.querySelectorAll('iframe[id^="controller-"]').forEach((t3) => {
        const n6 = t3.parentElement;
        n6 && (n6.style.visibility = "hidden", n6.style.opacity = "0");
      }), document.body && (document.body.style.overflow = "auto"), window.location.reload();
    } catch (e9) {
      throw console.error("Logout failed:", e9), e9;
    }
  }
  async probe() {
    try {
      if (await this.waitForKeychain(), !this.keychain) {
        console.error(new j().message);
        return;
      }
      const e9 = await this.keychain.probe(this.rpcUrl());
      let t3 = (e9 == null ? void 0 : e9.rpcUrl) || this.rpcUrl();
      this.account = new H2(
        this,
        t3,
        e9.address,
        this.keychain,
        this.options,
        this.iframes.keychain
      );
    } catch (e9) {
      console.error(e9);
      return;
    }
    if (!this.iframes.profile) {
      const e9 = await this.keychain.username();
      this.iframes.profile = new $t2({
        ...this.options,
        onConnect: (t3) => {
          this.profile = t3;
        },
        methods: {
          openSettings: () => this.openSettings.bind(this),
          openPurchaseCredits: () => this.openPurchaseCredits.bind(this),
          openExecute: () => this.openExecute.bind(this),
          logout: () => this.logout.bind(this)
        },
        rpcUrl: this.rpcUrl(),
        username: e9,
        version: this.version
      });
    }
    return this.account;
  }
  async connect() {
    if (this.account)
      return this.account;
    if (!this.keychain || !this.iframes.keychain) {
      console.error(new j().message);
      return;
    }
    typeof document < "u" && document.hasStorageAccess && (await document.hasStorageAccess() || await document.requestStorageAccess()), this.iframes.keychain.open();
    try {
      let e9 = await this.keychain.connect(
        // Policy precedence logic:
        // 1. If shouldOverridePresetPolicies is true and policies are provided, use policies
        // 2. Otherwise, if preset is defined, use empty object (let preset take precedence)
        // 3. Otherwise, use provided policies or empty object
        this.options.shouldOverridePresetPolicies && this.options.policies ? this.options.policies : this.options.preset ? {} : this.options.policies || {},
        this.rpcUrl(),
        this.options.signupOptions,
        T
      );
      if (e9.code !== w.SUCCESS)
        throw new Error(e9.message);
      return e9 = e9, this.account = new H2(
        this,
        this.rpcUrl(),
        e9.address,
        this.keychain,
        this.options,
        this.iframes.keychain
      ), this.account;
    } catch (e9) {
      console.log(e9);
    } finally {
      this.iframes.keychain.close();
    }
  }
  async switchStarknetChain(e9) {
    var _a2;
    if (!this.keychain || !this.iframes.keychain)
      return console.error(new j().message), false;
    try {
      if (this.selectedChain = e9, (await this.keychain.probe(this.rpcUrl())).rpcUrl === this.rpcUrl())
        return true;
      await this.keychain.switchChain(this.rpcUrl()), await ((_a2 = this.profile) == null ? void 0 : _a2.switchChain(this.rpcUrl()));
    } catch (t3) {
      return console.error(t3), false;
    }
    return this.emitNetworkChanged(e9), true;
  }
  addStarknetChain(e9) {
    return Promise.resolve(true);
  }
  async disconnect() {
    if (!this.keychain) {
      console.error(new j().message);
      return;
    }
    return typeof document < "u" && document.hasStorageAccess && (await document.hasStorageAccess() || await document.requestStorageAccess()), this.account = void 0, this.keychain.disconnect();
  }
  async openProfile(e9 = "inventory") {
    var _a2, _b;
    if (!this.profile || !((_a2 = this.iframes.profile) == null ? void 0 : _a2.url)) {
      console.error("Profile is not ready");
      return;
    }
    if (!this.account) {
      console.error("Account is not ready");
      return;
    }
    this.profile.navigate(`${(_b = this.iframes.profile.url) == null ? void 0 : _b.pathname}/${e9}`), this.iframes.profile.open();
  }
  async openProfileTo(e9) {
    var _a2, _b;
    if (!this.profile || !((_a2 = this.iframes.profile) == null ? void 0 : _a2.url)) {
      console.error("Profile is not ready");
      return;
    }
    if (!this.account) {
      console.error("Account is not ready");
      return;
    }
    this.profile.navigate(`${(_b = this.iframes.profile.url) == null ? void 0 : _b.pathname}/${e9}`), this.iframes.profile.open();
  }
  async openProfileAt(e9) {
    var _a2;
    if (!this.profile || !((_a2 = this.iframes.profile) == null ? void 0 : _a2.url)) {
      console.error("Profile is not ready");
      return;
    }
    if (!this.account) {
      console.error("Account is not ready");
      return;
    }
    this.profile.navigate(e9), this.iframes.profile.open();
  }
  async openSettings() {
    var _a2, _b, _c2, _d2, _e2;
    if (!this.keychain || !this.iframes.keychain)
      return console.error(new j().message), null;
    ((_a2 = this.iframes.profile) == null ? void 0 : _a2.sendBackward) ? (_b = this.iframes.profile) == null ? void 0 : _b.sendBackward() : (_c2 = this.iframes.profile) == null ? void 0 : _c2.close(), this.iframes.keychain.open();
    const e9 = await this.keychain.openSettings();
    return this.iframes.keychain.close(), (_e2 = (_d2 = this.iframes.profile) == null ? void 0 : _d2.sendForward) == null ? void 0 : _e2.call(_d2), !(e9 && e9.code === w.NOT_CONNECTED);
  }
  revoke(e9, t3) {
    return this.keychain ? this.keychain.revoke(e9) : (console.error(new j().message), null);
  }
  rpcUrl() {
    const e9 = this.chains.get(this.selectedChain);
    if (!e9) {
      const t3 = Array.from(this.chains.keys()).map(
        (n6) => shortString_exports.decodeShortString(n6)
      );
      throw new Error(
        `Chain not found: ${shortString_exports.decodeShortString(this.selectedChain)}. Available chains: ${t3.join(", ")}`
      );
    }
    return e9.rpcUrl;
  }
  username() {
    if (!this.keychain) {
      console.error(new j().message);
      return;
    }
    return this.keychain.username();
  }
  openPurchaseCredits() {
    if (!this.keychain || !this.iframes.keychain) {
      console.error(new j().message);
      return;
    }
    if (!this.iframes.profile) {
      console.error("Profile is not ready");
      return;
    }
    this.iframes.profile.close(), this.iframes.keychain.open(), this.keychain.openPurchaseCredits();
  }
  openStarterPack(e9) {
    if (!this.keychain || !this.iframes.keychain) {
      console.error(new j().message);
      return;
    }
    if (!this.iframes.profile) {
      console.error("Profile is not ready");
      return;
    }
    this.iframes.profile.close(), this.iframes.keychain.open(), this.keychain.openStarterPack(e9);
  }
  async openExecute(e9, t3) {
    var _a2, _b, _c2, _d2;
    if (!this.keychain || !this.iframes.keychain) {
      console.error(new j().message);
      return;
    }
    if (!this.iframes.profile) {
      console.error("Profile is not ready");
      return;
    }
    let n6 = this.selectedChain;
    t3 && this.switchStarknetChain(t3), (_a2 = this.iframes.profile) == null ? void 0 : _a2.sendBackward(), this.iframes.keychain.open(), (_b = this.iframes.profile) == null ? void 0 : _b.close();
    const o3 = await this.keychain.execute(e9, void 0, void 0, true);
    return (_c2 = this.iframes.profile) == null ? void 0 : _c2.open(), this.iframes.keychain.close(), (_d2 = this.iframes.profile) == null ? void 0 : _d2.sendForward(), t3 && this.switchStarknetChain(n6), {
      status: !(o3 && (o3.code === w.NOT_CONNECTED || o3.code === w.CANCELED)),
      transactionHash: o3 == null ? void 0 : o3.transaction_hash
    };
  }
  async delegateAccount() {
    return this.keychain ? await this.keychain.delegateAccount() : (console.error(new j().message), null);
  }
  initializeChains(e9) {
    for (const t3 of e9)
      try {
        const n6 = new URL(t3.rpcUrl), o3 = k(n6), s2 = o3 === constants_exports.StarknetChainId.SN_MAIN, a = o3 === constants_exports.StarknetChainId.SN_SEPOLIA, i4 = n6.hostname === "api.cartridge.gg", c3 = n6.hostname === "localhost" || n6.hostname === "127.0.0.1";
        if ((s2 || a) && !(i4 || c3))
          throw new Error(
            `Only Cartridge RPC providers are allowed for ${s2 ? "mainnet" : "sepolia"}. Please use: https://api.cartridge.gg/x/starknet/${s2 ? "mainnet" : "sepolia"}`
          );
        this.chains.set(o3, t3);
      } catch (n6) {
        throw console.error(`Failed to parse chainId for ${t3.rpcUrl}:`, n6), n6;
      }
    this.chains.has(this.selectedChain) || console.warn(
      `Selected chain ${this.selectedChain} not found in configured chains. Available chains: ${Array.from(this.chains.keys()).join(", ")}`
    );
  }
  waitForKeychain({
    timeout: e9 = 5e4,
    interval: t3 = 100
  } = {}) {
    return new Promise((n6, o3) => {
      const s2 = Date.now(), a = setInterval(() => {
        if (Date.now() - s2 > e9) {
          clearInterval(a), o3(new Error("Timeout waiting for keychain"));
          return;
        }
        this.keychain && (clearInterval(a), n6());
      }, t3);
    });
  }
};
var R2 = /* @__PURE__ */ new Map();
async function me2(r2) {
  var _a2, _b;
  if (!((_a2 = r2.addresses) == null ? void 0 : _a2.length) && !((_b = r2.usernames) == null ? void 0 : _b.length))
    return { results: [] };
  const e9 = await fetch(`${b}/lookup`, {
    method: "POST",
    headers: {
      "Content-Type": "application/json"
    },
    body: JSON.stringify(r2)
  });
  if (!e9.ok)
    throw new Error(`HTTP error! status: ${e9.status}`);
  return e9.json();
}
async function qt2(r2) {
  const e9 = r2.filter((t3) => !R2.has(t3));
  return e9.length > 0 && (await me2({ usernames: e9 })).results.forEach((n6) => {
    R2.set(n6.username, n6.addresses[0]);
  }), new Map(
    r2.map((t3) => [t3, R2.get(t3)]).filter((t3) => t3[1] !== void 0)
  );
}
async function Xt2(r2) {
  r2 = r2.map(num_exports.toHex);
  const e9 = r2.filter((t3) => !R2.has(t3));
  return e9.length > 0 && (await me2({
    addresses: e9
  })).results.forEach((n6) => {
    R2.set(n6.addresses[0], n6.username);
  }), new Map(
    r2.map((t3) => [t3, R2.get(t3)]).filter((t3) => t3[1] !== void 0)
  );
}
var zt2 = [
  {
    name: "Wrapped BTC",
    symbol: "WBTC",
    decimals: 8,
    l2_token_address: "0x03fe2b97c1fd336e750087d68b9b867997fd64a2661ff3ca5a7c771641e8e7ac",
    sort_order: 0,
    total_supply: null,
    logo_url: "https://imagedelivery.net/0xPAQaDtnQhBs8IzYRIlNg/7dcb2db2-a7a7-44af-660b-8262e057a100/logo"
  },
  {
    name: "USD Coin",
    symbol: "USDC",
    decimals: 6,
    l2_token_address: "0x053c91253bc9682c04929ca02ed00b3e423f6710d2ee7e0d5ebb06f3ecf368a8",
    sort_order: 5,
    total_supply: null,
    logo_url: "https://imagedelivery.net/0xPAQaDtnQhBs8IzYRIlNg/e5aaa970-a998-47e8-bd43-4a3b56b87200/logo"
  },
  {
    name: "LUSD Stablecoin",
    symbol: "LUSD",
    decimals: 18,
    l2_token_address: "0x070a76fd48ca0ef910631754d77dd822147fe98a569b826ec85e3c33fde586ac",
    sort_order: 3,
    total_supply: null,
    hidden: true,
    logo_url: "https://imagedelivery.net/0xPAQaDtnQhBs8IzYRIlNg/dc0ae733-5498-4afa-f475-48dba677aa00/logo"
  },
  {
    name: "Tether USD",
    symbol: "USDT",
    decimals: 6,
    l2_token_address: "0x068f5c6a61780768455de69077e07e89787839bf8166decfbf92b645209c0fb8",
    sort_order: 4,
    total_supply: null,
    logo_url: "https://imagedelivery.net/0xPAQaDtnQhBs8IzYRIlNg/c8a721d1-07c3-46e4-ab4e-523977c30b00/logo"
  },
  {
    name: "Ether",
    symbol: "ETH",
    decimals: 18,
    l2_token_address: "0x049d36570d4e46f48e99674bd3fcc84644ddd6b96f7c741b1562b82f9e004dc7",
    sort_order: 3,
    total_supply: null,
    logo_url: "https://imagedelivery.net/0xPAQaDtnQhBs8IzYRIlNg/e07829b7-0382-4e03-7ecd-a478c5aa9f00/logo"
  },
  {
    name: "Dai Stablecoin",
    symbol: "DAIv0",
    decimals: 18,
    l2_token_address: "0x00da114221cb83fa859dbdb4c44beeaa0bb37c7537ad5ae66fe5e0efd20e6eb3",
    sort_order: 4,
    total_supply: null,
    hidden: true,
    logo_url: "https://imagedelivery.net/0xPAQaDtnQhBs8IzYRIlNg/919e761b-56f7-4f53-32aa-5e066f7f6200/logo"
  },
  {
    name: "Dai Stablecoin",
    symbol: "DAI",
    decimals: 18,
    l2_token_address: "0x05574eb6b8789a91466f902c380d978e472db68170ff82a5b650b95a58ddf4ad",
    sort_order: 4,
    total_supply: null,
    logo_url: "https://imagedelivery.net/0xPAQaDtnQhBs8IzYRIlNg/919e761b-56f7-4f53-32aa-5e066f7f6200/logo"
  },
  {
    name: "Legacy Starknet Wrapped Staked Ether",
    symbol: "wstETH-legacy",
    decimals: 18,
    l2_token_address: "0x042b8f0484674ca266ac5d08e4ac6a3fe65bd3129795def2dca5c34ecc5f96d2",
    sort_order: 1,
    total_supply: null,
    logo_url: "https://imagedelivery.net/0xPAQaDtnQhBs8IzYRIlNg/26162dcc-29c2-4f5e-3acd-5e6be1f07a00/logo"
  },
  {
    name: "Wrapped Staked Ether",
    symbol: "wstETH",
    decimals: 18,
    l2_token_address: "0x0057912720381af14b0e5c87aa4718ed5e527eab60b3801ebf702ab09139e38b",
    sort_order: 1,
    total_supply: null,
    logo_url: "https://imagedelivery.net/0xPAQaDtnQhBs8IzYRIlNg/dbbcbdea-1a92-437d-3701-4a5ee129d000/logo"
  },
  {
    name: "Rocket Pool ETH",
    symbol: "rETH",
    decimals: 18,
    l2_token_address: "0x0319111a5037cbec2b3e638cc34a3474e2d2608299f3e62866e9cc683208c610",
    sort_order: 1,
    total_supply: null,
    logo_url: "https://imagedelivery.net/0xPAQaDtnQhBs8IzYRIlNg/c9f2d6fe-fbc6-4384-0990-923dfcb7a200/logo"
  },
  {
    name: "LORDS",
    symbol: "LORDS",
    decimals: 18,
    l2_token_address: "0x0124aeb495b947201f5fac96fd1138e326ad86195b98df6dec9009158a533b49",
    sort_order: 1,
    total_supply: 509e5,
    logo_url: "https://imagedelivery.net/0xPAQaDtnQhBs8IzYRIlNg/a3bfe959-50c4-4f89-0aef-b19207d82a00/logo"
  },
  {
    name: "R Stablecoin",
    symbol: "R",
    decimals: 18,
    l2_token_address: "0x01fa2fb85f624600112040e1f3a848f53a37ed5a7385810063d5fe6887280333",
    sort_order: 3,
    total_supply: null,
    hidden: true,
    logo_url: "https://imagedelivery.net/0xPAQaDtnQhBs8IzYRIlNg/77612e4e-f7ee-4dba-2066-af321843ef00/logo"
  },
  {
    name: "Frax",
    symbol: "FRAX",
    decimals: 18,
    l2_token_address: "0x009c6b4fb13dfaa025c1383ed6190af8ed8cbb09d9588a3bb020feb152442406",
    sort_order: 1,
    total_supply: 649462235,
    hidden: true,
    logo_url: "https://imagedelivery.net/0xPAQaDtnQhBs8IzYRIlNg/eeaf0779-e492-474c-ef19-b27843525600/logo"
  },
  {
    name: "Frax Share",
    symbol: "FXS",
    decimals: 18,
    l2_token_address: "0x0058efd0e73c33a848ffaa88738d128ebf0af98ea78cf3c14dc757bb02d39ffb",
    sort_order: 1,
    total_supply: null,
    hidden: true,
    logo_url: "https://imagedelivery.net/0xPAQaDtnQhBs8IzYRIlNg/98bea621-1e4f-4d63-9689-bdaef0d56500/logo"
  },
  {
    name: "Staked Frax Ether",
    symbol: "sfrxETH",
    decimals: 18,
    l2_token_address: "0x04578fffc279e61b5cb0267a5f8e24b6089d40f93158fbbad2cb23b8622c9233",
    sort_order: 1,
    total_supply: null,
    hidden: true,
    logo_url: "https://imagedelivery.net/0xPAQaDtnQhBs8IzYRIlNg/cd6fe18a-25db-4de9-758a-daf3b364ea00/logo"
  },
  {
    name: "Uniswap",
    symbol: "UNI",
    decimals: 18,
    l2_token_address: "0x049210ffc442172463f3177147c1aeaa36c51d152c1b0630f2364c300d4f48ee",
    sort_order: 1,
    total_supply: 1e9,
    logo_url: "https://imagedelivery.net/0xPAQaDtnQhBs8IzYRIlNg/361b018e-bd53-4019-27c8-7cf8d9031b00/logo"
  },
  {
    name: "Paper",
    symbol: "PAPER",
    decimals: 18,
    l2_token_address: "0x0410466536b5ae074f7fea81e5533b8134a9fa08b3dd077dd9db08f64997d113",
    sort_order: 1,
    total_supply: null,
    hidden: true,
    logo_url: "https://imagedelivery.net/0xPAQaDtnQhBs8IzYRIlNg/811f019a-0461-4cff-6c1e-442102863f00/logo"
  },
  {
    name: "StarkPepe",
    symbol: "xSPEPE",
    decimals: 18,
    l2_token_address: "0x06f15ec4b6ff0b7f7a216c4b2ccdefc96cbf114d6242292ca82971592f62273b",
    sort_order: 1,
    total_supply: null,
    hidden: true,
    disabled: true
  },
  {
    name: "StarkNet Token",
    symbol: "STRK",
    decimals: 18,
    l2_token_address: "0x04718f5a0fc34cc1af16a1cdee98ffb20c31f5cd61d6ab07201858f4287c938d",
    sort_order: 2,
    total_supply: 1e10,
    logo_url: "https://imagedelivery.net/0xPAQaDtnQhBs8IzYRIlNg/1b126320-367c-48ed-cf5a-ba7580e49600/logo"
  },
  {
    name: "zkLend Token",
    symbol: "ZEND",
    decimals: 18,
    l2_token_address: "0x00585c32b625999e6e5e78645ff8df7a9001cf5cf3eb6b80ccdd16cb64bd3a34",
    sort_order: 1,
    total_supply: null,
    logo_url: "https://imagedelivery.net/0xPAQaDtnQhBs8IzYRIlNg/95515b0e-1230-4158-10f1-56888f613c00/logo"
  },
  {
    name: "Ekubo Protocol",
    symbol: "EKUBO",
    decimals: 18,
    l2_token_address: "0x075afe6402ad5a5c20dd25e10ec3b3986acaa647b77e4ae24b0cbc9a54a27a87",
    sort_order: 1,
    total_supply: 1e7,
    logo_url: "https://imagedelivery.net/0xPAQaDtnQhBs8IzYRIlNg/634d9c36-2f0b-4781-93e6-72d701b5af00/logo"
  },
  {
    name: "SOCKS",
    symbol: "SOCKS",
    decimals: 18,
    l2_token_address: "0x023ed2ba4fb5709302c5dfd739fa7613359042f143286c115b6c7f7dc2601015",
    sort_order: 1,
    total_supply: 1e11,
    hidden: true,
    logo_url: "https://imagedelivery.net/0xPAQaDtnQhBs8IzYRIlNg/2db5a2a6-c98e-4b80-35e0-31b489132100/logo"
  },
  {
    name: "Nostra",
    symbol: "NSTR",
    decimals: 18,
    l2_token_address: "0x00c530f2c0aa4c16a0806365b0898499fba372e5df7a7172dc6fe9ba777e8007",
    sort_order: 1,
    total_supply: 1e8,
    logo_url: "https://imagedelivery.net/0xPAQaDtnQhBs8IzYRIlNg/a45c2224-17a7-4269-ea7e-3924e9755800/logo"
  },
  {
    name: "Carmine",
    symbol: "CRM",
    decimals: 18,
    l2_token_address: "0x51c4b1fe3bf6774b87ad0b15ef5d1472759076e42944fff9b9f641ff13e5bbe",
    sort_order: 1,
    total_supply: 1e8,
    logo_url: "https://imagedelivery.net/0xPAQaDtnQhBs8IzYRIlNg/6ab817f1-8075-4a94-6e14-f112f1f89d00/logo"
  },
  {
    name: "Cash",
    symbol: "CASH",
    decimals: 18,
    l2_token_address: "0x498edfaf50ca5855666a700c25dd629d577eb9afccdf3b5977aec79aee55ada",
    sort_order: 3,
    total_supply: null,
    hidden: false,
    logo_url: "https://imagedelivery.net/0xPAQaDtnQhBs8IzYRIlNg/6bd6d156-f509-4b51-5dfc-3ee566143600/logo"
  },
  {
    name: "Nums",
    symbol: "NUMS",
    decimals: 18,
    l2_token_address: "0xe5f10eddc01699dc899a30dbc3c9858148fa4aa0a47c0ffd85f887ffc4653e",
    sort_order: 1,
    total_supply: 1,
    hidden: true,
    logo_url: "https://imagedelivery.net/0xPAQaDtnQhBs8IzYRIlNg/90868d05-cb75-4c42-278c-5a540db2cf00/logo"
  },
  {
    name: "Flip",
    symbol: "FLIP",
    decimals: 18,
    l2_token_address: "0x01bfe97d729138fc7c2d93c77d6d1d8a24708d5060608017d9b384adf38f04c7",
    sort_order: 1,
    total_supply: null,
    hidden: true,
    logo_url: "https://imagedelivery.net/0xPAQaDtnQhBs8IzYRIlNg/275f0fa8-a691-471c-ace6-0eb0315dde00/logo"
  },
  {
    name: "Eternum Stone",
    symbol: "STONE",
    decimals: 18,
    l2_token_address: "0x439a1c010e3e1bb2d43d43411000893c0042bd88f6c701611a0ea914d426da4",
    sort_order: 1,
    total_supply: null,
    hidden: true,
    logo_url: "https://imagedelivery.net/0xPAQaDtnQhBs8IzYRIlNg/932e7f83-a4c2-40f0-3048-35af3b194100/logo"
  },
  {
    name: "Eternum Coal",
    symbol: "COAL",
    decimals: 18,
    l2_token_address: "0xce635e3f241b0ae78c46a929d84a9101910188f9c4024eaa7559556503c31a",
    sort_order: 1,
    total_supply: null,
    hidden: true,
    logo_url: "https://imagedelivery.net/0xPAQaDtnQhBs8IzYRIlNg/cf2ee180-06bf-4443-e3aa-724d7c28e800/logo"
  },
  {
    name: "Eternum Wood",
    symbol: "WOOD",
    decimals: 18,
    l2_token_address: "0x40d8907cec0f7ae9c364dfb12485a1314d84c129bf1898d2f3d4b7fcc7d44f4",
    sort_order: 1,
    total_supply: null,
    hidden: true,
    logo_url: "https://imagedelivery.net/0xPAQaDtnQhBs8IzYRIlNg/1db5f954-c1ef-447e-9f8f-05bd9f3b2b00/logo"
  },
  {
    name: "Eternum Copper",
    symbol: "COPPER",
    decimals: 18,
    l2_token_address: "0x66ed5c928ee027a9419ace1cbea8389885161db5572a7c5c4fef2310e9bf494",
    sort_order: 1,
    total_supply: null,
    hidden: true,
    logo_url: "https://imagedelivery.net/0xPAQaDtnQhBs8IzYRIlNg/6bbcdcc9-6146-404d-9501-92a664cf3100/logo"
  },
  {
    name: "Eternum Ironwood",
    symbol: "IRONWOOD",
    decimals: 18,
    l2_token_address: "0x1720cf6318bff45e62acc588680ae3cd4d5f8465b1d52cb710533c9299b031a",
    sort_order: 1,
    total_supply: null,
    hidden: true,
    logo_url: "https://imagedelivery.net/0xPAQaDtnQhBs8IzYRIlNg/5af7c03b-e4ae-4aee-eba4-a4e2160a1d00/logo"
  },
  {
    name: "Eternum Obsidian",
    symbol: "OBSIDIAN",
    decimals: 18,
    l2_token_address: "0x3b6448d09dcd023507376402686261f5d6739455fa02f804907b066e488da66",
    sort_order: 1,
    total_supply: null,
    hidden: true,
    logo_url: "https://imagedelivery.net/0xPAQaDtnQhBs8IzYRIlNg/8be9bc66-486b-4181-6804-725a1db8ad00/logo"
  },
  {
    name: "Eternum Gold",
    symbol: "GOLD",
    decimals: 18,
    l2_token_address: "0xdff9dca192609c4e86ab3be22c7ec1e968876c992d21986f3c542be97fa2f",
    sort_order: 1,
    total_supply: null,
    hidden: true,
    logo_url: "https://imagedelivery.net/0xPAQaDtnQhBs8IzYRIlNg/fb9e90f7-3c2f-4c64-7e43-c3f694f35e00/logo"
  },
  {
    name: "Eternum Silver",
    symbol: "SILVER",
    decimals: 18,
    l2_token_address: "0x6fe21d2d4a8a05bdb70f09c9250af9870020d5dcc35f410b4a39d6605c3e353",
    sort_order: 1,
    total_supply: null,
    hidden: true,
    logo_url: "https://imagedelivery.net/0xPAQaDtnQhBs8IzYRIlNg/e443afeb-850b-46a0-a7ba-a473306d6b00/logo"
  },
  {
    name: "Eternum Mithral",
    symbol: "MITHRAL",
    decimals: 18,
    l2_token_address: "0x67ba235c569c23877064b2ac6ebd4d79f32d3c00f5fab8e28a3b5700b957f6",
    sort_order: 1,
    total_supply: null,
    hidden: true,
    logo_url: "https://imagedelivery.net/0xPAQaDtnQhBs8IzYRIlNg/33dc517f-8a66-45eb-f2c5-de5388e47500/logo"
  },
  {
    name: "Eternum Alchemical Silver",
    symbol: "ALCHEMICALSILVER",
    decimals: 18,
    l2_token_address: "0x3956a5301e99522038a2e7dcb9c2a89bf087ffa79310ee0a508b5538efd8ddd",
    sort_order: 1,
    total_supply: null,
    hidden: true,
    logo_url: "https://imagedelivery.net/0xPAQaDtnQhBs8IzYRIlNg/3d2e0fd8-4af8-49a0-4bdb-691a4d6ef800/logo"
  },
  {
    name: "Eternum Cold Iron",
    symbol: "COLDIRON",
    decimals: 18,
    l2_token_address: "0x555d713e59d4ff96b7960447e9bc9e79bfdeab5b0eea74e3df81bce61cfbc77",
    sort_order: 1,
    total_supply: null,
    hidden: true,
    logo_url: "https://imagedelivery.net/0xPAQaDtnQhBs8IzYRIlNg/878c0d8a-8e2c-4281-0896-9cbbb2ef9400/logo"
  },
  {
    name: "Eternum Deep Crystal",
    symbol: "DEEPCRYSTAL",
    decimals: 18,
    l2_token_address: "0x1d655ac834d38df7921074fc1588411e202b1af83307cbd996983aff52db3a8",
    sort_order: 1,
    total_supply: null,
    hidden: true,
    logo_url: "https://imagedelivery.net/0xPAQaDtnQhBs8IzYRIlNg/1c2c954f-448c-476b-a4a6-19b52efe3e00/logo"
  },
  {
    name: "Eternum Ruby",
    symbol: "RUBY",
    decimals: 18,
    l2_token_address: "0x3d9b66720959d0e7687b898292c10e62e78626f2dba5e1909961a2ce3f86612",
    sort_order: 1,
    total_supply: null,
    hidden: true,
    logo_url: "https://imagedelivery.net/0xPAQaDtnQhBs8IzYRIlNg/6a45b34d-3bfe-4994-45b0-f2bee8abac00/logo"
  },
  {
    name: "Eternum Diamonds",
    symbol: "DIAMONDS",
    decimals: 18,
    l2_token_address: "0xe03ea8ae385f64754820af5c01c36abf1b8130dd6797d3fd9d430e4114e876",
    sort_order: 1,
    total_supply: null,
    hidden: true,
    logo_url: "https://imagedelivery.net/0xPAQaDtnQhBs8IzYRIlNg/b1fa609d-8799-4754-cdea-ab69514ca700/logo"
  },
  {
    name: "Eternum Hartwood",
    symbol: "HARTWOOD",
    decimals: 18,
    l2_token_address: "0x5620aa7170cd66dbcbc37d03087bfe4633ffef91d3e4d97b501de906004f79b",
    sort_order: 1,
    total_supply: null,
    hidden: true,
    logo_url: "https://imagedelivery.net/0xPAQaDtnQhBs8IzYRIlNg/27e37e85-91bd-4ee1-0552-1e0795077400/logo"
  },
  {
    name: "Eternum Ignium",
    symbol: "IGNIUM",
    decimals: 18,
    l2_token_address: "0x625c1f789b03ebebc7a9322366f38ebad1f693b84b2abd8cb8f5b2748b0cdd5",
    sort_order: 1,
    total_supply: null,
    hidden: true,
    logo_url: "https://imagedelivery.net/0xPAQaDtnQhBs8IzYRIlNg/58591e20-24fb-4353-417a-81d877a5a200/logo"
  },
  {
    name: "Eternum Twilight Quartz",
    symbol: "TWILIGHTQUARTZ",
    decimals: 18,
    l2_token_address: "0x35e24c02409c3cfe8d5646399a62c4d102bb782938d5f5180e92c9c62d3faf7",
    sort_order: 1,
    total_supply: null,
    hidden: true,
    logo_url: "https://imagedelivery.net/0xPAQaDtnQhBs8IzYRIlNg/2f8cb892-e82a-4af3-bd09-316061faec00/logo"
  },
  {
    name: "Eternum True Ice",
    symbol: "TRUEICE",
    decimals: 18,
    l2_token_address: "0x4485f5a6e16562e1c761cd348e63256d00389e3ddf4f5d98afe7ab44c57c481",
    sort_order: 1,
    total_supply: null,
    hidden: true,
    logo_url: "https://imagedelivery.net/0xPAQaDtnQhBs8IzYRIlNg/fe4bfc17-6553-4dc5-58d2-f452b4aa8a00/logo"
  },
  {
    name: "Eternum Adamantine",
    symbol: "ADAMANTINE",
    decimals: 18,
    l2_token_address: "0x367f838f85a2f5e1580d6f011e4476f581083314cff8721ba3dda9706076eed",
    sort_order: 1,
    total_supply: null,
    hidden: true,
    logo_url: "https://imagedelivery.net/0xPAQaDtnQhBs8IzYRIlNg/13bd026b-3612-480e-0119-04cf4c505a00/logo"
  },
  {
    name: "Eternum Sapphire",
    symbol: "SAPPHIRE",
    decimals: 18,
    l2_token_address: "0x2f8dd022568af8f9f718aa37707a9b858529db56910633a160456838b6cbcbc",
    sort_order: 1,
    total_supply: null,
    hidden: true,
    logo_url: "https://imagedelivery.net/0xPAQaDtnQhBs8IzYRIlNg/0ebf555f-e732-4054-f8e5-55b2ed49ba00/logo"
  },
  {
    name: "Eternum Ethereal Silica",
    symbol: "ETHEREALSILICA",
    decimals: 18,
    l2_token_address: "0x68b6e23cbbd58a644700f55e96c83580921e9f521b6e5175396b53ba7910e7d",
    sort_order: 1,
    total_supply: null,
    hidden: true,
    logo_url: "https://imagedelivery.net/0xPAQaDtnQhBs8IzYRIlNg/f02a5b43-bfcf-408c-7d1b-fcfe68b02d00/logo"
  },
  {
    name: "Eternum Dragon Hide",
    symbol: "DRAGONHIDE",
    decimals: 18,
    l2_token_address: "0x3bf856515bece3c93f5061b7941b8645f817a0acab93c758b8c7b4bc0afa3c6",
    sort_order: 1,
    total_supply: null,
    hidden: true,
    logo_url: "https://imagedelivery.net/0xPAQaDtnQhBs8IzYRIlNg/e74955fc-5c8a-4dff-4882-a49a46a5a800/logo"
  },
  {
    name: "Eternum Ancient Fragment",
    symbol: "ANCIENTFRAGMENT",
    decimals: 18,
    l2_token_address: "0x0695b08ecdfdd828c2e6267da62f59e6d7543e690ef56a484df25c8566b332a5",
    sort_order: 1,
    total_supply: null,
    hidden: true,
    logo_url: "https://imagedelivery.net/0xPAQaDtnQhBs8IzYRIlNg/9af855b7-4790-4390-9466-6bed4481ab00/logo"
  },
  {
    name: "Eternum Donkey",
    symbol: "DONKEY",
    decimals: 18,
    l2_token_address: "0x264be95a4a2ace20add68cb321acdccd2f9f8440ee1c7abd85da44ddab01085",
    sort_order: 1,
    total_supply: null,
    hidden: true,
    logo_url: "https://imagedelivery.net/0xPAQaDtnQhBs8IzYRIlNg/20817378-a45e-4521-f464-10f6dd13c500/logo"
  },
  {
    name: "Eternum Knight",
    symbol: "KNIGHT",
    decimals: 18,
    l2_token_address: "0xac965f9e67164723c16735a9da8dbc9eb8e43b1bd0323591e87c056badf606",
    sort_order: 1,
    total_supply: null,
    hidden: true,
    logo_url: "https://imagedelivery.net/0xPAQaDtnQhBs8IzYRIlNg/8787ed1f-af5c-4873-c01a-55f05e999a00/logo"
  },
  {
    name: "Eternum Crossbowman",
    symbol: "CROSSBOWMAN",
    decimals: 18,
    l2_token_address: "0x67e4ac00a241be06ba6afc11fa2715ec7da0c42c05a67ef6ecfcfeda725aaa8",
    sort_order: 1,
    total_supply: null,
    hidden: true,
    logo_url: "https://imagedelivery.net/0xPAQaDtnQhBs8IzYRIlNg/dec7f31b-4b1d-46bb-4fca-c0253cf55a00/logo"
  },
  {
    name: "Eternum Paladin",
    symbol: "PALADIN",
    decimals: 18,
    l2_token_address: "0x3bc86299bee061c7c8d7546ccb62b9daf9bffc653b1508facb722c6593874bc",
    sort_order: 1,
    total_supply: null,
    hidden: true,
    logo_url: "https://imagedelivery.net/0xPAQaDtnQhBs8IzYRIlNg/7d2cd5a5-f38a-49f6-11f8-ba3b59a59e00/logo"
  },
  {
    name: "Eternum Wheat",
    symbol: "WHEAT",
    decimals: 18,
    l2_token_address: "0x57a3f1ee475e072ce3be41785c0e889b7295d7a0dcc22b992c5b9408dbeb280",
    sort_order: 1,
    total_supply: null,
    hidden: true,
    logo_url: "https://imagedelivery.net/0xPAQaDtnQhBs8IzYRIlNg/c338b6a8-77c4-4dd6-34f5-1af0d3fb1e00/logo"
  },
  {
    name: "Eternum Fish",
    symbol: "FISH",
    decimals: 18,
    l2_token_address: "0x27719173cfe10f1aa38d2aaed0a075b6077290f1e817aa3485d2b828394f4d9",
    sort_order: 1,
    total_supply: null,
    hidden: true,
    logo_url: "https://imagedelivery.net/0xPAQaDtnQhBs8IzYRIlNg/6deef27f-df40-4248-4e1b-ed1d79a3f000/logo"
  },
  {
    name: "Fools",
    symbol: "FOOLS",
    decimals: 18,
    l2_token_address: "0x068a7a07e08fc3e723a878223d00f669106780d5ea6665eb15d893476d47bf3b",
    sort_order: 1,
    total_supply: null,
    logo_url: "https://assets.underware.gg/pistols/fools.svg"
  },
  {
    name: "Fame",
    symbol: "FAME",
    decimals: 18,
    l2_token_address: "0x02549653a4ae1ff8d04a20b8820a49cbe97486c536ec0e4c8f68aa33d80067cf",
    sort_order: 1,
    total_supply: null,
    logo_url: "https://assets.underware.gg/pistols/fame.svg"
  }
];
var Ot2 = {
  theme: {
    name: "Cartridge",
    icon: "icon.svg"
  }
};
var U4 = "https://static.cartridge.gg/presets";
async function F2() {
  try {
    const r2 = await fetch(`${U4}/index.json`);
    if (!r2.ok)
      throw new Error(`Failed to load configs index: ${r2.statusText}`);
    return await r2.json();
  } catch (r2) {
    return console.error("Error loading configs index:", r2), { configs: [], baseUrl: U4 };
  }
}
async function Gt2() {
  return (await F2()).configs;
}
async function Vt2(r2) {
  try {
    const n6 = `${(await F2()).baseUrl || U4}/${r2}`, o3 = await fetch(`${n6}/config.json`);
    if (!o3.ok)
      throw new Error(
        `Failed to load config ${r2}: ${o3.statusText}`
      );
    const s2 = await o3.json();
    if (s2 && s2.theme) {
      s2.theme.icon && !s2.theme.icon.startsWith("http") && (s2.theme.icon = `${n6}/${s2.theme.icon}`), s2.theme.cover && (typeof s2.theme.cover == "string" ? s2.theme.cover.startsWith("http") || (s2.theme.cover = `${n6}/${s2.theme.cover}`) : (s2.theme.cover.light && !s2.theme.cover.light.startsWith("http") && (s2.theme.cover.light = `${n6}/${s2.theme.cover.light}`), s2.theme.cover.dark && !s2.theme.cover.dark.startsWith("http") && (s2.theme.cover.dark = `${n6}/${s2.theme.cover.dark}`)));
      const a = (i4) => {
        if (i4) {
          for (const c3 in i4)
            if (i4[c3])
              for (const d3 in i4[c3])
                i4[c3][d3] && !i4[c3][d3].startsWith("http") && (i4[c3][d3] = `${n6}/${i4[c3][d3]}`);
        }
      };
      if (s2.theme.optimizedIcon && a(s2.theme.optimizedIcon), s2.theme.optimizedCover)
        if (typeof s2.theme.optimizedCover == "string")
          s2.theme.optimizedCover.startsWith("http") || (s2.theme.optimizedCover = `${n6}/${s2.theme.optimizedCover}`);
        else if (s2.theme.optimizedCover.light || s2.theme.optimizedCover.dark) {
          const i4 = s2.theme.optimizedCover;
          i4.light && a(i4.light), i4.dark && a(i4.dark);
        } else
          a(s2.theme.optimizedCover);
    }
    return s2;
  } catch (e9) {
    return console.error(`Error loading config ${r2}:`, e9), null;
  }
}
async function Jt2() {
  const r2 = await F2(), e9 = r2.configs, t3 = r2.baseUrl || U4, n6 = {};
  return await Promise.all(
    e9.map(async (o3) => {
      try {
        const s2 = await fetch(`${t3}/${o3}/config.json`);
        if (s2.ok) {
          const a = await s2.json();
          n6[o3] = a;
        }
      } catch (s2) {
        console.error(`Error loading config ${o3}:`, s2);
      }
    })
  ), n6;
}
var Zt2 = zt2;
var er2 = Ot2.theme;

export {
  w,
  l,
  Q2 as Q,
  x,
  U2 as U,
  n2 as n,
  h,
  k,
  j,
  St2 as St,
  Dt2 as Dt,
  Mt2 as Mt,
  Ut2 as Ut,
  Qt2 as Qt,
  jt2 as jt,
  qt2 as qt,
  Xt2 as Xt,
  F2 as F,
  Gt2 as Gt,
  Vt2 as Vt,
  Jt2 as Jt,
  Zt2 as Zt,
  er2 as er
};
/*! Bundled license information:

eventemitter2/lib/eventemitter2.js:
  (*!
   * EventEmitter2
   * https://github.com/hij1nx/EventEmitter2
   *
   * Copyright (c) 2013 hij1nx
   * Licensed under the MIT license.
   *)

ieee754/index.js:
  (*! ieee754. BSD-3-Clause License. Feross Aboukhadijeh <https://feross.org/opensource> *)

buffer/index.js:
  (*!
   * The buffer module from node.js, for the browser.
   *
   * @author   Feross Aboukhadijeh <https://feross.org>
   * @license  MIT
   *)

safe-buffer/index.js:
  (*! safe-buffer. MIT License. Feross Aboukhadijeh <https://feross.org/opensource> *)

@solana/buffer-layout/lib/Layout.js:
  (**
   * Support for translating between Uint8Array instances and JavaScript
   * native types.
   *
   * {@link module:Layout~Layout|Layout} is the basis of a class
   * hierarchy that associates property names with sequences of encoded
   * bytes.
   *
   * Layouts are supported for these scalar (numeric) types:
   * * {@link module:Layout~UInt|Unsigned integers in little-endian
   *   format} with {@link module:Layout.u8|8-bit}, {@link
   *   module:Layout.u16|16-bit}, {@link module:Layout.u24|24-bit},
   *   {@link module:Layout.u32|32-bit}, {@link
   *   module:Layout.u40|40-bit}, and {@link module:Layout.u48|48-bit}
   *   representation ranges;
   * * {@link module:Layout~UIntBE|Unsigned integers in big-endian
   *   format} with {@link module:Layout.u16be|16-bit}, {@link
   *   module:Layout.u24be|24-bit}, {@link module:Layout.u32be|32-bit},
   *   {@link module:Layout.u40be|40-bit}, and {@link
   *   module:Layout.u48be|48-bit} representation ranges;
   * * {@link module:Layout~Int|Signed integers in little-endian
   *   format} with {@link module:Layout.s8|8-bit}, {@link
   *   module:Layout.s16|16-bit}, {@link module:Layout.s24|24-bit},
   *   {@link module:Layout.s32|32-bit}, {@link
   *   module:Layout.s40|40-bit}, and {@link module:Layout.s48|48-bit}
   *   representation ranges;
   * * {@link module:Layout~IntBE|Signed integers in big-endian format}
   *   with {@link module:Layout.s16be|16-bit}, {@link
   *   module:Layout.s24be|24-bit}, {@link module:Layout.s32be|32-bit},
   *   {@link module:Layout.s40be|40-bit}, and {@link
   *   module:Layout.s48be|48-bit} representation ranges;
   * * 64-bit integral values that decode to an exact (if magnitude is
   *   less than 2^53) or nearby integral Number in {@link
   *   module:Layout.nu64|unsigned little-endian}, {@link
   *   module:Layout.nu64be|unsigned big-endian}, {@link
   *   module:Layout.ns64|signed little-endian}, and {@link
   *   module:Layout.ns64be|unsigned big-endian} encodings;
   * * 32-bit floating point values with {@link
   *   module:Layout.f32|little-endian} and {@link
   *   module:Layout.f32be|big-endian} representations;
   * * 64-bit floating point values with {@link
   *   module:Layout.f64|little-endian} and {@link
   *   module:Layout.f64be|big-endian} representations;
   * * {@link module:Layout.const|Constants} that take no space in the
   *   encoded expression.
   *
   * and for these aggregate types:
   * * {@link module:Layout.seq|Sequence}s of instances of a {@link
   *   module:Layout~Layout|Layout}, with JavaScript representation as
   *   an Array and constant or data-dependent {@link
   *   module:Layout~Sequence#count|length};
   * * {@link module:Layout.struct|Structure}s that aggregate a
   *   heterogeneous sequence of {@link module:Layout~Layout|Layout}
   *   instances, with JavaScript representation as an Object;
   * * {@link module:Layout.union|Union}s that support multiple {@link
   *   module:Layout~VariantLayout|variant layouts} over a fixed
   *   (padded) or variable (not padded) span of bytes, using an
   *   unsigned integer at the start of the data or a separate {@link
   *   module:Layout.unionLayoutDiscriminator|layout element} to
   *   determine which layout to use when interpreting the buffer
   *   contents;
   * * {@link module:Layout.bits|BitStructure}s that contain a sequence
   *   of individual {@link
   *   module:Layout~BitStructure#addField|BitField}s packed into an 8,
   *   16, 24, or 32-bit unsigned integer starting at the least- or
   *   most-significant bit;
   * * {@link module:Layout.cstr|C strings} of varying length;
   * * {@link module:Layout.blob|Blobs} of fixed- or variable-{@link
   *   module:Layout~Blob#length|length} raw data.
   *
   * All {@link module:Layout~Layout|Layout} instances are immutable
   * after construction, to prevent internal state from becoming
   * inconsistent.
   *
   * @local Layout
   * @local ExternalLayout
   * @local GreedyCount
   * @local OffsetLayout
   * @local UInt
   * @local UIntBE
   * @local Int
   * @local IntBE
   * @local NearUInt64
   * @local NearUInt64BE
   * @local NearInt64
   * @local NearInt64BE
   * @local Float
   * @local FloatBE
   * @local Double
   * @local DoubleBE
   * @local Sequence
   * @local Structure
   * @local UnionDiscriminator
   * @local UnionLayoutDiscriminator
   * @local Union
   * @local VariantLayout
   * @local BitStructure
   * @local BitField
   * @local Boolean
   * @local Blob
   * @local CString
   * @local Constant
   * @local bindConstructorLayout
   * @module Layout
   * @license MIT
   * @author Peter A. Bigot
   * @see {@link https://github.com/pabigot/buffer-layout|buffer-layout on GitHub}
   *)

@noble/curves/esm/abstract/edwards.js:
  (*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) *)

@noble/curves/esm/abstract/montgomery.js:
  (*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) *)

@noble/curves/esm/ed25519.js:
  (*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) *)

@cartridge/controller/dist/index.js:
  (*! noble-hashes - MIT License (c) 2022 Paul Miller (paulmillr.com) *)
*/
//# sourceMappingURL=chunk-AIH653EG.js.map
